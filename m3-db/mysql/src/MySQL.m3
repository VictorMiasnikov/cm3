(*******************************************************************************
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.10
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
*******************************************************************************)

UNSAFE MODULE MySQL;


IMPORT M3toC;
IMPORT MySQLRaw;
IMPORT Ctypes AS C;


TYPE RefRow = UNTRACED REF ARRAY [0 .. MAX_COLUMNS] OF C.char_star;

REVEAL
  T = UNTRACED BRANDED REF MySQLRaw.OPAQUE;
  ResultT = UNTRACED BRANDED REF MySQLRaw.OPAQUE;
  StmtT = UNTRACED BRANDED REF MySQLRaw.OPAQUE;
  RowOffsetT = UNTRACED BRANDED REF MySQLRaw.OPAQUE;
  ManagerT = UNTRACED BRANDED REF MySQLRaw.OPAQUE;
  ParametersT = UNTRACED BRANDED REF MySQLRaw.OPAQUE;
  BindT = UNTRACED BRANDED REF MySQLRaw.OPAQUE;
  CharsT = UNTRACED BRANDED REF MySQLRaw.OPAQUE;

VAR Null := LOOPHOLE(0, ADDRESS);

PROCEDURE NewString (t: TEXT): C.char_star =
  VAR res: C.char_star;
  BEGIN
    IF t = NIL THEN res := Null; ELSE res := M3toC.SharedTtoS(t); END;
    RETURN res;
  END NewString;

PROCEDURE FreeString (t: TEXT; c: C.char_star) =
  BEGIN
    IF t # NIL THEN M3toC.FreeSharedS(t, c); END;
  END FreeString;

PROCEDURE ToText (s: C.char_star): TEXT =
  BEGIN
    IF s # NIL THEN RETURN M3toC.CopyStoT(s); ELSE RETURN NIL; END;
  END ToText;

PROCEDURE NewField (READONLY fieldRef: MySQLRaw.MYSQL_FIELD): FieldT =
  VAR ret := NEW(FieldT);
  BEGIN
    ret.name := ToText(fieldRef.name);
    ret.org_name := ToText(fieldRef.org_name);
    ret.table := ToText(fieldRef.table);
    ret.org_table := ToText(fieldRef.org_table);
    ret.db := ToText(fieldRef.db);
    ret.catalog := ToText(fieldRef.catalog);
    ret.def := ToText(fieldRef.def);
    ret.length := fieldRef.length;
    ret.max_length := fieldRef.max_length;
    ret.name_length := fieldRef.name_length;
    ret.org_name_length := fieldRef.org_name_length;
    ret.table_length := fieldRef.table_length;
    ret.org_table_length := fieldRef.org_table_length;
    ret.db_length := fieldRef.db_length;
    ret.catalog_length := fieldRef.catalog_length;
    ret.def_length := fieldRef.def_length;
    ret.flags := fieldRef.flags;
    ret.decimals := fieldRef.decimals;
    ret.charsetnr := fieldRef.charsetnr;
    ret.type := fieldRef.type;
    RETURN ret;
  END NewField;

PROCEDURE GetFieldList
  (fieldRef: MySQLRaw.RefMysqlFieldT; numFields: CARDINAL): RefFieldArray =
  VAR ret: RefFieldArray;
  BEGIN
    ret := NEW(RefFieldArray, numFields);
    FOR j := 0 TO numFields - 1 DO
      ret[j] := NewField(fieldRef^);
      INC(fieldRef, BYTESIZE(MySQLRaw.MYSQL_FIELD));
    END;
    RETURN ret;
  END GetFieldList;




PROCEDURE New_MYSQL_FIELD (self: C.int_star; ): C.int_star =
  BEGIN
    RETURN MySQLRaw.New_MYSQL_FIELD();
  END New_MYSQL_FIELD;

PROCEDURE Delete_MYSQL_FIELD (VALUE self: C.int; ) =
  BEGIN
    MySQLRaw.Delete_MYSQL_FIELD(self);
  END Delete_MYSQL_FIELD;

PROCEDURE ServerInit
  (argc: INTEGER; READONLY argv, groups: ARRAY OF TEXT; ): INTEGER
  RAISES {ReturnE} =
  VAR
    arg2  : C.char_star;
    arg3  : C.char_star;
    result: INTEGER;
  BEGIN
    TRY
      arg2 := NewString(argv[0]);
      arg3 := NewString(groups[0]);
      result := MySQLRaw.ServerInit(argc, arg2, arg3);
      IF result # 0 THEN RAISE ReturnE(result); END;
    FINALLY
      FreeString(argv[0], arg2);
      FreeString(groups[0], arg3);
    END;
    RETURN result;
  END ServerInit;

PROCEDURE ServerEnd () =
  BEGIN
    MySQLRaw.ServerEnd();
  END ServerEnd;

PROCEDURE ThreadInit (): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
  BEGIN
    ret := MySQLRaw.ThreadInit();
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END ThreadInit;

PROCEDURE ThreadEnd () =
  BEGIN
    MySQLRaw.ThreadEnd();
  END ThreadEnd;

PROCEDURE NumRows (res: ResultT; ): LONGINT =
  VAR
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(
                                        res, MySQLRaw.RefMysqlResultT);
  BEGIN
    RETURN MySQLRaw.NumRows(arg1);
  END NumRows;

PROCEDURE NumFields (res: ResultT; ): CARDINAL =
  VAR
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(
                                        res, MySQLRaw.RefMysqlResultT);
  BEGIN
    RETURN MySQLRaw.NumFields(arg1);
  END NumFields;

PROCEDURE Eof (res: ResultT; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(
                                        res, MySQLRaw.RefMysqlResultT);
  BEGIN
    ret := MySQLRaw.Eof(arg1);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END Eof;

PROCEDURE FetchFieldDirect (res: ResultT; fieldnr: CARDINAL; ): FieldT =
  VAR
    ret   : MySQLRaw.RefMysqlFieldT;
    result: FieldT;
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(
                                        res, MySQLRaw.RefMysqlResultT);
  BEGIN
    ret := MySQLRaw.FetchFieldDirect(arg1, fieldnr);
    result := NewField(ret^);
    RETURN result;
  END FetchFieldDirect;

PROCEDURE FetchFields (res: ResultT; ): RefFieldArray =
  VAR
    ret   : MySQLRaw.RefMysqlFieldT;
    result: RefFieldArray;
    len   : CARDINAL;
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(
                                        res, MySQLRaw.RefMysqlResultT);
  BEGIN
    ret := MySQLRaw.FetchFields(arg1);
    len := MySQLRaw.NumFields(arg1);
    result := GetFieldList(ret, len);
    RETURN result;
  END FetchFields;

PROCEDURE RowTell (res: ResultT; ): RowOffsetT =
  VAR
    ret   : MySQLRaw.RowOffsetT;
    result: RowOffsetT;
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(
                                        res, MySQLRaw.RefMysqlResultT);
  BEGIN
    ret := MySQLRaw.RowTell(arg1);
    result := LOOPHOLE(ret, RowOffsetT);
    RETURN result;
  END RowTell;

PROCEDURE FieldTell (res: ResultT; ): CARDINAL =
  VAR
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(
                                        res, MySQLRaw.RefMysqlResultT);
  BEGIN
    RETURN MySQLRaw.FieldTell(arg1);
  END FieldTell;

PROCEDURE FieldCount (mysql: T; ): CARDINAL =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.FieldCount(rawT);
  END FieldCount;

PROCEDURE AffectedRows (mysql: T; ): LONGINT =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.AffectedRows(rawT);
  END AffectedRows;

PROCEDURE InsertId (mysql: T; ): LONGINT =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.InsertId(rawT);
  END InsertId;

PROCEDURE Errno (mysql: T; ): CARDINAL =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.Errno(rawT);
  END Errno;

PROCEDURE Error (mysql: T; ): TEXT =
  VAR
    result: C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    result := MySQLRaw.Error(rawT);
    RETURN M3toC.CopyStoT(result);
  END Error;

PROCEDURE Sqlstate (mysql: T; ): TEXT =
  VAR
    result: C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    result := MySQLRaw.Sqlstate(rawT);
    RETURN M3toC.CopyStoT(result);
  END Sqlstate;

PROCEDURE WarningCount (mysql: T; ): CARDINAL =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.WarningCount(rawT);
  END WarningCount;

PROCEDURE Info (mysql: T; ): TEXT =
  VAR
    result: C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    result := MySQLRaw.Info(rawT);
    RETURN M3toC.CopyStoT(result);
  END Info;

PROCEDURE ThreadId (mysql: T; ): CARDINAL =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.ThreadId(rawT);
  END ThreadId;

PROCEDURE CharacterSetName (mysql: T; ): TEXT =
  VAR
    result: C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    result := MySQLRaw.CharacterSetName(rawT);
    RETURN M3toC.CopyStoT(result);
  END CharacterSetName;

PROCEDURE SetCharacterSet (mysql: T; csname: TEXT; ): INTEGER
  RAISES {ReturnE} =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    result: INTEGER;
  BEGIN
    TRY
      arg2 := NewString(csname);
      result := MySQLRaw.SetCharacterSet(rawT, arg2);
      IF result # 0 THEN RAISE ReturnE(result); END;
    FINALLY
      FreeString(csname, arg2);
    END;
    RETURN result;
  END SetCharacterSet;

PROCEDURE Init (mysql: T; ): T RAISES {ConnE} =
  VAR
    ret   : MySQLRaw.RefMysqlT;
    result: T;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.Init(rawT);
    result := LOOPHOLE(ret, T);
    IF result = NIL THEN RAISE ConnE; END;
    RETURN result;
  END Init;

PROCEDURE SslSet (mysql: T; key, cert, ca, capath, cipher: TEXT; ):
  BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    arg3  : C.const_char_star;
    arg4  : C.const_char_star;
    arg5  : C.const_char_star;
    arg6  : C.const_char_star;
  BEGIN
    arg2 := NewString(key);
    arg3 := NewString(cert);
    arg4 := NewString(ca);
    arg5 := NewString(capath);
    arg6 := NewString(cipher);
    ret := MySQLRaw.SslSet(rawT, arg2, arg3, arg4, arg5, arg6);
    result := VAL(ret, BOOLEAN);
    FreeString(key, arg2);
    FreeString(cert, arg3);
    FreeString(ca, arg4);
    FreeString(capath, arg5);
    FreeString(cipher, arg6);
    RETURN result;
  END SslSet;

PROCEDURE GetSslCipher (mysql: T; ): TEXT =
  VAR
    result: C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    result := MySQLRaw.GetSslCipher(rawT);
    RETURN M3toC.CopyStoT(result);
  END GetSslCipher;

PROCEDURE ChangeUser (mysql: T; user, passwd, db: TEXT; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    arg3  : C.const_char_star;
    arg4  : C.const_char_star;
  BEGIN
    arg2 := NewString(user);
    arg3 := NewString(passwd);
    arg4 := NewString(db);
    ret := MySQLRaw.ChangeUser(rawT, arg2, arg3, arg4);
    result := VAL(ret, BOOLEAN);
    FreeString(user, arg2);
    FreeString(passwd, arg3);
    FreeString(db, arg4);
    RETURN result;
  END ChangeUser;

PROCEDURE RealConnect (mysql                 : T;
                       host, user, passwd, db: TEXT;
                       port                  : CARDINAL;
                       unix_socket           : TEXT;
                       clientflag            : CARDINAL; ): T
  RAISES {ConnE} =
  VAR
    ret   : MySQLRaw.RefMysqlT;
    result: T;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    arg3  : C.const_char_star;
    arg4  : C.const_char_star;
    arg5  : C.const_char_star;
    arg7  : C.const_char_star;
  BEGIN
    TRY
      arg2 := NewString(host);
      arg3 := NewString(user);
      arg4 := NewString(passwd);
      arg5 := NewString(db);
      arg7 := NewString(unix_socket);
      ret := MySQLRaw.RealConnect(
               rawT, arg2, arg3, arg4, arg5, port, arg7, clientflag);
      result := LOOPHOLE(ret, T);
      IF result = NIL THEN RAISE ConnE; END;
    FINALLY
      FreeString(host, arg2);
      FreeString(user, arg3);
      FreeString(passwd, arg4);
      FreeString(db, arg5);
      FreeString(unix_socket, arg7);
    END;
    RETURN result;
  END RealConnect;

PROCEDURE SelectDb (mysql: T; db: TEXT; ): INTEGER RAISES {ReturnE} =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    result: INTEGER;
  BEGIN
    TRY
      arg2 := NewString(db);
      result := MySQLRaw.SelectDb(rawT, arg2);
      IF result # 0 THEN RAISE ReturnE(result); END;
    FINALLY
      FreeString(db, arg2);
    END;
    RETURN result;
  END SelectDb;

PROCEDURE Query (mysql: T; q: TEXT; ): INTEGER RAISES {ReturnE} =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    result: INTEGER;
  BEGIN
    TRY
      arg2 := NewString(q);
      result := MySQLRaw.Query(rawT, arg2);
      IF result # 0 THEN RAISE ReturnE(result); END;
    FINALLY
      FreeString(q, arg2);
    END;
    RETURN result;
  END Query;

PROCEDURE SendQuery (mysql: T; q: TEXT; length: CARDINAL; ): INTEGER
  RAISES {ReturnE} =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    result: INTEGER;
  BEGIN
    TRY
      arg2 := NewString(q);
      result := MySQLRaw.SendQuery(rawT, arg2, length);
      IF result # 0 THEN RAISE ReturnE(result); END;
    FINALLY
      FreeString(q, arg2);
    END;
    RETURN result;
  END SendQuery;

PROCEDURE RealQuery (mysql: T; q: TEXT; length: CARDINAL; ): INTEGER
  RAISES {ReturnE} =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.const_char_star;
    result: INTEGER;
  BEGIN
    TRY
      arg2 := NewString(q);
      result := MySQLRaw.RealQuery(rawT, arg2, length);
      IF result # 0 THEN RAISE ReturnE(result); END;
    FINALLY
      FreeString(q, arg2);
    END;
    RETURN result;
  END RealQuery;

PROCEDURE StoreResult (mysql: T; ): ResultT RAISES {ResultE} =
  VAR
    ret   : MySQLRaw.RefMysqlResultT;
    result: ResultT;
    rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.StoreResult(rawT);
    result := LOOPHOLE(ret, ResultT);
    IF result = NIL THEN RAISE ResultE; END;
    RETURN result;
  END StoreResult;

PROCEDURE UseResult (mysql: T; ): ResultT RAISES {ResultE} =
  VAR
    ret   : MySQLRaw.RefMysqlResultT;
    result: ResultT;
    rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.UseResult(rawT);
    result := LOOPHOLE(ret, ResultT);
    IF result = NIL THEN RAISE ResultE; END;
    RETURN result;
  END UseResult;

PROCEDURE GetCharacterSetInfo (mysql: T; VAR charset: CharsT; ) =
  VAR
    rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2: MySQLRaw.RefMysqlCharsT := LOOPHOLE(
                                       charset, MySQLRaw.RefMysqlCharsT);
  BEGIN
    MySQLRaw.GetCharacterSetInfo(rawT, arg2);
  END GetCharacterSetInfo;

PROCEDURE SessionTrackGetFirst (         mysql : T;
                                         type  : INTEGER;
                                READONLY data  : ARRAY OF TEXT;
                                VAR      length: INTEGER;       ): INTEGER
  RAISES {ReturnE} =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg3  : C.char_star;
    result: INTEGER;
  BEGIN
    TRY
      arg3 := NewString(data[0]);
      result := MySQLRaw.SessionTrackGetFirst(rawT, type, arg3, length);
      IF result # 0 THEN RAISE ReturnE(result); END;
    FINALLY
      FreeString(data[0], arg3);
    END;
    RETURN result;
  END SessionTrackGetFirst;

PROCEDURE SessionTrackGetNext (         mysql : T;
                                        type  : INTEGER;
                               READONLY data  : ARRAY OF TEXT;
                               VAR      length: INTEGER;       ): INTEGER
  RAISES {ReturnE} =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg3  : C.char_star;
    result: INTEGER;
  BEGIN
    TRY
      arg3 := NewString(data[0]);
      result := MySQLRaw.SessionTrackGetNext(rawT, type, arg3, length);
      IF result # 0 THEN RAISE ReturnE(result); END;
    FINALLY
      FreeString(data[0], arg3);
    END;
    RETURN result;
  END SessionTrackGetNext;

PROCEDURE SetLocalInfileHandler (mysql             : T;
                                 local_infile_init : InitCBT;
                                 local_infile_read : ReadCBT;
                                 local_infile_end  : EndCBT;
                                 local_infile_error: ErrorCBT;
                                 arg6              : ADDRESS;  ) =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);

  PROCEDURE P0 (p1: REF C.void_star; p2: C.char_star; p3: C.void_star):
    C.int =
    VAR
      r1: REF ADDRESS := p1;
      r2              := M3toC.CopyStoT(p2);
      r3              := p3;
    BEGIN
      RETURN local_infile_init(r1, r2, r3);
    END P0;

  PROCEDURE P1 (p1: C.void_star; p2: C.char_star; p3: C.unsigned_int):
    C.int =
    VAR
      r1: ADDRESS := p1;
      r2          := M3toC.CopyStoT(p2);
      r3          := p3;
    BEGIN
      RETURN local_infile_read(r1, r2, r3);
    END P1;

  PROCEDURE P2 (p1: C.void_star; p2: C.char_star; p3: C.unsigned_int):
    C.int =
    VAR
      r1: ADDRESS := p1;
      r2          := M3toC.CopyStoT(p2);
      r3          := p3;
    BEGIN
      RETURN local_infile_error(r1, r2, r3);
    END P2;
  VAR

  BEGIN
    MySQLRaw.SetLocalInfileHandler(rawT, <* NOWARN *> P0, <* NOWARN *> P1,
                                   local_infile_end, <* NOWARN *> P2, arg6);
  END SetLocalInfileHandler;

PROCEDURE SetLocalInfileDefault (mysql: T; ) =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    MySQLRaw.SetLocalInfileDefault(rawT);
  END SetLocalInfileDefault;

PROCEDURE Shutdown (mysql: T; shutdown_level: INTEGER; ): INTEGER
  RAISES {ReturnE} =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.Shutdown(rawT, shutdown_level);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END Shutdown;

PROCEDURE DumpDebugInfo (mysql: T; ): INTEGER RAISES {ReturnE} =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.DumpDebugInfo(rawT);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END DumpDebugInfo;

PROCEDURE Refresh (mysql: T; refresh_options: CARDINAL; ): INTEGER
  RAISES {ReturnE} =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.Refresh(rawT, refresh_options);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END Refresh;

PROCEDURE Kill (mysql: T; pid: CARDINAL; ): INTEGER RAISES {ReturnE} =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.Kill(rawT, pid);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END Kill;

PROCEDURE SetServerOption (mysql: T; option: INTEGER; ): INTEGER
  RAISES {ReturnE} =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.SetServerOption(rawT, option);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END SetServerOption;

PROCEDURE Ping (mysql: T; ): INTEGER RAISES {ReturnE} =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.Ping(rawT);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END Ping;

PROCEDURE Stat (mysql: T; ): TEXT =
  VAR
    result: C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    result := MySQLRaw.Stat(rawT);
    RETURN M3toC.CopyStoT(result);
  END Stat;

PROCEDURE GetServerInfo (mysql: T; ): TEXT =
  VAR
    result: C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    result := MySQLRaw.GetServerInfo(rawT);
    RETURN M3toC.CopyStoT(result);
  END GetServerInfo;

PROCEDURE GetClientInfo (): TEXT =
  VAR result: C.char_star;
  BEGIN
    result := MySQLRaw.GetClientInfo();
    RETURN M3toC.CopyStoT(result);
  END GetClientInfo;

PROCEDURE GetClientVersion (): CARDINAL =
  BEGIN
    RETURN MySQLRaw.GetClientVersion();
  END GetClientVersion;

PROCEDURE GetHostInfo (mysql: T; ): TEXT =
  VAR
    result: C.char_star;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    result := MySQLRaw.GetHostInfo(rawT);
    RETURN M3toC.CopyStoT(result);
  END GetHostInfo;

PROCEDURE GetServerVersion (mysql: T; ): CARDINAL =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.GetServerVersion(rawT);
  END GetServerVersion;

PROCEDURE GetProtoInfo (mysql: T; ): CARDINAL =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    RETURN MySQLRaw.GetProtoInfo(rawT);
  END GetProtoInfo;

PROCEDURE ListDbs (mysql: T; wild: TEXT; ): ResultT RAISES {ResultE} =
  VAR
    ret   : MySQLRaw.RefMysqlResultT;
    result: ResultT;
    rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2: C.const_char_star;
  BEGIN
    TRY
      arg2 := NewString(wild);
      ret := MySQLRaw.ListDbs(rawT, arg2);
      result := LOOPHOLE(ret, ResultT);
      IF result = NIL THEN RAISE ResultE; END;
    FINALLY
      FreeString(wild, arg2);
    END;
    RETURN result;
  END ListDbs;

PROCEDURE ListTables (mysql: T; wild: TEXT; ): ResultT RAISES {ResultE} =
  VAR
    ret   : MySQLRaw.RefMysqlResultT;
    result: ResultT;
    rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2: C.const_char_star;
  BEGIN
    TRY
      arg2 := NewString(wild);
      ret := MySQLRaw.ListTables(rawT, arg2);
      result := LOOPHOLE(ret, ResultT);
      IF result = NIL THEN RAISE ResultE; END;
    FINALLY
      FreeString(wild, arg2);
    END;
    RETURN result;
  END ListTables;

PROCEDURE ListProcesses (mysql: T; ): ResultT RAISES {ResultE} =
  VAR
    ret   : MySQLRaw.RefMysqlResultT;
    result: ResultT;
    rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.ListProcesses(rawT);
    result := LOOPHOLE(ret, ResultT);
    IF result = NIL THEN RAISE ResultE; END;
    RETURN result;
  END ListProcesses;

PROCEDURE Options (mysql: T; option: INTEGER; arg: ADDRESS; ): INTEGER
  RAISES {ReturnE} =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.Options(rawT, option, arg);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END Options;

PROCEDURE Options4 (mysql: T; option: INTEGER; arg1, arg2: ADDRESS; ):
  INTEGER RAISES {ReturnE} =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.Options4(rawT, option, arg1, arg2);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END Options4;

PROCEDURE GetOption (mysql: T; option: INTEGER; arg: ADDRESS; ): INTEGER
  RAISES {ReturnE} =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.GetOption(rawT, option, arg);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END GetOption;

PROCEDURE FreeResult (mysql_res: ResultT; ) =
  VAR
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(mysql_res,
                                               MySQLRaw.RefMysqlResultT);
  BEGIN
    MySQLRaw.FreeResult(arg1);
  END FreeResult;

PROCEDURE DataSeek (mysql_res: ResultT; offset: LONGINT; ) =
  VAR
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(mysql_res,
                                               MySQLRaw.RefMysqlResultT);
  BEGIN
    MySQLRaw.DataSeek(arg1, offset);
  END DataSeek;

PROCEDURE RowSeek (mysql_res: ResultT; VAR offset: RowOffsetT; ):
  RowOffsetT =
  VAR
    ret   : MySQLRaw.RowOffsetT;
    result: RowOffsetT;
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(mysql_res,
                                               MySQLRaw.RefMysqlResultT);
    arg2: MySQLRaw.RowOffsetT := LOOPHOLE(offset, MySQLRaw.RowOffsetT);
  BEGIN
    ret := MySQLRaw.RowSeek(arg1, arg2);
    result := LOOPHOLE(ret, RowOffsetT);
    RETURN result;
  END RowSeek;

PROCEDURE FieldSeek (mysql_res: ResultT; offset: CARDINAL; ): CARDINAL =
  VAR
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(mysql_res,
                                               MySQLRaw.RefMysqlResultT);
  BEGIN
    RETURN MySQLRaw.FieldSeek(arg1, offset);
  END FieldSeek;

PROCEDURE FetchRow (mysql_res: ResultT; ): REF ARRAY OF TEXT =
  VAR
    ret      : C.char_star_star;
    result   : RefRow;
    numFields: INTEGER;
    row      : REF ARRAY OF TEXT;
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(mysql_res,
                                               MySQLRaw.RefMysqlResultT);
  BEGIN
    ret := MySQLRaw.FetchRow(arg1);
    IF ret = NIL THEN
      row := NIL;
    ELSE
      result := LOOPHOLE(ret, RefRow);
      numFields := NumFields(mysql_res);
      row := NEW(REF ARRAY OF TEXT, numFields);
      FOR i := 0 TO numFields - 1 DO
        (* DB NULL results in NIL M3 text *)
        IF result[i] # NIL THEN row[i] := M3toC.CopyStoT(result[i]) END;
      END;
    END;
    RETURN row;
  END FetchRow;

PROCEDURE FetchLengths (mysql_res: ResultT; ): RefLengthsT =
  VAR
    ret   : C.unsigned_long_star;
    result: RefLengthsT;
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(mysql_res,
                                               MySQLRaw.RefMysqlResultT);
  BEGIN
    ret := MySQLRaw.FetchLengths(arg1);
    result := LOOPHOLE(ret, RefLengthsT);
    RETURN result;
  END FetchLengths;

PROCEDURE FetchField (mysql_res: ResultT; ): FieldT =
  VAR
    ret   : MySQLRaw.RefMysqlFieldT;
    result: FieldT;
    arg1: MySQLRaw.RefMysqlResultT := LOOPHOLE(mysql_res,
                                               MySQLRaw.RefMysqlResultT);
  BEGIN
    ret := MySQLRaw.FetchField(arg1);
    result := NewField(ret^);
    RETURN result;
  END FetchField;

PROCEDURE ListFields (mysql: T; table, wild: TEXT; ): ResultT
  RAISES {ResultE} =
  VAR
    ret   : MySQLRaw.RefMysqlResultT;
    result: ResultT;
    rawT: MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2: C.const_char_star;
    arg3: C.const_char_star;
  BEGIN
    TRY
      arg2 := NewString(table);
      arg3 := NewString(wild);
      ret := MySQLRaw.ListFields(rawT, arg2, arg3);
      result := LOOPHOLE(ret, ResultT);
      IF result = NIL THEN RAISE ResultE; END;
    FINALLY
      FreeString(table, arg2);
      FreeString(wild, arg3);
    END;
    RETURN result;
  END ListFields;

PROCEDURE EscapeString (to, from: TEXT; from_length: CARDINAL; ):
  CARDINAL =
  VAR
    arg1  : C.char_star;
    arg2  : C.const_char_star;
    result: CARDINAL;
  BEGIN
    arg1 := NewString(to);
    arg2 := NewString(from);
    result := MySQLRaw.EscapeString(arg1, arg2, from_length);
    FreeString(to, arg1);
    FreeString(from, arg2);
    RETURN result;
  END EscapeString;

PROCEDURE HexString (to, from: TEXT; from_length: CARDINAL; ): CARDINAL =
  VAR
    arg1  : C.char_star;
    arg2  : C.const_char_star;
    result: CARDINAL;
  BEGIN
    arg1 := NewString(to);
    arg2 := NewString(from);
    result := MySQLRaw.HexString(arg1, arg2, from_length);
    FreeString(to, arg1);
    FreeString(from, arg2);
    RETURN result;
  END HexString;

PROCEDURE RealEscapeString (mysql: T; to, from: TEXT; length: CARDINAL; ):
  CARDINAL =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.char_star;
    arg3  : C.const_char_star;
    result: CARDINAL;
  BEGIN
    arg2 := NewString(to);
    arg3 := NewString(from);
    result := MySQLRaw.RealEscapeString(rawT, arg2, arg3, length);
    FreeString(to, arg2);
    FreeString(from, arg3);
    RETURN result;
  END RealEscapeString;

PROCEDURE RealEscapeStringQuote
  (mysql: T; to, from: TEXT; length: CARDINAL; quote: CHAR; ): CARDINAL =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2  : C.char_star;
    arg3  : C.const_char_star;
    result: CARDINAL;
  BEGIN
    arg2 := NewString(to);
    arg3 := NewString(from);
    result :=
      MySQLRaw.RealEscapeStringQuote(rawT, arg2, arg3, length, ORD(quote));
    FreeString(to, arg2);
    FreeString(from, arg3);
    RETURN result;
  END RealEscapeStringQuote;

PROCEDURE Debug (debug: TEXT; ) =
  VAR arg1: C.const_char_star;
  BEGIN
    arg1 := NewString(debug);
    MySQLRaw.Debug(arg1);
    FreeString(debug, arg1);
  END Debug;

PROCEDURE ThreadSafe (): CARDINAL =
  BEGIN
    RETURN MySQLRaw.ThreadSafe();
  END ThreadSafe;

PROCEDURE ReadQueryResult (mysql: T; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.ReadQueryResult(rawT);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END ReadQueryResult;

PROCEDURE ResetConnection (mysql: T; ): INTEGER RAISES {ReturnE} =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.ResetConnection(rawT);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END ResetConnection;

PROCEDURE StmtInit (mysql: T; ): StmtT RAISES {ResultE} =
  VAR
    ret   : MySQLRaw.RefMysqlStmtT;
    result: StmtT;
    rawT  : MySQLRaw.RefMysqlT     := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.StmtInit(rawT);
    result := LOOPHOLE(ret, StmtT);
    IF result = NIL THEN RAISE ResultE; END;
    RETURN result;
  END StmtInit;

PROCEDURE StmtPrepare (stmt: StmtT; query: TEXT; length: CARDINAL; ):
  INTEGER RAISES {ReturnE} =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    arg2: C.const_char_star;
    result: INTEGER;
  BEGIN
    TRY
      arg2 := NewString(query);
      result := MySQLRaw.StmtPrepare(arg1, arg2, length);
      IF result # 0 THEN RAISE ReturnE(result); END;
    FINALLY
      FreeString(query, arg2);
    END;
    RETURN result;
  END StmtPrepare;

PROCEDURE StmtExecute (stmt: StmtT; ): INTEGER RAISES {ReturnE} =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.StmtExecute(arg1);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END StmtExecute;

PROCEDURE StmtFetch (stmt: StmtT; ): INTEGER RAISES {ReturnE} =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.StmtFetch(arg1);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END StmtFetch;

PROCEDURE StmtFetchColumn
  (stmt: StmtT; bind_arg: BindT; column, offset: CARDINAL; ): INTEGER
  RAISES {ReturnE} =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    arg2: MySQLRaw.RefMysqlBindT := LOOPHOLE(
                                      bind_arg, MySQLRaw.RefMysqlBindT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.StmtFetchColumn(arg1, arg2, column, offset);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END StmtFetchColumn;

PROCEDURE StmtStoreResult (stmt: StmtT; ): INTEGER RAISES {ReturnE} =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.StmtStoreResult(arg1);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END StmtStoreResult;

PROCEDURE StmtParamCount (stmt: StmtT; ): CARDINAL =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    RETURN MySQLRaw.StmtParamCount(arg1);
  END StmtParamCount;

PROCEDURE StmtAttrSet (stmt: StmtT; attr_type: INTEGER; attr: ADDRESS; ):
  BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    ret := MySQLRaw.StmtAttrSet(arg1, attr_type, attr);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END StmtAttrSet;

PROCEDURE StmtAttrGet (stmt: StmtT; attr_type: INTEGER; attr: ADDRESS; ):
  BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    ret := MySQLRaw.StmtAttrGet(arg1, attr_type, attr);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END StmtAttrGet;

PROCEDURE StmtBindParam (stmt: StmtT; bnd: BindT; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    arg2: MySQLRaw.RefMysqlBindT := LOOPHOLE(bnd, MySQLRaw.RefMysqlBindT);
  BEGIN
    ret := MySQLRaw.StmtBindParam(arg1, arg2);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END StmtBindParam;

PROCEDURE StmtBindResult (stmt: StmtT; bnd: BindT; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    arg2: MySQLRaw.RefMysqlBindT := LOOPHOLE(bnd, MySQLRaw.RefMysqlBindT);
  BEGIN
    ret := MySQLRaw.StmtBindResult(arg1, arg2);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END StmtBindResult;

PROCEDURE StmtClose (stmt: StmtT; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    ret := MySQLRaw.StmtClose(arg1);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END StmtClose;

PROCEDURE StmtReset (stmt: StmtT; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    ret := MySQLRaw.StmtReset(arg1);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END StmtReset;

PROCEDURE StmtFreeResult (stmt: StmtT; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    ret := MySQLRaw.StmtFreeResult(arg1);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END StmtFreeResult;

PROCEDURE StmtSendLongData
  (stmt: StmtT; param_number: CARDINAL; data: TEXT; length: CARDINAL; ):
  BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    arg3: C.const_char_star;
  BEGIN
    arg3 := NewString(data);
    ret := MySQLRaw.StmtSendLongData(arg1, param_number, arg3, length);
    result := VAL(ret, BOOLEAN);
    FreeString(data, arg3);
    RETURN result;
  END StmtSendLongData;

PROCEDURE StmtResultMetadata (stmt: StmtT; ): ResultT RAISES {ResultE} =
  VAR
    ret   : MySQLRaw.RefMysqlResultT;
    result: ResultT;
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    ret := MySQLRaw.StmtResultMetadata(arg1);
    result := LOOPHOLE(ret, ResultT);
    IF result = NIL THEN RAISE ResultE; END;
    RETURN result;
  END StmtResultMetadata;

PROCEDURE StmtParamMetadata (stmt: StmtT; ): ResultT RAISES {ResultE} =
  VAR
    ret   : MySQLRaw.RefMysqlResultT;
    result: ResultT;
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    ret := MySQLRaw.StmtParamMetadata(arg1);
    result := LOOPHOLE(ret, ResultT);
    IF result = NIL THEN RAISE ResultE; END;
    RETURN result;
  END StmtParamMetadata;

PROCEDURE StmtErrno (stmt: StmtT; ): CARDINAL =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    RETURN MySQLRaw.StmtErrno(arg1);
  END StmtErrno;

PROCEDURE StmtError (stmt: StmtT; ): TEXT =
  VAR
    result: C.char_star;
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    result := MySQLRaw.StmtError(arg1);
    RETURN M3toC.CopyStoT(result);
  END StmtError;

PROCEDURE StmtSqlstate (stmt: StmtT; ): TEXT =
  VAR
    result: C.char_star;
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    result := MySQLRaw.StmtSqlstate(arg1);
    RETURN M3toC.CopyStoT(result);
  END StmtSqlstate;

PROCEDURE StmtRowSeek (stmt: StmtT; VAR offset: RowOffsetT; ): RowOffsetT =
  VAR
    ret   : MySQLRaw.RowOffsetT;
    result: RowOffsetT;
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    arg2: MySQLRaw.RowOffsetT    := LOOPHOLE(offset, MySQLRaw.RowOffsetT);
  BEGIN
    ret := MySQLRaw.StmtRowSeek(arg1, arg2);
    result := LOOPHOLE(ret, RowOffsetT);
    RETURN result;
  END StmtRowSeek;

PROCEDURE StmtRowTell (stmt: StmtT; ): RowOffsetT =
  VAR
    ret   : MySQLRaw.RowOffsetT;
    result: RowOffsetT;
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    ret := MySQLRaw.StmtRowTell(arg1);
    result := LOOPHOLE(ret, RowOffsetT);
    RETURN result;
  END StmtRowTell;

PROCEDURE StmtDataSeek (stmt: StmtT; offset: LONGINT; ) =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    MySQLRaw.StmtDataSeek(arg1, offset);
  END StmtDataSeek;

PROCEDURE StmtNumRows (stmt: StmtT; ): LONGINT =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    RETURN MySQLRaw.StmtNumRows(arg1);
  END StmtNumRows;

PROCEDURE StmtAffectedRows (stmt: StmtT; ): LONGINT =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    RETURN MySQLRaw.StmtAffectedRows(arg1);
  END StmtAffectedRows;

PROCEDURE StmtInsertId (stmt: StmtT; ): LONGINT =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    RETURN MySQLRaw.StmtInsertId(arg1);
  END StmtInsertId;

PROCEDURE StmtFieldCount (stmt: StmtT; ): CARDINAL =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
  BEGIN
    RETURN MySQLRaw.StmtFieldCount(arg1);
  END StmtFieldCount;

PROCEDURE Commit (mysql: T; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.Commit(rawT);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END Commit;

PROCEDURE Rollback (mysql: T; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.Rollback(rawT);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END Rollback;

PROCEDURE Autocommit (mysql: T; auto_mode: BOOLEAN; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    arg2                       := LOOPHOLE(auto_mode, MySQLRaw.my_bool);
  BEGIN
    ret := MySQLRaw.Autocommit(rawT, arg2);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END Autocommit;

PROCEDURE MoreResults (mysql: T; ): BOOLEAN =
  VAR
    ret   : MySQLRaw.my_bool;
    result: BOOLEAN;
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
  BEGIN
    ret := MySQLRaw.MoreResults(rawT);
    result := VAL(ret, BOOLEAN);
    RETURN result;
  END MoreResults;

PROCEDURE NextResult (mysql: T; ): INTEGER RAISES {ReturnE} =
  VAR
    rawT  : MySQLRaw.RefMysqlT := LOOPHOLE(mysql, MySQLRaw.RefMysqlT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.NextResult(rawT);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END NextResult;

PROCEDURE StmtNextResult (stmt: StmtT; ): INTEGER RAISES {ReturnE} =
  VAR
    arg1: MySQLRaw.RefMysqlStmtT := LOOPHOLE(stmt, MySQLRaw.RefMysqlStmtT);
    result: INTEGER;
  BEGIN
    result := MySQLRaw.StmtNextResult(arg1);
    IF result # 0 THEN RAISE ReturnE(result); END;
    RETURN result;
  END StmtNextResult;

PROCEDURE Close (sock: T; ) =
  VAR rawT: MySQLRaw.RefMysqlT := LOOPHOLE(sock, MySQLRaw.RefMysqlT);
  BEGIN
    MySQLRaw.Close(rawT);
  END Close;


BEGIN
END MySQL.
