<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: m3tk/src/target/M3CBackEnd_C.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>m3tk/src/target/M3CBackEnd_C.m3</H2></A><HR>
<inModule>
<PRE></PRE>*************************************************************************
                      Copyright (C) Olivetti 1989                        
                          All Rights reserved                            
                                                                         
 Use and copy of this software and preparation of derivative works based 
 upon this software are permitted to any person, provided this same      
 copyright notice and the following Olivetti warranty disclaimer are      
 included in any copy of the software or any modification thereof or     
 derivative work therefrom made by any person.                           
                                                                         
 This software is made available AS IS and Olivetti disclaims all        
 warranties with respect to this software, whether expressed or implied  
 under any law, including all implied warranties of merchantibility and  
 fitness for any purpose. In no event shall Olivetti be liable for any   
 damages whatsoever resulting from loss of use, data or profits or       
 otherwise arising out of or in connection with the use or performance   
 of this software.                                                       
*************************************************************************

 Copyright (C) 1993, Digital Equipment Corporation           
 All rights reserved.                                        
 See the file COPYRIGHT for a full description.              

<P>
<P><PRE>MODULE <module>M3CBackEnd_C</module>  EXPORTS <A HREF="../sem/M3CBackEnd.i3.html"><implements>M3CBackEnd</A></implements>, <A HREF="M3CBackEnd_C.i3.html"><implements>M3CBackEnd_C</A></implements>;
</PRE> This module defines the interface for the information required by
the compiler front-end from a back-end . 

<P> ToDo: all the bootstrap things like FIRST(REAL) 
<P>
  4/25/09: fixed FIRST(REAL) etc. but not sure about what this might
  break w.r.t. cross-compiling and such things. 


<P> Version targeted to C back-end for a variety of machines 

<P><PRE>IMPORT <A HREF="../sem/M3CBackEnd.i3.html">M3CBackEnd</A>;
IMPORT <A HREF="../../../libm3/src/fmtlex/Fmt.i3.html">Fmt</A>, <A HREF="../../../m3core/src/text/Text.i3.html">Text</A>, <A HREF="../../../libm3/src/rw/TextRd.i3.html">TextRd</A>, <A HREF="../../../libm3/src/rw/TextWr.i3.html">TextWr</A>, <A HREF="../../../libm3/src/rw/Rd.i3.html">Rd</A>, <A HREF="../../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="../../../m3core/src/word/Word.i3.html">Word</A>, <A HREF="../../../m3core/src/convert/Convert.i3.html">Convert</A>, <A HREF="../../../libm3/src/rw/RdExtras.i3.html">RdExtras</A>;
IMPORT <A HREF="../ast/M3AST_AS.i3.html">M3AST_AS</A>, <A HREF="../ast/M3AST_SM.i3.html">M3AST_SM</A>;

IMPORT <A HREF="../ast/M3AST_AS_F.i3.html">M3AST_AS_F</A>, <A HREF="../ast/M3AST_SM_F.i3.html">M3AST_SM_F</A>;

IMPORT <A HREF="../../derived/SeqM3AST_AS_RANGE_EXP.i3.html">SeqM3AST_AS_RANGE_EXP</A>, <A HREF="../../derived/SeqM3AST_AS_Fields.i3.html">SeqM3AST_AS_Fields</A>;

IMPORT <A HREF="../syn/M3CId.i3.html">M3CId</A>, <A HREF="../syn/M3CLiteral.i3.html">M3CLiteral</A>;
IMPORT <A HREF="../toolmisc/M3Error.i3.html">M3Error</A>, <A HREF="../../../m3tk-misc/src/M3Assert.i3.html">M3Assert</A>, <A HREF="../syn/M3CSrcPos.i3.html">M3CSrcPos</A>;
IMPORT <A HREF="../sem/M3CStdProcs.i3.html">M3CStdProcs</A>, <A HREF="../sem/M3CWordProcs.i3.html">M3CWordProcs</A>;
IMPORT <A HREF="../sem/M3CExpValue.i3.html">M3CExpValue</A>, <A HREF="../sem/M3CTypesMisc.i3.html">M3CTypesMisc</A>, <A HREF="../sem/M3ASTNext.i3.html">M3ASTNext</A>;
FROM <A HREF="M3CBackEnd_C_cc.i3.html">M3CBackEnd_C_cc</A> IMPORT a32, a64, a16, a8, minAlignment, recAlignment,
  arrayAlignment, ptrA, ptrS, realA, realS, longRealA, longRealS, intA, intS,
  longintA, longintS, wideCharA, wideCharS;

IMPORT <A HREF="M3CBackEnd_Int_Integer.i3.html">M3CBackEnd_Int_Integer</A>, <A HREF="M3CBackEnd_Int_Longint.i3.html">M3CBackEnd_Int_Longint</A>;
IMPORT <A HREF="M3CBackEnd_Float_Real.i3.html">M3CBackEnd_Float_Real</A>, <A HREF="M3CBackEnd_Float_LongReal.i3.html">M3CBackEnd_Float_LongReal</A>,
    <A HREF="M3CBackEnd_Float_Extended.i3.html">M3CBackEnd_Float_Extended</A>;
</PRE> For FATAL 
<PRE>IMPORT <A HREF="../../../m3core/src/thread/Common/Thread.i3.html">Thread</A>;

&lt;*FATAL Thread.Alerted, Wr.Failure, Rd.Failure, Rd.EndOfFile, Convert.Failed *&gt;

CONST
  NilValue = 0;
</PRE> This does the alignments for ordinals. 
<PRE>PROCEDURE <A NAME="OrdAlign"><procedure>OrdAlign</procedure></A>(size: INTEGER): INTEGER RAISES {}=
  BEGIN
    IF size = 0 THEN
      RETURN 0
    ELSIF size &lt;= 8 THEN RETURN a8
    ELSIF size &lt;= 16 THEN RETURN a16
    ELSIF size &lt;= 32 THEN RETURN a32
    ELSIF size &lt;= 64 THEN RETURN a64
    ELSE &lt;*ASSERT FALSE*&gt;

    END; (* if *)
  END OrdAlign;
</PRE> This does the alignments for sets. 
<PRE>PROCEDURE <A NAME="SetAlign"><procedure>SetAlign</procedure></A>(VAR (*inout*) size: INTEGER; exact: BOOLEAN): INTEGER =
  BEGIN
    IF NOT exact THEN (* represented as arrays of ints *)
      size := AlignTo(size, intS);
    END; (* if *)
    RETURN MAX(intA, recAlignment);
  END SetAlign;

PROCEDURE <A NAME="RegisterProcs"><procedure>RegisterProcs</procedure></A>() RAISES {}=
  BEGIN
    M3CBackEnd.LiteralValue:= LiteralValue_C;
    M3CBackEnd.ConstructorValue:= ConstructorValue_C;
    M3CBackEnd.ConstructorOriginal:= ConstructorOriginal_C;
    M3CBackEnd.IsOrdinal := IsOrdinal_C;
    M3CBackEnd.Ord:= Ord_C;
    M3CBackEnd.Val:= Val_C;
    M3CBackEnd.ConvertOrdinal := ConvertOrdinal_C;
    M3CBackEnd.BinaryOp:= BinaryOp_C;
    M3CBackEnd.InOp:= InOp_C;
    M3CBackEnd.UnaryOp:= UnaryOp_C;
    M3CBackEnd.StdUnaryOp:= StdUnaryOp_C;
    M3CBackEnd.StdBinaryOp:= StdBinaryOp_C;
    M3CBackEnd.StdUnaryTypeOp:= StdUnaryTypeOp_C;
    M3CBackEnd.WordOp := WordOp_C;
    M3CBackEnd.Compare:= Compare_C;
    M3CBackEnd.LoopholeOK:= LoopholeOK_C;
    M3CBackEnd.BitsOK:= BitsOK_C;
    M3CBackEnd.VarParamOK:= VarParamOK_C;
    M3CBackEnd.BitSizeAndAlign:= BitSizeAndAlign_C;
    M3CBackEnd.ExpValueToText := ExpValueToText_C;
    M3CBackEnd.TextToExpValue := TextToExpValue_C;
  END RegisterProcs;

CONST
  BadBits = -1;

PROCEDURE <A NAME="SizeInBits"><procedure>SizeInBits</procedure></A>(ts: M3AST_SM.TYPE_SPEC_UNSET;
    exact := FALSE): INTEGER RAISES {}=
  BEGIN
    IF ts = NIL THEN
      RETURN BadBits
    ELSE
      MayBeExactBitSizeAndAlign(ts, exact);
      RETURN NARROW(ts, M3AST_AS.TYPE_SPEC).sm_bitsize;
    END;
  END SizeInBits;

PROCEDURE <A NAME="BitSizeAndAlign_C"><procedure>BitSizeAndAlign_C</procedure></A>(ts: M3AST_AS.TYPE_SPEC) RAISES {}=
  BEGIN
    MayBeExactBitSizeAndAlign(ts);
  END BitSizeAndAlign_C;

PROCEDURE <A NAME="MayBeExactBitSizeAndAlign"><procedure>MayBeExactBitSizeAndAlign</procedure></A>(ts: M3AST_AS.TYPE_SPEC;
    exact := FALSE) RAISES {}=
  VAR
    array_element, array_index: M3AST_SM.TYPE_SPEC_UNSET;
    size, align: INTEGER;
    isopen: BOOLEAN;
  BEGIN
    size := 0; align := 0;

    TYPECASE ts OF &lt;*NOWARN*&gt;
    | M3AST_AS.Ref_type,
      M3AST_AS.RefAny_type,
      M3AST_AS.Root_type,
      M3AST_AS.Address_type,
      M3AST_AS.Null_type,
      M3AST_AS.Opaque_type,
      M3AST_AS.Procedure_type =&gt;
        size := ptrS;
        align := ptrA;

    | M3AST_AS.Integer_type =&gt;
        size := intS;
        align := intA;

    | M3AST_AS.Longint_type =&gt;
        size := longintS;
        align := longintA;

    | M3AST_AS.WideChar_type =&gt;
        size := wideCharS;
        align := wideCharA;

    | M3AST_AS.Real_type =&gt;
        size := realS;
        align := realA;

    | M3AST_AS.LongReal_type, M3AST_AS.Extended_type =&gt;
        size := longRealS;
        align := longRealA;

    | M3AST_AS.Enumeration_type(t) =&gt;
        size := BitsForInt(t.sm_num_elements-1, exact);
        align := OrdAlign(size);

    | M3AST_AS.Subrange_type(t) =&gt;
        TYPECASE t.sm_base_type_spec OF
        | M3AST_AS.Longint_type =&gt;
          WITH range = t.as_range,
               s1 = NARROW(range.as_exp1.sm_exp_value, Longint_value).sm_value,
               s2 = NARROW(range.as_exp1.sm_exp_value, Longint_value).sm_value
           DO
            IF s1 &lt;= s2 THEN
              IF s1 &gt;= 0L THEN
                size := BitsForLongint(s2, exact);
              ELSE
                IF s2 &lt; 0L THEN s2 := 0L; END;
                size := 1 + MAX(BitsForLongint(-(s1+1L), TRUE),
                                BitsForLongint(s2, TRUE));
                IF NOT exact THEN size := ChooseByteHalfFull(size); END;
              END;
            END; (* if *)
            align := OrdAlign(size);
          END;
        ELSE
          WITH range = t.as_range,
               s1 = NARROW(range.as_exp1.sm_exp_value, Integer_value).sm_value,
               s2 = NARROW(range.as_exp2.sm_exp_value, Integer_value).sm_value
           DO
            IF s1 &lt;= s2 THEN
              IF s1 &gt;= 0 THEN
                size := BitsForInt(s2, exact);
              ELSE
                IF s2 &lt; 0 THEN s2 := 0; END;
                size := 1 + MAX(BitsForInt(-(s1+1), TRUE),
                                BitsForInt(s2, TRUE));
                IF NOT exact THEN size := ChooseByteHalfFull(size); END;
              END;
            END; (* if *)
            align := OrdAlign(size);
          END;
        END;

    | M3AST_AS.Set_type(t) =&gt;
      VAR s1, s2: INTEGER; BEGIN
        GetSetBounds(t, s1, s2);
        IF s1 &lt;= s2 THEN
          size := 1 + s2 - s1;
        END; (* if *)
        align := SetAlign(size, exact);
      END;

    | M3AST_AS.Packed_type(t) =&gt;
        (* the check for legality is done elsewhere *)
        size := NARROW(t.as_exp.sm_exp_value, Integer_value).sm_value;
        align := 1;

    | M3AST_AS.Record_type(t) =&gt;
        FieldsSizeAndAlign(t.as_fields_s, size, align);

    | M3AST_AS.Object_type(object_type) =&gt;
        (* compute in place in case of self-reference *)
        size := ptrS; ts.sm_bitsize := size;
        align :=  ptrA; ts.sm_align := align;
        (* compute the referent size and alignment (for this component
        of the object; i.e. ignore supertypes). *)
        object_type.sm_rf_bitsize := 0;
        object_type.sm_rf_align := 0;
        FieldsSizeAndAlign(object_type.as_fields_s,
            object_type.sm_rf_bitsize, object_type.sm_rf_align);

    | M3AST_AS.Array_type(t) =&gt;
        EVAL M3ASTNext.Array(t, array_element, isopen, array_index);
        WITH elemTS = NARROW(array_element, M3AST_AS.TYPE_SPEC) DO
          align := MAX(elemTS.sm_align, arrayAlignment);
          IF isopen THEN
            (* leave size at 0 *)
          ELSE
            VAR
              low, high: M3AST_SM.Exp_value;
              s1, s2: INTEGER;
            BEGIN
              IF M3CExpValue.GetBounds(array_index, low, high) =
                    M3CBackEnd.NumStatus.Valid THEN
                s1 := NARROW(low, Integer_value).sm_value;
                s2 := NARROW(high, Integer_value).sm_value;
                IF s1 &lt;= s2 THEN
                  size :=
                      AlignTo(elemTS.sm_bitsize, elemTS.sm_align) * (s2-s1+1);
                END;
              END;
            END;
          END;
        END;
    END; (* case *)

    ts.sm_bitsize := size;
    ts.sm_align := align;
  END MayBeExactBitSizeAndAlign;

PROCEDURE <A NAME="FieldsSizeAndAlign"><procedure>FieldsSizeAndAlign</procedure></A>(fields: SeqM3AST_AS_Fields.T;
    VAR (*inout*) size, align: INTEGER) RAISES {}=
  VAR
    field_id: M3AST_AS.Field_id;
    iter := M3ASTNext.NewIterField(fields);
  BEGIN
    WHILE M3ASTNext.Field(iter, field_id) DO
      size := AlignTo(size, field_id.sm_type_spec.sm_align);
      INC(size, field_id.sm_type_spec.sm_bitsize);
      align := MAX(align, field_id.sm_type_spec.sm_align);
    END;
    align := MAX(align, recAlignment);
  END FieldsSizeAndAlign;

PROCEDURE <A NAME="LiteralValue_C"><procedure>LiteralValue_C</procedure></A>(lit: M3AST_AS.EXP;
    VAR (*out*) er: M3AST_SM.Exp_value): M3CBackEnd.NumStatus RAISES {}=
  BEGIN
    TYPECASE lit OF &lt;*NOWARN*&gt;
    | M3AST_AS.Char_literal =&gt;
        (* 'x' or '\n' or '\ddd' or '\xDD'*)
        VAR
          cvi: INTEGER;
          t: TEXT := M3CLiteral.ToText(
              NARROW(lit, M3AST_AS.Char_literal).lx_litrep);
        BEGIN
          IF Text.GetChar(t, 1) = '\\' THEN
            (* escape *)
            CASE Text.GetChar(t, 2) OF
            | 'n' =&gt; cvi := ORD('\n');
            | 't' =&gt; cvi := ORD('\t');
            | 'r' =&gt; cvi := ORD('\r');
            | '\'' =&gt; cvi := ORD('\'');
            | '\&quot;' =&gt; cvi := ORD('\&quot;');
            | 'f' =&gt; cvi := ORD('\f');
            | '\\' =&gt; cvi := ORD('\\');
            | 'x' =&gt;
              cvi := CHV(Text.GetChar(t, 3)) * 16 +
                     CHV(Text.GetChar(t, 4));
            ELSE  (* \ddd *)
              cvi := CHV(Text.GetChar(t, 2)) * 64 +
                     CHV(Text.GetChar(t, 3)) * 8 +
                     CHV(Text.GetChar(t, 4));
            END; (* case *)
          ELSE
            cvi := ORD(Text.GetChar(t, 1));
          END; (* if *)
          er := M3CBackEnd_Int_Integer.New_value(cvi);
        END;

    | M3AST_AS.WideChar_literal =&gt;
        (* 'x' or '\n' or '\dddddd' or '\xDDDD' *)
        VAR
          cvi: INTEGER;
          t: TEXT := M3CLiteral.ToText(
              NARROW(lit, M3AST_AS.Char_literal).lx_litrep);
        BEGIN
          IF Text.GetChar(t, 1) = '\\' THEN
            (* escape *)
            CASE Text.GetChar(t, 2) OF
            | 'n' =&gt; cvi := ORD('\n');
            | 't' =&gt; cvi := ORD('\t');
            | 'r' =&gt; cvi := ORD('\r');
            | '\'' =&gt; cvi := ORD('\'');
            | '\&quot;' =&gt; cvi := ORD('\&quot;');
            | 'f' =&gt; cvi := ORD('\f');
            | '\\' =&gt; cvi := ORD('\\');
            | 'x' =&gt;
              cvi := CHV(Text.GetChar(t, 3)) * 4096 +
                     CHV(Text.GetChar(t, 4)) * 256 +
                     CHV(Text.GetChar(t, 5)) * 16 +
                     CHV(Text.GetChar(t, 6));
            ELSE  (* \ddd *)
              cvi := CHV(Text.GetChar(t, 2)) * 32768 +
                     CHV(Text.GetChar(t, 3)) * 4096 +
                     CHV(Text.GetChar(t, 4)) * 512 +
                     CHV(Text.GetChar(t, 5)) * 64 +
                     CHV(Text.GetChar(t, 6)) * 8 +
                     CHV(Text.GetChar(t, 7));
            END; (* case *)
          ELSE
            cvi := ORD(Text.GetChar(t, 1));
          END; (* if *)
          er := M3CBackEnd_Int_Integer.New_value(cvi);
        END;

    | M3AST_AS.Text_literal =&gt;
        VAR tv := NEW(Text_value);
            t: TEXT := M3CLiteral.ToText(
                NARROW(lit, M3AST_AS.Text_literal).lx_litrep);
        BEGIN
          er := tv;
          tv.sm_value := Text.Sub(t, 1, Text.Length(t) - 2);
        END;

    | M3AST_AS.WideText_literal =&gt;
        VAR tv := NEW(Text_value);
            t: TEXT := M3CLiteral.ToText(
                NARROW(lit, M3AST_AS.Text_literal).lx_litrep);
        BEGIN
          er := tv;
          tv.sm_value := Text.Sub(t, 2, Text.Length(t) - 3);
        END;

    | M3AST_AS.Nil_literal =&gt;
        er := M3CBackEnd_Int_Integer.New_value(NilValue);

    | M3AST_AS.Integer_literal =&gt;
        VAR
          t: TEXT := M3CLiteral.ToText(
              NARROW(lit, M3AST_AS.Integer_literal).lx_litrep);
          int: INTEGER;
        BEGIN
          IF NOT TextTo_Integer(t, int) THEN
            RETURN M3CBackEnd.NumStatus.Overflow;
          END;
          er := M3CBackEnd_Int_Integer.New_value(int);
        END;

    | M3AST_AS.Longint_literal =&gt;
        VAR
          t: TEXT := M3CLiteral.ToText(
              NARROW(lit, M3AST_AS.Longint_literal).lx_litrep);
          int: LONGINT;
        BEGIN
          IF NOT TextTo_Longint(t, int) THEN
            RETURN M3CBackEnd.NumStatus.Overflow;
          END;
          er := M3CBackEnd_Int_Longint.New_value(int);
        END;

    | M3AST_AS.Real_literal =&gt;
        VAR
	  real: REAL;
	  t := M3CLiteral.ToText(NARROW(lit, M3AST_AS.Real_literal).lx_litrep);
        BEGIN
          IF NOT TextTo_Real(t, real) THEN
            RETURN M3CBackEnd.NumStatus.Overflow;
          END;
          er := M3CBackEnd_Float_Real.New_value(real);
        END;

    | M3AST_AS.LongReal_literal =&gt;
        VAR
	  longReal: LONGREAL;
	  t := M3CLiteral.ToText(
              NARROW(lit, M3AST_AS.LongReal_literal).lx_litrep);
        BEGIN
          IF NOT TextTo_LongReal(t, longReal) THEN
            RETURN M3CBackEnd.NumStatus.Overflow;
          END;
          er := M3CBackEnd_Float_LongReal.New_value(longReal)
        END;

    | M3AST_AS.Extended_literal =&gt;
        VAR
	  extended: EXTENDED;
	  t := M3CLiteral.ToText(
              NARROW(lit, M3AST_AS.Extended_literal).lx_litrep);
        BEGIN
          IF NOT TextTo_Extended(t, extended) THEN
            RETURN M3CBackEnd.NumStatus.Overflow;
          END;
          er := M3CBackEnd_Float_Extended.New_value(extended)
        END;

    | M3AST_AS.Exp_used_id, M3AST_AS.Select =&gt;
        (* procedure constants *)
        VAR
          idp, idu: M3AST_AS.Exp_used_id;
          pv := NEW(Proc_value);
        BEGIN
          er := pv;
          IF ISTYPE(lit, M3AST_AS.Select) THEN
            idp := NARROW(lit, M3AST_AS.Select).as_id;
            idu := NARROW(lit, M3AST_AS.Select).as_exp;
          ELSE
            idp := lit; idu := NIL;
          END; (* if *)
          pv.sm_value := M3CId.ToText(idp.vUSED_ID.lx_symrep);
          IF idu # NIL THEN
            pv.sm_value := M3CId.ToText(idu.vUSED_ID.lx_symrep) &amp; Separator &amp;
              pv.sm_value;
          END; (* if *)
        END;
    END; (* case *)
    RETURN M3CBackEnd.NumStatus.Valid;
  END LiteralValue_C;

&lt;*INLINE*&gt; PROCEDURE <A NAME="CHV"><procedure>CHV</procedure></A>(ch: CHAR): INTEGER RAISES {}=
  BEGIN
    RETURN ORD(ch) - ORD('0');
  END CHV;

PROCEDURE <A NAME="GetSetBounds"><procedure>GetSetBounds</procedure></A>(s: M3AST_AS.Set_type; VAR low, high: INTEGER) RAISES {}=
  VAR
    baseType: M3AST_SM.TYPE_SPEC_UNSET;
    l, h: M3AST_SM.Exp_value;
  BEGIN
    M3CTypesMisc.GetTYPE_SPECFromM3TYPE(s.as_type, baseType);
    M3Assert.Check(
        M3CExpValue.GetBounds(baseType, l, h) = M3CBackEnd.NumStatus.Valid);
    low := NARROW(l, Integer_value).sm_value;
    high := NARROW(h, Integer_value).sm_value;
  END GetSetBounds;

PROCEDURE <A NAME="ConstructorValue_C"><procedure>ConstructorValue_C</procedure></A>(
    cons: M3AST_AS.Constructor;
    VAR (*out*) er: M3AST_SM.Exp_value)
    : M3CBackEnd.NumStatus
    RAISES {}=
  BEGIN
    TYPECASE M3CTypesMisc.CheckedUnpack(cons.sm_exp_type_spec) OF &lt;*NOWARN*&gt;
    | M3AST_AS.Set_type(setType) =&gt;
        VAR
          cv := NEW(Set_constructor_value);
          s1, s2: INTEGER;
        BEGIN
          GetSetBounds(setType, s1, s2);
          cv.sm_low := s1;
          cv.sm_value := NEW(REF ARRAY OF INTEGER,
              (setType.sm_bitsize + Word.Size - 1) DIV Word.Size);
          FOR i := 0 TO LAST(cv.sm_value^) DO
            cv.sm_value[i] := 0;
          END;
          VAR
            iterActuals := SeqM3AST_AS_RANGE_EXP.NewIter(cons.sm_actual_s);
            actual: M3AST_AS.RANGE_EXP;
            lowBit, highBit: INTEGER;
          BEGIN
            WHILE SeqM3AST_AS_RANGE_EXP.Next(iterActuals, actual) DO
              TYPECASE actual OF &lt;*NOWARN*&gt;
              | M3AST_AS.Range_EXP(rExp) =&gt;
                  lowBit := NARROW(
                      rExp.as_exp.sm_exp_value, Integer_value).sm_value;
                  highBit := lowBit;
              | M3AST_AS.Range(range) =&gt;
                  lowBit := NARROW(
                      range.as_exp1.sm_exp_value, Integer_value).sm_value;
                  highBit := NARROW(
                      range.as_exp2.sm_exp_value, Integer_value).sm_value;
              END;
              DEC(lowBit, s1);
              DEC(highBit, s1);
              FOR setbit := lowBit TO highBit DO
                WITH w = cv.sm_value[setbit DIV Word.Size] DO
                  w := Word.Or(w, Word.Shift(1, setbit MOD Word.Size));
                END;
              END;
            END;
          END;
          er := cv;
        END;
    | M3AST_AS.Record_type, M3AST_AS.Array_type =&gt;
        VAR
          cv := NEW(Array_or_record_constructor_value);
        BEGIN
          cv.sm_constructor := cons;
          er := cv;
        END;
    END;
    RETURN M3CBackEnd.NumStatus.Valid;
  END ConstructorValue_C;

PROCEDURE <A NAME="ConstructorOriginal_C"><procedure>ConstructorOriginal_C</procedure></A>(
    e: M3AST_SM.Exp_value)
    : M3AST_AS.Constructor
    RAISES {}=
  BEGIN
    TYPECASE e OF &lt;*NOWARN*&gt;
    | Array_or_record_constructor_value(cv) =&gt;
        RETURN cv.sm_constructor;
    END; (* typecase *)
  END ConstructorOriginal_C;

PROCEDURE <A NAME="IsOrdinal_C"><procedure>IsOrdinal_C</procedure></A>(e: M3AST_SM.Exp_value): BOOLEAN RAISES {}=
  BEGIN
    RETURN e # NIL AND (ISTYPE(e, Integer_value) OR ISTYPE(e, Longint_value));
  END IsOrdinal_C;

PROCEDURE <A NAME="Val_C"><procedure>Val_C</procedure></A>(n: INTEGER;
                ts: M3AST_SM.TYPE_SPEC_UNSET;
    VAR (*out*) er: M3AST_SM.Exp_value): M3CBackEnd.NumStatus RAISES {}=
  BEGIN
    (* ORD(n) = n for all types *)
    TYPECASE ts OF
    | M3AST_AS.Longint_type =&gt;
      er := M3CBackEnd_Int_Longint.New_value(VAL(n, LONGINT));
      RETURN M3CBackEnd.NumStatus.Valid;
    | M3AST_AS.Subrange_type(subrange) =&gt;
      RETURN Val_C(n, subrange.sm_base_type_spec, er);
    ELSE
      er := M3CBackEnd_Int_Integer.New_value(VAL(n, INTEGER));
      RETURN M3CBackEnd.NumStatus.Valid;
    END;
  END Val_C;

PROCEDURE <A NAME="Ord_C"><procedure>Ord_C</procedure></A>(
    e: M3AST_SM.Exp_value;
    VAR (*out*) i: INTEGER)
    : M3CBackEnd.NumStatus
    RAISES {}=
  BEGIN
    TYPECASE e OF &lt;*NOWARN*&gt;
    | Integer_value(iv) =&gt;
        i := iv.sm_value;
        RETURN M3CBackEnd.NumStatus.Valid;
    | Longint_value(iv) =&gt;
        IF iv.sm_value &lt; VAL(FIRST(INTEGER), LONGINT) THEN
          RETURN M3CBackEnd.NumStatus.Overflow;
        END;
        IF iv.sm_value &gt; VAL(LAST(INTEGER), LONGINT) THEN
          RETURN M3CBackEnd.NumStatus.Overflow;
        END;
        i := VAL(iv.sm_value, INTEGER);
        RETURN M3CBackEnd.NumStatus.Valid;
    END;
  END Ord_C;

PROCEDURE <A NAME="ConvertOrdinal_C"><procedure>ConvertOrdinal_C</procedure></A>(
    e: M3AST_SM.Exp_value;
    ts: M3AST_AS.TYPE_SPEC;
    VAR (* out *) er: M3AST_SM.Exp_value)
    : M3CBackEnd.NumStatus
    RAISES {}=
  BEGIN
    TYPECASE ts OF
    | M3AST_AS.Longint_type =&gt;
      TYPECASE e OF &lt;*NOWARN*&gt;
      | Integer_value(iv) =&gt;
        er := M3CBackEnd_Int_Longint.New_value(VAL(iv.sm_value, LONGINT));
      | Longint_value =&gt; er := e;
      END;
    | M3AST_AS.Subrange_type(subrange) =&gt;
      RETURN ConvertOrdinal_C(e, subrange.sm_base_type_spec, er);
    ELSE
      TYPECASE e OF &lt;*NOWARN*&gt;
      | Integer_value =&gt; er := e;
      | Longint_value(iv) =&gt;
        IF iv.sm_value &lt; VAL(FIRST(INTEGER), LONGINT) THEN
          RETURN M3CBackEnd.NumStatus.Overflow;
        END;
        IF iv.sm_value &gt; VAL(LAST(INTEGER), LONGINT) THEN
          RETURN M3CBackEnd.NumStatus.Overflow;
        END;
        er := M3CBackEnd_Int_Integer.New_value(VAL(iv.sm_value, INTEGER));
      END;
    END;
    RETURN M3CBackEnd.NumStatus.Valid;
  END ConvertOrdinal_C;

PROCEDURE <A NAME="BinaryOp_C"><procedure>BinaryOp_C</procedure></A>(op: M3AST_AS.BINARY; e1, e2: M3AST_SM.Exp_value;
    VAR (*out*) er: M3AST_SM.Exp_value): M3CBackEnd.NumStatus RAISES {}=
  BEGIN
    (* Compatibility check *)
    IF TYPECODE(e1) # TYPECODE(e2) THEN
      RETURN M3CBackEnd.NumStatus.Unknown;
    END;
    (* Now the real work, computing values *)
    TYPECASE e2 OF
    | Integer_value(iv2) =&gt;
        RETURN M3CBackEnd_Int_Integer.BinaryOp(op, NARROW(e1, Integer_value),
                                               iv2, er);

    | Longint_value(liv2) =&gt;
        RETURN M3CBackEnd_Int_Longint.BinaryOp(op, NARROW(e1, Longint_value),
                                               liv2, er);

    | Text_value(textValue2) =&gt;
        VAR
          tv := NEW(Text_value);
        BEGIN
          IF ISTYPE(op, M3AST_AS.Textcat) THEN
            er := tv;
            tv.sm_value :=
                NARROW(e1, Text_value).sm_value &amp; textValue2.sm_value;
          ELSE
            RETURN M3CBackEnd.NumStatus.Unknown;
          END;
        END;

    | Real_value(rv2) =&gt;
        RETURN M3CBackEnd_Float_Real.BinaryOp(op,
                                              NARROW(e1, Real_value), rv2, er);

    | LongReal_value(lrv2) =&gt;
        RETURN M3CBackEnd_Float_LongReal.BinaryOp(op,
            NARROW(e1, LongReal_value), lrv2, er);

    | Extended_value(ev2) =&gt;
        RETURN M3CBackEnd_Float_Extended.BinaryOp(op,
            NARROW(e1, Extended_value), ev2, er);

    | Set_constructor_value(c2) =&gt;
        VAR
          c1 := NARROW(e1, Set_constructor_value);
        BEGIN
          IF NUMBER(c1.sm_value^) # NUMBER(c2.sm_value^) THEN
            RETURN M3CBackEnd.NumStatus.Unknown;
          END;
          TYPECASE op OF &lt;*NOWARN*&gt;
          | M3AST_AS.Plus,
            M3AST_AS.Minus,
            M3AST_AS.Times,
            M3AST_AS.Rdiv =&gt;
              (* All return set as result *)
              VAR
                cv := NEW(Set_constructor_value);
              BEGIN
                cv.sm_value := NEW(REF ARRAY OF INTEGER, NUMBER(c1.sm_value^));
                er := cv;
                FOR i := 0 TO LAST(c1.sm_value^) DO
                  WITH w = cv.sm_value[i] DO
                    VAR
                      w1 := c1.sm_value[i];
                      w2 := c2.sm_value[i];
                    BEGIN
                      TYPECASE op OF &lt;*NOWARN*&gt;
                      | M3AST_AS.Plus =&gt;
                          w := Word.Or(w1, w2);
                      | M3AST_AS.Minus =&gt;
                         w := Word.And(w1, Word.Not(w2));
                      | M3AST_AS.Times =&gt;
                          w := Word.And(w1, w2);
                      | M3AST_AS.Rdiv =&gt;
                          w := Word.Xor(w1, w2);
                      END; (* case *)
                    END;
                  END; (* with *)
                END; (* for *)
              END;

          | M3AST_AS.Eq, M3AST_AS.Ne,
            M3AST_AS.Le, M3AST_AS.Ge,
            M3AST_AS.Lt, M3AST_AS.Gt =&gt;
              (* All return booleans. The following is not very efficient but
               who cares? It won't get executed very often. *)
              VAR
                result: BOOLEAN;
              BEGIN
                IF Compare(c1, c2) = 0 THEN
                  (* Equal *)
                  TYPECASE op OF &lt;*NOWARN*&gt;
                  | M3AST_AS.Eq, M3AST_AS.Le, M3AST_AS.Ge =&gt;
                      result := TRUE;
                  | M3AST_AS.Ne, M3AST_AS.Lt, M3AST_AS.Gt =&gt;
                      result := FALSE;
                  END;
                ELSE
                  (* Not equal *)
                  TYPECASE op OF
                  | M3AST_AS.Eq =&gt;
                      result := FALSE;
                  | M3AST_AS.Ne =&gt;
                      result := TRUE;
                  ELSE
                    IF ISTYPE(op, M3AST_AS.Le) OR
		       ISTYPE(op, M3AST_AS.Lt) THEN
                      VAR
                        temp := c1;
                      BEGIN
                        c1 := c2; c2 := temp;
                      END;
                    END;
                    result := TRUE;
                    FOR i := 0 TO LAST(c1.sm_value^) DO
                      VAR
                        elem1 := c1.sm_value[i];
                      BEGIN
                        IF elem1 # Word.Or(elem1, c2.sm_value[i]) THEN
                          result := FALSE;
                          EXIT;
                        END;
                      END;
                    END;
                  END;
                END;
                er := M3CBackEnd_Int_Integer.New_value(ORD(result));
              END;
          END; (* case *)
        END; (* begin *)

    ELSE
      RETURN NotImplemented();
    END; (* case *)

    RETURN M3CBackEnd.NumStatus.Valid;
  END BinaryOp_C;

PROCEDURE <A NAME="InOp_C"><procedure>InOp_C</procedure></A>(e1, e2: M3AST_SM.Exp_value;
    VAR (*out*) er: M3AST_SM.Exp_value): M3CBackEnd.NumStatus RAISES {}=
  VAR
    int := NARROW(e1, Integer_value).sm_value;
    set := NARROW(e2, Set_constructor_value);
    bool: BOOLEAN;
  BEGIN
    WITH i = int - set.sm_low, s = set.sm_value DO
      bool := Word.Extract(s[i DIV Word.Size], i MOD Word.Size, 1) # 0;
    END;
    er := M3CBackEnd_Int_Integer.New_value(ORD(bool));
    RETURN M3CBackEnd.NumStatus.Valid;
  END InOp_C;

PROCEDURE <A NAME="UnaryOp_C"><procedure>UnaryOp_C</procedure></A>(op: M3AST_AS.UNARY; e: M3AST_SM.Exp_value;
    VAR (*out*) er: M3AST_SM.Exp_value): M3CBackEnd.NumStatus RAISES {}=
  BEGIN
    TYPECASE e OF
    | Integer_value(iv) =&gt;
        RETURN M3CBackEnd_Int_Integer.UnaryOp(op, iv, er);

    | Longint_value(liv) =&gt;
        RETURN M3CBackEnd_Int_Longint.UnaryOp(op, liv, er);

    | Real_value(rv) =&gt;
        RETURN M3CBackEnd_Float_Real.UnaryOp(op, rv, er);

    | LongReal_value(lrv) =&gt;
        RETURN M3CBackEnd_Float_LongReal.UnaryOp(op, lrv, er);

    | Extended_value(ev) =&gt;
        RETURN M3CBackEnd_Float_Extended.UnaryOp(op, ev, er);

    ELSE
      RETURN M3CBackEnd.NumStatus.Unknown;
    END; (* case *)
  END UnaryOp_C;

PROCEDURE <A NAME="StdUnaryOp_C"><procedure>StdUnaryOp_C</procedure></A>(f: M3CStdProcs.Func;
    e: M3AST_SM.Exp_value;
    VAR (*out*) er: M3AST_SM.Exp_value;
    it: M3AST_AS.INT_TYPE := NIL;
    ft: M3AST_AS.FLOAT_TYPE := NIL):
  M3CBackEnd.NumStatus RAISES {}=
  BEGIN
    TYPECASE e OF
    | Integer_value(iv) =&gt;
        RETURN M3CBackEnd_Int_Integer.StdUnaryOp(f, iv, er, it, ft);

    | Longint_value(liv) =&gt;
        RETURN M3CBackEnd_Int_Longint.StdUnaryOp(f, liv, er, it, ft);

    | Real_value(rv) =&gt;
        RETURN M3CBackEnd_Float_Real.StdUnaryOp(f, rv, er, it, ft);

    | LongReal_value(lrv) =&gt;
        RETURN M3CBackEnd_Float_LongReal.StdUnaryOp(f, lrv, er, it, ft);

    | Extended_value(ev) =&gt;
        RETURN M3CBackEnd_Float_Extended.StdUnaryOp(f, ev, er, it, ft);
    ELSE
      RETURN NotImplemented();
    END; (* case *)
  END StdUnaryOp_C;

PROCEDURE <A NAME="StdBinaryOp_C"><procedure>StdBinaryOp_C</procedure></A>(f: M3CStdProcs.Func;
    e1, e2: M3AST_SM.Exp_value;
    VAR (*out*) er: M3AST_SM.Exp_value): M3CBackEnd.NumStatus RAISES {}=
  BEGIN
    IF TYPECODE(e1) # TYPECODE(e2) THEN RETURN
      M3CBackEnd.NumStatus.Unknown;
    END;
    TYPECASE e1 OF
    | Integer_value(iv1) =&gt;
        RETURN M3CBackEnd_Int_Integer.StdBinaryOp(f, iv1,
            NARROW(e2, Integer_value), er);

    | Longint_value(liv1) =&gt;
        RETURN M3CBackEnd_Int_Longint.StdBinaryOp(f, liv1,
            NARROW(e2, Longint_value), er);

    | Real_value(rv1) =&gt;
        RETURN M3CBackEnd_Float_Real.StdBinaryOp(f, rv1,
            NARROW(e2, Real_value), er);

    | LongReal_value(lrv1) =&gt;
        RETURN M3CBackEnd_Float_LongReal.StdBinaryOp(f, lrv1,
            NARROW(e2, LongReal_value), er);

    | Extended_value(ev1) =&gt;
        RETURN M3CBackEnd_Float_Extended.StdBinaryOp(f, ev1,
            NARROW(e2, Extended_value), er);

    ELSE
      RETURN NotImplemented();
    END; (* case *)
  END StdBinaryOp_C;

PROCEDURE <A NAME="StdUnaryTypeOp_C"><procedure>StdUnaryTypeOp_C</procedure></A>(
    pf: M3CStdProcs.Func;
    ts: M3AST_SM.TYPE_SPEC_UNSET;
    VAR (*out*) er: M3AST_SM.Exp_value): M3CBackEnd.NumStatus RAISES {}=
  BEGIN
    CASE pf OF
    | M3CStdProcs.T.BitSize =&gt;
        er := M3CBackEnd_Int_Integer.New_value(SizeInBits(ts));
    | M3CStdProcs.T.ByteSize,
      M3CStdProcs.T.AdrSize =&gt;
        er := M3CBackEnd_Int_Integer.New_value(RoundToByte(SizeInBits(ts)));
    | M3CStdProcs.T.First =&gt;
        TYPECASE ts OF &lt;*NOWARN*&gt;
        | M3AST_AS.Integer_type =&gt;
            er := M3CBackEnd_Int_Integer.New_value(FIRST(INTEGER));
        | M3AST_AS.Longint_type =&gt;
            er := M3CBackEnd_Int_Longint.New_value(FIRST(LONGINT));
        | M3AST_AS.WideChar_type =&gt;
            er := M3CBackEnd_Int_Integer.New_value(ORD(FIRST(WIDECHAR)));
        | M3AST_AS.Real_type =&gt;
          er := M3CBackEnd_Float_Real.New_value(FIRST(REAL))
        | M3AST_AS.LongReal_type =&gt;
          er := M3CBackEnd_Float_LongReal.New_value(FIRST(LONGREAL))
        | M3AST_AS.Extended_type =&gt;
          er := M3CBackEnd_Float_Extended.New_value(FIRST(EXTENDED))
        END; (* typecase *)
    | M3CStdProcs.T.Last =&gt;
        TYPECASE ts OF &lt;*NOWARN*&gt;
        | M3AST_AS.Integer_type =&gt;
            er := M3CBackEnd_Int_Integer.New_value(LAST(INTEGER));
        | M3AST_AS.Longint_type =&gt;
            er := M3CBackEnd_Int_Longint.New_value(LAST(LONGINT));
        | M3AST_AS.WideChar_type =&gt;
            er := M3CBackEnd_Int_Integer.New_value(ORD(LAST(WIDECHAR)));
        | M3AST_AS.Real_type =&gt;
          er := M3CBackEnd_Float_Real.New_value(LAST(REAL))
        | M3AST_AS.LongReal_type =&gt;
          er := M3CBackEnd_Float_LongReal.New_value(LAST(LONGREAL))
        | M3AST_AS.Extended_type =&gt;
          er := M3CBackEnd_Float_Extended.New_value(LAST(EXTENDED))
        END; (* typecase *)
    ELSE
      RETURN NotImplemented();
    END; (* case *)
    RETURN M3CBackEnd.NumStatus.Valid;
  END StdUnaryTypeOp_C;

PROCEDURE <A NAME="RoundToByte"><procedure>RoundToByte</procedure></A>(n: INTEGER): INTEGER RAISES {}=
  CONST
    BitsInByte = 8;
  VAR er: INTEGER;
  BEGIN
    er := n DIV BitsInByte;
    IF (n MOD BitsInByte) # 0 THEN
      INC(er);
    END; (* if *)
    RETURN er;
  END RoundToByte;

PROCEDURE <A NAME="WordOp_C"><procedure>WordOp_C</procedure></A>(
    w: M3CWordProcs.T;
    READONLY args: ARRAY OF M3AST_SM.Exp_value;
    VAR (* out *) er: M3AST_SM.Exp_value)
    : M3CBackEnd.NumStatus
    RAISES {}=
  BEGIN
    TYPECASE args[0] OF
    | Integer_value =&gt;
      RETURN M3CBackEnd_Int_Integer.WordOp(w, args, er);
    | Longint_value =&gt;
      RETURN M3CBackEnd_Int_Longint.WordOp(w, args, er);
    ELSE
      RETURN NotImplemented();
    END;
  END WordOp_C;

PROCEDURE <A NAME="LoopholeOK_C"><procedure>LoopholeOK_C</procedure></A>(&lt;*UNUSED*&gt; e: M3AST_AS.EXP;
    &lt;*UNUSED*&gt; ts: M3AST_AS.TYPE_SPEC): BOOLEAN RAISES {}=
  BEGIN
    RETURN TRUE; (* no extra prohibitions *)
  END LoopholeOK_C;

PROCEDURE <A NAME="AlignTo"><procedure>AlignTo</procedure></A>(size, align: CARDINAL): INTEGER RAISES {}=
  VAR
    rem: CARDINAL;
  BEGIN
    IF align = 0 THEN RETURN size END;
    rem := size MOD align;
    IF rem = 0 THEN
      RETURN size
    ELSE
      RETURN size - rem + align;
    END; (* if *)
  END AlignTo;

PROCEDURE <A NAME="BitsForInt"><procedure>BitsForInt</procedure></A>(n: INTEGER; exact := FALSE): CARDINAL RAISES {}=
  VAR i, c: CARDINAL;
  BEGIN
    IF n &lt;= 0 THEN RETURN 0 END;
    i := 0;
    c := n;
    WHILE c # 0 DO
      INC(i); c := c DIV 2;
    END; (* while *)
    IF NOT exact THEN
      i := ChooseByteHalfFull(i);
    END;
    RETURN i;
  END BitsForInt;

PROCEDURE <A NAME="BitsForLongint"><procedure>BitsForLongint</procedure></A>(n: LONGINT; exact := FALSE): CARDINAL RAISES {}=
  VAR i: CARDINAL;
  BEGIN
    IF n &lt;= 0L THEN RETURN 0 END;
    i := 0;
    WHILE n # 0L DO
      INC(i); n := n DIV 2L;
    END; (* while *)
    IF NOT exact THEN
      i := ChooseByteHalfFull(i);
    END;
    RETURN i;
  END BitsForLongint;

PROCEDURE <A NAME="ChooseByteHalfFull"><procedure>ChooseByteHalfFull</procedure></A>(i: INTEGER): INTEGER=
  BEGIN
    IF i &lt;= 8 THEN i := 8
    ELSIF i &lt;= 16 THEN i := 16;
    ELSIF i &lt;= 32 THEN i := 32;
    ELSIF i &lt;= 64 THEN i := 64;
    ELSE &lt;*ASSERT FALSE*&gt;
    END; (* if *)
    RETURN i;
  END ChooseByteHalfFull;

PROCEDURE <A NAME="BitsOK_C"><procedure>BitsOK_C</procedure></A>(e: M3AST_AS.EXP;
    ts: M3AST_AS.TYPE_SPEC): BOOLEAN RAISES {}=
  VAR tts: M3AST_SM.TYPE_SPEC_UNSET;
  BEGIN
    M3Assert.Check(ISTYPE(e.sm_exp_value, Integer_value));
    tts := ts;
    RETURN SizeInBits(tts, exact := TRUE) &lt;=
           NARROW(e.sm_exp_value, Integer_value).sm_value;
  END BitsOK_C;

PROCEDURE <A NAME="VarParamOK_C"><procedure>VarParamOK_C</procedure></A>(ts: M3AST_AS.TYPE_SPEC): BOOLEAN RAISES {}=
  BEGIN
    RETURN ts.sm_align MOD minAlignment = 0;
  END VarParamOK_C;

PROCEDURE <A NAME="Compare_C"><procedure>Compare_C</procedure></A>(e1, e2: M3AST_SM.Exp_value): INTEGER RAISES {}=
  BEGIN
    TYPECASE e1 OF
    | Integer_value(eiv1) =&gt;
        TYPECASE e2 OF
        | Integer_value(eiv2) =&gt;
            IF eiv1.sm_value = eiv2.sm_value THEN
              RETURN 0
            ELSIF eiv1.sm_value &lt; eiv2.sm_value THEN
              RETURN -1
            ELSE
              RETURN 1
            END; (* if *)
        ELSE
          RETURN 1;
        END;

    | Longint_value(eiv1) =&gt;
        TYPECASE e2 OF
        | Longint_value(eiv2) =&gt;
            IF eiv1.sm_value = eiv2.sm_value THEN
              RETURN 0
            ELSIF eiv1.sm_value &lt; eiv2.sm_value THEN
              RETURN -1
            ELSE
              RETURN 1
            END; (* if *)
        ELSE
          RETURN 1;
        END;

    | Set_constructor_value(cv1) =&gt;
        TYPECASE e2 OF
        | Set_constructor_value(cv2) =&gt;
            WITH s1 = cv1.sm_value, s2 = cv2.sm_value DO
              IF NUMBER(cv1.sm_value^) = NUMBER(cv2.sm_value^) THEN
                FOR i := 0 TO LAST(cv1.sm_value^) DO
                  IF s1[i] # s2[i] THEN RETURN 1 END;
                END;
              ELSE
                 RETURN 1;
              END;
              RETURN 0;
            END;
        ELSE
          RETURN 1;
        END;

    | Text_value(tv1) =&gt;
        TYPECASE e2 OF
        | Text_value(tv2) =&gt;
            RETURN Text.Compare(tv1.sm_value, tv2.sm_value);
        ELSE
          RETURN 1;
        END;

    | Proc_value(pv1) =&gt;
        TYPECASE e2 OF
        | Proc_value(pv2) =&gt;
            RETURN Text.Compare(pv1.sm_value, pv2.sm_value);
        ELSE
          RETURN 1;
        END;

    | Real_value(rv1) =&gt;
        TYPECASE e2 OF
        | Real_value(rv2) =&gt;
            IF rv1.sm_value = rv2.sm_value THEN RETURN 0
            ELSIF rv1.sm_value &lt; rv2.sm_value THEN RETURN -1
            ELSE  RETURN 1
            END; (* if *)
        ELSE RETURN 1;
        END;

    | LongReal_value(rv1) =&gt;
        TYPECASE e2 OF
        | LongReal_value(rv2) =&gt;
            IF rv1.sm_value = rv2.sm_value THEN RETURN 0
            ELSIF rv1.sm_value &lt; rv2.sm_value THEN RETURN -1
            ELSE RETURN 1
            END; (* if *)
        ELSE RETURN 1;
        END;

    | Extended_value(rv1) =&gt;
        TYPECASE e2 OF
        | Extended_value(rv2) =&gt;
            IF rv1.sm_value = rv2.sm_value THEN RETURN 0
            ELSIF rv1.sm_value &lt; rv2.sm_value THEN RETURN -1
            ELSE RETURN 1
            END; (* if *)
        ELSE RETURN 1;
        END;

    ELSE
      EVAL NotImplemented();
      RETURN 0;
    END; (* case *)
  END Compare_C;

PROCEDURE <A NAME="NotImplemented"><procedure>NotImplemented</procedure></A>(): M3CBackEnd.NumStatus RAISES {}=
  BEGIN
    M3Error.ReportAtPos(M3CSrcPos.Null, &quot;back-end facility not implemented&quot;);
    RETURN M3CBackEnd.NumStatus.Unknown;
  END NotImplemented;

CONST
  SetCh = 's';
  LongRealCh = 'l';  LongRealText = &quot;l&quot;;
  RealCh = 'r';      RealText = &quot;r&quot;;
  TextCh = 't';      TextText = &quot;t&quot;;
  ProcCh = 'p';      ProcText = &quot;p&quot;;
  LongintCh = 'i';   LongintText = &quot;i&quot;;
  (* Integer values, hopefully the most common, are just hex numbers *)

PROCEDURE <A NAME="ExpValueToText_C"><procedure>ExpValueToText_C</procedure></A>(e: M3AST_SM.Exp_value): TEXT RAISES {}=
  BEGIN
    TYPECASE e OF &lt;*NOWARN*&gt;
    | Integer_value(intValue) =&gt;
        RETURN Fmt.Int(intValue.sm_value, 16);
    | Longint_value(intValue) =&gt;
        RETURN LongintText &amp; Fmt.LongInt(intValue.sm_value, 16);
    | Set_constructor_value(setValue) =&gt;
        VAR
          s := TextWr.New();
          val := setValue.sm_value;
          result: TEXT;
        BEGIN
          Wr.PutChar(s, SetCh);
          Wr.PutText(s, Fmt.F(&quot;%s %s&quot;,
              Fmt.Int(setValue.sm_low, 16),
              Fmt.Int(NUMBER(val^), 16)));
          FOR i := 0 TO LAST(val^) DO
            Wr.PutText(s, Fmt.F(&quot; %s&quot;, Fmt.Int(val[i], 16)));
          END;
          result := TextWr.ToText(s);
          Wr.Close(s);
          RETURN result;
        END;
    | LongReal_value(longValue) =&gt;
        RETURN LongRealText &amp; Fmt.LongReal(longValue.sm_value);
    | Real_value(realValue) =&gt;
        RETURN RealText &amp; Fmt.Real(realValue.sm_value);
    | Proc_value(procValue) =&gt;
        RETURN ProcText &amp; procValue.sm_value;
    | Text_value(textValue) =&gt;
        RETURN TextText &amp; textValue.sm_value;
    END;
  END ExpValueToText_C;

EXCEPTION
  Fatal;
&lt;*FATAL Fatal*&gt;

PROCEDURE <A NAME="TextToExpValue_C"><procedure>TextToExpValue_C</procedure></A>(t: TEXT): M3AST_SM.Exp_value RAISES {}=
  VAR
    length := Text.Length(t);
  BEGIN
    CASE Text.GetChar(t, 0) OF
    | SetCh =&gt;
        RETURN SetTextToExpValue(t);
    | LongRealCh =&gt;
        VAR
	  new := NEW(LongReal_value);
        BEGIN
          IF NOT TextTo_LongReal(t, new.sm_value) THEN RAISE Fatal END;
          RETURN new;
        END;
    | RealCh =&gt;
        VAR
	  new := NEW(Real_value);
        BEGIN
          IF NOT TextTo_Real(t, new.sm_value) THEN RAISE Fatal END;
          RETURN new;
        END;
    | ProcCh =&gt;
        RETURN NEW(Proc_value, sm_value := Text.Sub(t, 1, length - 1));
    | TextCh =&gt;
        RETURN NEW(Text_value, sm_value := Text.Sub(t, 1, length - 1));
    | LongintCh =&gt;
      VAR new := NEW(Longint_value);
      BEGIN
        IF NOT TextTo_Longint(t, new.sm_value, 16) THEN RAISE Fatal END;
        RETURN new;
      END;
    ELSE
      VAR
        new := NEW(Integer_value);
      BEGIN
        IF NOT TextTo_Integer(t, new.sm_value, 16) THEN RAISE Fatal END;
        RETURN new;
      END;
    END
  END TextToExpValue_C;

PROCEDURE <A NAME="SetTextToExpValue"><procedure>SetTextToExpValue</procedure></A>(t: TEXT): Set_constructor_value RAISES {}=
  VAR
    new := NEW(Set_constructor_value);
    s := TextRd.New(t);
  BEGIN
    EVAL(Rd.GetChar(s));
    new.sm_low := GetInt(s, 16);
    new.sm_value := NEW(REF ARRAY OF INTEGER, GetInt(s, 16));
    FOR i := 0 TO LAST(new.sm_value^) DO
      new.sm_value[i] := GetInt(s, 16);
    END;
    Rd.Close(s);
    RETURN new;
  END SetTextToExpValue;

PROCEDURE <A NAME="GetInt"><procedure>GetInt</procedure></A>(s: Rd.T; base: CARDINAL): INTEGER=
  VAR t := RdExtras.GetText(s); result: INTEGER;
  BEGIN
    EVAL TextTo_Integer(t, result, base);
    RETURN result;
  END GetInt;

PROCEDURE <A NAME="TextTo_Integer"><procedure>TextTo_Integer</procedure></A>(t: Text.T;
    VAR i: INTEGER;
    &lt;*UNUSED*&gt; base: Fmt.Base := 10)
    : BOOLEAN=
  VAR used: INTEGER; l: INTEGER;  buf: ARRAY [0..63] OF CHAR;
  BEGIN
    M3Assert.Check(t # NIL);
    l := Text.Length(t);
    M3Assert.Check(l &lt;= NUMBER(buf));
    Text.SetChars(buf, t);
    IF l&gt;2 AND buf[2] = '_' OR
       l&gt;1 AND buf[1] = '_' THEN
      i := Convert.ToUnsigned(SUBARRAY(buf, 0, l), used);
    ELSE
      i := Convert.ToInt(SUBARRAY(buf, 0, l), used);
    END;
    RETURN used = l;
  END TextTo_Integer;

PROCEDURE <A NAME="TextTo_Longint"><procedure>TextTo_Longint</procedure></A>(t: Text.T;
    VAR i: LONGINT;
    &lt;*UNUSED*&gt; base: Fmt.Base := 10)
    : BOOLEAN=
  VAR used: INTEGER; l: INTEGER;  buf: ARRAY [0..63] OF CHAR;
  BEGIN
    M3Assert.Check(t # NIL);
    l := Text.Length(t);
    M3Assert.Check(l &lt;= NUMBER(buf));
    Text.SetChars(buf, t);
    IF l&gt;2 AND buf[2] = '_' OR
       l&gt;1 AND buf[1] = '_' THEN
      i := Convert.ToLongUnsigned(SUBARRAY(buf, 0, l), used);
    ELSE
      i := Convert.ToLongInt(SUBARRAY(buf, 0, l), used);
    END;
    RETURN used = l;
  END TextTo_Longint;

PROCEDURE <A NAME="TextTo_Real"><procedure>TextTo_Real</procedure></A>(t: Text.T; VAR real: REAL): BOOLEAN=
  VAR used: INTEGER;  buf: ARRAY [0..63] OF CHAR;  len := Text.Length(t);
  BEGIN
    M3Assert.Check(len &lt;= NUMBER(buf));
    Text.SetChars(buf, t);
    real := Convert.ToFloat(SUBARRAY(buf, 0, len), used);
    RETURN used = len;
  END TextTo_Real;

PROCEDURE <A NAME="TextTo_LongReal"><procedure>TextTo_LongReal</procedure></A>(t: Text.T; VAR long: LONGREAL): BOOLEAN=
  VAR used: INTEGER;  buf: ARRAY [0..63] OF CHAR;  len := Text.Length(t);
  BEGIN
    M3Assert.Check(len &lt;= NUMBER(buf));
    Text.SetChars(buf, t);
    long := Convert.ToLongFloat(SUBARRAY(buf, 0, len), used);
    RETURN used = len;
  END TextTo_LongReal;

PROCEDURE <A NAME="TextTo_Extended"><procedure>TextTo_Extended</procedure></A>(t: Text.T; VAR extended: EXTENDED): BOOLEAN=
  VAR used: INTEGER;  buf: ARRAY [0..63] OF CHAR;  len := Text.Length(t);
  BEGIN
    M3Assert.Check(len &lt;= NUMBER(buf));
    Text.SetChars(buf, t);
    extended := Convert.ToExtended(SUBARRAY(buf, 0, len), used);
    RETURN used = len;
  END TextTo_Extended;

BEGIN
  RegisterProcs();
END M3CBackEnd_C.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
