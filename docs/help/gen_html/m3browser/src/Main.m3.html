<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: m3browser/src/Main.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>m3browser/src/Main.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright (C) 1992, Digital Equipment Corporation             
 All rights reserved.                                          
 See the file COPYRIGHT for a full description.                
                                                               
 Last modified on Mon Feb  5 10:49:57 PST 1996 by heydon       
      modified on Tue May 23 07:48:55 PDT 1995 by kalsow       
                                                               
 Enhanced by Peter Klein (pk@i3.informatik.rwth-aachen.de) to  
 parse procedure signatures and connect procedure declarations 
 in interfaces with their implmentations. -  Mar 7, 1995       

<P><PRE>MODULE <module><implements><A HREF="../../m3core/src/main/Main.i3.html">Main</A></implements></module>;

IMPORT <A HREF="../../m3core/src/text/Text.i3.html">Text</A>, <A HREF="../../libm3/src/rw/Rd.i3.html">Rd</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="../../libm3/src/rw/TextRd.i3.html">TextRd</A>, <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../m3core/src/time/Common/Time.i3.html">Time</A>, <A HREF="../../libm3/src/fmtlex/Fmt.i3.html">Fmt</A>, <A HREF="../../libm3/derived/IntRefTbl.i3.html">IntRefTbl</A>, <A HREF="../../libm3/derived/IntList.i3.html">IntList</A>;
IMPORT <A HREF="../../libm3/src/os/Common/Process.i3.html">Process</A>, <A HREF="../../libm3/src/params/Params.i3.html">Params</A>, <A HREF="../../libm3/src/fmtlex/Lex.i3.html">Lex</A>, <A HREF="#x1">OS</A>, <A HREF="../../m3core/src/float/IEEE-default/FloatMode.i3.html">FloatMode</A>, <A HREF="../../m3core/src/word/Word.i3.html">Word</A>, <A HREF="../../libm3/derived/IntIntTbl.i3.html">IntIntTbl</A>, <A HREF="../../libm3/derived/TextIntTbl.i3.html">TextIntTbl</A>;
IMPORT <A HREF="../../libm3/src/rw/FileWr.i3.html">FileWr</A>, <A HREF="../../libm3/src/os/Common/OSError.i3.html">OSError</A>, <A HREF="../../libm3/src/atom/Atom.i3.html">Atom</A>, <A HREF="../../m3core/src/time/Common/FmtTime.i3.html">FmtTime</A>, <A HREF="../../m3quake/src/MxConfig.i3.html">MxConfig</A>, <A HREF="../../m3core/src/runtime/common/RTParams.i3.html">RTParams</A>, <A HREF="../../m3core/src/runtime/common/RTCollector.i3.html">RTCollector</A>;
IMPORT <A HREF="../../libm3/src/os/Common/FS.i3.html">FS</A>, <A HREF="../../libm3/derived/RefList.i3.html">RefList</A>, <A HREF="../../libm3/derived/IntSeq.i3.html">IntSeq</A>, <A HREF="#x2">XFormat</A>, <A HREF="../../libm3/derived/RefSeq.i3.html">RefSeq</A>, <A HREF="../../libm3/derived/TextRefTbl.i3.html">TextRefTbl</A>, <A HREF="../../m3markup/src/CharMap.i3.html">CharMap</A>, <A HREF="../../tcp/src/common/IP.i3.html">IP</A>;
IMPORT <A HREF="#x3">Buf</A>, <A HREF="#x4">ID</A>, <A HREF="#x5">Wx</A>, <A HREF="#x6">MarkUp</A>, <A HREF="#x7">CMarkUp</A>, <A HREF="#x8">TCPServer</A>, <A HREF="#x9">ErrLog</A>, <A HREF="../../m3core/src/runtime/common/RTutils.i3.html">RTutils</A>, <A HREF="../../m3core/src/runtime/common/RTHeapStats.i3.html">RTHeapStats</A>;

CONST
  Title_page = &quot;m3browser.html&quot;;
  SLASH      = MxConfig.HOST_PATH_SEP;
  StartPage  = &quot;&lt;HTML&gt;\n&lt;HEAD&gt;\n&quot;;
  StartTitle = &quot;&lt;TITLE&gt;&quot;;
  Body       = &quot;&lt;BODY BGCOLOR=\&quot;#ffffff\&quot; VLINK=\&quot;#006633\&quot;&gt;\n&quot;;
  EndTitle   = &quot;&lt;/TITLE&gt;\n&lt;/HEAD&gt;\n&quot; &amp; Body;
  IsIndex    = &quot;&lt;ISINDEX&gt;\n&quot;;
  EndPage    = &quot;&lt;/BODY&gt;\n&lt;/HTML&gt;\n&quot;;

VAR (* configuration *)
  package_root     := MxConfig.Get(&quot;PKG_USE&quot;);
  server_machine   :  TEXT; (* initialized in &quot;ParseOptions&quot; *)
  server_socket    := 3829;
  server_address   := IP.GetHostAddr();
  accept_address   := server_address;
  accept_maskBits: [0 .. 32] := 0;
  derived_dirs     := IntList.List1 (ID.Add (MxConfig.Get(&quot;BUILD_DIR&quot;)));
  n_workers        := 3;
  refresh_interval := 30.0d0; (* minutes *)
  start_time       := Time.Now ();
  title_page := TRUE;
  verbose := FALSE;

TYPE
  TextVec = REF ARRAY OF TEXT;
  IntVec  = REF ARRAY OF INTEGER;

TYPE
  Class = {
      Interface,
      GenInterface,
      Module,
      GenModule,
      HSource,
      CSource
  };

CONST
  ClassTags = ARRAY Class OF TEXT {
    &quot;interfaces&quot;,
    &quot;generic interfaces&quot;,
    &quot;implementations&quot;,
    &quot;generic implementations&quot;,
    &quot;C include files&quot;,
    &quot;C sources&quot;
  };

CONST
  ClassPrefix = ARRAY Class OF TEXT {
    &quot;B&quot;,  (* interface *)
    &quot;A&quot;,  (* generic interface *)
    &quot;D&quot;,  (* impl *)
    &quot;C&quot;,  (* generic impl *)
    &quot;F&quot;,  (* C include *)
    &quot;E&quot;   (* C source *)
  };

CONST
  ClassTitle = ARRAY Class OF TEXT {
    &quot;Modula-3 Interface: &quot;,
    &quot;Generic Modula-3 Interface: &quot;,
    &quot;Modula-3 Implementation: &quot;,
    &quot;Generic Modula-3 Implementation: &quot;,
    &quot;C include file: &quot;,
    &quot;C source: &quot;
  };

TYPE
  Unit = REF RECORD
    name  : ID.T     := ID.NoID;
    next  : Unit     := NIL;
    set   : UnitSet  := NIL;
    dir   : TEXT     := NIL;
    class : Class    := Class.Interface;
    hidden: BOOLEAN  := FALSE;
  END;

TYPE
  UnitSet = REF RECORD
    pkg           : Pkg     := NIL;
    path          : TEXT    := NIL;
    name          : ID.T    := ID.NoID;
    units         : Unit    := NIL;
    webinfo       : Buf.T   := NIL;
    webinfo_time  : Time.T  := OS.NO_TIME;
    m3export_time : Time.T  := OS.NO_TIME;
    is_pgm        : BOOLEAN := FALSE;
  END;

TYPE
  Pkg = REF RECORD
    name : ID.T      := ID.NoID;
    sets : RefList.T := NIL; (* of UnitSet *)
  END;

CONST
  INTEGER_UID = 16_195c2a74;
  LONGINT_UID = 16_05562176;
  REFANY_UID  = 16_1c1c45e6;
  ADDRESS_UID = 16_08402063;
  ROOT_UID    = 16_9d8fb489;
  UNROOT_UID  = 16_898ea789;
  NULL_UID    = 16_48ec756e;

TYPE
  Type = REF RECORD
    uid       : INTEGER  := 0;
    home      : ID.T     := ID.NoID;
    class     : CHAR     := '\000';
    start     : INTEGER  := 0;
    defn      : Buf.T    := NIL;
    names     : TypeName := NIL;
    super     : Type     := NIL;
    subtypes  : Type     := NIL;
    next_peer : Type     := NIL;
  END;

TYPE
  TypeName = REF RECORD
    next  : TypeName;
    name  : ID.T;
    home  : ID.T;
  END;

TYPE
  DataBase = RECORD
    packages    : IntRefTbl.T; (* package name -&gt; Pkg *)
    libs        : IntRefTbl.T; (* name -&gt; LIST(UnitSet) *)
    pgms        : IntRefTbl.T; (* name -&gt; LIST(UnitSet) *)
    units       : IntRefTbl.T; (* name -&gt; LIST(Unit) *)
    exporters   : IntRefTbl.T; (* name -&gt; LIST(impl name)*)
    importers   : IntRefTbl.T; (* name -&gt; LIST(unit name)*)
    type_ids    : IntRefTbl.T; (* uid -&gt;  Type *)
    type_names  : IntRefTbl.T; (* name -&gt; LIST(Type) *)
    revelations : IntIntTbl.T; (* opaque uid -&gt; concrete uid *)
    opaques     : IntIntTbl.T; (* concrete uid -&gt; opaque uid *)
  END;

VAR
  server      : TCPServer.T := NIL;
  db          : DataBase;
  last_update : Time.T := OS.NO_TIME;
  n_queries   : INTEGER := 0;

PROCEDURE <A NAME="InitDB"><procedure>InitDB</procedure></A> (VAR x: DataBase) =
  BEGIN
    x.packages    := NEW (IntRefTbl.Default).init ();
    x.libs        := NEW (IntRefTbl.Default).init ();
    x.pgms        := NEW (IntRefTbl.Default).init ();
    x.units       := NEW (IntRefTbl.Default).init ();
    x.exporters   := NEW (IntRefTbl.Default).init ();
    x.importers   := NEW (IntRefTbl.Default).init ();
    x.type_ids    := NEW (IntRefTbl.Default).init ();
    x.type_names  := NEW (IntRefTbl.Default).init ();
    x.revelations := NEW (IntIntTbl.Default).init ();
    x.opaques     := NEW (IntIntTbl.Default).init ();
  END InitDB;

PROCEDURE <A NAME="ResetDB"><procedure>ResetDB</procedure></A> (VAR x: DataBase) =
  BEGIN
    x.packages    := NIL;
    x.libs        := NIL;
    x.pgms        := NIL;
    x.units       := NIL;
    x.exporters   := NIL;
    x.importers   := NIL;
    x.type_ids    := NIL;
    x.type_names  := NIL;
    x.revelations := NIL;
    x.opaques     := NIL;
  END ResetDB;
</PRE>-------------------------------------------------- command line parsing ---

<P><PRE>PROCEDURE <A NAME="ParseOptions"><procedure>ParseOptions</procedure></A> () =
  VAR i := 1;  parm: TEXT;  first_dir := TRUE;
  BEGIN
    WHILE (i &lt; Params.Count) DO
      parm := Params.Get (i); INC (i);
      IF Text.Equal (parm, &quot;-workers&quot;) THEN
        parm := Params.Get (i);  INC (i);
        n_workers := GetCard (parm, &quot;number of workers&quot;);
      ELSIF Text.Equal (parm, &quot;-port&quot;) THEN
        parm := Params.Get (i);  INC (i);
        server_socket := GetCard (parm, &quot;port number&quot;);
      ELSIF Text.Equal (parm, &quot;-refresh&quot;) THEN
        parm := Params.Get (i);  INC (i);
        refresh_interval := FLOAT (GetCard(parm, &quot;refresh interval&quot;),LONGREAL);
      ELSIF Text.Equal (parm, &quot;-root&quot;) THEN
        parm := Params.Get (i);  INC (i);
        package_root := parm;
      ELSIF Text.Equal (parm, &quot;-dir&quot;) THEN
        IF (first_dir) THEN derived_dirs := NIL; first_dir := FALSE; END;
        parm := Params.Get (i);  INC (i);
        derived_dirs := IntList.Cons (ID.Add (parm), derived_dirs);
      ELSIF Text.Equal (parm, &quot;-mask&quot;) THEN
        parm := Params.Get (i);  INC (i);
        accept_maskBits := MIN(32,MAX(0,GetCard (parm, &quot;mask length&quot;)));
      ELSIF Text.Equal (parm, &quot;-notitle&quot;) THEN
        title_page := FALSE;
      ELSIF Text.Equal (parm, &quot;-v&quot;) THEN
        verbose := TRUE;
      ELSE
        ErrLog.Msg (&quot;Unrecognized option: &quot;, parm);
        Abort ();
      END;
    END;
    TRY server_machine := IP.GetCanonicalByAddr(IP.GetHostAddr()) EXCEPT
      IP.Error =&gt; server_machine := NIL
    END;
    IF (server_machine = NIL) THEN
      ErrLog.Msg (&quot;unable to get host machine's name&quot;);
      Abort ();
    END;
    derived_dirs := IntList.ReverseD (derived_dirs);
  END ParseOptions;

PROCEDURE <A NAME="GetCard"><procedure>GetCard</procedure></A> (txt: TEXT;  nm: TEXT): INTEGER =
  VAR i: INTEGER;
  BEGIN
    TRY
      i := Lex.Int (TextRd.New (txt));
      IF (i &gt; 0) THEN RETURN i; END;
    EXCEPT Rd.Failure, Lex.Error, FloatMode.Trap, Thread.Alerted =&gt;
      (*ouch*)
    END;
    ErrLog.Msg (&quot;bad &quot;, nm, &quot; specified: &quot;, txt);
    Abort ();
    RETURN 0;
  END GetCard;
</PRE>------------------------------------------------------------ title page ---

<P><PRE>PROCEDURE <A NAME="CreateTitlePage"><procedure>CreateTitlePage</procedure></A> (wx: Wx.T;  relative: BOOLEAN) =
  VAR
    server := server_machine &amp; &quot;:&quot; &amp; Fmt.Int (server_socket);
    update := Fmt.LongReal (refresh_interval, Fmt.Style.Auto,prec:=1);
    d      : IntList.T;
    prefix : TEXT := &quot;&quot;;
  BEGIN
    IF NOT relative THEN
      prefix := &quot;http://&quot; &amp; server ;
    END;
    Out (wx, StartPage);
    Out (wx, StartTitle, &quot;Modula-3 browser&quot;, EndTitle);
    Out (wx, &quot;&lt;H2&gt;Modula-3 browser of &quot;, package_root, &quot;&lt;/H2&gt;&lt;P&gt;\n&quot;);
    Out (wx, &quot;\n&lt;UL&gt;\n&quot;);
    Out (wx, &quot;&lt;LI&gt;&lt;A HREF=\&quot;&quot;, prefix, &quot;/G\&quot;&gt;programs&lt;/A&gt;\n&quot;);
    Out (wx, &quot;&lt;LI&gt;&lt;A HREF=\&quot;&quot;, prefix, &quot;/0\&quot;&gt;libraries&lt;/A&gt;\n&quot;);
    Out (wx, &quot;&lt;LI&gt;&lt;A HREF=\&quot;&quot;, prefix, &quot;/1\&quot;&gt;interfaces&lt;/A&gt;\n&quot;);
    Out (wx, &quot;&lt;LI&gt;&lt;A HREF=\&quot;&quot;, prefix, &quot;/2\&quot;&gt;implementations&lt;/A&gt;\n&quot;);
    Out (wx, &quot;&lt;LI&gt;&lt;A HREF=\&quot;&quot;, prefix, &quot;/K\&quot;&gt;types&lt;/A&gt;\n&quot;);
    Out (wx, &quot;&lt;/UL&gt;\n&lt;P&gt;\n&quot;);
    Out (wx, &quot;&lt;HR&gt;\nserver stats:\n&lt;P&gt;\n&quot;);
    Out (wx, &quot;&lt;PRE&gt;\n&quot;);
    Out (wx, &quot;    server machine:   &quot;, server_machine, &quot;\n&quot;);
    Out (wx, &quot;    server started:   &quot;, FmtTime.Long (start_time), &quot;\n&quot;);
    Out (wx, &quot;    last update:      &quot;, FmtTime.Long (Time.Now ()), &quot;\n&quot;);
    Out (wx, &quot;    update interval:  &quot;, update, &quot; minutes\n&quot;);
    Out (wx, &quot;    queries answered: &quot;, Fmt.Int (n_queries), &quot;\n&quot;);
    Out (wx, &quot;    packages scanned: &quot;, Fmt.Int (db.packages.size()), &quot;\n&quot;);
    Out (wx, &quot;    build dirs:      &quot;);
    d := derived_dirs;
    WHILE (d # NIL) DO
      Out (wx, &quot; &quot;, ID.ToText (d.head));
      d := d.tail;
    END;
    Out (wx, &quot;\n&quot;);
    Out (wx, &quot;&lt;/PRE&gt;\n&quot;);
    Out (wx, EndPage);
  END CreateTitlePage;

PROCEDURE <A NAME="WriteTitlePage"><procedure>WriteTitlePage</procedure></A> () =
  VAR wr: Wr.T;  wx := Wx.New ();
  BEGIN
    CreateTitlePage (wx, relative := FALSE);
    TRY
      wr := FileWr.Open (Title_page);
      Wr.PutText (wr, Wx.ToText (wx));
      Wr.Close (wr);
    EXCEPT
    | Wr.Failure(ec) =&gt;
        ErrLog.Msg (&quot;problem writing \&quot;&quot;, Title_page, &quot;\&quot;&quot;, ErrMsg (ec));
    | Thread.Alerted =&gt;
        ErrLog.Msg (&quot;interrupted while writing \&quot;&quot;, Title_page, &quot;\&quot;&quot;);
    | OSError.E(ec) =&gt;
        ErrLog.Msg (&quot;problem writing \&quot;&quot;, Title_page, &quot;\&quot;&quot;, ErrMsg (ec));
    END;
  END WriteTitlePage;
</PRE>----------------------------------------------- periodic refresh thread ---

<P><PRE>PROCEDURE <A NAME="Refresh"><procedure>Refresh</procedure></A> (&lt;*UNUSED*&gt; service: TCPServer.T) =
  BEGIN
    ScanPackages ();
    IF title_page THEN WriteTitlePage (); END;
    RTCollector.Collect ();
  END Refresh;
</PRE>------------------------------------------------------- package browser ---

<P><PRE>TYPE
  ScanState = RECORD
    pkg_name : ID.T;
    old_pkg  : Pkg;
    new_pkg  : Pkg;
    modified : BOOLEAN;
    dir_name : ID.T;
    new_set  : UnitSet;
    new      : DataBase;
  END;

PROCEDURE <A NAME="ScanPackages"><procedure>ScanPackages</procedure></A> () =
  VAR iter: FS.Iterator;  s: ScanState;  now := Time.Now ();  nm: TEXT;
  BEGIN
    IF verbose THEN ErrLog.Msg (&quot; --- &quot;, FmtTime.Long (now)); END;
    last_update    := now;
    s.modified     := FALSE;
    InitDB (s.new);
    AddBuiltinTypes (s);

    TRY
      iter := FS.Iterate (package_root);
      WHILE iter.next (nm) DO
        s.pkg_name := ID.Add (nm);
        ScanPkg (s);
      END;
    EXCEPT OSError.E (ec) =&gt;
      ErrLog.Msg (&quot;trouble scanning packages&quot;, ErrMsg (ec));
    END;

    IF (s.modified) THEN
      BuildNameMaps (s);
      db := s.new;
      ErrLog.Msg (&quot; --- &quot;, FmtTime.Long (Time.Now ()));
    END;

    (* make sure the collector has a chance *)
    ResetDB (s.new);
    s.old_pkg := NIL;
    s.new_pkg := NIL;
    s.new_set := NIL;
  END ScanPackages;

PROCEDURE <A NAME="ScanPkg"><procedure>ScanPkg</procedure></A> (VAR s: ScanState) =
  VAR ref: REFANY;  d: IntList.T;  u: UnitSet;
  BEGIN
    s.new_pkg := NIL;
    IF db.packages.get (s.pkg_name, ref)
      THEN s.old_pkg := ref;
      ELSE s.old_pkg := NIL;
    END;

    (* scan the derived directories *)
    d := derived_dirs;
    WHILE (d # NIL) DO
      s.dir_name := d.head;
      u := ScanDir (s);
      IF (u # NIL) THEN
        IF (s.new_pkg = NIL) THEN
          s.new_pkg := NEW (Pkg, name := s.pkg_name);
          EVAL s.new.packages.put (s.pkg_name, s.new_pkg);
        END;
        u.pkg := s.new_pkg;
        s.new_pkg.sets := RefList.Cons (u, s.new_pkg.sets);
      END;
      d := d.tail;
    END;
  END ScanPkg;

PROCEDURE <A NAME="ScanDir"><procedure>ScanDir</procedure></A> (VAR s: ScanState): UnitSet =
  VAR
    us_path       := MakePath (ID.ToText (s.pkg_name), ID.ToText (s.dir_name));
    path          := MakePath (package_root, us_path);
    webinfo       := MakePath (path, &quot;.M3WEB&quot;);
    webinfo_time  := OS.ModTime (webinfo);
    m3exports     := MakePath (path, &quot;.M3EXPORTS&quot;);
    m3export_time := OS.ModTime (m3exports);
    us            : UnitSet := NIL;
    old_set       : UnitSet := NIL;
    x             : RefList.T;
  BEGIN
    IF (m3export_time = OS.NO_TIME) AND (webinfo_time = OS.NO_TIME) THEN
      RETURN NIL;
    END;

    IF (s.old_pkg # NIL) THEN
      (* search for a match in the old package *)
      x := s.old_pkg.sets;
      WHILE (x # NIL) DO
        us := x.head;
        IF Text.Equal (us.path, us_path) THEN  old_set := us; EXIT;  END;
        x := x.tail;
      END;
    END;

    IF (old_set # NIL)
      AND (old_set.webinfo_time &gt;= webinfo_time)
      AND (old_set.m3export_time &gt;= m3export_time) THEN
      RETURN old_set;
    END;

    (* build a new unit set *)
    us := NEW (UnitSet);
    us.path          := us_path;
    us.name          := ID.NoID;
    us.units         := NIL;
    us.webinfo       := NIL;
    us.webinfo_time  := webinfo_time;
    us.m3export_time := m3export_time;
    us.is_pgm        := FALSE;

    s.modified := TRUE;
    s.new_set := us;

    IF (old_set # NIL) AND (old_set.webinfo_time &gt;= webinfo_time)
      THEN us.webinfo := old_set.webinfo;
      ELSE us.webinfo := BufFromFile (webinfo);
    END;

    ScanExports (s, m3exports);
    IF (us.name = ID.NoID) THEN
      us.name := s.pkg_name;
    END;

    IF verbose THEN ErrLog.Msg (&quot;updated &quot;, us.path); END;

    RETURN us;
  END ScanDir;
</PRE>------------------------------------------------------------ .M3EXPORTS ---

<P><PRE>PROCEDURE <A NAME="BufFromFile"><procedure>BufFromFile</procedure></A> (path: TEXT; pad: CARDINAL := 0) : Buf.T =
  BEGIN
    TRY
      RETURN Buf.FromFile (path, NIL, pad);
    EXCEPT
      OSError.E =&gt; RETURN NIL;
    END;
  END BufFromFile;

TYPE
  ParseWord = RECORD start, len: INTEGER; END;

VAR
  hidden_id      := ID.Add (&quot;hidden&quot;);
  add_intf_id    := ID.Add (&quot;_map_add_interface&quot;);
  add_mod_id     := ID.Add (&quot;_map_add_module&quot;);
  add_gintf_id   := ID.Add (&quot;_map_add_generic_interface&quot;);
  add_gmod_id    := ID.Add (&quot;_map_add_generic_module&quot;);
  add_c_id       := ID.Add (&quot;_map_add_c_source&quot;);
  add_h_id       := ID.Add (&quot;_map_add_h_source&quot;);
  define_lib_id  := ID.Add (&quot;_define_lib&quot;);
  define_pgm_id  := ID.Add (&quot;_define_pgm&quot;);

PROCEDURE <A NAME="ScanExports"><procedure>ScanExports</procedure></A> (VAR s: ScanState;  m3exports: TEXT) =
  VAR
    cur : INTEGER;
    len : INTEGER;
    n   : INTEGER;
    x   : ARRAY [0..9] OF ParseWord;
    key : ID.T;
    buf := BufFromFile (m3exports);
  BEGIN
    IF (buf = NIL) THEN
      ErrLog.Msg (&quot;unable to read \&quot;&quot;, m3exports, &quot;\&quot;&quot;);
      RETURN;
    END;

    cur := 0;
    len := NUMBER (buf^);
    WHILE (cur &lt; len) DO
      n := ParseLine (buf, cur, x);
      IF (n &gt; 0) THEN
        key := ParseID (buf, x[0]);
        IF (key = add_intf_id) THEN
          AddUnit (s, Class.Interface, buf, x[1], x[2], x[3], x[4]);
        ELSIF (key = add_mod_id) THEN
          AddUnit (s, Class.Module, buf, x[1], x[2], x[3], x[4]);
        ELSIF (key = add_gintf_id) THEN
         AddUnit (s, Class.GenInterface, buf, x[1], x[2], x[3], x[4]);
        ELSIF (key = add_gmod_id) THEN
          AddUnit (s, Class.GenModule, buf, x[1], x[2], x[3], x[4]);
        ELSIF (key = add_c_id) THEN
          AddUnit (s, Class.CSource, buf, x[1], x[2], x[3], x[4]);
        ELSIF (key = add_h_id) THEN
          AddUnit (s, Class.HSource, buf, x[1], x[2], x[3], x[4]);
        ELSIF (key = define_lib_id) THEN
          s.new_set.is_pgm := FALSE;
          s.new_set.name   := ParseID (buf, x[1]);
        ELSIF (key = define_pgm_id) THEN
          s.new_set.is_pgm := TRUE;
          s.new_set.name   := ParseID (buf, x[1]);
        END;
      END;
    END;
  END ScanExports;

PROCEDURE <A NAME="ParseLine"><procedure>ParseLine</procedure></A> (buf: Buf.T;  VAR cur: INTEGER;
                      VAR x: ARRAY [0..9] OF ParseWord): INTEGER =
  VAR
    eof := NUMBER (buf^);
    len := 0;
    cnt := 0;
    ch  : CHAR;
  BEGIN
    FOR i := FIRST (x) TO LAST (x) DO  x[i].start := 0;  x[i].len := 0;  END;

    ch := buf[cur]; INC (cur);
    WHILE (cur &lt;= eof) AND (ch # '\n') DO
      IF (ch = '%') THEN
        (* comment to end of line *)
        WHILE (cur &lt; eof) AND (ch # '\n') DO ch := buf[cur];  INC (cur);  END;
        EXIT;
      ELSIF (ch = '(') OR (ch = ',') OR (ch = ')')
        OR (ch = ' ') OR (ch = '\t') OR (ch = '&quot;') OR (ch = '\r') THEN
        (* misc. punctuation *)
        IF (len &gt; 0) THEN
          x [cnt].len := len;
          INC (cnt);
          len := 0;
        END;
      ELSIF (len &lt;= 0) THEN
        (* start a new word *)
        x [cnt].start := cur-1;
        len := 1;
      ELSE
        INC (len);
      END;
      ch := buf[cur]; INC (cur);
    END;

    IF (len &gt; 0) THEN
      x [cnt].len := len;
      INC (cnt);
      len := 0;
    END;
    RETURN cnt;
  END ParseLine;

PROCEDURE <A NAME="AddUnit"><procedure>AddUnit</procedure></A> (VAR s: ScanState;  class: Class;  buf: Buf.T;
                     READONLY xname, xpkg, xpkg_dir, xhide: ParseWord) =
  VAR
    name    := ParseID (buf, xname);
    pkg     := ParseID (buf, xpkg);
    pkg_dir := ParseID (buf, xpkg_dir);
    hide    := ParseID (buf, xhide);
    d       := s.new_set;
    dir     := MakePath (ID.ToText (pkg), ID.ToText (pkg_dir));
  BEGIN
    d.units := NEW (Unit, name := name, next := d.units, set := d,
                    dir := dir, class := class, hidden := (hide = hidden_id));
  END AddUnit;

PROCEDURE <A NAME="ParseID"><procedure>ParseID</procedure></A> (buf: Buf.T;  READONLY x: ParseWord): ID.T =
  BEGIN
    RETURN ID.FromStr (SUBARRAY (buf^, x.start, x.len));
  END ParseID;
</PRE>---------------------------------------------------------------- .M3WEB ---

<P><PRE>PROCEDURE <A NAME="ScanWebInfo"><procedure>ScanWebInfo</procedure></A> (VAR s: ScanState;  buf: Buf.T) =
  VAR
    c         : CHAR;
    is_intf   : BOOLEAN;
    cur       : INTEGER;
    len       : INTEGER;
    eol       : INTEGER;
    cur_file  : ID.T;
    cur_unit  : ID.T;
    unit      : ID.T;
    uid       : INTEGER;
    type_name : ID.T;
    start     : INTEGER;
    lhs, rhs  : INTEGER;
    super     : INTEGER;
  BEGIN
    IF (buf = NIL) THEN RETURN END;

    cur := 0;
    len := NUMBER (buf^);

    (* skip the table of contents *)
    WHILE (cur &lt; len) AND (buf[cur] # '$')  DO INC (cur); END;
    WHILE (cur &lt; len) AND (buf[cur] # '\n') DO INC (cur); END;

    WHILE (cur &lt; len) DO
      c := buf[cur]; INC (cur);
      eol := cur;
      WHILE (eol &lt; len) AND (buf[eol] # '\n') AND (buf[eol] # '\r') DO
        INC (eol);
      END;
      CASE c OF
      | '@' =&gt; (* file name  *)
          cur_file := ID.FromStr (SUBARRAY (buf^, cur, eol-cur));
      | 'A' =&gt; (* module name *)
          cur_unit := UnitName (buf, cur, eol-cur, FALSE);
          is_intf := FALSE;
      | 'B' =&gt; (* interface name *)
          cur_unit := UnitName (buf, cur, eol-cur, TRUE);
          is_intf := TRUE;
      | 'C' =&gt; (* import *)
          unit := UnitName (buf, cur, eol-cur, TRUE);
          IF NOT is_intf OR (unit # cur_unit) THEN
            NoteUse (s.new.importers, cur_unit, unit);
          END;
      | 'D' =&gt; (* export *)
          unit := UnitName (buf, cur, eol-cur, TRUE);
          IF NOT is_intf OR (unit # cur_unit) THEN
            NoteUse (s.new.exporters, cur_unit, unit);
          END;
      | 'E' =&gt; (* typename *)
          uid := ReadUID (buf, cur);
          SkipBlanks (buf, cur);
          type_name := ID.FromStr (SUBARRAY (buf^, cur, eol-cur));
          NoteTypeName (s, uid, type_name, cur_unit);
      | 'F', 'G', 'H', 'J', 'K', 'M', 'N', 'Q', 'R', 'Y' =&gt;
          start := cur-1;
          uid := ReadUID (buf, cur);
          NoteType (s, uid, buf, start, cur_unit, c);
      | 'O' =&gt;
          start := cur-1;
          uid := ReadUID (buf, cur);
          NoteType (s, uid, buf, start, cur_unit, c);
          NoteSubtype (s, uid, ADDRESS_UID);
      | 'P' =&gt;
          start := cur-1;
          uid := ReadUID (buf, cur);
          NoteType (s, uid, buf, start, cur_unit, c);
          NoteSubtype (s, uid, REFANY_UID);
      | 'U', 'V' =&gt;
          start := cur-1;
          uid := ReadUID (buf, cur);
          super := ReadUID (buf, cur);
          NoteType (s, uid, buf, start, cur_unit, c);
          IF (super # 0) THEN NoteSubtype (s, uid, super); END;
      | 'Z' =&gt;
          lhs := ReadUID (buf, cur);
          SkipBlanks (buf, cur);
          rhs := ReadUID (buf, cur);
          NoteRevelation (s, lhs, rhs);
      | '?' =&gt; (* builtin type *)
          start := cur-1;
          uid := ReadUID (buf, cur);
          SkipBlanks (buf, cur);
          type_name := ID.FromStr (SUBARRAY (buf^, cur, eol-cur));
          NoteType (s, uid, buf, start, cur_unit, c);
          NoteTypeName (s, uid, type_name, cur_unit);
      ELSE (* skip *)
      END;
      cur := eol;
      WHILE (cur &lt; len) AND ((buf[cur] = '\n') OR (buf[cur] = '\r')) DO
        INC (cur);
      END;
    END;
  END ScanWebInfo;

PROCEDURE <A NAME="UnitName"><procedure>UnitName</procedure></A> (buf: Buf.T;  start, len: INTEGER;  intf: BOOLEAN): ID.T =
  CONST CC = ARRAY BOOLEAN OF CHAR { 'm', 'i' };
  VAR xx: ARRAY [0..255] OF CHAR;  n := MIN (NUMBER (xx), len);
  BEGIN
    SUBARRAY (xx, 0, n) := SUBARRAY (buf^, start, n);
    IF (n &lt; NUMBER (xx)) THEN xx[n] := '.'; INC (n); END;
    IF (n &lt; NUMBER (xx)) THEN xx[n] := CC[intf]; INC (n); END;
    IF (n &lt; NUMBER (xx)) THEN xx[n] := '3'; INC (n); END;
    RETURN ID.FromStr (SUBARRAY (xx, 0, n));
  END UnitName;

PROCEDURE <A NAME="NoteUse"><procedure>NoteUse</procedure></A> (tbl: IntRefTbl.T;  impl, intf: ID.T) =
  VAR ref: REFANY;  ids: IntList.T;
  BEGIN
    IF tbl.get (intf, ref) THEN
      ids := ref;
      WHILE (ids # NIL) DO
        IF (ids.head = impl) THEN RETURN; END;
        ids := ids.tail;
      END;
      ids := ref;
      ids.tail := IntList.Cons (impl, ids.tail);
    ELSE
      EVAL tbl.put (intf, IntList.List1 (impl));
    END;
  END NoteUse;

PROCEDURE <A NAME="NoteTypeName"><procedure>NoteTypeName</procedure></A> (VAR s: ScanState;  uid: INTEGER;  name, home: ID.T) =
  VAR t := NewType (s, uid);  tn: TypeName;  x: RefList.T;  ref: REFANY;
  BEGIN
    (* search for a duplicate *)
    tn := t.names;
    WHILE (tn # NIL) DO
      IF (tn.name = name) AND (tn.home = home) THEN RETURN END;
      tn := tn.next;
    END;

    (* create a new name *)
    tn := NEW (TypeName, next := NIL, name := name, home := home);
    IF (t.names # NIL) THEN
      (* preserve the &quot;first&quot; name *)
      tn.next := t.names.next;
      t.names.next := tn;
    ELSE
      t.names := tn;
    END;

    (* register the name in the table *)
    IF s.new.type_names.get (name, ref) THEN
      x := ref;
      x.tail := RefList.Cons (t, x.tail);
    ELSE
      EVAL s.new.type_names.put (name, RefList.List1 (t));
    END;
  END NoteTypeName;

PROCEDURE <A NAME="NoteType"><procedure>NoteType</procedure></A> (VAR s: ScanState;  uid: INTEGER;  buf: Buf.T;
                    start: INTEGER;  home: ID.T;  class: CHAR) =
  VAR t := NewType (s, uid);
  BEGIN
    IF (t.home = ID.NoID) THEN
      t.class  := class;
      t.home   := home;
      t.defn   := buf;
      t.start  := start;
    END;
  END NoteType;

PROCEDURE <A NAME="NoteRevelation"><procedure>NoteRevelation</procedure></A> (VAR s: ScanState;  lhs, rhs: INTEGER) =
  BEGIN
    EVAL s.new.revelations.put (lhs, rhs);
    EVAL s.new.opaques.put (rhs, lhs);
  END NoteRevelation;

PROCEDURE <A NAME="NoteSubtype"><procedure>NoteSubtype</procedure></A> (VAR s: ScanState;  subtype, super: INTEGER) =
  VAR sub := NewType (s, subtype);  sup := NewType (s, super);
  BEGIN
    IF (sub.super = NIL) THEN
      sub.super := sup;
      sub.next_peer := sup.subtypes;
      sup.subtypes := sub;
    ELSIF (sub.super # sup) THEN
      ErrLog.Msg (&quot;two super types for &quot;, FmtUID(sub.uid),
                    &quot; =&gt; &quot;, FmtUID (sub.super.uid) &amp;&quot; and &quot;&amp; FmtUID (sup.uid));
    END;
  END NoteSubtype;

PROCEDURE <A NAME="SuperType"><procedure>SuperType</procedure></A> (t: Type): Type =
  BEGIN
    IF (t = NIL) THEN
      RETURN NIL;
    ELSIF (t.super # NIL) THEN
      RETURN t.super;
    ELSIF TranslateOpaque (t.uid, t) AND (t.super # NIL) THEN
      RETURN t.super;
    ELSE
      RETURN NIL;
    END;
  END SuperType;

PROCEDURE <A NAME="TranslateOpaque"><procedure>TranslateOpaque</procedure></A> (lhs_uid: INTEGER;  VAR rhs: Type): BOOLEAN =
  VAR rhs_uid: INTEGER;  ref: REFANY;
  BEGIN
    IF db.revelations.get (lhs_uid, rhs_uid)
      AND db.type_ids.get (rhs_uid, ref) THEN
      rhs := ref;
      RETURN TRUE;
    END;
    RETURN FALSE;
  END TranslateOpaque;

PROCEDURE <A NAME="FindOpaque"><procedure>FindOpaque</procedure></A> (rhs_uid: INTEGER;  VAR lhs: Type): BOOLEAN =
  VAR lhs_uid: INTEGER;  ref: REFANY;
  BEGIN
    IF db.opaques.get (rhs_uid, lhs_uid)
      AND db.type_ids.get (lhs_uid, ref) THEN
      lhs := ref;
      RETURN TRUE;
    END;
    RETURN FALSE;
  END FindOpaque;

PROCEDURE <A NAME="NewType"><procedure>NewType</procedure></A> (VAR s: ScanState;  uid: INTEGER): Type =
  VAR t: Type;  ref: REFANY;
  BEGIN
    IF s.new.type_ids.get (uid, ref) THEN
      t := ref;
    ELSE
      t := NEW (Type, uid := uid, class := '\000');
      EVAL s.new.type_ids.put (uid, t);
    END;
    RETURN t;
  END NewType;
</PRE>-------------------------------------------------------------- name map ---

<P><PRE>PROCEDURE <A NAME="BuildNameMaps"><procedure>BuildNameMaps</procedure></A> (VAR s: ScanState) =
  VAR
    it   := s.new.packages.iterate ();
    pkg  : Pkg;
    set  : UnitSet;
    unit : Unit;
    x    : RefList.T;
    nm   : INTEGER;
    ref  : REFANY;
  BEGIN
    WHILE it.next (nm, ref) DO
      pkg := ref;
      x := pkg.sets;
      WHILE (x # NIL) DO
        set := x.head;
        IF (set.name # ID.NoID) THEN
          IF (set.is_pgm)
            THEN AddName (s.new.pgms, set.name, set);
            ELSE AddName (s.new.libs, set.name, set);
          END;
        END;
        unit := set.units;
        WHILE (unit # NIL) DO
          AddName (s.new.units, unit.name, unit);
          unit := unit.next;
        END;
        ScanWebInfo (s, set.webinfo);
        x := x.tail;
      END;
    END;

  END BuildNameMaps;

CONST
  BuiltinDesc =
      &quot;$ 0\n&quot;
    &amp; &quot;@**PREDEFINED**\n&quot;
    &amp; &quot;BM3_BUILTIN\n&quot;
    &amp; &quot;?195c2a74 INTEGER\n&quot;
    &amp; &quot;?05562176 LONGINT\n&quot;
    &amp; &quot;?97e237e2 CARDINAL\n&quot;
    &amp; &quot;?9ced36e7 LONGCARD\n&quot;
    &amp; &quot;?1e59237d BOOLEAN\n&quot;
    &amp; &quot;?08402063 ADDRESS\n&quot;
    &amp; &quot;?56e16863 CHAR\n&quot;
    &amp; &quot;?48e16572 REAL\n&quot;
    &amp; &quot;?94fe32f6 LONGREAL\n&quot;
    &amp; &quot;?9ee024e3 EXTENDED\n&quot;
    &amp; &quot;?48ec756e NULL\n&quot;
    &amp; &quot;?1c1c45e6 REFANY\n&quot;
    &amp; &quot;?00000000 VOID\n&quot;
    &amp; &quot;V9d8fb489 00000000 0 0 0 4\n&quot; (* ROOT = OBJECT END *)
    &amp; &quot;E9d8fb489 ROOT\n&quot;
    &amp; &quot;U898ea789 00000000 0 0 0 4\n&quot; (* UNTRACED ROOT = UNTRACED OBJECT END *)
    &amp; &quot;E898ea789 UNTRACED-ROOT\n&quot;
    &amp; &quot;Y50f86574 1c1c45e6\n&quot; (* TEXT &lt;: REFANY *)
    &amp; &quot;E50f86574 TEXT\n&quot;
    &amp; &quot;Y1541f475 9d8fb489\n&quot; (* MUTEX &lt;: ROOT *)
    &amp; &quot;E1541f475 MUTEX\n&quot;
    ;

VAR(*CONST*) BuiltinBuf := Buf.FromText (BuiltinDesc);

PROCEDURE <A NAME="AddBuiltinTypes"><procedure>AddBuiltinTypes</procedure></A> (VAR s: ScanState) =
  BEGIN
    ScanWebInfo (s, BuiltinBuf);
    NoteSubtype (s, UNROOT_UID, ADDRESS_UID); (* UNTRACED-ROOT &lt;: ADDRESS *)
    NoteSubtype (s, ROOT_UID,   REFANY_UID);  (* ROOT &lt;: REFANY *)
    NoteSubtype (s, NULL_UID,   REFANY_UID);  (* NULL &lt;: REFANY *)
    (*** too messy for the current data structures ****************
    NoteSubtype (s, NULL_UID,   ADDRESS_UID); (* NULL &lt;: ADDRESS *)
    ***************************************************************)
  END AddBuiltinTypes;

PROCEDURE <A NAME="AddName"><procedure>AddName</procedure></A> (tbl: IntRefTbl.T;  nm: ID.T;  val: REFANY) =
  VAR ref: REFANY;  x: RefList.T;
  BEGIN
    IF tbl.get (nm, ref) THEN
      x := ref;
      x.tail := RefList.Cons (val, x.tail);
    ELSE
      EVAL tbl.put (nm, RefList.List1 (val));
    END;
  END AddName;
</PRE>----------------------------------------------------- misc. I/O support ---

<P><PRE>PROCEDURE <A NAME="ErrMsg"><procedure>ErrMsg</procedure></A> (args: OSError.Code): TEXT =
  VAR msg: TEXT := NIL;
  BEGIN
    WHILE (args # NIL) DO
      IF (msg = NIL)
        THEN msg := &quot;: &quot;;
        ELSE msg := msg &amp; &quot; *** &quot;;
      END;
      msg := msg &amp; Atom.ToText (args.head);
      args := args.tail;
    END;
    RETURN msg;
  END ErrMsg;
</PRE>--------------------------------------------------- main request server ---

<P><PRE>PROCEDURE <A NAME="ProcessRequest"><procedure>ProcessRequest</procedure></A> (&lt;*UNUSED*&gt;service: TCPServer.T;  req: TEXT): TEXT =
  VAR
    len   := Text.Length (req);
    wx    := Wx.New ();
    cmd   : CHAR;
    query : TextVec;
    buf   : Buf.T;
    orig  : TEXT;
    answer: TEXT;
  BEGIN
    orig := req;
    INC (n_queries);
    IF (len &lt; 5) THEN
      ErrLog.Msg (&quot;request too short: &quot;, req);
      RETURN &quot;HTTP/1.0 400 request too short: &quot; &amp; req &amp; &quot;\r\n&quot;;
    ELSIF NOT Text.Equal (Text.Sub (req, 0, 5), &quot;GET /&quot;) THEN
      ErrLog.Msg (&quot;unknown request: &quot;, req);
      RETURN &quot;HTTP/1.0 400 unknown request: &quot; &amp; req &amp; &quot;\r\n&quot;;
    END;

    IF len = 5 THEN req := req &amp; &quot; &quot;; len := 6; END;  (* &quot;GET /&quot; -&gt; &quot;GET / &quot; *)
    cmd := Text.GetChar (req, 5);
    buf := NEW (Buf.T, len - 6);
    Text.SetChars (buf^, Text.Sub (req, 6));
    ParseQuery (buf^, req, query);
    IF Text.Equal (req, &quot;HTTP/1.0&quot;) THEN req := &quot;&quot;; END;

    Wx.PutText (wx, &quot;HTTP/1.0 200 ok\r\n&quot;);
    IF (cmd # 'Z') THEN Wx.PutText (wx, &quot;Content-type: text/html\n\n&quot;); END;
    CASE cmd OF
    | '0' =&gt;  GenUnitSetList (query, wx, FALSE);
    | '1' =&gt;  GenIntfList (req, query, wx);
    | '2' =&gt;  GenImplList (req, query, wx);
    | '3' =&gt;  GenAnyUnit (req, wx);
    | '4' =&gt;  GenExportUnit (req, wx);
    | '5' =&gt;  GenAnyUnitSet (req, wx, FALSE);
    | '6' =&gt;  GenOneUnit (req, wx);
    | '8' =&gt;  GenOneUnitSet  (req, wx, FALSE);
    | '9' =&gt;  GenUnitSetPrefix (req, query, wx, FALSE);
    | 'A' =&gt;  GenUnitPrefix (req, wx, Class.GenInterface, query);
    | 'B' =&gt;  GenUnitPrefix (req, wx, Class.Interface, query);
    | 'C' =&gt;  GenUnitPrefix (req, wx, Class.GenModule, query);
    | 'D' =&gt;  GenUnitPrefix (req, wx, Class.Module, query);
    | 'E' =&gt;  GenUnitPrefix (req, wx, Class.CSource, query);
    | 'F' =&gt;  GenUnitPrefix (req, wx, Class.HSource, query);
    | 'G' =&gt;  GenUnitSetList (query, wx, TRUE);
    | 'H' =&gt;  GenAnyUnitSet (req, wx, TRUE);
    | 'I' =&gt;  GenOneUnitSet  (req, wx, TRUE);
    | 'J' =&gt;  GenUnitSetPrefix (req, query, wx, TRUE);
    | 'K' =&gt;  GenTypeList (req, query, wx);
    | 'L' =&gt;  GenOneType (req, wx);
    | 'M' =&gt;  GenTypePrefix (req, query, wx);
    | 'N' =&gt;  GenTypeFromUID (req, wx, FALSE);
    | 'O' =&gt;  GenTypeFromUID (req, wx, TRUE);
    | 'P' =&gt;  GenTypeGraph (req, wx);
    | 'Q' =&gt;  GenFlatType (req, wx);
    | 'R' =&gt;  GenImportUnits (req, wx);
    | 'S' =&gt;  GenProcExporterUnit (req, wx);
    | 'X' =&gt;  RTutils.Heap (TRUE, RTutils.HeapPresentation.ByByteCount);
    | 'Y' =&gt;  RTHeapStats.ReportReachable ();
    | 'Z' =&gt;  Wx.PutText (wx, &quot;Content-type: application/edit\n\n&quot;);
              Wx.PutText (wx, req);
              Wx.PutText (wx, &quot;\n&quot;);
    | '\n', '\r', '\t', ' ' =&gt; CreateTitlePage (wx, relative := TRUE);
    ELSE
      req := Text.FromChar (cmd) &amp; req;
      ErrLog.Msg (&quot;unknown request: `GET /&quot;, req, &quot;'&quot;);
      RETURN &quot;HTTP/1.0 400 unknown request: GET /&quot; &amp; req &amp; &quot;\r\n&quot;;
    END;

    answer := Wx.ToText (wx);

    (* make sure the collector has a chance *)
    wx    := NIL;
    query := NIL;
    buf   := NIL;
    orig  := NIL;

    RETURN answer;
  END ProcessRequest;

PROCEDURE <A NAME="ParseQuery"><procedure>ParseQuery</procedure></A> (VAR buf   : ARRAY OF CHAR;
                      VAR req   : TEXT;
                      VAR query : TextVec) =

  VAR
    len := NUMBER (buf);
    ch, cx: CHAR;
    start: INTEGER := 0;
    s0, end, n_words: INTEGER;

  PROCEDURE AddWord (a, b: INTEGER) =
    BEGIN
      IF (n_words &lt; NUMBER (query^)) AND (b &gt; a) THEN
        query [n_words] := Text.FromChars (SUBARRAY (buf, a, b-a));
        INC (n_words);
      END;
    END AddWord;

  BEGIN
    req := &quot;&quot;;
    query := NIL;
    IF (len &lt;= 0) THEN RETURN; END;

    (* skip leading white space *)
    WHILE (start &lt; len) DO
      ch := buf[start];
      IF (ch # ' ') AND (ch # '\n') AND (ch # '\r') AND (ch # '\t') THEN
        EXIT;
      END;
      INC (start);
    END;

    (* find the end of the request *)
    end := start;
    WHILE (end &lt; len) DO
      ch := buf[end];
      IF (ch = ' ') OR (ch = '?') OR (ch = '\n')
        OR (ch = '\r') OR (ch = '\t') THEN
        req := Text.FromChars (SUBARRAY (buf, start, end - start));
        EXIT;
      END;
      INC (end);
    END;

    IF (ch # '?') THEN RETURN END;

    (* count the words in the query *)
    start := end;  (* == index of '?' *)
    end := start+1;  n_words := 1;
    WHILE (end &lt; len) DO
      ch := buf[end];
      IF (ch = '+') THEN INC (n_words) END;
      INC (end);
    END;

    (* allocate space for the query *)
    query := NEW (TextVec, n_words);

    (* extract the words *)
    INC (start);  s0 := start; end := start; n_words := 0;
    LOOP
      IF (end &gt;= len) THEN
        AddWord (start, s0);
        EXIT;
      END;
      ch := buf[end];
      IF (ch = '+') THEN
        AddWord (start, s0);
        start := end + 1;  s0 := start;  end := start;
      ELSIF (ch = '%') THEN
        (* grab the next two letters and build the ascii character *)
        INC (end);  ch := buf [MIN (len-1, end)];
        INC (end);  cx := buf [MIN (len-1, end)];
        buf [s0] := HexChar (ch, cx);  INC (s0);
        INC (end);
      ELSIF (ch = ' ') OR (ch = '\n') OR (ch = '\r') OR (ch = '\t') THEN
        (* end of string *)
        AddWord (start, s0);
        EXIT;
      ELSE
        (* add the character *)
        buf [s0] := ch;  INC (s0);
        INC (end);
      END;
    END;

    (* make sure the query isn't filled with NILs *)
    IF (n_words &lt;= 0) THEN
      query := NIL;
    ELSIF (n_words &lt; NUMBER (query^)) THEN
      VAR new_query := NEW (TextVec, n_words); BEGIN
        new_query^ := SUBARRAY (query^, 0, n_words);
        query := new_query;
      END;
    END;
  END ParseQuery;

PROCEDURE <A NAME="HexChar"><procedure>HexChar</procedure></A> (a, b: CHAR): CHAR =
  VAR n := 0;
  BEGIN
    IF    ('0' &lt;= a) AND (a &lt;= '9') THEN  n := ORD(a) - ORD ('0');
    ELSIF ('A' &lt;= a) AND (a &lt;= 'F') THEN  n := ORD(a) - ORD ('A');
    ELSIF ('a' &lt;= a) AND (a &lt;= 'f') THEN  n := ORD(a) - ORD ('a');
    END;
    n := n * 16;
    IF    ('0' &lt;= b) AND (b &lt;= '9') THEN  n := n + ORD(b) - ORD ('0');
    ELSIF ('A' &lt;= b) AND (b &lt;= 'F') THEN  n := n + ORD(b) - ORD ('A');
    ELSIF ('a' &lt;= b) AND (b &lt;= 'f') THEN  n := n + ORD(b) - ORD ('a');
    END;
    RETURN VAL (n, CHAR);
  END HexChar;
</PRE>-------------------------------------------------------------- requests ---

<P><PRE>PROCEDURE <A NAME="GenUnitSetList"><procedure>GenUnitSetList</procedure></A> (query: TextVec;  wx: Wx.T;  pgm: BOOLEAN) =
  VAR
    it   : IntRefTbl.Iterator;
    x    := NEW (IntSeq.T).init ();
    nm   : INTEGER;
    ref  : REFANY;
    cmd0, cmd1, tag: TEXT;
  BEGIN
    IF (pgm) THEN
      it := db.pgms.iterate (); cmd0 := &quot;H&quot;; cmd1 := &quot;J&quot;; tag := &quot;Programs&quot;;
    ELSE
      it := db.libs.iterate (); cmd0 := &quot;5&quot;; cmd1 := &quot;9&quot;; tag := &quot;Libraries&quot;;
    END;

    (* collect and count the names *)
    WHILE it.next (nm, ref) DO
      IF (query = NIL) OR QueryMatch (nm, query) THEN
        x.addhi (nm);
      END;
    END;

    (* finally, generate the output *)
    Out (wx, StartPage);
    Out (wx, StartTitle, &quot;Modula-3 &quot;, tag, &quot; in &quot;);
    Out (wx, package_root, EndTitle);
    Out (wx, IsIndex);
    Out (wx, &quot;&lt;H2&gt;&quot;, tag, &quot; in &quot;, package_root, &quot;&lt;/H2&gt;\n&quot;);
    GenDir (cmd0, cmd1, Flatten (x)^, wx, 100);
    Out (wx, EndPage);
  END GenUnitSetList;

PROCEDURE <A NAME="GenUnitSetPrefix"><procedure>GenUnitSetPrefix</procedure></A> (prefix: TEXT;  query: TextVec;  wx: Wx.T;
                            pgm: BOOLEAN) =
  VAR
    it   : IntRefTbl.Iterator;
    nm   : INTEGER;
    ref  : REFANY;
    tag  : TEXT;
    cmd0, cmd1: TEXT;
    x    := NEW (IntSeq.T).init ();
    prefix_len := Text.Length (prefix);
  BEGIN
    IF (pgm) THEN
      it := db.pgms.iterate (); cmd0 := &quot;H&quot;; cmd1 := &quot;J&quot;; tag := &quot;Programs&quot;;
    ELSE
      it := db.libs.iterate (); cmd0 := &quot;5&quot;; cmd1 := &quot;9&quot;; tag := &quot;Libraries&quot;;
    END;

    (* collect and count the names *)
    WHILE it.next (nm, ref) DO
      IF PrefixMatch (prefix, nm, prefix_len) THEN
        IF (query = NIL) OR QueryMatch (nm, query) THEN
          x.addhi (nm);
        END;
      END;
    END;

    (* finally, generate the output *)
    Out (wx, StartPage, StartTitle);
    Out (wx, &quot;Modula-3 &quot;, tag, &quot; (&quot;, prefix, &quot;...)&quot;);
    Out (wx, EndTitle, IsIndex);
    Out (wx, &quot;&lt;H2&gt;&quot;, tag, &quot; (&quot;, prefix, &quot;...) &lt;/H2&gt;\n&quot;);
    GenDir (cmd0, cmd1, Flatten (x)^, wx, 100);
    Out (wx, EndPage);
  END GenUnitSetPrefix;

PROCEDURE <A NAME="GenIntfList"><procedure>GenIntfList</procedure></A> (req: TEXT;  query: TextVec;  wx: Wx.T) =
  VAR limit := 30;
  BEGIN
    IF (req # NIL) AND (Text.Length (req) &gt; 0) THEN
      (* generate the full, flat list *)
      limit := LAST(INTEGER);
    END;
    Out (wx, StartPage);
    Out (wx, StartTitle, &quot;Modula-3 Interfaces&quot;, EndTitle);
    Out (wx, IsIndex);
    GenList (wx, Class.Interface, limit, query);
    GenList (wx, Class.GenInterface, limit, query);
    GenList (wx, Class.HSource, limit, query);
    Out (wx, EndPage);
  END GenIntfList;

PROCEDURE <A NAME="GenImplList"><procedure>GenImplList</procedure></A> (req: TEXT;  query: TextVec;  wx: Wx.T) =
  VAR limit := 30;
  BEGIN
    IF (req # NIL) AND (Text.Length (req) &gt; 0) THEN
      (* generate the full, flat list *)
      limit := LAST(INTEGER);
    END;
    Out (wx, StartPage);
    Out (wx, StartTitle, &quot;Modula-3 Implementations&quot;, EndTitle);
    Out (wx, IsIndex);
    GenList (wx, Class.Module, limit, query);
    GenList (wx, Class.GenModule, limit, query);
    GenList (wx, Class.CSource, limit, query);
    Out (wx, EndPage);
  END GenImplList;

PROCEDURE <A NAME="GenList"><procedure>GenList</procedure></A> (wx: Wx.T;  c: Class;  limit: INTEGER;  query: TextVec) =
  VAR elts := UnitVector (c, NIL, query);
  BEGIN
    IF NUMBER (elts^) = 0 THEN RETURN END;
    Out (wx, &quot;&lt;H2&gt;&quot;, ClassTags[c], &quot;&lt;/H2&gt;\n&quot;);
    GenDir (&quot;3&quot;, ClassPrefix [c], elts^, wx, limit);
  END GenList;

PROCEDURE <A NAME="GenUnitPrefix"><procedure>GenUnitPrefix</procedure></A> (req: TEXT;  wx: Wx.T;  c: Class;  query: TextVec) =
  VAR elts := UnitVector (c, req, query);
  BEGIN
    Out (wx, StartPage);
    Out (wx, StartTitle, &quot;Modula-3 &quot;, ClassTags[c]);
    Out (wx, &quot; (&quot;, req, &quot;...)&quot;, EndTitle);
    Out (wx, IsIndex);
    Out (wx, &quot;&lt;H2&gt;&quot;, ClassTags[c]);
    Out (wx, &quot; (&quot;, req, &quot;...)&lt;/H2&gt;\n&quot;);
    IF NUMBER (elts^) # 0 THEN
      GenDir (&quot;3&quot;, ClassPrefix [c], elts^, wx, 50)
    END;
    Out (wx, EndPage);
  END GenUnitPrefix;

PROCEDURE <A NAME="UnitVector"><procedure>UnitVector</procedure></A> (c: Class;  prefix: TEXT;  query: TextVec): IntVec =
  VAR
    name: INTEGER;
    ref: REFANY;
    prefix_len: INTEGER;
    it := db.units.iterate ();
    x  : RefList.T := NIL;
    u  : Unit;
    z  := NEW (IntSeq.T).init ();
  BEGIN
    IF (prefix # NIL) THEN prefix_len := Text.Length (prefix); END;

    (* collect and count the names *)
    WHILE it.next (name, ref) DO
      IF (prefix = NIL) OR PrefixMatch (prefix, name, prefix_len) THEN
        IF (query = NIL) OR QueryMatch (name, query) THEN
          x := ref;
          WHILE (x # NIL) DO
            u := x.head;
            IF (u.class = c) THEN
              z.addhi (u.name);
              EXIT;
            END;
            x := x.tail;
          END;
        END;
      END;
    END;

    RETURN Flatten (z);
  END UnitVector;

PROCEDURE <A NAME="GenAnyUnit"><procedure>GenAnyUnit</procedure></A> (name: TEXT;  wx: Wx.T) =
  VAR x: RefList.T;  ref: REFANY;  u: Unit;  nm := ID.Add (name);
  BEGIN
    IF NOT db.units.get (nm, ref) THEN
      Out (wx, StartPage);
      Out (wx, StartTitle, name, EndTitle);
      Out (wx, &quot;&lt;H2&gt;&quot;, name, &quot;:&lt;/H2&gt;\n&quot;);
      Out (wx, &quot;&lt;STRONG&gt; *unknown* &lt;/STRONG&gt;\n&quot;);
      Out (wx, EndPage);
      RETURN;
    END;
    x := RemoveDuplicateUnits (ref);
    u := x.head;

    Out (wx, StartPage);
    Out (wx, StartTitle, ClassTitle [u.class], name, EndTitle);
    IF (x.tail # NIL) THEN
      Out (wx, &quot;&lt;H2&gt;&quot;, ID.ToText (u.name), &quot;:&lt;/H2&gt;\n&quot;);
      GenChoices (&quot;6&quot;, x, wx);
    ELSE
      Out (wx, &quot;&lt;H2&gt;&quot;, u.dir, SLASH, ID.ToText (u.name), &quot;:&lt;/H2&gt;\n&quot;);
      GenInstances (&quot;6&quot;, ref, wx);
      GenExporters (name, wx);
      GenImportLink (nm, name, wx);
      GenUnit (u, wx);
    END;
    Out (wx, EndPage);
  END GenAnyUnit;

PROCEDURE <A NAME="GenOneUnit"><procedure>GenOneUnit</procedure></A> (req: TEXT;  wx: Wx.T) =
  VAR x: RefList.T;  n_units: INTEGER;  name: TEXT;  dir: TEXT;
      u: Unit; ref: REFANY;  nm: ID.T;
  BEGIN
    SplitReq (req, nm, dir);
    name := ID.ToText (nm);
    IF NOT db.units.get (nm, ref) THEN
      Out (wx, StartPage);
      Out (wx, StartTitle, name, EndTitle);
      Out (wx, &quot;&lt;H2&gt;&quot;, name, &quot;:&lt;/H2&gt;\n&quot;);
      Out (wx, &quot;&lt;STRONG&gt; *unknown* &lt;/STRONG&gt;\n&quot;);
      Out (wx, EndPage);
      RETURN;
    END;
    x := RemoveDuplicateUnits (ref);

    (* check for multiple units *)
    ScanChoices (x, dir, n_units, u);

    Out (wx, StartPage);
    IF (n_units = 0) THEN
      u := x.head;
      Out (wx, StartTitle, ClassTitle [u.class], name, EndTitle);
      Out (wx, &quot;&lt;H2&gt;&quot;, dir, SLASH, name, &quot;:&lt;/H2&gt;\n&quot;);
      Out (wx, &quot;&lt;STRONG&gt; *deleted* &lt;/STRONG&gt;\n&quot;);
    ELSE
      Out (wx, StartTitle, ClassTitle [u.class], name, EndTitle);
      Out (wx, &quot;&lt;H2&gt;&quot;, u.dir, SLASH, ID.ToText (u.name), &quot;:&lt;/H2&gt;\n&quot;);
      GenInstances (&quot;6&quot;, ref, wx);
      GenExporters (name, wx);
      GenImportLink (nm, name, wx);
      GenUnit (u, wx);
    END;
    Out (wx, EndPage);
  END GenOneUnit;

PROCEDURE <A NAME="RemoveDuplicateUnits"><procedure>RemoveDuplicateUnits</procedure></A> (x: RefList.T): RefList.T =
  (* remove duplicate source units.  All units in 'x' are assumed
     to have the same name.  *)
  VAR seen: TextIntTbl.T;  z: RefList.T := NIL;  u, v: Unit;
  BEGIN
    IF (x = NIL) OR (x.tail = NIL) THEN
      (* zero or one element list *)
      RETURN x;
    ELSIF (x.tail.tail = NIL) THEN
      (* two element list *)
      u := x.head;
      v := x.tail.head;
      IF Text.Equal (u.dir, v.dir)
        THEN RETURN x.tail;
        ELSE RETURN x;
      END;
    END;

    (* otherwise, build a table and check each one... *)
    seen := NEW (TextIntTbl.Default).init ();
    WHILE (x # NIL) DO
      u := x.head;
      IF NOT seen.put (u.dir, 0) THEN
        z := RefList.Cons (u, z);
      END;
      x := x.tail;
    END;
    RETURN z;
  END RemoveDuplicateUnits;

PROCEDURE <A NAME="SplitReq"><procedure>SplitReq</procedure></A> (req: TEXT;  VAR name: ID.T;  VAR dir: TEXT) =
  VAR len := Text.Length (req);  j: CARDINAL;
  BEGIN
    j := 0;
    WHILE (j &lt; len) AND Text.GetChar (req, j) # '@' DO INC (j) END;
    IF (j &lt; len) THEN
      name := ID.Add (Text.Sub (req, 0, j));
      dir  := Text.Sub (req, j+1, len - j - 1);
    ELSE
      name := ID.Add (req);
      dir  := &quot;&quot;;
    END;
  END SplitReq;

PROCEDURE <A NAME="GenInstances"><procedure>GenInstances</procedure></A> (cmd: TEXT;  x: RefList.T;  wx: Wx.T) =
  CONST LibCmd = ARRAY BOOLEAN OF TEXT { &quot;8&quot;, &quot;I&quot; };
  VAR single := FALSE;  u: Unit;  lib: TEXT;  uname: TEXT;
  BEGIN
    IF (x = NIL) THEN RETURN END;
    single := (x.tail = NIL);
    u := x.head;
    uname := ID.ToText (u.name);
    Out (wx, &quot;&lt;H4&gt;&quot;, uname, &quot; is contained in:&lt;/H4&gt;\n&quot;);
    Out (wx, &quot;&lt;UL&gt;\n&quot;);
    WHILE (x # NIL) DO
      u := x.head;
      lib := LibName (ID.ToText (u.set.name), u.set.is_pgm);
      Out (wx, &quot;&lt;LI&gt;&lt;A HREF=\&quot;/&quot;, LibCmd[u.set.is_pgm]);
      Out (wx, ID.ToText (u.set.name), &quot;@&quot;, u.set.path, &quot;\&quot;&gt;&quot;);
      Out (wx, u.set.path, SLASH, lib);
      Out (wx, &quot;&lt;/A&gt;: &lt;A HREF=\&quot;/&quot;, cmd, uname, &quot;@&quot;, u.dir);
      Out (wx, &quot;\&quot;&gt;&quot;, u.dir, SLASH, uname);
      Out (wx, &quot;&lt;/A&gt;\n&quot;);
      x := x.tail;
    END;
    Out (wx, &quot;&lt;/UL&gt;\n&quot;);
  END GenInstances;

PROCEDURE <A NAME="GenExporters"><procedure>GenExporters</procedure></A> (name: TEXT;  wx: Wx.T) =
  VAR ref: REFANY;  id: IntList.T;  txt: TEXT;  nm := ID.Add (name);
  BEGIN
    IF db.exporters.get (nm, ref) THEN
      Out (wx, &quot;&lt;H4&gt;exported by:&lt;/H4&gt;\n&quot;);
      Out (wx, &quot;&lt;UL&gt;\n&quot;);
      id := ref;
      WHILE (id # NIL) DO
        txt := ID.ToText (id.head);
        Out (wx, &quot;&lt;LI&gt;&lt;A HREF=\&quot;/3&quot;, txt, &quot;\&quot;&gt;&quot;, txt, &quot;&lt;/A&gt;\n&quot;);
        id := id.tail;
      END;
      Out (wx, &quot;&lt;/UL&gt;\n&quot;);
    END;
  END GenExporters;

PROCEDURE <A NAME="GenExportUnit"><procedure>GenExportUnit</procedure></A> (name: TEXT;  wx: Wx.T) =
  VAR ref: REFANY;  id: IntList.T;  nm := ID.Add (name);
  BEGIN
    (* look up my exporters *)
    IF NOT db.exporters.get (nm, ref) OR (ref = NIL) THEN
      Out (wx, StartPage);
      Out (wx, StartTitle, &quot;Exporters of &quot;, name, EndTitle);
      Out (wx, &quot;&lt;H2&gt;Exporters of &quot;, name, &quot;:&lt;/H2&gt;\n&quot;);
      Out (wx, &quot;&lt;STRONG&gt; *unknown* &lt;/STRONG&gt;\n&quot;);
      Out (wx, EndPage);
      RETURN;
    END;
    id := ref;

    IF (id.tail = NIL) THEN
      (* there's a unique exporter *)
      GenAnyUnit (ID.ToText (id.head), wx);
    ELSE
      Out (wx, StartPage);
      Out (wx, StartTitle, &quot;Exporters of &quot;, name, EndTitle);
      Out (wx, &quot;&lt;H2&gt;&quot;, name, &quot;:&lt;/H2&gt;\n&quot;);
      GenExporters (name, wx);
      Out (wx, EndPage);
    END;
  END GenExportUnit;

PROCEDURE <A NAME="GenProcExporterUnit"><procedure>GenProcExporterUnit</procedure></A> (name: TEXT;  wx: Wx.T) =
  VAR exp: IntList.T;
      units: RefList.T;
      unit: Unit;
      matchingUnit: Unit := NIL;
      ref: REFANY;
      tmpWx: Wx.T;
      interface, procedure: TEXT;
      unitText: TEXT;
      matchingUnitText: TEXT;

  BEGIN
    (* extract interface/procedure name *)
    interface := Text.Sub(name, start := 0,
                   length := Text.FindCharR(name, c:= '.'));
    procedure := Text.Sub(name, start := Text.FindCharR(name, c:= '.') + 1);

    (* look up exporters *)
    IF (db.exporters.get(ID.Add(interface), ref)) THEN
      exp := ref;
      (* find the procedure's exporter *)
      WHILE (exp # NIL) DO
        IF (db.units.get(exp.head, ref)) THEN
          units := RemoveDuplicateUnits(ref);
          WHILE (units # NIL) DO
            unit := units.head;
            (* generate the unit into a temporary wx *)
            tmpWx := Wx.New();
            GenUnit(unit, tmpWx);
            unitText := Wx.ToText(tmpWx);
            (* check if the header for the procedure is in the unit *)
            IF CharMap.Substr(unitText, &quot;&lt;A NAME=\&quot;&quot; &amp; procedure &amp; &quot;\&quot;&gt;&quot;) THEN
              IF matchingUnit # NIL THEN
                (* mulitple units with this header: generate choice list *)
                GenChoicesWithHeaders(&quot;6&quot;, RemoveDuplicateUnits(ref),
                                      procedure, wx);
                RETURN;
              END;
              matchingUnit := unit;
              matchingUnitText := unitText;
            END;
            units := units.tail;
          END;
          IF matchingUnit # NIL THEN
            (* unique exporter: emit *)
            WITH name = ID.ToText(matchingUnit.name) DO
              Out (wx, StartPage);
              Out (wx, StartTitle, ClassTitle [matchingUnit.class],
                name, EndTitle);
              Out(wx, &quot;&lt;H2&gt;&quot;, matchingUnit.dir, SLASH, name, &quot;:&lt;/H2&gt;\n&quot;);
              GenInstances(&quot;6&quot;, ref, wx);
              GenExporters(name, wx);
              GenImportLink(matchingUnit.name, name, wx);
              Out(wx, matchingUnitText);
            END;
            RETURN;
          END;
        END;
        exp := exp.tail;
      END;
    END;
    Out(wx, StartTitle, &quot;Implementation of &quot;, procedure, EndTitle);
    Out(wx, &quot;&lt;H2&gt;Implementation of &quot;, procedure, &quot;:&lt;/H2&gt;\n&quot;);
    Out(wx, &quot;&lt;STRONG&gt; *unknown* &lt;/STRONG&gt;\n&quot;);
    Out (wx, EndPage);
  END GenProcExporterUnit;

PROCEDURE <A NAME="GenImportLink"><procedure>GenImportLink</procedure></A> (nm: ID.T;  name: TEXT;  wx: Wx.T) =
  VAR ref: REFANY;
  BEGIN
    IF db.importers.get (nm, ref) THEN
      Out (wx, name, &quot; is imported by &lt;A HREF=\&quot;R&quot;, name, &quot;\&quot;&gt;&quot;);
      Out (wx, Fmt.Int (IntList.Length (ref)), &quot; units&lt;/A&gt;&lt;P&gt;\n&quot;);
    END;
  END GenImportLink;

PROCEDURE <A NAME="GenImportUnits"><procedure>GenImportUnits</procedure></A> (name: TEXT;  wx: Wx.T) =
  VAR ref: REFANY;  id: IntList.T;  nm := ID.Add (name);
  BEGIN
    (* look up my importers *)
    IF NOT db.importers.get (nm, ref) OR (ref = NIL) THEN
      Out (wx, StartPage);
      Out (wx, StartTitle, &quot;Importers of &quot;, name, EndTitle);
      Out (wx, &quot;&lt;H2&gt;Importers of &quot;, name, &quot;:&lt;/H2&gt;\n&quot;);
      Out (wx, &quot;&lt;STRONG&gt; *unknown* &lt;/STRONG&gt;\n&quot;);
      Out (wx, EndPage);
    RETURN;
    END;
    id := ref;

    IF (id.tail = NIL) THEN
      (* there's a unique importer *)
      GenAnyUnit (ID.ToText (id.head), wx);
    ELSE
      Out (wx, StartPage);
      Out (wx, StartTitle, &quot;Importers of &quot;, name, EndTitle);
      Out (wx, &quot;&lt;H2&gt;Importers of &quot;, name, &quot;:&lt;/H2&gt;\n&quot;);
      GenImporters (id, wx);
      Out (wx, EndPage);
    END;
  END GenImportUnits;

PROCEDURE <A NAME="GenImporters"><procedure>GenImporters</procedure></A> (imp: IntList.T;  wx: Wx.T) =
  VAR z := NEW (IntSeq.T).init ();
  BEGIN
    WHILE (imp # NIL) DO
      z.addhi (imp.head);
      imp := imp.tail;
    END;
    GenDir (&quot;3&quot;, &quot;3&quot;, Flatten (z)^, wx, LAST(INTEGER));
  END GenImporters;

PROCEDURE <A NAME="ScanChoices"><procedure>ScanChoices</procedure></A> (x: RefList.T;  dir: TEXT;
                       VAR cnt: INTEGER;  VAR u: Unit) =
  VAR n := 0;  uu: Unit;
  BEGIN
    WHILE (x # NIL) DO
      uu := x.head;
      IF (uu.dir # NIL) AND ((dir = NIL) OR Text.Equal (dir, uu.dir)) THEN
        u := uu;
        INC (n);
      END;
      x := x.tail;
    END;
    cnt := n;
  END ScanChoices;

PROCEDURE <A NAME="GenChoices"><procedure>GenChoices</procedure></A> (cmd: TEXT;  x: RefList.T;  wx: Wx.T) =
  VAR u: Unit;
  BEGIN
    Out (wx, &quot;&lt;H3&gt;Select an instance:&lt;/H3&gt;\n&quot;);
    Out (wx, &quot;&lt;UL&gt;\n&quot;);
    TRY
      WHILE (x # NIL) DO
        (* this one is still current *)
        u := x.head;
        Out (wx, &quot;&lt;LI&gt;&lt;A HREF=\&quot;/&quot;, cmd, ID.ToText (u.name), &quot;@&quot;, u.dir);
        Out (wx, &quot;\&quot;&gt;&quot;, u.dir, &quot;&lt;/A&gt;\n&quot;);
        x := x.tail;
      END;
    FINALLY
      Out (wx, &quot;&lt;/UL&gt;\n&quot;);
    END;
  END GenChoices;

PROCEDURE <A NAME="GenChoicesWithHeaders"><procedure>GenChoicesWithHeaders</procedure></A> (cmd: TEXT;  x: RefList.T;  h: TEXT;  wx: Wx.T) =
  VAR u: Unit;
  BEGIN
    Out (wx, &quot;&lt;H3&gt;Select an instance:&lt;/H3&gt;\n&quot;);
    Out (wx, &quot;&lt;UL&gt;\n&quot;);
    TRY
      WHILE (x # NIL) DO
        (* this one is still current *)
        u := x.head;
        Out (wx, &quot;&lt;LI&gt;&lt;A HREF=\&quot;/&quot;, cmd, ID.ToText (u.name), &quot;@&quot;, u.dir);
        Out (wx, &quot;#&quot;, h, &quot;\&quot;&gt;&quot;, u.dir, &quot;&lt;/A&gt;\n&quot;);
        x := x.tail;
      END;
    FINALLY
      Out (wx, &quot;&lt;/UL&gt;\n&quot;);
    END;
  END GenChoicesWithHeaders;

PROCEDURE <A NAME="GenUnit"><procedure>GenUnit</procedure></A> (u: Unit;  wx: Wx.T) =
  VAR file := MakePath (package_root, u.dir, ID.ToText (u.name));  buf: Buf.T;
  BEGIN
    (*
    Out (wx, &quot;&lt;A HREF=\&quot;/Z&quot;, file, &quot;\&quot;&gt;[edit file]&lt;/A&gt;\n&lt;P&gt;\n&quot;);
    *)

    buf := BufFromFile (file, pad := 1);
    IF (buf = NIL) THEN
      Out (wx, &quot;&lt;STRONG&gt; unable to open &quot;, file, &quot; &lt;/STRONG&gt;&quot;);
      RETURN;
    END;

    Out (wx, &quot;&lt;HR&gt;\n&quot;);
    IF (u.class = Class.CSource) OR (u.class = Class.HSource)
      THEN CMarkUp.Annotate (buf, wx);
      ELSE MarkUp.Annotate (buf, wx);
    END;
  END GenUnit;
</PRE>------------------------------------------------------------- unit sets ---

<P><PRE>PROCEDURE <A NAME="GenAnyUnitSet"><procedure>GenAnyUnitSet</procedure></A> (name: TEXT;  wx: Wx.T;  pgm: BOOLEAN) =
  VAR
    us  : UnitSet;
    ref : REFANY;
    x   : RefList.T;
    nm  := ID.Add (name);
    tbl : IntRefTbl.T;
    tag : TEXT;
    cmd0: TEXT;
  BEGIN
    IF (pgm)
      THEN tbl := db.pgms;  tag := &quot;program&quot;;  cmd0 := &quot;I&quot;;
      ELSE tbl := db.libs;  tag := &quot;library&quot;;  cmd0 := &quot;8&quot;;
    END;

    IF NOT tbl.get (nm, ref) THEN
      Out (wx, StartPage, StartTitle);
      Out (wx, &quot;Modula-3 &quot;, tag, &quot;: &quot;, name, EndTitle);
      Out (wx, &quot;&lt;H2&gt;&quot;, LibName (name, pgm), &quot;:&lt;/H2&gt;\n&quot;);
      Out (wx, &quot;&lt;STRONG&gt; *unknown* &lt;/STRONG&gt;\n&quot;);
      Out (wx, EndPage);
      RETURN;
    END;
    x := ref;
    us := x.head;

    Out (wx, StartPage);
    IF (x.tail # NIL) THEN
      Out (wx, StartTitle, &quot;Modula-3 &quot;, tag, &quot;: &quot;, name);
      Out (wx, EndTitle);
      Out (wx, &quot;&lt;H2&gt;&quot;, ID.ToText (us.name), &quot;:&lt;/H2&gt;\n&quot;);
      GenUnitSetChoices (cmd0, x, wx, pgm);
    ELSE
      Out (wx, StartTitle, &quot;Modula-3 &quot;, tag, &quot;: &quot;, name);
      Out (wx, EndTitle, IsIndex);
      Out (wx, &quot;&lt;H2&gt;&quot;, us.path, SLASH);
      Out (wx, LibName (name, pgm), &quot;:&lt;/H2&gt;\n&quot;);
      GenUnitSetContents (us, wx);
    END;
    Out (wx, EndPage);
  END GenAnyUnitSet;

PROCEDURE <A NAME="GenOneUnitSet"><procedure>GenOneUnitSet</procedure></A> (req: TEXT;  wx: Wx.T;  pgm: BOOLEAN) =
  VAR
    us     : UnitSet;
    n_libs : INTEGER;
    nm     : ID.T;
    name   : TEXT;
    dir    : TEXT;
    ref    : REFANY;
    x      : RefList.T;
    tbl    : IntRefTbl.T;
    tag    : TEXT;
    cmd0   : TEXT;
  BEGIN
    IF (pgm)
      THEN tbl := db.pgms;  tag := &quot;program&quot;;  cmd0 := &quot;I&quot;;
      ELSE tbl := db.libs;  tag := &quot;library&quot;;  cmd0 := &quot;8&quot;;
    END;

    SplitReq (req, nm, dir);
    name := ID.ToText (nm);
    IF NOT tbl.get (nm, ref) THEN
      Out (wx, StartPage, StartTitle);
      Out (wx, &quot;Modula-3 &quot;, tag, &quot;: &quot;, name, EndTitle);
      Out (wx, &quot;&lt;H2&gt;&quot;, LibName (name, pgm), &quot;:&lt;/H2&gt;\n&quot;);
      Out (wx, &quot;&lt;STRONG&gt; *unknown* &lt;/STRONG&gt;\n&quot;);
      Out (wx, EndPage);
      RETURN;
    END;
    x := ref;

    (* check for multiple libs *)
    ScanUnitSetChoices (x, dir, pgm, n_libs, us);

    Out (wx, StartPage);
    IF (n_libs = 0) THEN
      Out (wx, StartTitle, &quot;Modula-3 &quot;, tag, &quot;: &quot;, name);
      Out (wx, EndTitle);
      Out (wx, &quot;&lt;H2&gt;&quot;, dir, SLASH);
      Out (wx, LibName (name, pgm), &quot;:&lt;/H2&gt;\n&quot;);
      Out (wx, &quot;&lt;STRONG&gt; *deleted* &lt;/STRONG&gt;\n&quot;);
    ELSE
      Out (wx, StartTitle, &quot;Modula-3 &quot;, tag, &quot;: &quot;, name);
      Out (wx, EndTitle, IsIndex);
      Out (wx, &quot;&lt;H2&gt;&quot;, us.path, SLASH);
      Out (wx, LibName (ID.ToText (us.name), pgm), &quot;:&lt;/H2&gt;\n&quot;);
      GenUnitSetContents (us, wx);
    END;
    Out (wx, EndPage);
  END GenOneUnitSet;

PROCEDURE <A NAME="ScanUnitSetChoices"><procedure>ScanUnitSetChoices</procedure></A> (x: RefList.T;  dir: TEXT;  pgm: BOOLEAN;
                              VAR cnt: INTEGER; VAR last: UnitSet) =
  VAR n := 0;  us: UnitSet;
  BEGIN
    WHILE (x # NIL) DO
      us := x.head;
      IF (us.path # NIL)
        AND (us.is_pgm = pgm)
        AND ((dir = NIL) OR Text.Equal (dir, us.path)) THEN
        (* this one is still current *)
        last := us;
        INC (n);
      END;
      x := x.tail;
    END;
    cnt  := n;
  END ScanUnitSetChoices;

PROCEDURE <A NAME="GenUnitSetChoices"><procedure>GenUnitSetChoices</procedure></A> (cmd: TEXT;  x: RefList.T;  wx: Wx.T; pgm: BOOLEAN) =
  VAR us: UnitSet;
  BEGIN
    Out (wx, &quot;&lt;H3&gt;Select an instance:&lt;/H3&gt;\n&quot;);
    Out (wx, &quot;&lt;UL&gt;\n&quot;);
    TRY
      WHILE (x # NIL) DO
        us := x.head;
        IF (us.is_pgm = pgm) THEN
          (* this one is still current *)
          Out (wx, &quot;&lt;LI&gt;&lt;A HREF=\&quot;/&quot;, cmd, ID.ToText (us.name), &quot;@&quot;, us.path);
          Out (wx, &quot;\&quot;&gt;&quot;, us.path, &quot;&lt;/A&gt;\n&quot;);
        END;
        x := x.tail;
      END;
    FINALLY
      Out (wx, &quot;&lt;/UL&gt;\n&quot;);
    END;
  END GenUnitSetChoices;

PROCEDURE <A NAME="GenUnitSetContents"><procedure>GenUnitSetContents</procedure></A> (us: UnitSet;  wx: Wx.T) =
  VAR cnts: ARRAY Class OF INTEGER;  u: Unit;
  BEGIN
    (* count the number units in each class *)
    FOR c := FIRST (cnts) TO LAST (cnts) DO cnts[c] := 0; END;
    u := us.units;
    WHILE (u # NIL) DO INC (cnts[u.class]);  u := u.next; END;

    FOR c := FIRST (cnts) TO LAST (cnts) DO
      IF (cnts[c] &lt;= 0) THEN
        (* skip *)
      ELSIF (cnts[c] &lt;= 40) THEN
        Out (wx, &quot;&lt;H3&gt;&quot;, ClassTags[c], &quot;:&lt;/H3&gt;\n&quot;);
        GenShortUnitSetIdList (us, c, wx);
      ELSE
        Out (wx, &quot;&lt;H3&gt;&quot;, ClassTags[c], &quot;:&lt;/H3&gt;\n&quot;);
        GenLongUnitSetIdList (us, c, wx, cnts[c]);
      END;
    END;
  END GenUnitSetContents;

PROCEDURE <A NAME="GenShortUnitSetIdList"><procedure>GenShortUnitSetIdList</procedure></A> (us: UnitSet;  c: Class;  wx: Wx.T) =
  VAR u := us.units;  n := 0;  elts: ARRAY [0..39] OF INTEGER;
  BEGIN
    WHILE (u # NIL) DO
      IF (u.class = c) THEN
        elts[n] := u.name;  INC (n);
      END;
      u := u.next;
    END;
    GenDir (&quot;3&quot;, ClassPrefix [c], SUBARRAY (elts, 0, n), wx, 30);
  END GenShortUnitSetIdList;

PROCEDURE <A NAME="GenLongUnitSetIdList"><procedure>GenLongUnitSetIdList</procedure></A> (us: UnitSet;  c: Class;  wx: Wx.T;  n: INTEGER) =
  VAR u := us.units;  elts := NEW (IntVec, n);
  BEGIN
    n := 0;
    WHILE (u # NIL) DO
      IF (u.class = c) THEN
        elts[n] := u.name;  INC (n);
      END;
      u := u.next;
    END;
    GenDir (&quot;3&quot;, ClassPrefix [c], elts^, wx, 30);
  END GenLongUnitSetIdList;
</PRE>----------------------------------------------------------------- types ---

<P><PRE>PROCEDURE <A NAME="GenTypeList"><procedure>GenTypeList</procedure></A> (req: TEXT;  query: TextVec;  wx: Wx.T) =
  VAR
    limit   := 60;
    it      := db.type_names.iterate ();
    ref     : REFANY;
    nm      : INTEGER;
    x       := NEW (IntSeq.T).init ();
    last_nm : INTEGER;
  BEGIN
    IF (req # NIL) AND (Text.Length (req) &gt; 0) THEN
      (* generate the full, flat list *)
      limit := LAST(INTEGER);
    END;

    (* extract the list *)
    WHILE it.next (nm, ref) DO
      IF (query = NIL) OR QueryMatch (nm, query) THEN
        x.addhi (nm);
        last_nm := nm;
      END;
    END;

    IF (x.size() = 1) THEN
      GenOneType (ID.ToText (last_nm), wx);
    ELSE
      Out (wx, StartPage);
      Out (wx, StartTitle, &quot;Modula-3 Types&quot;, EndTitle);
      Out (wx, IsIndex);
      Out (wx, &quot;&lt;H2&gt;Modula-3 Types &lt;/H2&gt;\n&quot;);
      GenDir (&quot;L&quot;, &quot;M&quot;, Flatten (x)^, wx, limit);
      Out (wx, EndPage);
    END;
  END GenTypeList;

PROCEDURE <A NAME="GenTypePrefix"><procedure>GenTypePrefix</procedure></A> (prefix: TEXT;  query: TextVec;  wx: Wx.T) =
  VAR
    limit := 60;
    it    := db.type_names.iterate ();
    ref   : REFANY;
    nm    : INTEGER;
    x     := NEW (IntSeq.T).init ();
    plen  := Text.Length (prefix);
  BEGIN
    (* extract the list *)
    WHILE it.next (nm, ref) DO
      IF PrefixMatch (prefix, nm, plen) THEN
        IF (query = NIL) OR QueryMatch (nm, query) THEN
          x.addhi (nm);
        END;
      END;
    END;

    Out (wx, StartPage);
    Out (wx, StartTitle, &quot;Modula-3 Types (&quot;, prefix, &quot;...)&quot;, EndTitle);
    Out (wx, IsIndex);
    Out (wx, &quot;&lt;H2&gt;Modula-3 Types (&quot;, prefix, &quot;...)&lt;/H2&gt;\n&quot;);
    GenDir (&quot;L&quot;, &quot;M&quot;, Flatten (x)^, wx, limit);
    Out (wx, EndPage);
  END GenTypePrefix;

PROCEDURE <A NAME="GenOneType"><procedure>GenOneType</procedure></A> (name: TEXT;  wx: Wx.T) =
  VAR nm := ID.Add (name);  ref: REFANY;  x: RefList.T;
  BEGIN
    IF NOT db.type_names.get (nm, ref) THEN
      Out (wx, StartPage);
      Out (wx, StartTitle, name, EndTitle);
      Out (wx, &quot;&lt;H2&gt;&quot;, name, &quot;:&lt;/H2&gt;\n&quot;);
      Out (wx, &quot;&lt;STRONG&gt; *unknown* &lt;/STRONG&gt;\n&quot;);
      Out (wx, EndPage);
      RETURN;
    END;
    x := ref;

    IF (x.tail # NIL) THEN
      Out (wx, StartPage);
      Out (wx, StartTitle, &quot;Modula-3 Type: &quot;, name, EndTitle);
      Out (wx, &quot;&lt;H2&gt;&quot;, name, &quot;:&lt;/H2&gt;\n&quot;);
      GenTypeChoices (x, wx);
      Out (wx, EndPage);
    ELSE
      GenType (x.head, wx, FALSE, name);
    END;
  END GenOneType;

PROCEDURE <A NAME="GenTypeChoices"><procedure>GenTypeChoices</procedure></A> (x: RefList.T;  wx: Wx.T) =
  VAR t: Type;  tn: TypeName;
  BEGIN
    Out (wx, &quot;&lt;H3&gt;Select an instance:&lt;/H3&gt;\n&quot;);
    Out (wx, &quot;&lt;UL&gt;\n&quot;);
    TRY
      WHILE (x # NIL) DO
        t := x.head;
        Out (wx, &quot;&lt;LI&gt;&lt;A HREF=\&quot;/N&quot;, FmtUID(t.uid), &quot;\&quot;&gt;&quot;);
        tn := t.names;
        WHILE (tn # NIL) DO
          IF (tn # t.names) THEN Out (wx, &quot;,\n &quot;); END;
          Out (wx, ID.ToText (tn.name), &quot; in &quot;, ID.ToText (tn.home));
          tn := tn.next;
        END;
        Out (wx, &quot;&lt;/A&gt;\n&quot;);
        x := x.tail;
      END;
    FINALLY
      Out (wx, &quot;&lt;/UL&gt;\n&quot;);
    END;
  END GenTypeChoices;

PROCEDURE <A NAME="GenTypeFromUID"><procedure>GenTypeFromUID</procedure></A> (req: TEXT;  wx: Wx.T;  expanded: BOOLEAN) =
  VAR uid := ScanUID (req);  ref: REFANY;
  BEGIN
    IF NOT db.type_ids.get (uid, ref) THEN
      Out (wx, StartPage);
      Out (wx, StartTitle, &quot;Type &amp;lt;&quot;, req, &quot;&amp;gt;&quot;, EndTitle);
      Out (wx, &quot;&lt;H2&gt;Type &amp;lt;&quot;, req, &quot;&amp;gt;:&lt;/H2&gt;\n&quot;);
      Out (wx, &quot;&lt;STRONG&gt; *unknown* &lt;/STRONG&gt;\n&quot;);
      Out (wx, EndPage);
      RETURN;
    END;
    GenType (ref, wx, expanded, NIL);
  END GenTypeFromUID;

PROCEDURE <A NAME="GenTypeGraph"><procedure>GenTypeGraph</procedure></A> (req: TEXT;  wx: Wx.T) =
  VAR
    self     := ScanUID (req);
    name     : TEXT;
    home     : TEXT;
    t        : Type;
    indent   : INTEGER;
    ref      : REFANY;
    cnt      : ARRAY [0..4] OF INTEGER;
    maxDepth : INTEGER;
    total    : INTEGER;
  BEGIN
    GetTypeName (self, name, home, NIL);
    Out (wx, StartPage);
    Out (wx, StartTitle, &quot;Subtype graph for &quot;, name, EndTitle);
    Out (wx, &quot;&lt;H2&gt;Subtype graph for &quot;, name, &quot;:&lt;/H2&gt;&lt;P&gt;\n&quot;);

    IF NOT db.type_ids.get (self, ref) THEN Out (wx, EndPage); RETURN END;
    t := ref;

    (* find out how deep to print the tree *)
    FOR i := FIRST (cnt) TO LAST (cnt) DO cnt[i] := 0 END;
    CountSubtypes (t, 0, cnt);
    maxDepth := 0;    total := 0;
    WHILE (maxDepth &lt;= LAST (cnt)) AND (total + cnt[maxDepth] &lt; 100) DO
      INC (total, cnt[maxDepth]);
      INC (maxDepth);
    END;
    maxDepth := MAX (1, maxDepth - 1);

    Out (wx, &quot;&lt;PRE&gt;\n&quot;);
    indent := GenSuperTypes (t, 0, wx);
    GenSubtypes (t, 0, maxDepth, indent, wx);
    Out (wx, &quot;&lt;/PRE&gt;\n&quot;);
    Out (wx, EndPage);
  END GenTypeGraph;

PROCEDURE <A NAME="CountSubtypes"><procedure>CountSubtypes</procedure></A> (t: Type;  depth: INTEGER;  VAR cnt: ARRAY OF INTEGER)=
  VAR u, v: Type;
  BEGIN
    IF (depth &lt;= LAST (cnt)) THEN
      u := t.subtypes;
      WHILE (u # NIL) DO
        INC (cnt[depth]);
        v := u;
        EVAL FindOpaque (u.uid, v);
        CountSubtypes (v, depth+1, cnt);
        u := u.next_peer;
      END;
    END;
  END CountSubtypes;

PROCEDURE <A NAME="GenSuperTypes"><procedure>GenSuperTypes</procedure></A> (t: Type;  depth: INTEGER;  wx: Wx.T): INTEGER =
  VAR in: INTEGER;
  BEGIN
    IF (t = NIL) THEN
      RETURN 0;
    ELSIF (depth &gt;= 99) THEN
      Out (wx, &quot;....\n&quot;);
      RETURN 3;
    ELSE
      in := GenSuperTypes (SuperType (t), depth+1, wx);
      IF (depth # 0) THEN in := 0 END; (* hack *)
      GenGraphEntry (t, in, 0, wx, (depth = 0));
      RETURN in + 3;
    END;
  END GenSuperTypes;

PROCEDURE <A NAME="GenGraphEntry"><procedure>GenGraphEntry</procedure></A> (t: Type;  indent, depth: INTEGER;  wx: Wx.T;
                         key: BOOLEAN)=
  VAR name, home: TEXT;
  BEGIN
    GetTypeName (t.uid, name, home, NIL);
    Indent (wx, indent);
    FOR i := 1 TO depth DO Out (wx, &quot;|  &quot;); END;
    Out (wx, &quot;&lt;A HREF=\&quot;/N&quot;, FmtUID (t.uid), &quot;\&quot;&gt;&quot;, name, &quot;&lt;/A&gt;&quot;);
    IF (home # NIL) THEN
      Out (wx, &quot; in &lt;A HREF=\&quot;/3&quot;, home,&quot;\&quot;&gt;&quot;, home, &quot;&lt;/A&gt;&quot;);
    END;
    IF (key) THEN
      Out (wx, &quot; &lt;==&quot;);
    END;
    Out (wx, &quot;\n&quot;);
  END GenGraphEntry;

PROCEDURE <A NAME="GenSubtypes"><procedure>GenSubtypes</procedure></A> (t: Type;  depth, maxDepth, indent: INTEGER;  wx: Wx.T) =
  VAR z: RefSeq.T;  u, v: Type;
  BEGIN
    IF (t = NIL) OR (t.subtypes = NIL) THEN
      RETURN;
    ELSIF (depth &gt;= maxDepth) THEN
      Indent (wx, indent);
      FOR i := 1 TO depth DO Out (wx, &quot;|  &quot;); END;
      Out (wx, &quot;....\n&quot;);
      RETURN;
    ELSE
      z := NEW (RefSeq.T).init ();
      u := t.subtypes;
      WHILE (u # NIL) DO
        IF FindOpaque (u.uid, v)
          THEN z.addhi (v);
          ELSE z.addhi (u);
        END;
        u := u.next_peer;
      END;
      GenSubtypeNames (z, depth, maxDepth, indent, wx);
    END;
  END GenSubtypes;

PROCEDURE <A NAME="GenSubtypeNames"><procedure>GenSubtypeNames</procedure></A> (z: RefSeq.T;  depth, maxDepth, indent: INTEGER;
                           wx: Wx.T) =
  TYPE XX = REF ARRAY OF RECORD type: Type;  name, home: TEXT; END;
  VAR
    n   := z.size ();
    map := NEW (IntVec, n);
    xx  := NEW (XX, n);

  PROCEDURE CmpTypeName (a, b: INTEGER): [-1..+1] =
    VAR ca, cb: CHAR;
    BEGIN
      WITH xa = xx[a],  xb = xx[b] DO
        ca := Text.GetChar (xa.name, 0);
        cb := Text.GetChar (xb.name, 0);
        IF    (ca # '&amp;') AND (cb = '&amp;') THEN RETURN -1;
        ELSIF (ca = '&amp;') AND (cb # '&amp;') THEN RETURN +1;
        ELSE RETURN CharMap.CmpText (xa.name, xb.name);
        END;
      END;
    END CmpTypeName;

  BEGIN
    (* build the list of names &amp; homes *)
    FOR i := 0 TO n-1 DO
      map[i] := i;
      WITH zz = xx[i] DO
        zz.type := z.get (i);
        GetTypeName (zz.type.uid, zz.name, zz.home, NIL);
      END;
    END;

    Sort (map^, CmpTypeName);

    FOR i := 0 TO n-1 DO
      WITH zz = xx[map[i]] DO
        GenGraphEntry (zz.type, indent, depth, wx, FALSE);
        GenSubtypes (zz.type, depth+1, maxDepth, indent, wx);
      END;
    END;
  END GenSubtypeNames;

PROCEDURE <A NAME="GetTypeName"><procedure>GetTypeName</procedure></A> (uid: INTEGER;  VAR(*OUT*)name, home: TEXT;  pref: TEXT)=
  VAR ref: REFANY;  t, u: Type := NIL;
  BEGIN
    IF db.type_ids.get (uid, ref) THEN
      t := ref;
      IF SetTypeName (t, name, home, pref) THEN RETURN END;
    END;
    IF FindOpaque (uid, u) THEN
      t := u;
      IF SetTypeName (t, name, home, pref) THEN RETURN END;
    END;
    name := &quot;&amp;lt;&quot; &amp; FmtUID (uid) &amp; &quot;&amp;gt;&quot;;
    home := NIL;
    IF (t # NIL) THEN home := ID.ToText (t.home); END;
  END GetTypeName;

PROCEDURE <A NAME="SetTypeName"><procedure>SetTypeName</procedure></A> (t: Type;  VAR(*OUT*)name, home: TEXT;
                       pref: TEXT): BOOLEAN =
  VAR id: ID.T;  tn: TypeName;
  BEGIN
    IF (t.names = NIL) THEN RETURN FALSE; END;

    IF (pref # NIL) THEN
      (* search for a match *)
      id := ID.Add (pref);
      tn := t.names;
      WHILE (tn # NIL) DO
        IF (tn.name = id) THEN
          name := pref;
          home := ID.ToText (tn.home);
          RETURN TRUE;
        END;
        tn := tn.next;
      END;
    END;

    name := ID.ToText (t.names.name);
    home := ID.ToText (t.names.home);
    RETURN TRUE;
  END SetTypeName;

PROCEDURE <A NAME="GenType"><procedure>GenType</procedure></A> (t: Type;  wx: Wx.T;  expanded: BOOLEAN;  pref: TEXT) =
  VAR ex: IntRefTbl.T;
  BEGIN
    GenTypeHeader (t, ORD(expanded), pref, wx);
    IF (t.defn = NIL) THEN Out (wx, EndPage); RETURN END;

    ex := NIL;
    IF expanded THEN
      ex := NEW (IntRefTbl.Default).init ();
      EVAL ex.put (t.uid, NIL);
    END;

    Out (wx, &quot;structure:\n&quot;);
    Out (wx, &quot;&lt;PRE&gt;\n&quot;);
    FormatType (t, ex, wx);
    Out (wx, &quot;&lt;/PRE&gt;\n&quot;);
    Out (wx, EndPage);
  END GenType;

PROCEDURE <A NAME="FormatType"><procedure>FormatType</procedure></A> (t: Type;  expanded: IntRefTbl.T;  wx: Wx.T) =
  VAR fmt := XFormat.New (wx);
  BEGIN
    fmt.putText (&quot;  &quot;);
    fmt.begin (0);
    GenTypeExpr (t.defn, t.start, 1, ' ', expanded, fmt, topLevel := TRUE);
    fmt.end ();
    fmt.flush ();
    fmt.close ();
  END FormatType;

TYPE
  ObjEntry = REF RECORD
    next   : ObjEntry := NIL;
    name   : TEXT     := NIL;
    uid    : INTEGER  := 0;
    dfault : TEXT     := NIL;
    hidden : BOOLEAN  := FALSE;
    source : INTEGER  := 0;
  END;

  ObjEntryQueue = RECORD
    head, tail: ObjEntry := NIL;
  END;

  ObjInfo = RECORD
    traced  : BOOLEAN := FALSE;
    fields  : ObjEntryQueue;
    methods : ObjEntryQueue;
    names   : TextRefTbl.T := NIL;
  END;

PROCEDURE <A NAME="GenFlatType"><procedure>GenFlatType</procedure></A> (req: TEXT;  wx: Wx.T) =
  VAR uid := ScanUID (req);  ref: REFANY;  t: Type;  info: ObjInfo;
  BEGIN
    IF NOT db.type_ids.get (uid, ref) THEN
      Out (wx, StartPage);
      Out (wx, StartTitle, &quot;Type &amp;lt;&quot;, req, &quot;&amp;gt;&quot;, EndTitle);
      Out (wx, &quot;&lt;H2&gt;Type &amp;lt;&quot;, req, &quot;&amp;gt;:&lt;/H2&gt;\n&quot;);
      Out (wx, &quot;&lt;STRONG&gt; *unknown* &lt;/STRONG&gt;\n&quot;);
      Out (wx, EndPage);
      RETURN;
    END;
    t := ref;
    GenTypeHeader (t, 2, NIL, wx);
    IF (t.defn = NIL) THEN Out (wx, EndPage); RETURN END;

    info.names := NEW (TextRefTbl.Default).init ();
    ExtractObject (t, info);

    Out (wx, &quot;structure:\n&quot;);
    Out (wx, &quot;&lt;PRE&gt;\n&quot;);
    IF (info.fields.head # NIL) OR (info.methods.head # NIL)
      THEN FormatObject (info, wx);
      ELSE FormatType (t, NIL, wx);
    END;
    Out (wx, &quot;&lt;/PRE&gt;\n&quot;);
    Out (wx, EndPage);
  END GenFlatType;

PROCEDURE <A NAME="ExtractObject"><procedure>ExtractObject</procedure></A> (t: Type;  VAR info: ObjInfo) =
  VAR
    defn          : Buf.T;
    start         : INTEGER;
    eof           : INTEGER;
    ch            : CHAR;
    n_fields      : INTEGER;
    n_methods     : INTEGER;
    n_overrides   : INTEGER;
    n_pending     : INTEGER;
    field_source  : INTEGER;
    method_source : INTEGER;
    id, idX       : TEXT;
    entry         : ObjEntry;
    ref           : REFANY;
    rhs           : Type;
  BEGIN
    IF (t = NIL) THEN RETURN END;
    field_source  := t.uid;
    method_source := t.uid;
    IF TranslateOpaque (t.uid, rhs) THEN t := rhs; END;
    ExtractObject (SuperType (t), info);
    defn := t.defn;
    IF (defn = NIL) THEN RETURN END;
    eof := NUMBER (t.defn^);
    start := t.start;
    IF (start &gt;= eof) THEN RETURN END;
    ch := defn [start]; INC (start);
    IF (ch # 'U') AND (ch # 'V') THEN RETURN END;
    IF (ch = 'V') THEN info.traced := TRUE END;

    EVAL ReadUID (defn, start); (* self *)
    EVAL ReadUID (defn, start); (* super type *)
    n_fields    := ReadInt (defn, start); (* # fields *)
    n_methods   := ReadInt (defn, start); (* # methods *)
    n_overrides := ReadInt (defn, start); (* # overrides *)
    start := NextLine (defn, start);
    n_pending := n_fields + n_methods + n_overrides;

    WHILE (start &lt; eof) AND (n_pending &gt; 0) DO

      ch := defn[start];  INC (start);
      CASE ch OF
      | 'L' =&gt; (* field *)
           DEC (n_fields);
           DEC (n_pending);
           entry := NEW (ObjEntry);
           entry.name := ReadName (defn, start);
           EVAL ReadInt (defn, start); (* bit offset *)
           EVAL ReadInt (defn, start); (* bit size *)
           entry.uid := ReadUID (defn, start); (* type *)
           entry.source := field_source;  field_source := 0;
           AddObjEntry (info, info.fields, entry);
      | 'W' =&gt; (* method *)
           DEC (n_methods);
           DEC (n_pending);
           entry := NEW (ObjEntry);
           entry.name := ReadName (defn, start);
           entry.uid := ReadUID (defn, start); (* type *)
           entry.dfault := ReadBrand (defn, start);
           entry.source := method_source;  method_source := 0;
           AddObjEntry (info, info.methods, entry);
      | 'X' =&gt; (* overrides *)
           DEC (n_overrides);
           DEC (n_pending);
           id  := ReadName (defn, start);
           idX := ReadName (defn, start);
           IF info.names.get (id, ref) THEN
             entry := ref;
             entry.dfault := idX;
           END;
      ELSE
        (* skip *)
      END; (* CASE *)
      IF (n_pending &gt; 0) THEN
        start := NextLine (defn, start);
      END;
    END;
  END ExtractObject;

PROCEDURE <A NAME="AddObjEntry"><procedure>AddObjEntry</procedure></A> (VAR info: ObjInfo;  VAR q: ObjEntryQueue;  e: ObjEntry)=
  VAR ref: REFANY;  old: ObjEntry;
  BEGIN
    IF (q.head = NIL)
      THEN q.head := e;
      ELSE q.tail.next := e;
    END;
    q.tail := e;
    IF info.names.get (e.name, ref) THEN
      old := ref;
      old.hidden := TRUE;
    END;
    EVAL info.names.put (e.name, e);
  END AddObjEntry;

PROCEDURE <A NAME="FormatObject"><procedure>FormatObject</procedure></A> (READONLY info: ObjInfo;  wx: Wx.T) =
  VAR fmt := XFormat.New (wx);  x: ObjEntry;
  BEGIN
    fmt.putText (&quot;  &quot;);
    fmt.begin (2);
    IF (NOT info.traced) THEN fmt.putText (&quot;UNTRACED &quot;); END;
    fmt.putText (&quot;OBJECT&quot;);
    fmt.newLine ();
    IF (info.fields.head # NIL) THEN
      fmt.newLine ();
      fmt.align (4, tryOneLine := FALSE);
      x := info.fields.head;
      WHILE (x # NIL) DO
        FormatObjEntry (x, fmt, FALSE);
        x := x.next;
      END;
      fmt.end ();
    END;
    IF (info.methods.head # NIL) THEN
      fmt.newLine (-2);
      fmt.putText (&quot;METHODS&quot;);
      fmt.newLine ();
      fmt.align (4, tryOneLine := FALSE);
      x := info.methods.head;
      WHILE (x # NIL) DO
        FormatObjEntry (x, fmt, TRUE);
        x := x.next;
      END;
      fmt.end ();
    END;
    fmt.newLine (-2);
    fmt.putText (&quot;END&quot;);
    fmt.end ();
    fmt.flush ();
    fmt.close ();
  END FormatObject;

PROCEDURE <A NAME="FormatObjEntry"><procedure>FormatObjEntry</procedure></A> (x: ObjEntry;  fmt: XFormat.T;  method: BOOLEAN) =
  BEGIN
    fmt.group ();

      fmt.group ();
        fmt.putText (x.name);
        fmt.putChar (' ');
      fmt.end ();

      fmt.group ();
        IF (method) THEN
          GenTypeName (x.uid, NIL, fmt, sig_only := TRUE);
        ELSE
          fmt.putText (&quot;: &quot;);
          GenTypeName (x.uid, NIL, fmt);
        END;
        IF (x.dfault = NIL) THEN fmt.putText (&quot;;&quot;); END;
      fmt.end ();

      fmt.group ();
        IF (x.dfault # NIL) THEN
          fmt.putText (&quot; := &quot;);
          GenProcRef (fmt, x.dfault);
          fmt.putText (&quot;;&quot;);
        END;
      fmt.end ();

      fmt.group ();
        IF (x.source # 0) THEN
          fmt.putText (&quot; (* &quot;);
          GenTypeName (x.source, NIL, fmt);
          fmt.putText (&quot; *)&quot;);
        END;
        IF (x.hidden) THEN
          fmt.putText (&quot; (*HIDDEN*)&quot;);
        END;
      fmt.end ();

    fmt.end ();
  END FormatObjEntry;

PROCEDURE <A NAME="GenTypeHeader"><procedure>GenTypeHeader</procedure></A> (t: Type;  mode: INTEGER;  pref: TEXT;  wx: Wx.T) =
  VAR uid, xid: TEXT;  tn := t.names;  name, home: TEXT;  u: Type;
  BEGIN
    uid := FmtUID (t.uid);
    GetTypeName (t.uid, name, home, pref);

    IF (home # NIL) THEN
      Out (wx, StartPage);
      Out (wx, StartTitle, name, &quot; in &quot;, home, EndTitle);
      Out (wx, &quot;&lt;H2&gt;&quot;, name);
      Out (wx, &quot; in &lt;A HREF=\&quot;/3&quot;, home, &quot;\&quot;&gt;&quot;, home, &quot;&lt;/A&gt;:&lt;/H2&gt;&lt;P&gt;\n&quot;);
    ELSE
      Out (wx, StartPage);
      Out (wx, StartTitle, name, EndTitle);
      Out (wx, &quot;&lt;H2&gt;&quot;, name, &quot;:&lt;/H2&gt;&lt;P&gt;\n&quot;);
    END;
    Out (wx, &quot;(internal uid = &amp;lt;&quot;, uid, &quot;&amp;gt;&quot;);
    IF TranslateOpaque (t.uid, u) THEN
      xid := FmtUID (u.uid);
      Out (wx, &quot;, revealed = &amp;lt;&quot;, xid, &quot;&amp;gt;&quot;);
    END;
    IF FindOpaque (t.uid, u) THEN
      xid := FmtUID (u.uid);
      Out (wx, &quot;, opaque = &amp;lt;&quot;, xid, &quot;&amp;gt;&quot;);
    END;
    Out (wx, &quot;)&lt;P&gt;\n&quot;);

    IF (mode # 0) THEN
      Out (wx, &quot;  &lt;A HREF=\&quot;/N&quot;, uid, &quot;\&quot;&gt;[condensed view]&lt;/A&gt;\n&quot;);
    END;
    IF (mode # 1) THEN
      Out (wx, &quot;  &lt;A HREF=\&quot;/O&quot;, uid, &quot;\&quot;&gt;[expanded view]&lt;/A&gt;\n&quot;);
    END;
    IF (mode # 2) THEN
      IF (t.class = 'V') OR (t.class = 'U') OR
        ((t.class = 'Y') AND TranslateOpaque (t.uid, u)) THEN
        Out (wx, &quot;  &lt;A HREF=\&quot;/Q&quot;, uid, &quot;\&quot;&gt;[flat view]&lt;/A&gt;\n&quot;);
      END;
    END;
    IF (t.subtypes # NIL) OR (SuperType (t) # NIL) THEN
      Out (wx, &quot;  &lt;A HREF=\&quot;/P&quot;, uid, &quot;\&quot;&gt;[subtype graph]&lt;/A&gt;\n&quot;);
    END;
    Out (wx, &quot;&lt;P&gt;\n&quot;);

    IF (tn # NIL) AND (tn.next # NIL) THEN
      Out (wx, &quot;aliases:\n&lt;UL&gt;\n&quot;);
      WHILE (tn # NIL) DO
        Out (wx, &quot;&lt;LI&gt;&quot;, ID.ToText (tn.name), &quot; in &quot;);
        Out (wx, &quot;&lt;A HREF=\&quot;/3&quot;, ID.ToText(tn.home),&quot;\&quot;&gt;&quot;);
        Out (wx, ID.ToText(tn.home),&quot;&lt;/A&gt;\n&quot;);
        tn := tn.next;
      END;
      Out (wx, &quot;&lt;/UL&gt;\n&lt;P&gt;\n&quot;);
      tn := t.names;
    END;
  END GenTypeHeader;

VAR debug := RTParams.IsPresent(&quot;debug&quot;);

PROCEDURE <A NAME="GenTypeExpr"><procedure>GenTypeExpr</procedure></A> (defn     : Buf.T;
                       start    : INTEGER;
                       count    : INTEGER;
                       kind     : CHAR;
                       expanded : IntRefTbl.T;
                       fmt      : XFormat.T;
                       topLevel : BOOLEAN := FALSE;
                       sig_only : BOOLEAN := FALSE;
                       opaque_id: INTEGER := 0) =
  VAR
    eof        := NUMBER (defn^);
    ch         : CHAR;
    a, b, c, d : INTEGER;
    e, f       : INTEGER;
    id, idX    : TEXT;
    rhs        : Type;
  BEGIN
    WHILE (start &lt; eof) AND (count &gt; 0) DO

      IF (debug) THEN
        fmt.putMarkup (&quot;(&quot;);
        fmt.putMarkup (Fmt.Int (start));
        fmt.putMarkup (&quot;*&quot;);
        fmt.putMarkup (Fmt.Int (count));
        fmt.putMarkup (&quot;*&quot;);
        fmt.putMarkup (Text.FromChar (defn[start]));
        fmt.putMarkup (&quot;)&quot;);
      END;

      ch := defn[start];  INC (start);
      IF (ch = kind) OR (kind = ' ') THEN
        DEC (count);
        CASE ch OF
        | '?' =&gt; (* builtin type *)
             EVAL ReadUID (defn, start);
             id := ReadName (defn, start);
             fmt.putText (id);
        | 'F' =&gt; (* array *)
             EVAL ReadUID (defn, start);
             a := ReadUID (defn, start);
             b := ReadUID (defn, start);
             fmt.begin (2);
               fmt.putText (&quot;ARRAY &quot;);
               fmt.break (0);
               GenTypeName (a, expanded, fmt);
               fmt.putChar (' ');
               fmt.break (0);
               fmt.putText (&quot;OF &quot;);
               fmt.break (0);
               GenTypeName (b, expanded, fmt);
             fmt.end ();
        | 'G' =&gt; (* open array *)
             EVAL ReadUID (defn, start);
             a := ReadUID (defn, start);
             fmt.begin (2);
               fmt.putText (&quot;ARRAY OF &quot;);
               fmt.break ();
               GenTypeName (a, expanded, fmt);
             fmt.end ();
        | 'H' =&gt; (* enum *)
             EVAL ReadUID (defn, start);
             a := ReadInt (defn, start);
             b := NextLine (defn, start);
             fmt.begin (2);
               fmt.putText (&quot;{&quot;);
               GenTypeExpr (defn, b, a, 'I', expanded, fmt);
               fmt.putText (&quot;}&quot;);
             fmt.end ();
        | 'I' =&gt; (* enum elt *)
             id := ReadName (defn, start);
             fmt.break ();
             fmt.putText (id);
             IF (count &gt; 0) THEN fmt.putText (&quot;, &quot;); END;
        | 'J' =&gt; (* bits for *)
             EVAL ReadUID (defn, start);
             a := ReadInt (defn, start);
             b := ReadUID (defn, start);
             fmt.begin (2);
               fmt.putText (&quot;BITS &quot;);
               fmt.putText (Fmt.Int (a));
               fmt.putText (&quot; FOR &quot;);
               fmt.break ();
               GenTypeName (b, expanded, fmt);
             fmt.end ();
        | 'K' =&gt; (* record *)
             EVAL ReadUID (defn, start);  (* self *)
             EVAL ReadInt (defn, start);  (* total size *)
             a := ReadInt (defn, start);  (* # fields *)
             b := NextLine (defn, start);
             fmt.begin (2);
               fmt.putText (&quot;RECORD &quot;);
               IF (topLevel) THEN fmt.newLine () END;
               fmt.unitedBreak ();
               fmt.align (3, tryOneLine := NOT topLevel);
               GenTypeExpr (defn, b, a, 'L', expanded, fmt);
               fmt.end ();
               fmt.unitedBreak (-2);
               fmt.putText (&quot;END &quot;);
             fmt.end (); (* RECORD *)
        | 'L' =&gt; (* field *)
             id := ReadName (defn, start);
             EVAL ReadInt (defn, start);
             EVAL ReadInt (defn, start);
             a := ReadUID (defn, start);
             fmt.group ();
               fmt.group ();
                 fmt.putText (id);
                 fmt.putChar (' ');
               fmt.end ();
               fmt.group ();
                 fmt.putText (&quot;: &quot;);
               fmt.end ();
               fmt.group ();
                 GenTypeName (a, expanded, fmt);
                 fmt.putText (&quot;; &quot;);
               fmt.end ();
             fmt.end ();
        | 'M' =&gt; (* set *)
             EVAL ReadUID (defn, start);
             a := ReadUID (defn, start);
             fmt.begin (2);
               fmt.putText (&quot;SET OF &quot;);
               fmt.break ();
               GenTypeName (a, expanded, fmt);
             fmt.end ();
        | 'N' =&gt; (* subrange *)
             EVAL ReadUID (defn, start);
             a   := ReadUID (defn, start);
             id  := ReadName (defn, start);
             idX := ReadName (defn, start);
             fmt.begin (2);
               fmt.putText (&quot;[ &quot;);
               fmt.putText (id);
               fmt.break ();
               fmt.putText (&quot; .. &quot;);
               fmt.putText (idX);
               fmt.putText (&quot; ]&quot;);
               IF (a # INTEGER_UID) OR (a # LONGINT_UID) THEN
                 fmt.putChar (' ');
                 fmt.break ();
                 fmt.putText (&quot;(OF &quot;);
                 GenTypeName (a, expanded, fmt);
                 fmt.putText (&quot;)&quot;);
               END;
             fmt.end ();
        | 'O', 'P' =&gt; (* untraced ref *)
             EVAL ReadUID (defn, start);
             a := ReadUID (defn, start);
             id := ReadBrand (defn, start);
             fmt.begin (2);
               IF (ch = 'O') THEN
                 fmt.putText (&quot;UNTRACED &quot;);
               END;
               IF (id # NIL) THEN
                 fmt.break ();
                 fmt.putText (&quot;BRANDED \&quot;&quot;);
                 fmt.putText (id, raw := TRUE);
                 fmt.putText (&quot;\&quot; &quot;);
               END;
               fmt.break ();
               fmt.putText (&quot;REF &quot;);
               fmt.break ();
               GenTypeName (a, expanded, fmt);
             fmt.end ();
        | 'Q' =&gt; (* indirect *)
             EVAL ReadUID (defn, start);
             a := ReadUID (defn, start);
             fmt.begin (2);
               fmt.putText (&quot;VAR &quot;);
               fmt.break ();
               GenTypeName (a, expanded, fmt);
             fmt.end ();
        | 'R' =&gt; (* procedure *)
             EVAL ReadUID (defn, start);
             a := ReadInt (defn, start);  (* # formals *)
             b := ReadUID (defn, start);  (* return type *)
             c := ReadInt (defn, start);  (* # raises *)
             d := NextLine (defn, start);
             fmt.begin (2);
               IF (NOT sig_only) THEN
                 fmt.putText (&quot;PROCEDURE &quot;);
               END;
               fmt.putText (&quot;(&quot;);
               IF (a &gt; 0) THEN
                 fmt.align (3, tryOneLine := TRUE);
                 GenTypeExpr (defn, d, a, 'S', expanded, fmt);
                 fmt.end ();
               END;
               fmt.putText (&quot;)&quot;);
               IF (b # 0) THEN
                 fmt.break ();
                 fmt.putText (&quot;: &quot;);
                 GenTypeName (b, expanded, fmt);
               END;
               IF (c &gt; 0) THEN
                 fmt.break ();
                 fmt.begin (2);
                 fmt.putText (&quot; RAISES {&quot;);
                 GenTypeExpr (defn, d, a, 'T', expanded, fmt);
                 fmt.putText (&quot;}&quot;);
                 fmt.end ();
               END;
             fmt.end ();
          | 'S' =&gt; (* formal *)
             id := ReadName (defn, start);
             a := ReadUID (defn, start);
             fmt.group ();
               fmt.group ();
                 fmt.putText (id);
                 fmt.putChar (' ');
               fmt.end ();
               fmt.group ();
                 fmt.putText (&quot;: &quot;);
               fmt.end ();
               fmt.group ();
                 GenTypeName (a, expanded, fmt);
                 IF (count &gt; 0) THEN fmt.putText (&quot;; &quot;); END;
               fmt.end ();
             fmt.end ();
        | 'T' =&gt; (* raises *)
             id := ReadName (defn, start);
             fmt.break ();
             fmt.putText (id);
             IF (count &gt; 0) THEN fmt.putText (&quot;, &quot;); END;
        | 'U', 'V' =&gt; (* untraced obj, obj *)
             a := ReadUID (defn, start); (* self *)
             b := ReadUID (defn, start); (* super type *)
             c := ReadInt (defn, start); (* # fields *)
             d := ReadInt (defn, start); (* # methods *)
             e := ReadInt (defn, start); (* # overrides *)
             EVAL ReadInt (defn, start); (* total field size *)
             f := NextLine (defn, start);
             id := ReadBrand (defn, start);

             fmt.begin (2);
               IF (b # 0) THEN (* super type *)
                 IF (expanded = NIL) THEN
                   GenTypeName (b, expanded, fmt);
                   fmt.putChar (' ');
                 ELSE
                   GenTypeName (b, expanded, fmt, topLevel);
                   fmt.newLine ();
                   fmt.newLine (-2);
                 END;
               ELSE
                 IF (ch = 'U') THEN fmt.putText (&quot;UNTRACED &quot;); END;
               END;
               IF (id # NIL) THEN
                 fmt.break ();
                 fmt.putText (&quot;BRANDED \&quot;&quot;);
                 fmt.putText (id, raw := TRUE);
                 fmt.putText (&quot;\&quot; &quot;);
               END;
               fmt.putText (&quot;OBJECT &quot;);
               IF (expanded # NIL) THEN
                 IF NOT GenObjectName (a, fmt) THEN
                   EVAL GenObjectName (opaque_id, fmt);
                 END;
               END;
               IF (c &gt; 0) THEN
                 fmt.unitedBreak ();
                 fmt.align (3, tryOneLine := NOT topLevel);
                 GenTypeExpr (defn, f, c, 'L', expanded, fmt);
                 fmt.end ();
               END;
               IF (d &gt; 0) THEN
                 fmt.unitedBreak (-2);
                 fmt.putText (&quot;METHODS &quot;);
                 fmt.unitedBreak (0);
                 GenTypeExpr (defn, f, d, 'W', expanded, fmt);
               END;
               IF (e &gt; 0) THEN
                 fmt.unitedBreak (-2);
                 fmt.putText (&quot;OVERRIDES &quot;);
                 fmt.unitedBreak (0);
                 fmt.align (3, tryOneLine := NOT topLevel);
                 GenTypeExpr (defn, f, e, 'X', expanded, fmt);
                 fmt.end ();
               END;
               IF (topLevel) THEN fmt.newLine (-2); END;
               fmt.unitedBreak (-2);
               fmt.putText (&quot;END &quot;);
             fmt.end (); (* OBJECT *)
        | 'W' =&gt; (* method *)
             id := ReadName (defn, start);
             a := ReadUID (defn, start);
             idX := ReadBrand (defn, start);
             fmt.unitedBreak ();
             fmt.putText (id);
             fmt.putChar (' ');
             fmt.begin ();
               GenTypeName (a, expanded, fmt, sig_only := TRUE);
               IF (idX # NIL) THEN
                 fmt.putText (&quot; := &quot;);
                 GenProcRef (fmt, idX);
               END;
               fmt.putText (&quot;; &quot;);
             fmt.end ();
        | 'X' =&gt; (* overrides *)
             id  := ReadName (defn, start);
             idX := ReadName (defn, start);
             fmt.group ();
               fmt.group ();
                 fmt.putText (id);
                 fmt.putChar (' ');
               fmt.end ();
               fmt.group ();
                 fmt.putText (&quot;:= &quot;);
               fmt.end ();
               fmt.group ();
                 GenProcRef (fmt, idX);
                 fmt.putText (&quot;; &quot;);
               fmt.end ();
             fmt.end ();
        | 'Y' =&gt; (* opaque *)
             a := ReadUID (defn, start); (* self *)
             b := ReadUID (defn, start); (* super *)
             IF TranslateOpaque (a, rhs) THEN
               GenTypeExpr (rhs.defn, rhs.start, 1, ' ',
                   expanded, fmt, topLevel, opaque_id := a);
             ELSE
               fmt.begin (2);
                 fmt.putText (&quot;&lt;: &quot;);
                 GenTypeName (a, expanded, fmt, topLevel);
               fmt.end ();
             END;
        | '@', 'A', 'B', 'C', 'D', 'Z' =&gt;
             INC (count); (* ignore this line *)
        ELSE
          fmt.putMarkup (&quot;(! bad char =\&quot;&quot;);
          fmt.putMarkup (Text.FromChar (ch));
          fmt.putMarkup (&quot;\&quot; !)&quot;);
        END; (* CASE *)
      END; (* IF ch = kind *)
      IF (count &gt; 0) THEN
        start := NextLine (defn, start);
      END;
    END;
  END GenTypeExpr;

PROCEDURE <A NAME="NextLine"><procedure>NextLine</procedure></A> (defn: Buf.T;  start: INTEGER): INTEGER =
  VAR eof := NUMBER (defn^);
  BEGIN
    WHILE (start &lt; eof) AND (defn[start] # '\n') DO INC (start); END;
    RETURN start + 1;
  END NextLine;
</PRE>*********
PROCEDURE SkipLine (defn: Buf.T;  start: INTEGER;  kind: CHAR): INTEGER =
  VAR eof := NUMBER (defn^);
  BEGIN
    WHILE (start &lt; eof) AND (defn[start] # kind) DO
      start := NextLine (defn, start);
    END;
    RETURN NextLine (defn, start);
  END SkipLine;
*********

<P><PRE>PROCEDURE <A NAME="GenTypeName"><procedure>GenTypeName</procedure></A> (uid      : INTEGER;
                       ex       : IntRefTbl.T;
                       fmt      : XFormat.T;
                       topLevel : BOOLEAN := FALSE;
                       sig_only : BOOLEAN := FALSE) =
  VAR t: Type;  ref: REFANY;  old: BOOLEAN;
  BEGIN
    IF NOT db.type_ids.get (uid, ref) THEN
      fmt.putMarkup (&quot;&amp;lt;&quot;, 1);
      fmt.putText   (FmtUID (uid));
      fmt.putMarkup (&quot;&amp;gt;&quot;, 1);
      RETURN;
    END;
    t := ref;
    IF (ex # NIL)
      AND (t.defn # NIL)
      AND (topLevel = IsRef (t))
      AND NOT ex.get (uid, ref) THEN
      old := ex.put (uid, NIL);
      fmt.group ();
      GenTypeExpr (t.defn, t.start, 1, ' ', ex, fmt, topLevel, sig_only);
      fmt.end ();
      IF NOT old THEN EVAL ex.delete (uid, ref); END;
      RETURN;
    END;
    fmt.group ();
    fmt.putMarkup (&quot;&lt;A HREF=\&quot;/N&quot;);
    fmt.putMarkup (FmtUID (uid));
    fmt.putMarkup (&quot;\&quot;&gt;&quot;);
    IF (t.names # NIL) AND NOT sig_only THEN
      fmt.putText (ID.ToText (t.names.name));
    ELSE
      fmt.putMarkup (&quot;&amp;lt;&quot;, 1);
      fmt.putText   (FmtUID (uid));
      fmt.putMarkup (&quot;&amp;gt;&quot;, 1);
    END;
    fmt.putMarkup (&quot;&lt;/A&gt;&quot;);
    fmt.end ();
  END GenTypeName;

PROCEDURE <A NAME="IsRef"><procedure>IsRef</procedure></A> (t: Type): BOOLEAN =
  BEGIN
    RETURN (t.class = 'P') OR (t.class = 'V')
        OR (t.class = 'O') OR (t.class = 'U')
        OR (t.class = 'Y');
  END IsRef;

PROCEDURE <A NAME="GenObjectName"><procedure>GenObjectName</procedure></A> (uid: INTEGER;  fmt: XFormat.T): BOOLEAN =
  VAR t: Type;  ref: REFANY;
  BEGIN
    IF (uid = 0) THEN RETURN FALSE END;
    IF NOT db.type_ids.get (uid, ref) THEN RETURN FALSE END;
    t := ref;
    IF (t.names = NIL) THEN RETURN FALSE END;
    fmt.group ();
    fmt.putText (&quot;(* &quot;);
    fmt.putMarkup (&quot;&lt;A HREF=\&quot;/N&quot;);
    fmt.putMarkup (FmtUID (uid));
    fmt.putMarkup (&quot;\&quot;&gt;&quot;);
    fmt.putText (ID.ToText (t.names.name));
    fmt.putMarkup (&quot;&lt;/A&gt;&quot;);
    fmt.putText (&quot; *)&quot;);
    fmt.end ();
    RETURN TRUE;
  END GenObjectName;

PROCEDURE <A NAME="GenProcRef"><procedure>GenProcRef</procedure></A>(fmt: XFormat.T; t: TEXT) =
  VAR dotIndex := Text.FindChar(t, '.'); BEGIN
    fmt.group();
    IF dotIndex = -1 THEN
      fmt.putMarkup(t)
    ELSE
      WITH
    	unit = Text.Sub(t, 0, dotIndex),
    	proc = Text.Sub(t, dotIndex + 1) DO
    	fmt.putMarkup(&quot;&lt;A HREF=\&quot;/S&quot; &amp; unit &amp; &quot;.i3.&quot; &amp; proc &amp; &quot;#&quot;
    	       &amp; proc &amp; &quot;\&quot;&gt;&quot; &amp; t &amp; &quot;&lt;/A&gt;&quot;);
      END
    END;
    fmt.end();
  END GenProcRef;

PROCEDURE <A NAME="ReadUID"><procedure>ReadUID</procedure></A> (buf: Buf.T;  VAR cursor: INTEGER): INTEGER =
  VAR eof := NUMBER (buf^);  ch: CHAR;  uid: INTEGER := 0;  digit: INTEGER;
  BEGIN
    SkipBlanks (buf, cursor);
    WHILE (cursor &lt; eof) DO
      ch := buf[cursor];
      IF ('0' &lt;= ch) AND (ch &lt;= '9') THEN
        digit := ORD (ch) - ORD ('0');
      ELSIF ('a' &lt;= ch) AND (ch &lt;= 'f') THEN
        digit := 10 + ORD (ch) - ORD ('a');
      ELSE
        EXIT;
      END;
      INC (cursor);
      uid := Word.LeftShift (uid, 4) + digit;
      uid := Word.And (uid, 16_ffffffff);
    END;
    RETURN uid;
  END ReadUID;

PROCEDURE <A NAME="SkipBlanks"><procedure>SkipBlanks</procedure></A> (buf: Buf.T;  VAR cur: INTEGER) =
  VAR eof := NUMBER (buf^);
  BEGIN
    WHILE (cur &lt; eof) AND (buf[cur] = ' ') DO INC (cur); END;
  END SkipBlanks;

PROCEDURE <A NAME="ReadName"><procedure>ReadName</procedure></A> (buf: Buf.T;  VAR cursor: INTEGER): TEXT =
  VAR ch: CHAR;  eof := NUMBER (buf^);  start := cursor;
  BEGIN
    SkipBlanks (buf, cursor);
    start := cursor;
    WHILE (cursor &lt; eof) DO
      ch := buf[cursor];
      IF (ch = ' ') OR (ch = '\n') OR (ch = '\r') THEN EXIT END;
      INC (cursor);
    END;
    RETURN Text.FromChars (SUBARRAY (buf^, start, cursor - start));
  END ReadName;

PROCEDURE <A NAME="ReadInt"><procedure>ReadInt</procedure></A> (buf: Buf.T;  VAR cursor: INTEGER): INTEGER =
  VAR ch: CHAR;  eof := NUMBER (buf^);  val := 0;
  BEGIN
    SkipBlanks (buf, cursor);
    WHILE (cursor &lt; eof) DO
      ch := buf[cursor];
      IF (ch &lt; '0') OR ('9' &lt; ch) THEN EXIT END;
      val := val * 10 + ORD (ch) - ORD ('0');
      INC (cursor);
    END;
    RETURN val;
  END ReadInt;

PROCEDURE <A NAME="ReadBrand"><procedure>ReadBrand</procedure></A> (buf: Buf.T; VAR cursor: INTEGER): TEXT =
  VAR eof := NUMBER (buf^);  start: INTEGER;
  BEGIN
    IF (buf[cursor] # ' ') THEN RETURN NIL END;
    INC (cursor);
    start := cursor;
    WHILE (cursor &lt; eof) AND (buf[cursor] # '\r') AND (buf[cursor] # '\n') DO
      INC (cursor);
    END;
    RETURN Text.FromChars (SUBARRAY (buf^, start, cursor - start));
  END ReadBrand;

CONST
  HexDigits = ARRAY [0..15] OF CHAR { '0','1','2','3','4','5','6','7',
                                      '8','9','a','b','c','d','e','f' };

PROCEDURE <A NAME="FmtUID"><procedure>FmtUID</procedure></A> (uid: INTEGER): TEXT =
  VAR buf: ARRAY [0..7] OF CHAR;
  BEGIN
    FOR i := 7 TO 0 BY -1 DO
      buf [i] := HexDigits [Word.And (uid, 16_f)];
      uid := Word.RightShift (uid, 4);
    END;
    RETURN Text.FromChars (buf);
  END FmtUID;

PROCEDURE <A NAME="ScanUID"><procedure>ScanUID</procedure></A> (txt: TEXT): INTEGER =
  VAR cursor := 0;  buf := NEW (Buf.T, Text.Length (txt));
  BEGIN
    Text.SetChars (buf^, txt);
    RETURN ReadUID (buf, cursor);
  END ScanUID;
</PRE>------------------------------------------------------ HTML directories ---

<P> In principle an HTML front-end will do a good job rendering
   a list of names in &lt;DIR&gt;&lt;/DIR&gt; brackets.  In practice <CODE>xmosaic</CODE>
   doesn't.  The following code is intended to compensate. 

<P><PRE>PROCEDURE <A NAME="GenDir"><procedure>GenDir</procedure></A> (cmd, alt_cmd: TEXT;  VAR names: ARRAY OF INTEGER;
                  wx: Wx.T;  limit: INTEGER) =
  CONST Dir_width = 78; (* max # characters per line *)
  CONST Max_cols  = 6;  (* max # columns per line *)
  CONST Gap       = 2;  (* inter-column gap *)
  CONST Gap_text  = &quot;  &quot;;
  VAR max_len := 0;  n_cols := 1;  width, n_rows, j: CARDINAL;  nm: TEXT;
    prefix_len := 0;  n_names := NUMBER (names);  nm_len: INTEGER;
    counts: IntVec;
  BEGIN
    IF n_names &lt;= 0 THEN RETURN END;
    Sort (names);

    (* find the longest name *)
    FOR i := FIRST (names) TO LAST (names) DO
      max_len := MAX (max_len, Text.Length (ID.ToText (names[i])));
    END;

    (* if there are too many names, collapse the list to prefixes *)
    IF n_names &gt; limit THEN
      prefix_len := FindPrefixes (names, n_names, counts, max_len, limit);
      (* recompute the max length *)
      max_len := MIN (max_len, prefix_len + 3);
      FOR i := 0 TO n_names-1 DO
        IF counts[i] &lt;= 1 THEN
          max_len := MAX (max_len, Text.Length (ID.ToText (names[i])));
        END;
      END;
    END;

    (* compute an approriate layout *)
    max_len := MAX (5, max_len);
    INC (max_len, Gap);
    n_cols := MAX (1, MIN (Dir_width DIV max_len, Max_cols));
    n_rows := (n_names + n_cols - 1) DIV n_cols;
    width  := Dir_width DIV n_cols - Gap;

    Out (wx, &quot;&lt;PRE&gt;\n&quot;);
    TRY
      FOR row := 0 TO n_rows-1 DO
        FOR col := 0 TO n_cols-1 DO
          j := col * n_rows + row;
          IF (j &lt; n_names) THEN
            nm := ID.ToText (names [j]);
            nm_len := Text.Length (nm);
            IF (prefix_len # 0) AND (counts[j] &gt; 1) THEN
              IF (nm_len &gt; prefix_len) THEN
                nm := Text.Sub (nm, 0, prefix_len);
                nm_len := prefix_len;
              END;
              Out (wx, &quot;&lt;A HREF=\&quot;/&quot;, alt_cmd);
              Out (wx, nm, &quot;\&quot;&gt;&quot;, nm, &quot;...&quot;);
              INC (nm_len, 3);
            ELSE
              Out (wx, &quot;&lt;A HREF=\&quot;/&quot;, cmd, nm, &quot;\&quot;&gt;&quot;, nm);
            END;
            Out (wx, &quot;&lt;/A&gt;&quot;);
            IF (col # n_cols-1) THEN
              (* pad to the next column *)
              FOR x := 1 TO width - nm_len DO Out (wx, &quot; &quot;); END;
            END;
            Out (wx, Gap_text);
          END;
        END;
        Out (wx, &quot;\n&quot;);
      END;
    FINALLY
      Out (wx, &quot;&lt;/PRE&gt;\n&quot;);
    END;
  END GenDir;
</PRE>--------------------------------------------------- find prefix classes ---

<P><PRE>PROCEDURE <A NAME="FindPrefixes"><procedure>FindPrefixes</procedure></A> (VAR names   : ARRAY OF INTEGER;
                        VAR n_names : CARDINAL;
                        VAR counts  : IntVec;
                            max_len : INTEGER;
                            limit   : INTEGER): INTEGER =
  VAR len, n, n0: INTEGER;
      cnts := NEW (IntVec, NUMBER (names));
      cnts0 := NEW (IntVec, NUMBER (names));
      tmp: IntVec;
  BEGIN
    (* find a prefix that generates a non-trivial choice *)
    n := 0;  len := 0;
    WHILE (len &lt;= max_len) AND (n &lt; 2) DO
      INC (len);
      n := CntPrefixes (names, cnts^, len);
    END;

    (* find the largest prefix that's got fewer than limit classes *)
    REPEAT
      n0 := n;
      tmp := cnts0;  cnts0 := cnts;  cnts := tmp;
      INC (len);
      n := CntPrefixes (names, cnts^, len);
    UNTIL (len &gt;= max_len) OR (n &gt; limit);

    (* pick the best size *)
    IF (limit - n0 &lt;= n - limit) THEN
      (* use the shorter prefix *)
      DEC (len);
      cnts := cnts0;
    END;

    (* collapse the list of names *)
    n0 := 0;  counts := cnts;
    FOR i := 0 TO LAST (names) DO
      IF cnts[i] &gt; 0 THEN
        names[n0] := names[i];
        counts[n0] := cnts[i];
        INC (n0);
      END;
    END;

    n_names := n0;
    RETURN len;
  END FindPrefixes;

PROCEDURE <A NAME="CntPrefixes"><procedure>CntPrefixes</procedure></A> (READONLY names : ARRAY OF INTEGER;
                            VAR cnts  : ARRAY OF INTEGER;
                                len   : INTEGER): INTEGER =
  VAR n_classes := 1;  last_class := 0;  short: BOOLEAN;  class_id, xx: TEXT;
  BEGIN
    class_id := ID.ToText (names[0]);
    short := Text.Length (class_id) &lt; len;
    cnts [0] := 1;
    FOR i := 1 TO LAST (names) DO
      IF PrefixMatch (class_id, names[i], len) THEN
        INC (cnts[last_class]);
        cnts[i] := 0;
        xx := ID.ToText (names[i]);
        IF (short) AND (Text.Length (class_id) &lt; Text.Length (xx)) THEN
          (* use 'i' as the class representitive *)
          cnts[i] := cnts[last_class];
          cnts[last_class] := 0;
          class_id := xx;
          short := Text.Length (class_id) &lt; len;
        END;
      ELSE
        class_id := ID.ToText (names[i]);
        short := Text.Length (class_id) &lt; len;
        cnts[i] := 1;
        last_class := i;
        INC (n_classes);
      END;
    END;
    RETURN n_classes;
  END CntPrefixes;

PROCEDURE <A NAME="PrefixMatch"><procedure>PrefixMatch</procedure></A> (a: TEXT;  bx: ID.T;  len: INTEGER): BOOLEAN =
  BEGIN
    RETURN CharMap.PrefixMatch (a, ID.ToText (bx), len);
  END PrefixMatch;

PROCEDURE <A NAME="QueryMatch"><procedure>QueryMatch</procedure></A> (id: ID.T;  query: TextVec): BOOLEAN =
  VAR nm := ID.ToText (id);
  BEGIN
    IF (query = NIL) THEN RETURN TRUE END;
    FOR i := FIRST (query^) TO LAST (query^) DO
      IF NOT CharMap.Substr (nm, query[i]) THEN RETURN FALSE END;
    END;
    RETURN TRUE;
  END QueryMatch;
</PRE>--------------------------------------------------------------- sorting ---

<P><PRE>TYPE  Elem_T = INTEGER;

PROCEDURE <A NAME="Elem_Compare"><procedure>Elem_Compare</procedure></A> (a, b: INTEGER): [-1 .. +1] =
  BEGIN
    RETURN ID.Compare (a, b);
  END Elem_Compare;

PROCEDURE <A NAME="Sort"><procedure>Sort</procedure></A> (VAR a: ARRAY OF Elem_T;  cmp := Elem_Compare) =
  BEGIN
    QuickSort (a, 0, NUMBER (a), cmp);
    InsertionSort (a, 0, NUMBER (a), cmp);
  END Sort;

PROCEDURE <A NAME="QuickSort"><procedure>QuickSort</procedure></A> (VAR a: ARRAY OF Elem_T;  lo, hi: INTEGER;
                     cmp := Elem_Compare) =
  CONST CutOff = 9;
  VAR i, j: INTEGER;  key, tmp: Elem_T;
  BEGIN
    WHILE (hi - lo &gt; CutOff) DO (* sort a[lo..hi) *)

      (* use median-of-3 to select a key *)
      i := (hi + lo) DIV 2;
      IF cmp (a[lo], a[i]) &lt; 0 THEN
        IF cmp (a[i], a[hi-1]) &lt; 0 THEN
          key := a[i];
        ELSIF cmp (a[lo], a[hi-1]) &lt; 0 THEN
          key := a[hi-1];  a[hi-1] := a[i];  a[i] := key;
        ELSE
          key := a[lo];  a[lo] := a[hi-1];  a[hi-1] := a[i];  a[i] := key;
        END;
      ELSE (* a[lo] &gt;= a[i] *)
        IF cmp (a[hi-1], a[i]) &lt; 0 THEN
          key := a[i];  tmp := a[hi-1];  a[hi-1] := a[lo];  a[lo] := tmp;
        ELSIF cmp (a[lo], a[hi-1]) &lt; 0 THEN
          key := a[lo];  a[lo] := a[i];  a[i] := key;
        ELSE
          key := a[hi-1];  a[hi-1] := a[lo];  a[lo] := a[i];  a[i] := key;
        END;
      END;

      (* partition the array *)
      i := lo+1;  j := hi-2;

      (* find the first hole *)
      WHILE cmp (a[j], key) &gt; 0 DO DEC (j) END;
      tmp := a[j];
      DEC (j);

      LOOP
        IF (i &gt; j) THEN EXIT END;

        WHILE cmp (a[i], key) &lt; 0 DO INC (i) END;
        IF (i &gt; j) THEN EXIT END;
        a[j+1] := a[i];
        INC (i);

        WHILE cmp (a[j], key) &gt; 0 DO DEC (j) END;
        IF (i &gt; j) THEN  IF (j = i-1) THEN  DEC (j)  END;  EXIT  END;
        a[i-1] := a[j];
        DEC (j);
      END;

      (* fill in the last hole *)
      a[j+1] := tmp;
      i := j+2;

      (* then, recursively sort the smaller subfile *)
      IF (i - lo &lt; hi - i)
        THEN  QuickSort (a, lo, i-1, cmp);   lo := i;
        ELSE  QuickSort (a, i, hi, cmp);     hi := i-1;
      END;

    END; (* WHILE (hi-lo &gt; CutOff) *)
  END QuickSort;

PROCEDURE <A NAME="InsertionSort"><procedure>InsertionSort</procedure></A> (VAR a: ARRAY OF Elem_T;  lo, hi: INTEGER;
                         cmp := Elem_Compare) =
  VAR j: INTEGER;  key: Elem_T;
  BEGIN
    FOR i := lo+1 TO hi-1 DO
      key := a[i];
      j := i-1;
      WHILE (j &gt;= lo) AND cmp (key, a[j]) &lt; 0 DO
        a[j+1] := a[j];
        DEC (j);
      END;
      a[j+1] := key;
    END;
  END InsertionSort;
</PRE>------------------------------------------------------- low-level stuff ---

<P><PRE>PROCEDURE <A NAME="Flatten"><procedure>Flatten</procedure></A> (x: IntSeq.T): IntVec =
  VAR n := x.size ();  elts := NEW (IntVec, n);
  BEGIN
    FOR i := 0 TO n-1 DO
      elts[i] := x.get(i);
    END;
    RETURN elts;
  END Flatten;

PROCEDURE <A NAME="Indent"><procedure>Indent</procedure></A> (wx: Wx.T;  indent: INTEGER) =
  BEGIN
    WHILE (indent &gt; 8) DO  Wx.PutText (wx, &quot;        &quot;); DEC (indent, 8);  END;
    WHILE (indent &gt; 0) DO  Wx.PutChar (wx, ' '); DEC (indent);  END;
  END Indent;

PROCEDURE <A NAME="Out"><procedure>Out</procedure></A> (wx: Wx.T;  a, b, c, d, e: TEXT := NIL) =
  BEGIN
    IF (a # NIL) THEN Wx.PutText (wx, a);
     IF (b # NIL) THEN Wx.PutText (wx, b);
      IF (c # NIL) THEN Wx.PutText (wx, c);
       IF (d # NIL) THEN Wx.PutText (wx, d);
        IF (e # NIL) THEN Wx.PutText (wx, e);
    END END END END END
  END Out;

PROCEDURE <A NAME="Abort"><procedure>Abort</procedure></A> () =
  BEGIN
    TCPServer.Abort (server);
    Process.Exit (1);
  END Abort;

PROCEDURE <A NAME="MakePath"><procedure>MakePath</procedure></A> (a, b, c, d: TEXT := NIL): TEXT =
  VAR path := a;
  BEGIN
    IF (b # NIL) THEN path := path &amp; SLASH &amp; b END;
    IF (c # NIL) THEN path := path &amp; SLASH &amp; c END;
    IF (d # NIL) THEN path := path &amp; SLASH &amp; d END;
    RETURN path;
  END MakePath;

VAR posix : BOOLEAN := Text.Equal (SLASH, &quot;/&quot;);

PROCEDURE <A NAME="LibName"><procedure>LibName</procedure></A> (nm: TEXT;  pgm: BOOLEAN): TEXT =
  BEGIN
    IF (nm = NIL) THEN
      RETURN &quot;&lt;no name&gt;&quot;
    ELSIF pgm THEN
      IF posix
        THEN RETURN nm;
        ELSE RETURN nm &amp; &quot;.exe&quot;;
      END;
    ELSE
      IF posix
        THEN RETURN &quot;lib&quot; &amp; nm &amp; &quot;.a&quot;;
        ELSE RETURN nm &amp; &quot;.lib&quot;;
      END;
    END;
  END LibName;
</PRE>---------------------------------------------------------------------------

<P><PRE>BEGIN
  InitDB (db);
  ParseOptions ();
  Refresh (NIL);
  LOOP
    server := TCPServer.Fork (server_socket, n_workers, ProcessRequest,
                              Refresh, refresh_interval * 60.0d0,
                              ErrLog.Note, accept_address, accept_maskBits );
    IF (server = NIL) THEN EXIT END;
    TCPServer.Join (server);
  END;
END Main.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface OS is in:
</A><UL>
<LI><A HREF="../../cm3ide/src/utils/OS.i3.html#0TOP0">cm3ide/src/utils/OS.i3</A>
<LI><A HREF="../../fix_nl/src/OS.i3.html#0TOP0">fix_nl/src/OS.i3</A>
<LI><A HREF="OS.i3.html#0TOP0">m3browser/src/OS.i3</A>
</UL>
<P>
<HR>
<A NAME="x2">interface XFormat is in:
</A><UL>
<LI><A HREF="../../cm3ide/src/markup/XFormat.i3.html#0TOP0">cm3ide/src/markup/XFormat.i3</A>
<LI><A HREF="../../m3markup/src/XFormat.i3.html#0TOP0">m3markup/src/XFormat.i3</A>
</UL>
<P>
<HR>
<A NAME="x3">interface Buf is in:
</A><UL>
<LI><A HREF="../../cm3ide/src/utils/Buf.i3.html#0TOP0">cm3ide/src/utils/Buf.i3</A>
<LI><A HREF="../../libbuf/src/Buf.i3.html#0TOP0">libbuf/src/Buf.i3</A>
</UL>
<P>
<HR>
<A NAME="x4">interface ID is in:
</A><UL>
<LI><A HREF="../../cm3ide/src/utils/ID.i3.html#0TOP0">cm3ide/src/utils/ID.i3</A>
<LI><A HREF="../../m3markup/src/ID.i3.html#0TOP0">m3markup/src/ID.i3</A>
</UL>
<P>
<HR>
<A NAME="x5">interface Wx is in:
</A><UL>
<LI><A HREF="../../cm3ide/src/utils/Wx.i3.html#0TOP0">cm3ide/src/utils/Wx.i3</A>
<LI><A HREF="../../libbuf/src/Wx.i3.html#0TOP0">libbuf/src/Wx.i3</A>
</UL>
<P>
<HR>
<A NAME="x6">interface MarkUp is in:
</A><UL>
<LI><A HREF="../../cm3ide/src/markup/MarkUp.i3.html#0TOP0">cm3ide/src/markup/MarkUp.i3</A>
<LI><A HREF="../../m3markup/src/MarkUp.i3.html#0TOP0">m3markup/src/MarkUp.i3</A>
<LI><A HREF="../../m3tohtml/src/MarkUp.i3.html#0TOP0">m3tohtml/src/MarkUp.i3</A>
</UL>
<P>
<HR>
<A NAME="x7">interface CMarkUp is in:
</A><UL>
<LI><A HREF="../../cm3ide/src/markup/CMarkUp.i3.html#0TOP0">cm3ide/src/markup/CMarkUp.i3</A>
<LI><A HREF="../../m3markup/src/CMarkUp.i3.html#0TOP0">m3markup/src/CMarkUp.i3</A>
</UL>
<P>
<HR>
<A NAME="x8">interface TCPServer is in:
</A><UL>
<LI><A HREF="../../cm3ide/src/server/TCPServer.i3.html#0TOP0">cm3ide/src/server/TCPServer.i3</A>
<LI><A HREF="TCPServer.i3.html#0TOP0">m3browser/src/TCPServer.i3</A>
</UL>
<P>
<HR>
<A NAME="x9">interface ErrLog is in:
</A><UL>
<LI><A HREF="../../cm3ide/src/utils/ErrLog.i3.html#0TOP0">cm3ide/src/utils/ErrLog.i3</A>
<LI><A HREF="../../m3markup/src/ErrLog.i3.html#0TOP0">m3markup/src/ErrLog.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
