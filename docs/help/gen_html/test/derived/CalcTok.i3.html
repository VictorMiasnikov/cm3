<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: test/derived/CalcTok.i3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>test/derived/CalcTok.i3</H2></A><HR>
<inInterface>
<PRE>INTERFACE <interface><A HREF="CalcTok.m3.html">CalcTok</A></interface>;
</PRE><BLOCKQUOTE><EM> Generated by ktok </EM></BLOCKQUOTE><PRE>
</PRE> original token definition 
<PRE>IMPORT <A HREF="../../libm3/src/rw/Rd.i3.html">Rd</A>;
TYPE
  <A HREF="CalcTok.m3.html#ParseType">ParseType</A> &lt;: ParseTypePublic;
  Token = ParseType BRANDED &quot;CalcTok.Token&quot; OBJECT END;

  Lexer = OBJECT METHODS
    get(): Token RAISES {Rd.EndOfFile};
    (* get next token, or raise Rd.EndOfFile if token cannot be formed
       from remaining input *)

    unget();
    (* will be called at most once after get(), and only when lookahead is
       required after last token when parsing without exhausting input *)

    error(message: TEXT);
    (* might print file name, line number, and message, and exit *)
  END;

  RdLexer = Lexer OBJECT METHODS
    setRd(rd: Rd.T): RdLexer;
    (* Prepare to read tokens starting at cur(rd).
       After every token, rd is repositionned after that token. *)

    getRd(): Rd.T;
    (* get reader  *)

    fromText(t: TEXT): RdLexer;
    (* Calls setRd with a textReader. *)

    rewind();
    (* equivalent to Rd.Seek(rd, 0) followed by setRd *)

    getText(): TEXT;
    (* get TEXT of last token *)

    purge(): INTEGER;
    (* Allow any internally allocated ParseTypes to be garbage collected,
       even if the lexer itself remains in scope. Return number of ParseType
       objects allocated but not discarded (not the number of purged objects).
       Can be called at any time by the thread calling get. *)
  END;

  (* token types *)
  ConstTokenCode = [1..257]; (* &lt; 256 means char code *)
  ConstToken = Token BRANDED &quot;CalcTok.ConstToken&quot; OBJECT
    val: ConstTokenCode;
  END; (* neither extend this object nor reassign val *)
  LETTER = Token BRANDED &quot;CalcTok.LETTER&quot; OBJECT END;
  DIGIT = Token BRANDED &quot;CalcTok.DIGIT&quot; OBJECT END;

  (* ParseType allocation *)
  <A HREF="CalcTok.m3.html#Allocator">Allocator</A> &lt;: ROOT;
  ParseTypePublic = OBJECT METHODS
    discard();
    detach(): ParseType;
  END;

CONST
  LegalConstTokenCodes = SET OF ConstTokenCode{
    10, 40, 41, 42, 43, 45, 47, 256, 257};
    ASSIGN = 256;
    ERROR = 257;

PROCEDURE <A HREF="CalcTok.m3.html#NewPT">NewPT</A>(VAR a: Allocator; m3type: INTEGER): ParseType;
</PRE><BLOCKQUOTE><EM> IF a = NIL, then let a = new allocator for m3type.
   regardless, return a new ParseType specifically of type m3type </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="CalcTok.m3.html#Purge">Purge</A>(VAR a: Allocator): INTEGER;
</PRE><BLOCKQUOTE><EM> set a=NIL. return number of objects allocated using
   New(a, ...) which were not discarded using discard(). </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="CalcTok.m3.html#NewConstToken">NewConstToken</A>(val: ConstTokenCode): ConstToken;
</PRE><BLOCKQUOTE><EM> return a constToken with val=val (well it might not be so new) </EM></BLOCKQUOTE><PRE>
</PRE> discard() will fail for a constToken 

<P><PRE>PROCEDURE <A HREF="CalcTok.m3.html#Test">Test</A>(lex: Lexer);
</PRE><BLOCKQUOTE><EM> get tokens and print their names to stdout until Rd.EndOfFile </EM></BLOCKQUOTE><PRE>

END CalcTok.
</PRE>
</inInterface>
<PRE>























</PRE>
</BODY>
</HTML>
