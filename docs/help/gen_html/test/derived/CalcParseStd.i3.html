<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: test/derived/CalcParseStd.i3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>test/derived/CalcParseStd.i3</H2></A><HR>
<inInterface>
<PRE>INTERFACE <interface><A HREF="CalcParseStd.m3.html">CalcParseStd</A></interface>;
</PRE><BLOCKQUOTE><EM> generated by kext </EM></BLOCKQUOTE><PRE>
</PRE> extended parser definition 
<PRE>IMPORT <A HREF="CalcTokStd.i3.html">CalcTokStd</A>;
IMPORT <A HREF="CalcParse.i3.html">CalcParse</A>;
TYPE
  expr = CalcParse.expr BRANDED &quot;CalcParseStd.expr&quot; OBJECT
    val: INTEGER
  END;
  number = CalcParse.number BRANDED &quot;CalcParseStd.number&quot; OBJECT
    val: INTEGER
  END;
  list = CalcParse.list;
  DIGIT = CalcTokStd.DIGIT;
  stat = CalcParse.stat;
  LETTER = CalcTokStd.LETTER;

  <A HREF="CalcParseStd.m3.html#T">T</A> &lt;: Public;
  Public = CalcParse.T OBJECT
  END;

  (* And now, for a hack to allow compatible methods *)
  (* ... without importing the original parser *)
  Original_Parser = CalcParse.Original_Parser;
  Original_expr = CalcParse.Original_expr;
  Original_list = CalcParse.Original_list;
  Original_number = CalcParse.Original_number;
  Original_stat = CalcParse.Original_stat;
  (* ... and without importing the original token *)
  Original_LETTER = CalcParse.Original_LETTER;
  Original_DIGIT = CalcParse.Original_DIGIT;

  (* Make this interface as good as any token interface *)
  Token = CalcTokStd.Token;
  ConstToken = CalcTokStd.ConstToken;
  ParseType = CalcTokStd.ParseType;
  Allocator = CalcTokStd.Allocator;
  Lexer = CalcTokStd.Lexer;
  RdLexer = CalcTokStd.RdLexer;
CONST
  NewPT = CalcTokStd.NewPT;
  Purge = CalcTokStd.Purge;
  NewConstToken = CalcTokStd.NewConstToken;
END CalcParseStd.
</PRE>
</inInterface>
<PRE>























</PRE>
</BODY>
</HTML>
