<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: test/derived/CalcParseStd.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>test/derived/CalcParseStd.m3</H2></A><HR>
<inModule>
<PRE>MODULE <module><implements><A HREF="CalcParseStd.i3.html">CalcParseStd</A></implements></module>;
</PRE><BLOCKQUOTE><EM> generated by kext </EM></BLOCKQUOTE><PRE>
IMPORT <A HREF="CalcParse.i3.html">CalcParse</A>;
IMPORT <A HREF="../../libm3/src/fmtlex/Fmt.i3.html">Fmt</A>;
IMPORT <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>;
FROM <A HREF="../../libm3/src/rw/Stdio.i3.html">Stdio</A> IMPORT stdout;
&lt;* FATAL Wr.Failure, Thread.Alerted *&gt;

REVEAL
  <A NAME="T">T</A> = Public BRANDED &quot;CalcParseStd&quot; OBJECT
    allocate_expr: Allocator := NIL;
    allocate_list: Allocator := NIL;
    allocate_number: Allocator := NIL;
    allocate_stat: Allocator := NIL;
regs: ARRAY ['a'..'z'] OF INTEGER;
base: INTEGER;
  OVERRIDES
    purge := Proc_Purge;
    add_expr := Proc_add_expr;
    digit_number := Proc_digit_number;
    num_expr := Proc_num_expr;
    div_expr := Proc_div_expr;
    sub_expr := Proc_sub_expr;
    eval_stat := Proc_eval_stat;
    uminus_expr := Proc_uminus_expr;
    mul_expr := Proc_mul_expr;
    paren_expr := Proc_paren_expr;
    ident_expr := Proc_ident_expr;
    assign_stat := Proc_assign_stat;
    cons_number := Proc_cons_number;
  END;

PROCEDURE <A NAME="Proc_Purge"><procedure>Proc_Purge</procedure></A>(self: T): INTEGER =
  BEGIN
    RETURN CalcParse.T.purge(self)
      + Purge(self.allocate_expr)
      + Purge(self.allocate_list)
      + Purge(self.allocate_number)
      + Purge(self.allocate_stat);
  END Proc_Purge;
</PRE> rule procedures 
<PRE>PROCEDURE <A NAME="Proc_eval_stat"><procedure>Proc_eval_stat</procedure></A>(self: T;
 VAR p0: Original_stat; p1: Original_expr) =
  VAR
    result: stat;
    n1 := NARROW(p1, expr);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_stat, TYPECODE(stat));
    END;
    result := NARROW(p0, stat);(*%TYPEINIT%stat%*)
    CalcParse.T.eval_stat(self, p0, p1);
    result := NARROW(p0, stat);
    BEGIN (* user code *)
      Wr.PutText(stdout, Fmt.Int(n1.val) &amp; &quot;\n&quot;);Wr.Flush(stdout)
    END;
    p0 := result;
  END Proc_eval_stat;

PROCEDURE <A NAME="Proc_assign_stat"><procedure>Proc_assign_stat</procedure></A>(self: T;
 VAR p0: Original_stat; p1: Original_LETTER; p2: Original_expr) =
  VAR
    result: stat;
    n1 := NARROW(p1, LETTER);
    n2 := NARROW(p2, expr);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_stat, TYPECODE(stat));
    END;
    result := NARROW(p0, stat);(*%TYPEINIT%stat%*)
    CalcParse.T.assign_stat(self, p0, p1, p2);
    result := NARROW(p0, stat);
    BEGIN (* user code *)
      self.regs[n1.val] := n2.val
    END;
    p0 := result;
  END Proc_assign_stat;

PROCEDURE <A NAME="Proc_paren_expr"><procedure>Proc_paren_expr</procedure></A>(self: T;
 VAR p0: Original_expr; p1: Original_expr) =
  VAR
    result: expr;
    n1 := NARROW(p1, expr);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_expr, TYPECODE(expr));
    END;
    result := NARROW(p0, expr);
    CalcParse.T.paren_expr(self, p0, p1);
    result := NARROW(p0, expr);
    BEGIN (* user code *)
      result.discard(); result := n1.detach()
    END;
    p0 := result;
  END Proc_paren_expr;

PROCEDURE <A NAME="Proc_add_expr"><procedure>Proc_add_expr</procedure></A>(self: T;
 VAR p0: Original_expr; p1: Original_expr; p2: Original_expr) =
  VAR
    result: expr;
    n1 := NARROW(p1, expr);
    n2 := NARROW(p2, expr);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_expr, TYPECODE(expr));
    END;
    result := NARROW(p0, expr);
    CalcParse.T.add_expr(self, p0, p1, p2);
    result := NARROW(p0, expr);
    BEGIN (* user code *)
      result.val := n1.val + n2.val
    END;
    p0 := result;
  END Proc_add_expr;

PROCEDURE <A NAME="Proc_sub_expr"><procedure>Proc_sub_expr</procedure></A>(self: T;
 VAR p0: Original_expr; p1: Original_expr; p2: Original_expr) =
  VAR
    result: expr;
    n1 := NARROW(p1, expr);
    n2 := NARROW(p2, expr);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_expr, TYPECODE(expr));
    END;
    result := NARROW(p0, expr);
    CalcParse.T.sub_expr(self, p0, p1, p2);
    result := NARROW(p0, expr);
    BEGIN (* user code *)
      result.val := n1.val - n2.val
    END;
    p0 := result;
  END Proc_sub_expr;

PROCEDURE <A NAME="Proc_mul_expr"><procedure>Proc_mul_expr</procedure></A>(self: T;
 VAR p0: Original_expr; p1: Original_expr; p2: Original_expr) =
  VAR
    result: expr;
    n1 := NARROW(p1, expr);
    n2 := NARROW(p2, expr);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_expr, TYPECODE(expr));
    END;
    result := NARROW(p0, expr);
    CalcParse.T.mul_expr(self, p0, p1, p2);
    result := NARROW(p0, expr);
    BEGIN (* user code *)
      result.val := n1.val * n2.val
    END;
    p0 := result;
  END Proc_mul_expr;

PROCEDURE <A NAME="Proc_div_expr"><procedure>Proc_div_expr</procedure></A>(self: T;
 VAR p0: Original_expr; p1: Original_expr; p2: Original_expr) =
  VAR
    result: expr;
    n1 := NARROW(p1, expr);
    n2 := NARROW(p2, expr);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_expr, TYPECODE(expr));
    END;
    result := NARROW(p0, expr);
    CalcParse.T.div_expr(self, p0, p1, p2);
    result := NARROW(p0, expr);
    BEGIN (* user code *)
      result.val := n1.val DIV n2.val
    END;
    p0 := result;
  END Proc_div_expr;

PROCEDURE <A NAME="Proc_uminus_expr"><procedure>Proc_uminus_expr</procedure></A>(self: T;
 VAR p0: Original_expr; p1: Original_expr) =
  VAR
    result: expr;
    n1 := NARROW(p1, expr);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_expr, TYPECODE(expr));
    END;
    result := NARROW(p0, expr);
    CalcParse.T.uminus_expr(self, p0, p1);
    result := NARROW(p0, expr);
    BEGIN (* user code *)
      result.val := -n1.val
    END;
    p0 := result;
  END Proc_uminus_expr;

PROCEDURE <A NAME="Proc_ident_expr"><procedure>Proc_ident_expr</procedure></A>(self: T;
 VAR p0: Original_expr; p1: Original_LETTER) =
  VAR
    result: expr;
    n1 := NARROW(p1, LETTER);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_expr, TYPECODE(expr));
    END;
    result := NARROW(p0, expr);
    CalcParse.T.ident_expr(self, p0, p1);
    result := NARROW(p0, expr);
    BEGIN (* user code *)
      result.val := self.regs[n1.val]
    END;
    p0 := result;
  END Proc_ident_expr;

PROCEDURE <A NAME="Proc_num_expr"><procedure>Proc_num_expr</procedure></A>(self: T;
 VAR p0: Original_expr; p1: Original_number) =
  VAR
    result: expr;
    n1 := NARROW(p1, number);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_expr, TYPECODE(expr));
    END;
    result := NARROW(p0, expr);
    CalcParse.T.num_expr(self, p0, p1);
    result := NARROW(p0, expr);
    BEGIN (* user code *)
      result.val := n1.val
    END;
    p0 := result;
  END Proc_num_expr;

PROCEDURE <A NAME="Proc_digit_number"><procedure>Proc_digit_number</procedure></A>(self: T;
 VAR p0: Original_number; p1: Original_DIGIT) =
  VAR
    result: number;
    n1 := NARROW(p1, DIGIT);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_number, TYPECODE(number));
    END;
    result := NARROW(p0, number);
    CalcParse.T.digit_number(self, p0, p1);
    result := NARROW(p0, number);
    BEGIN (* user code *)
      result.val := n1.val;IF n1.val = 0 THEN self.base:=8 ELSE self.base:=10 END
    END;
    p0 := result;
  END Proc_digit_number;

PROCEDURE <A NAME="Proc_cons_number"><procedure>Proc_cons_number</procedure></A>(self: T;
 VAR p0: Original_number; p1: Original_number; p2: Original_DIGIT) =
  VAR
    result: number;
    n1 := NARROW(p1, number);
    n2 := NARROW(p2, DIGIT);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_number, TYPECODE(number));
    END;
    result := NARROW(p0, number);
    CalcParse.T.cons_number(self, p0, p1, p2);
    result := NARROW(p0, number);
    BEGIN (* user code *)
      result.val := self.base * n1.val + n2.val
    END;
    p0 := result;
  END Proc_cons_number;

BEGIN
END CalcParseStd.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
