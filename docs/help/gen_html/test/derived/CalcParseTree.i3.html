<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: test/derived/CalcParseTree.i3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>test/derived/CalcParseTree.i3</H2></A><HR>
<inInterface>
<PRE>INTERFACE <interface><A HREF="CalcParseTree.m3.html">CalcParseTree</A></interface>;
</PRE><BLOCKQUOTE><EM> generated by kext </EM></BLOCKQUOTE><PRE>
</PRE> extended parser definition 
<PRE>IMPORT <A HREF="CalcTokStd.i3.html">CalcTokStd</A>;
IMPORT <A HREF="CalcParseStd.i3.html">CalcParseStd</A>;
TYPE
  expr = CalcParseStd.expr BRANDED &quot;CalcParseTree.expr&quot; OBJECT
    e1, e2: expr; kind: CHAR := 'N'
  END;
  list = CalcParseStd.list;
  number = CalcParseStd.number;
  DIGIT = CalcTokStd.DIGIT;
  stat = CalcParseStd.stat;
  LETTER = CalcTokStd.LETTER;

  <A HREF="CalcParseTree.m3.html#T">T</A> &lt;: Public;
  Public = CalcParseStd.T OBJECT
  END;

  (* And now, for a hack to allow compatible methods *)
  (* ... without importing the original parser *)
  Original_Parser = CalcParseStd.Original_Parser;
  Original_expr = CalcParseStd.Original_expr;
  Original_list = CalcParseStd.Original_list;
  Original_number = CalcParseStd.Original_number;
  Original_stat = CalcParseStd.Original_stat;
  (* ... and without importing the original token *)
  Original_LETTER = CalcParseStd.Original_LETTER;
  Original_DIGIT = CalcParseStd.Original_DIGIT;

  (* Make this interface as good as any token interface *)
  Token = CalcTokStd.Token;
  ConstToken = CalcTokStd.ConstToken;
  ParseType = CalcTokStd.ParseType;
  Allocator = CalcTokStd.Allocator;
  Lexer = CalcTokStd.Lexer;
  RdLexer = CalcTokStd.RdLexer;
CONST
  NewPT = CalcTokStd.NewPT;
  Purge = CalcTokStd.Purge;
  NewConstToken = CalcTokStd.NewConstToken;
END CalcParseTree.
</PRE>
</inInterface>
<PRE>























</PRE>
</BODY>
</HTML>
