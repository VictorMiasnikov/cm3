<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: test/derived/CalcParseTree.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>test/derived/CalcParseTree.m3</H2></A><HR>
<inModule>
<PRE>MODULE <module><implements><A HREF="CalcParseTree.i3.html">CalcParseTree</A></implements></module>;
</PRE><BLOCKQUOTE><EM> generated by kext </EM></BLOCKQUOTE><PRE>
IMPORT <A HREF="CalcParseStd.i3.html">CalcParseStd</A>;
IMPORT <A HREF="../../libm3/src/fmtlex/Fmt.i3.html">Fmt</A>;
IMPORT <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>;
FROM <A HREF="../../libm3/src/rw/Stdio.i3.html">Stdio</A> IMPORT stdout;
&lt;* FATAL Wr.Failure, Thread.Alerted *&gt;

PROCEDURE <A NAME="Format"><procedure>Format</procedure></A>(e: expr): TEXT =
  BEGIN
    CASE e.kind OF
    | 'U' =&gt; RETURN &quot;(uminus &quot; &amp; Format(e.e1) &amp; &quot;)&quot;;
    | '+','-','*','/' =&gt;
      RETURN &quot;(&quot; &amp; Fmt.Char(e.kind) &amp; &quot; &quot; &amp;
             Format(e.e1) &amp; &quot; &quot; &amp; Format(e.e2) &amp; &quot;)&quot;;
    | 'N' =&gt; RETURN Fmt.Int(e.val);
    ELSE
      RETURN Fmt.Char(e.kind);
    END;
  END Format;

PROCEDURE <A NAME="Explain"><procedure>Explain</procedure></A>(e: expr) =
  BEGIN
    Wr.PutText(stdout, &quot; = &quot; &amp; Format(e) &amp; &quot;\n\n&quot;);
    Wr.Flush(stdout);
  END Explain;

REVEAL
  <A NAME="T">T</A> = Public BRANDED &quot;CalcParseTree&quot; OBJECT
    allocate_expr: Allocator := NIL;
    allocate_list: Allocator := NIL;
    allocate_number: Allocator := NIL;
    allocate_stat: Allocator := NIL;
  OVERRIDES
    purge := Proc_Purge;
    add_expr := Proc_add_expr;
    num_expr := Proc_num_expr;
    div_expr := Proc_div_expr;
    sub_expr := Proc_sub_expr;
    eval_stat := Proc_eval_stat;
    uminus_expr := Proc_uminus_expr;
    mul_expr := Proc_mul_expr;
    paren_expr := Proc_paren_expr;
    ident_expr := Proc_ident_expr;
    assign_stat := Proc_assign_stat;
  END;

PROCEDURE <A NAME="Proc_Purge"><procedure>Proc_Purge</procedure></A>(self: T): INTEGER =
  BEGIN
    RETURN CalcParseStd.T.purge(self)
      + Purge(self.allocate_expr)
      + Purge(self.allocate_list)
      + Purge(self.allocate_number)
      + Purge(self.allocate_stat);
  END Proc_Purge;
</PRE> rule procedures 
<PRE>PROCEDURE <A NAME="Proc_eval_stat"><procedure>Proc_eval_stat</procedure></A>(self: T;
 VAR p0: Original_stat; p1: Original_expr) =
  VAR
    result: stat;
    n1 := NARROW(p1, expr);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_stat, TYPECODE(stat));
    END;
    result := NARROW(p0, stat);(*%TYPEINIT%stat%*)
    CalcParseStd.T.eval_stat(self, p0, p1);
    result := NARROW(p0, stat);
    BEGIN (* user code *)
      Explain(n1.detach())
    END;
    p0 := result;
  END Proc_eval_stat;

PROCEDURE <A NAME="Proc_assign_stat"><procedure>Proc_assign_stat</procedure></A>(self: T;
 VAR p0: Original_stat; p1: Original_LETTER; p2: Original_expr) =
  VAR
    result: stat;
    n1 := NARROW(p1, LETTER);
    n2 := NARROW(p2, expr);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_stat, TYPECODE(stat));
    END;
    result := NARROW(p0, stat);(*%TYPEINIT%stat%*)
    CalcParseStd.T.assign_stat(self, p0, p1, p2);
    result := NARROW(p0, stat);
    BEGIN (* user code *)
      Wr.PutText(stdout, Fmt.Char(n1.val) &amp; &quot; := &quot; &amp;
                            Fmt.Int(n2.val) &amp; &quot;\n&quot;);Explain(n2.detach())
    END;
    p0 := result;
  END Proc_assign_stat;

PROCEDURE <A NAME="Proc_add_expr"><procedure>Proc_add_expr</procedure></A>(self: T;
 VAR p0: Original_expr; p1: Original_expr; p2: Original_expr) =
  VAR
    result: expr;
    n1 := NARROW(p1, expr);
    n2 := NARROW(p2, expr);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_expr, TYPECODE(expr));
    END;
    result := NARROW(p0, expr);
    result.kind := 'N';
    CalcParseStd.T.add_expr(self, p0, p1, p2);
    result := NARROW(p0, expr);
    BEGIN (* user code *)
      result.e1 := n1.detach(); result.e2 := n2.detach(); result.kind := '+'
    END;
    p0 := result;
  END Proc_add_expr;

PROCEDURE <A NAME="Proc_sub_expr"><procedure>Proc_sub_expr</procedure></A>(self: T;
 VAR p0: Original_expr; p1: Original_expr; p2: Original_expr) =
  VAR
    result: expr;
    n1 := NARROW(p1, expr);
    n2 := NARROW(p2, expr);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_expr, TYPECODE(expr));
    END;
    result := NARROW(p0, expr);
    result.kind := 'N';
    CalcParseStd.T.sub_expr(self, p0, p1, p2);
    result := NARROW(p0, expr);
    BEGIN (* user code *)
      result.e1 := n1.detach(); result.e2 := n2.detach(); result.kind := '-'
    END;
    p0 := result;
  END Proc_sub_expr;

PROCEDURE <A NAME="Proc_mul_expr"><procedure>Proc_mul_expr</procedure></A>(self: T;
 VAR p0: Original_expr; p1: Original_expr; p2: Original_expr) =
  VAR
    result: expr;
    n1 := NARROW(p1, expr);
    n2 := NARROW(p2, expr);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_expr, TYPECODE(expr));
    END;
    result := NARROW(p0, expr);
    result.kind := 'N';
    CalcParseStd.T.mul_expr(self, p0, p1, p2);
    result := NARROW(p0, expr);
    BEGIN (* user code *)
      result.e1 := n1.detach(); result.e2 := n2.detach(); result.kind := '*'
    END;
    p0 := result;
  END Proc_mul_expr;

PROCEDURE <A NAME="Proc_div_expr"><procedure>Proc_div_expr</procedure></A>(self: T;
 VAR p0: Original_expr; p1: Original_expr; p2: Original_expr) =
  VAR
    result: expr;
    n1 := NARROW(p1, expr);
    n2 := NARROW(p2, expr);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_expr, TYPECODE(expr));
    END;
    result := NARROW(p0, expr);
    result.kind := 'N';
    CalcParseStd.T.div_expr(self, p0, p1, p2);
    result := NARROW(p0, expr);
    BEGIN (* user code *)
      result.e1 := n1.detach(); result.e2 := n2.detach(); result.kind := '/'
    END;
    p0 := result;
  END Proc_div_expr;

PROCEDURE <A NAME="Proc_uminus_expr"><procedure>Proc_uminus_expr</procedure></A>(self: T;
 VAR p0: Original_expr; p1: Original_expr) =
  VAR
    result: expr;
    n1 := NARROW(p1, expr);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_expr, TYPECODE(expr));
    END;
    result := NARROW(p0, expr);
    result.kind := 'N';
    CalcParseStd.T.uminus_expr(self, p0, p1);
    result := NARROW(p0, expr);
    BEGIN (* user code *)
      result.e1 := n1.detach(); result.kind := 'U'
    END;
    p0 := result;
  END Proc_uminus_expr;

PROCEDURE <A NAME="Proc_ident_expr"><procedure>Proc_ident_expr</procedure></A>(self: T;
 VAR p0: Original_expr; p1: Original_LETTER) =
  VAR
    result: expr;
    n1 := NARROW(p1, LETTER);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_expr, TYPECODE(expr));
    END;
    result := NARROW(p0, expr);
    result.kind := 'N';
    CalcParseStd.T.ident_expr(self, p0, p1);
    result := NARROW(p0, expr);
    BEGIN (* user code *)
      result.kind := n1.val
    END;
    p0 := result;
  END Proc_ident_expr;

PROCEDURE <A NAME="Proc_num_expr"><procedure>Proc_num_expr</procedure></A>(self: T;
 VAR p0: Original_expr; p1: Original_number) =
  VAR
    result: expr;
    n1 := NARROW(p1, number);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_expr, TYPECODE(expr));
    END;
    result := NARROW(p0, expr);
    result.kind := 'N';
    CalcParseStd.T.num_expr(self, p0, p1);
    result := NARROW(p0, expr);
    BEGIN (* user code *)
      EVAL n1;(* just allocating the new type *)
    END;
    p0 := result;
  END Proc_num_expr;

PROCEDURE <A NAME="Proc_paren_expr"><procedure>Proc_paren_expr</procedure></A>(self: T;
 VAR p0: Original_expr; p1: Original_expr) =
  VAR
    result: expr;
    n1 := NARROW(p1, expr);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_expr, TYPECODE(expr));
    END;
    result := NARROW(p0, expr);
    result.kind := 'N';
    CalcParseStd.T.paren_expr(self, p0, p1);
    result := NARROW(p0, expr);
    BEGIN (* user code *)
      EVAL n1;(* just allocating the new type *)
    END;
    p0 := result;
  END Proc_paren_expr;

BEGIN
END CalcParseTree.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
