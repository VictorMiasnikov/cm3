<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: klex/derived/lexformBundle.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>klex/derived/lexformBundle.m3</H2></A><HR>
<inModule>
<PRE>MODULE <module><implements><A HREF="lexformBundle.i3.html">lexformBundle</A></implements></module>;
</PRE><BLOCKQUOTE><EM> Generated by m3bundle; see its manpage. </EM></BLOCKQUOTE><PRE>

IMPORT <A HREF="../../libm3/src/bundleintf/Bundle.i3.html">Bundle</A>, <A HREF="../../libm3/src/bundleintf/BundleRep.i3.html">BundleRep</A>, <A HREF="../../m3core/src/text/Text.i3.html">Text</A>;
IMPORT <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="../../libm3/src/rw/TextWr.i3.html">TextWr</A>;

TYPE T = Bundle.T OBJECT OVERRIDES
           get      := LookUp;
           getNames := GetNames;
         END;

TYPE Texts = REF ARRAY OF TEXT;

VAR
  bundle: T     := NIL;
  names : Texts := NIL;

PROCEDURE <A NAME="Get"><procedure>Get</procedure></A>(): Bundle.T =
  BEGIN
    IF (bundle = NIL) THEN bundle := NEW (T) END;
    RETURN bundle;
  END Get;

PROCEDURE <A NAME="GetNames"><procedure>GetNames</procedure></A> (&lt;*UNUSED*&gt; self: T): Texts =
  BEGIN
    IF names = NIL THEN
      names := NEW (Texts, NUMBER (Names));
      names^ := Names;
    END;
    RETURN names;
  END GetNames;

PROCEDURE <A NAME="LookUp"><procedure>LookUp</procedure></A> (&lt;*UNUSED*&gt; self: T;  element: TEXT): TEXT =
  BEGIN
    FOR i := 0 TO LAST (Names)-1 DO
      IF Text.Equal (Names[i], element) THEN
        IF Elements[i] = NIL THEN Elements[i] := GetElt (i) END;
        RETURN Elements[i];
      END;
    END;
    RETURN NIL;
  END LookUp;

CONST Names = ARRAY [0..3] OF TEXT {
  &quot;lexform.i3&quot;,
  &quot;lexform.proc.m3&quot;,
  &quot;lexform.m3&quot;,
  NIL
};

VAR Elements := ARRAY [0..3] OF TEXT {
  E0,
  E1,
  NIL (* E2 .. E2_1 *),
  NIL
};

PROCEDURE <A NAME="GetElt"><procedure>GetElt</procedure></A> (n: INTEGER): TEXT =
  &lt;*FATAL Thread.Alerted, Wr.Failure *&gt;
  VAR wr := TextWr.New ();
  BEGIN
    CASE n OF
    | 2 =&gt;
        Wr.PutText (wr, E2);
        Wr.PutText (wr, E2_0);
        Wr.PutText (wr, E2_1);
    ELSE (*skip*)
    END;
    RETURN TextWr.ToText (wr);
  END GetElt;

CONST E0 =
   &quot;INTERFACE %lex;\n%gen\n(* original lexer definition *)\nIMPORT %tok;\nF&quot;
 &amp; &quot;ROM %tok IMPORT Token;\nTYPE\n  T &lt;: Public;\n  Public = %tok.RdLexer O&quot;
 &amp; &quot;BJECT\n  METHODS\n    (* return Token for a regexp type *)\n%methods\\\n&quot;
 &amp; &quot;  END;\nEND %lex.\n&quot;;

CONST E1 =
   &quot;PROCEDURE %name(self: T): Token = BEGIN\n %default;END %name;\n\n&quot;;

CONST E2 =
   &quot;MODULE %lex;\n%gen\nIMPORT %tok;\nIMPORT TextRd;\nIMPORT Rd, Thread;\nI&quot;
 &amp; &quot;MPORT SeekRd;\nFROM %tok IMPORT Token;\n&lt;* FATAL Rd.Failure, Thread.Ale&quot;
 &amp; &quot;rted *&gt;\n\nREVEAL\n  T = Public BRANDED \&quot;%lex\&quot; OBJECT\n    textCache:&quot;
 &amp; &quot; TEXT;\n    charCache: CHAR;\n    posBeforeToken: INTEGER;\n    rd: Rd.&quot;
 &amp; &quot;T;\n%alloc\\\n  OVERRIDES\n    setRd := SetRd;\n    get := Get;\n    un&quot;
 &amp; &quot;get := Unget;\n    error := Error;\n    rewind := Rewind;\n    fromText&quot;
 &amp; &quot; := FromText;\n    getRd := GetRd;\n    getText := GetText;\n    purge &quot;
 &amp; &quot;:= Purge;\n%ovr\\\n  END;\n\nTYPE\n  Byte = BITS 8 FOR [0..255];\n  Sta&quot;
 &amp; &quot;teRef = BITS %lastStateRefBits FOR [0..%lastStateRefVal];\n  TransRef =&quot;
 &amp; &quot; BITS %lastTransRefBits FOR [0..%lastTransRefVal];\n  OutCode = BITS %l&quot;
 &amp; &quot;astOutBits FOR [0..%lastOutVal];\n\n  S = RECORD\n    keyBegin, keyEnd:&quot;
 &amp; &quot; Byte;\n    target: StateRef;\n    next: TransRef;\n    output: OutCode&quot;
 &amp; &quot;;\n  END;\n  X = RECORD\n    keyBegin, keyEnd: Byte;\n    target: State&quot;
 &amp; &quot;Ref;\n    next: TransRef;\n  END;\n\nCONST\n  First = ARRAY CHAR OF [0.&quot;
 &amp; &quot;.%lastStateRefVal] {\n%First};\n\n  States = ARRAY [1..%lastStateRefVal&quot;
 &amp; &quot;] OF S {\n%States};\n\n  Trans = ARRAY [1..%lastTransRefVal] OF X {\n%T&quot;
 &amp; &quot;rans};\n\nPROCEDURE SetRd(self: T; rd: Rd.T): %tok.RdLexer =\n  BEGIN\n&quot;
 &amp; &quot;    self.textCache := \&quot;\&quot;;\n    self.charCache := \'\\000\';\n    self&quot;
 &amp; &quot;.posBeforeToken := -1;\n    self.rd := rd;\n    RETURN self;\n  END Set&quot;
 &amp; &quot;Rd; \n\nPROCEDURE NextCode(self: T): OutCode RAISES {Rd.EndOfFile} =\n &quot;
 &amp; &quot; VAR\n    rd := self.rd;\n    lastAcceptingOutput: INTEGER := 0;\n    l&quot;
 &amp; &quot;astAcceptingPos: INTEGER := Rd.Index(rd);\n    firstChar := Rd.GetChar(&quot;
 &amp; &quot;rd);\n    curState := First[firstChar];\n    curTrans: INTEGER;\n    c:&quot;
 &amp; &quot; Byte;\n  BEGIN\n    self.charCache := firstChar;\n    self.posBeforeTo&quot;
 &amp; &quot;ken := lastAcceptingPos;\n    TRY\n      WHILE curState # 0 DO\n       &quot;
 &amp; &quot; WITH state = States[curState] DO\n          IF state.output # 0 THEN\n&quot;
 &amp; &quot;            lastAcceptingOutput := state.output;\n            lastAccep&quot;
 &amp; &quot;tingPos := Rd.Index(rd);\n          END;\n          IF state.keyBegin =&quot;
 &amp; &quot; 1 AND state.keyEnd = 255 THEN\n            curState := state.target;\n&quot;
 &amp; &quot;          ELSE\n            c := ORD(R&quot;;

CONST E2_0 =
   &quot;d.GetChar(rd));\n            IF c &gt;= state.keyBegin AND c &lt;= state.keyE&quot;
 &amp; &quot;nd THEN\n              curState := state.target;\n            ELSE\n   &quot;
 &amp; &quot;           curTrans := state.next;\n              WHILE curTrans # 0 DO&quot;
 &amp; &quot;\n                WITH trans = Trans[curTrans] DO\n                  IF&quot;
 &amp; &quot; c &gt;= trans.keyBegin AND c &lt;= trans.keyEnd THEN\n                    cu&quot;
 &amp; &quot;rState := trans.target;\n                    curTrans := 0;\n          &quot;
 &amp; &quot;        ELSE\n                    curTrans := trans.next;\n            &quot;
 &amp; &quot;      END;\n                END;\n              END;\n            END;\n&quot;
 &amp; &quot;          END;\n        END;\n      END;\n    EXCEPT\n    | Rd.EndOfFil&quot;
 &amp; &quot;e =&gt;\n      IF lastAcceptingOutput = 0 THEN\n        Rd.Seek(rd, lastAc&quot;
 &amp; &quot;ceptingPos);\n        RAISE Rd.EndOfFile;\n      END;\n    END;\n    Rd&quot;
 &amp; &quot;.Seek(rd, lastAcceptingPos);\n    RETURN lastAcceptingOutput;\n  END Ne&quot;
 &amp; &quot;xtCode;\n\nPROCEDURE Get(self: T): Token RAISES {Rd.EndOfFile} =\n  VAR&quot;
 &amp; &quot;\n    result: Token;\n  BEGIN\n    SeekRd.DiscardPrevious(self.rd);\n  &quot;
 &amp; &quot;  REPEAT\n      self.textCache := NIL;\n      CASE NextCode(self) OF\n &quot;
 &amp; &quot;     | 0 =&gt; &lt;* ASSERT FALSE *&gt; (* unmatched *)\n%case\\\n      END;\n  &quot;
 &amp; &quot;  UNTIL result # NIL;\n    RETURN result;\n  END Get; \n\nPROCEDURE Ung&quot;
 &amp; &quot;et(self: T) =\n  BEGIN     \n    &lt;* ASSERT self.posBeforeToken # -1 *&gt;\n&quot;
 &amp; &quot;    Rd.Seek(self.rd, self.posBeforeToken);\n    self.posBeforeToken := &quot;
 &amp; &quot;-1;\n  END Unget;\n\nPROCEDURE GetText(self: T): TEXT =\n  VAR\n    len&quot;
 &amp; &quot;: INTEGER;\n  BEGIN\n    IF self.textCache = NIL THEN\n      &lt;* ASSERT &quot;
 &amp; &quot;self.posBeforeToken # -1 *&gt;\n      len := Rd.Index(self.rd) - self.posB&quot;
 &amp; &quot;eforeToken;\n      Rd.Seek(self.rd, self.posBeforeToken);\n      self.t&quot;
 &amp; &quot;extCache := Rd.GetText(self.rd, len);\n    END;\n    RETURN self.textCa&quot;
 &amp; &quot;che;\n  END GetText;\n\nPROCEDURE Purge(self: T): INTEGER =\n  BEGIN\n &quot;
 &amp; &quot;   RETURN 0%purge;\n  END Purge;\n\nPROCEDURE GetRd(self: T): Rd.T =\n &quot;
 &amp; &quot; BEGIN RETURN self.rd; END GetRd;\n\nPROCEDURE Rewind(self: T) =\n  BEG&quot;
 &amp; &quot;IN Rd.Seek(self.rd, 0); EVAL self.setRd(self.rd); END Rewind;\n\nPROCED&quot;
 &amp; &quot;URE FromText(self: T; t: TEXT): %tok.RdLexer =\n  BEGIN RETURN self.set&quot;
 &amp; &quot;Rd(TextRd.New(t))&quot;;

CONST E2_1 =
   &quot;; END FromText;\n\nPROCEDURE Error(self: T; message: TEXT) =\n  BEGIN S&quot;
 &amp; &quot;eekRd.E(self.rd, message); END Error;\n\n(* default token methods *)\n%&quot;
 &amp; &quot;default\\\nPROCEDURE char(self: T): Token =\n  BEGIN RETURN %tok.NewCon&quot;
 &amp; &quot;stToken(ORD(self.charCache)); END char;\n\nBEGIN\nEND %lex.\n&quot;;

BEGIN
END lexformBundle.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
