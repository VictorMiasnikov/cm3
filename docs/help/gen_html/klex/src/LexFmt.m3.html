<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: klex/src/LexFmt.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>klex/src/LexFmt.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright (c) 2000 California Institute of Technology 
 All rights reserved. See the file COPYRIGHT for a full description. 
 $Id: LexFmt.m3.html,v 1.3 2010-04-29 17:18:49 wagner Exp $ 

<P><PRE>MODULE <module><implements><A HREF="LexFmt.i3.html">LexFmt</A></implements></module>;
IMPORT <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>;
IMPORT <A HREF="../../libm3/src/rw/Rd.i3.html">Rd</A>, <A HREF="../../ktoklib/src/TokSpec.i3.html">TokSpec</A>;
IMPORT <A HREF="../../klexlib/src/LexParse.i3.html">LexParse</A>;
IMPORT <A HREF="../../m3core/src/text/Text.i3.html">Text</A>;
IMPORT <A HREF="../../libm3/src/rw/TextWr.i3.html">TextWr</A>;
IMPORT <A HREF="../../cit_util/src/TextSubs.i3.html">TextSubs</A>;
IMPORT <A HREF="../../libm3/derived/TextList.i3.html">TextList</A>;
IMPORT <A HREF="../../libm3/src/bundleintf/Bundle.i3.html">Bundle</A>, <A HREF="../derived/lexformBundle.i3.html">lexformBundle</A>;
IMPORT <A HREF="DFA.i3.html">DFA</A>;
IMPORT <A HREF="../../libm3/src/fmtlex/Fmt.i3.html">Fmt</A>;
IMPORT <A HREF="DFATrans.i3.html">DFATrans</A>;
IMPORT <A HREF="../../ktoklib/src/CharCodes.i3.html">CharCodes</A>;
FROM <A HREF="../../libm3/src/rw/Stdio.i3.html">Stdio</A> IMPORT stderr;
REVEAL
  <A NAME="T">T</A> = Public BRANDED OBJECT
    outMN, tokMN: TEXT;
    tok: TokSpec.T;
    lex: LexParse.T;
    dfa: DFA.T;
    form: Bundle.T;
  OVERRIDES
    writeInterface := WriteInterface;
    writeModule := WriteModule;
    test := Test;
  END;
&lt;* FATAL Thread.Alerted, Wr.Failure *&gt;

PROCEDURE <A NAME="New"><procedure>New</procedure></A>(from: Rd.T; tok: TokSpec.T;
              outMN, tokMN: TEXT): T =
  VAR
    self := NEW(T,
                outMN := outMN,
                tokMN := tokMN,
                tok := tok,
                lex := LexParse.New(from, tok),
                form := lexformBundle.Get());
  BEGIN
    self.dfa := DFA.FromNFA(self.lex.n);
    RETURN self;
  END New;

PROCEDURE <A NAME="Subs"><procedure>Subs</procedure></A>(self: T): TextSubs.T =
  VAR
    subs := NEW(TextSubs.T).init();
  BEGIN
    subs.add(&quot;\\\n&quot;, &quot;&quot;);
    subs.add(&quot;%lex&quot;, self.outMN);
    subs.add(&quot;%tok&quot;, self.tokMN);
    subs.add(&quot;%gen&quot;, &quot;(* Generated by klex *)&quot;);
    RETURN subs;
  END Subs;

PROCEDURE <A NAME="GuessToken"><procedure>GuessToken</procedure></A>(tok: TokSpec.T; name, tokMN: TEXT): TEXT =
  VAR
    cur := tok.tokens;
    len := Text.Length(name);
    tokName: TEXT;
    tokLen: INTEGER;
    tokLongest: TEXT := NIL;
    tokLongestLen, dummy: INTEGER := 0;
  BEGIN
    WHILE cur # NIL DO
      tokName := cur.head;
      tokLen := Text.Length(tokName);
      IF len &gt;= tokLen THEN
        IF tokLen &gt;= tokLongestLen THEN
          IF Text.Equal(Text.Sub(name, len - tokLen, tokLen), tokName) THEN
            tokLongestLen := tokLen;
            tokLongest := tokName;
          END;
        END;
      END;
      cur := cur.tail;
    END;
    IF tokLongest = NIL THEN
      IF NOT Text.Equal(name, &quot;skip&quot;) THEN
        Wr.PutText(stderr, &quot;Warning: &quot; &amp; CharCodes.Q(name) &amp;
          &quot; is not \&quot;skip\&quot; and contains no token suffix\n&quot;);
      END;
      RETURN &quot;EVAL self; RETURN NIL&quot;;
    ELSE
      IF NOT Text.Equal(name, tokLongest) THEN
        IF tok.constTokens.get(tokLongest, dummy) THEN
        Wr.PutText(stderr, &quot;Warning: &quot; &amp; CharCodes.Q(name) &amp;
          &quot; is constant but not a token\n&quot;);
        END;
      END;
      (* RETURN &quot;NEW(&quot; &amp; tokMN &amp; &quot;.&quot; &amp; tokLongest &amp; &quot;)&quot;; *)
      RETURN &quot;RETURN &quot; &amp; tokMN &amp; &quot;.NewPT(self.allocate_&quot; &amp; tokLongest &amp;
             &quot;, TYPECODE(&quot; &amp; tokMN &amp; &quot;.&quot; &amp; tokLongest &amp; &quot;))&quot;;
    END;
  END GuessToken;

PROCEDURE <A NAME="FmtProcs"><procedure>FmtProcs</procedure></A>(self: T; form: TEXT;
                   findDefault: BOOLEAN := FALSE;
                   constCodes: BOOLEAN := FALSE): TEXT =
  VAR
    cur := self.lex.names;
    acc := &quot;&quot;;
    subs: TextSubs.T;
    i, dummy: INTEGER := 0;
  BEGIN
    WHILE cur # NIL DO
      INC(i);
      IF constCodes = self.tok.constTokens.get(cur.head, dummy) THEN
        IF NOT findDefault OR NOT Text.Equal(cur.head, &quot;char&quot;) THEN
          subs := NEW(TextSubs.T).init();
          subs.add(&quot;%tok&quot;, self.tokMN);
          subs.add(&quot;%name&quot;, cur.head);
          subs.add(&quot;%code&quot;, Fmt.Int(i));
          IF findDefault THEN
            subs.add(&quot;%default&quot;, GuessToken(self.tok, cur.head, self.tokMN));
          END;
          acc := acc &amp; subs.apply(form);
        END;
      END;
      cur := cur.tail;
    END;
    RETURN acc;
  END FmtProcs;

PROCEDURE <A NAME="WriteInterface"><procedure>WriteInterface</procedure></A>(self: T; to: Wr.T) =
  VAR
    subs := Subs(self);
  BEGIN
    subs.add(&quot;%methods&quot;, FmtProcs(self, &quot;    %name(): Token;\n&quot;));
    Wr.PutText(to, subs.apply(Bundle.Get(self.form, &quot;lexform.i3&quot;)));
  END WriteInterface;

PROCEDURE <A NAME="FmtTrans"><procedure>FmtTrans</procedure></A>(trans: DFATrans.T): TEXT =
  BEGIN
    RETURN Fmt.Int(ORD(trans.keyBegin)) &amp; &quot;,&quot; &amp;
           Fmt.Int(ORD(trans.keyEnd)) &amp; &quot;,&quot; &amp;
           Fmt.Int(trans.target) &amp; &quot;,&quot; &amp;
           Fmt.Int(trans.prio);
  END FmtTrans;

TYPE
  TableKind = {First, States, Trans};
PROCEDURE <A NAME="FmtTable"><procedure>FmtTable</procedure></A>(self: T; kind: TableKind): TEXT =
  CONST
    lmargin = &quot;    &quot;;
  VAR
    dfa := self.dfa;
    wr := TextWr.New();
    lineLen := 0;
  PROCEDURE PutEntry(t: TEXT) =
    VAR
      len := Text.Length(t);
    BEGIN
      IF lineLen + len &gt; 71 THEN
        lineLen := 0;
        Wr.PutText(wr, &quot;,\n&quot; &amp; lmargin);
      END;
      IF lineLen # 0 THEN
        Wr.PutText(wr, &quot;, &quot;);
        lineLen := lineLen + 2;
      END;
      Wr.PutText(wr, t);
      lineLen := lineLen + len;
    END PutEntry;
  BEGIN
    Wr.PutText(wr, lmargin);
    CASE kind OF
    | TableKind.First =&gt;
      FOR i := FIRST(CHAR) TO LAST(CHAR) DO
        PutEntry(Fmt.Int(ORD(dfa.first[i])));
      END;
    | TableKind.States =&gt;
      FOR i := 1 TO dfa.numStates DO
        WITH state = dfa.statesArray[i] DO
          PutEntry(&quot;S{&quot; &amp; FmtTrans(state.next.head) &amp; &quot;,&quot; &amp;
            Fmt.Int(state.output) &amp; &quot;}&quot;);
        END;
      END;
    | TableKind.Trans =&gt;
      FOR i := 1 TO dfa.numTrans DO
        PutEntry(&quot;X{&quot; &amp; FmtTrans(dfa.transArray[i]) &amp; &quot;}&quot;);
      END;
    END;
    RETURN TextWr.ToText(wr);
  END FmtTable;

PROCEDURE <A NAME="CountBits"><procedure>CountBits</procedure></A>(maxVal: INTEGER): INTEGER =
  VAR
    bits: INTEGER := 0;
    bitsRep: INTEGER := 1;
  BEGIN
    WHILE bitsRep &lt;= maxVal DO
      INC(bits);
      bitsRep := bitsRep + bitsRep;
    END;
    RETURN bits;
  END CountBits;

PROCEDURE <A NAME="AddIntRange"><procedure>AddIntRange</procedure></A>(subs: TextSubs.T; key: TEXT; maxVal, bits: INTEGER) =
  BEGIN
    subs.add(key &amp; &quot;Val&quot;, Fmt.Int(maxVal));
    subs.add(key &amp; &quot;Bits&quot;, Fmt.Int(bits));
  END AddIntRange;

PROCEDURE <A NAME="AddIntRanges"><procedure>AddIntRanges</procedure></A>(self: T; subs: TextSubs.T) =
  VAR
    dfa := self.dfa;
    bitsAlready: INTEGER := 16; (*two bytes already in the record*)
    names := ARRAY[1..3] OF TEXT{&quot;%lastStateRef&quot;,
                                 &quot;%lastTransRef&quot;,
                                 &quot;%lastOut&quot;};
    maxVals := ARRAY[1..3] OF INTEGER{dfa.numStates,
                                      dfa.numTrans,
                                      TextList.Length(self.lex.names)};
    bits: ARRAY [1..3] OF INTEGER;
  BEGIN
    FOR i := 1 TO 3 DO
      bits[i] := CountBits(maxVals[i]);
    END;
    (*SRC restriction: packed types cannot cross word boundary*)
    FOR i := 1 TO 3 DO
      IF bitsAlready + bits[i] &gt; 32 THEN
        &lt;* ASSERT i # 1 *&gt; (* &gt;64K states? *)
        bits[i-1] := bits[i-1] + 32 - bitsAlready;
        bitsAlready := 0;
      END;
      INC(bitsAlready, bits[i]);
    END;
    FOR i := 1 TO 3 DO
      AddIntRange(subs, names[i], maxVals[i], bits[i]);
    END;

  END AddIntRanges;

PROCEDURE <A NAME="WriteModule"><procedure>WriteModule</procedure></A>(self: T; to: Wr.T) =
  VAR
    procForm := Bundle.Get(self.form, &quot;lexform.proc.m3&quot;);
    subs := Subs(self);
  BEGIN
    subs.add(&quot;%ovr&quot;, FmtProcs(self, &quot;    %name := %name;\n&quot;));
    subs.add(&quot;%case&quot;,
             FmtProcs(self, &quot;      | %code =&gt; result := self.%name();\n&quot;) &amp;
             FmtProcs(self, &quot;      | %code =&gt; result := %tok.NewConstToken(&quot; &amp;
             &quot;%tok.%name);\n&quot;, FALSE, TRUE));
    subs.add(&quot;%default&quot;, FmtProcs(self, procForm, TRUE));
    subs.add(&quot;%alloc&quot;, self.tok.fmtVar(&quot;    allocate_%name: &quot; &amp;
      self.tokMN &amp; &quot;.Allocator := NIL;\n&quot;));
    subs.add(&quot;%purge&quot;, self.tok.fmtVar(&quot;\n    + &quot; &amp;
      self.tokMN &amp; &quot;.Purge(self.allocate_%name)&quot;));
    subs.add(&quot;%First&quot;, FmtTable(self, TableKind.First));
    subs.add(&quot;%States&quot;, FmtTable(self, TableKind.States));
    subs.add(&quot;%Trans&quot;, FmtTable(self, TableKind.Trans));
    AddIntRanges(self, subs);
    Wr.PutText(to, subs.apply(Bundle.Get(self.form, &quot;lexform.m3&quot;)));
  END WriteModule;

PROCEDURE <A NAME="Test"><procedure>Test</procedure></A>(self: T) =
  BEGIN
    DFA.Test(self.dfa);
  END Test;

BEGIN
END LexFmt.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
