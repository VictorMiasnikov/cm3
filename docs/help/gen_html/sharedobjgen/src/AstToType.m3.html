<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: sharedobjgen/src/AstToType.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>sharedobjgen/src/AstToType.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright (C) 1991, Digital Equipment Corporation           
 All rights reserved.                                        
 See the file COPYRIGHT for a full description.              

<P><PRE>MODULE <module><implements><A HREF="#x1">AstToType</A></implements></module>;

IMPORT <A HREF="../../libm3/src/atom/Atom.i3.html">Atom</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="../../libm3/src/property/PropertyV.i3.html">PropertyV</A>, <A HREF="../../libm3/derived/RefRefTbl.i3.html">RefRefTbl</A>, <A HREF="#x2">FRefRefTbl</A>, <A HREF="../../libm3/derived/TextRefTbl.i3.html">TextRefTbl</A>, <A HREF="#x3">StubCode</A>,
       <A HREF="#x4">StubGenTool</A>, <A HREF="SOxCodeUtils.i3.html">SOxCodeUtils</A>;
IMPORT <A HREF="../../m3tk/src/gast/AST.i3.html">AST</A>, <A HREF="../../m3tk/src/gast/ASTWalk.i3.html">ASTWalk</A>;
IMPORT <A HREF="../../m3tk/src/ast/M3AST_AS.i3.html">M3AST_AS</A>, <A HREF="../../m3tk/src/ast/M3ASTScope.i3.html">M3ASTScope</A>;
IMPORT <A HREF="../../m3tk/src/syn/M3CId.i3.html">M3CId</A>;
IMPORT <A HREF="#x5">AstToVal</A>, <A HREF="#x6">Type</A>, <A HREF="#x7">Value</A>;
IMPORT <A HREF="../../m3tk/src/ast/M3AST_AS_F.i3.html">M3AST_AS_F</A>, <A HREF="../../m3tk/src/ast/M3AST_SM.i3.html">M3AST_SM</A>, <A HREF="../../m3tk/src/ast/M3AST_SM_F.i3.html">M3AST_SM_F</A>, <A HREF="../../m3tk/src/ast/M3AST_TM_F.i3.html">M3AST_TM_F</A>, <A HREF="../../m3tk/src/sem/M3ASTNext.i3.html">M3ASTNext</A>, <A HREF="../../m3tk/src/ast/M3AST_TL_F.i3.html">M3AST_TL_F</A>,
       <A HREF="../../m3tk/src/ast/M3AST_LX.i3.html">M3AST_LX</A>, <A HREF="../../m3tk/src/toolmisc/M3Context.i3.html">M3Context</A>, <A HREF="../../m3tk/src/sem/M3CConcTypeSpec.i3.html">M3CConcTypeSpec</A>, <A HREF="../../m3tk/src/sem/M3CSearch.i3.html">M3CSearch</A>, <A HREF="../../m3tk/src/sem/M3CStdTypes.i3.html">M3CStdTypes</A>,
       <A HREF="../../m3tk/src/toolmisc/M3CUnit.i3.html">M3CUnit</A>;
IMPORT <A HREF="../../m3tk/derived/SeqM3AST_AS_Enum_id.i3.html">SeqM3AST_AS_Enum_id</A>, <A HREF="../../m3tk/derived/SeqM3AST_AS_Fields.i3.html">SeqM3AST_AS_Fields</A>, <A HREF="../../m3tk/derived/SeqM3AST_AS_Field_id.i3.html">SeqM3AST_AS_Field_id</A>,
       <A HREF="../../m3tk/derived/SeqM3AST_AS_Method.i3.html">SeqM3AST_AS_Method</A>, <A HREF="../../m3tk/derived/SeqM3AST_AS_Qual_used_id.i3.html">SeqM3AST_AS_Qual_used_id</A>, <A HREF="../../m3tk/derived/SeqM3AST_AS_TYPE_SPEC.i3.html">SeqM3AST_AS_TYPE_SPEC</A>,
       <A HREF="../../m3tk/src/sem/M3CTypesMisc.i3.html">M3CTypesMisc</A>;
IMPORT <A HREF="../../m3tk/src/target/M3CBackEnd_C.i3.html">M3CBackEnd_C</A>;
IMPORT <A HREF="../../libm3/derived/AtomList.i3.html">AtomList</A>, <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../libm3/src/fmtlex/Lex.i3.html">Lex</A>, <A HREF="../../libm3/src/rw/Rd.i3.html">Rd</A>, <A HREF="../../libm3/src/rw/TextRd.i3.html">TextRd</A>, <A HREF="../../m3tk/src/syn/M3CPragma.i3.html">M3CPragma</A>, <A HREF="SOxCodeGenError.i3.html">SOxCodeGenError</A>,
       <A HREF="UpdateMethodsTbl.i3.html">UpdateMethodsTbl</A>, <A HREF="AtomAtomListTbl.i3.html">AtomAtomListTbl</A>, <A HREF="#x8">ImportList</A>;

&lt;* FATAL SOxCodeUtils.Error *&gt;

REVEAL <A NAME="Handle">Handle</A> = Public BRANDED OBJECT
     sharedObjTypeSpec: M3AST_AS.TYPE_SPEC;
     wrTypeSpec       : M3AST_AS.TYPE_SPEC   := NIL;
     rdTypeSpec       : M3AST_AS.TYPE_SPEC   := NIL;
     astMap           : RefRefTbl.T;
     nameMap          : TextRefTbl.T;
     OVERRIDES callback := Node END;

VAR sharedObjName := NEW(Type.Qid);

PROCEDURE <A NAME="NewHandle"><procedure>NewHandle</procedure></A> (wr: Wr.T; intfName: TEXT; context: M3Context.T): Handle =
  VAR ts      : M3AST_AS.TYPE_SPEC;
      used_id : M3AST_AS.USED_ID := NEW(M3AST_AS.USED_ID).init();
      cu      : M3AST_AS.Compilation_Unit;
      astTable: RefRefTbl.T;
      h       : Handle;
      sharedObjType: Type.T;
  BEGIN
    used_id.lx_symrep := M3CId.Enter(&quot;T&quot;);
    astTable := NEW(FRefRefTbl.Default).init();
    IF M3Context.FindExact(
         context, &quot;SharedObj&quot;, M3CUnit.Type.Interface, cu) THEN
      M3CSearch.Export(cu.as_root, used_id);
      ts := NARROW(used_id.sm_def, M3AST_AS.TYPED_ID).sm_type_spec;
    ELSE
      (* SharedObj not in context, i.e.  not imported, must be error *)
      SOxCodeUtils.Message(&quot;SharedObj.T not known in this scope.&quot;);
      RETURN NIL;
    END;
    InitAstTable(astTable);
    h := NEW(Handle, wr := wr, intf := Atom.FromText(intfName),
             context := context, astMap := astTable,
             nameMap := NEW(TextRefTbl.Default).init(),
             sharedObjTypeSpec := ts);
    sharedObjType := ProcessTypeSpec(h, ts);
    sharedObjType.name := NEW(Type.Qid, intf := Atom.FromText(&quot;SharedObj&quot;),
                              item := Atom.FromText(&quot;T&quot;));
    EVAL astTable.put(ts, sharedObjType);
    IF M3Context.FindExact(context, &quot;Wr&quot;, M3CUnit.Type.Interface, cu) THEN
      M3CSearch.Export(cu.as_root, used_id);
      h.wrTypeSpec := NARROW(used_id.sm_def, M3AST_AS.TYPED_ID).sm_type_spec;
    END;
    IF M3Context.FindExact(context, &quot;Rd&quot;, M3CUnit.Type.Interface, cu) THEN
      M3CSearch.Export(cu.as_root, used_id);
      h.rdTypeSpec := NARROW(used_id.sm_def, M3AST_AS.TYPED_ID).sm_type_spec;
    END;
    RETURN h;
  END NewHandle;
</PRE>===========================================================================

<P><PRE>PROCEDURE <A NAME="ProcessTypes"><procedure>ProcessTypes</procedure></A> (c        : M3Context.T;
                        qid_array: REF ARRAY OF Type.Qid;
                        name     : TEXT;
                        wr       : Wr.T                   ): INTEGER =
  VAR
    h      : Handle;
    t_array         := NEW(REF ARRAY OF Type.Object, NUMBER(qid_array^));
    meth_array := NEW(
                    REF ARRAY OF ImportList.MethodList, NUMBER(qid_array^));
    used_id    : M3AST_AS.USED_ID          := NEW(M3AST_AS.USED_ID).init();
    def_id     : M3AST_AS.DEF_ID;
    cu         : M3AST_AS.Compilation_Unit;
    ts,sts     : M3AST_AS.TYPE_SPEC;
    qid        : Type.Qid;
    newType    : Type.T;
    bool       : BOOLEAN;
    valid                                  := TRUE;
    countValids                            := 0;
    returnCode                             := 0;
    intfs      : REF ARRAY OF TEXT;
    umethodsTbl: UpdateMethodsTbl.T;
    umTable    : AtomAtomListTbl.T;
    umethods   : AtomList.T;
    msg        : TEXT;
  BEGIN
    umethodsTbl := NEW(UpdateMethodsTbl.Default).init();
    intfs := StubGenTool.interfaces;
    FOR i := FIRST(intfs^) TO LAST(intfs^) DO
      umTable := NEW(AtomAtomListTbl.Default).init();
      EVAL umethodsTbl.put(Atom.FromText(intfs[i]), umTable);
    END;
    IF NOT FindUpdateMethods(umethodsTbl, c, intfs) THEN
      (* Should not continue if error in SHARED UPDATE METHODS pragmas*)
      RETURN 1;
    END;
    FOR i := 0 TO LAST(qid_array^) DO
      qid := qid_array[i];
      h := NewHandle(wr, Atom.ToText(qid.intf), c);
      IF h = NIL THEN
        valid := FALSE;
        (* Can't continue if SharedObj.T not in current context *)
      END;
      IF valid THEN
        used_id.lx_symrep := M3CId.Enter(Atom.ToText(qid.item));
        IF M3Context.FindExact(
             c, Atom.ToText(qid.intf), M3CUnit.Type.Interface, cu) THEN
          valid := UpdateMethods(umethods, qid, umethodsTbl);
          IF NOT valid THEN
            SOxCodeUtils.Message(
              &quot;can not find SHARED UPDATE METHODS pragma&quot;);
          END;
        ELSE
          valid := FALSE;
        END;
      END;
      IF valid THEN
        M3CConcTypeSpec.SetCurrentReveal(cu, ASTWalk.VisitMode.Entry);
        (* M3CSearch.Export(cu.as_root, used_id);*)
        (* used_id.sm_def is now bound to the Type_id for the object named
           qid. *)
        def_id := M3ASTScope.Lookup(cu.as_root.as_id.vSCOPE, used_id);
        IF def_id = NIL THEN
          SOxCodeUtils.Message(Atom.ToText(qid.intf) &amp; &quot;.&quot;
                                 &amp; Atom.ToText(qid.item) &amp; &quot; not defined.&quot;);
          valid := FALSE;
        END;
      END;
      IF valid THEN
        ts := NARROW(def_id, M3AST_AS.TYPED_ID).sm_type_spec;
        IF CheckSharedObj(ts, bool, h, sts, msg) THEN
          IF ComputeType(newType, h, sts, bool, qid) THEN
            IF CheckMethods(meth_array[i], umethods, newType, qid.intf)
                 = FALSE THEN
              SOxCodeUtils.Message(&quot;Method error -- no stubs produced. &quot; &amp;
                msg);
              valid := FALSE
            ELSE
              t_array[i] := newType;
            END;
          ELSE
            valid := FALSE;
          END;
        ELSE
          SOxCodeUtils.Message(
            Atom.ToText(qid.intf) &amp; &quot;.&quot; &amp; Atom.ToText(qid.item)
              &amp; &quot; is not a legal shared object type. &quot; &amp; msg);
          valid := FALSE;
        END;
      END;

      IF valid THEN
        INC(countValids)
      ELSE
        qid_array[i] := NIL;
        t_array[i] := NIL;
        valid := TRUE;
      END;
    END;

    IF countValids &gt; 0 THEN
      StubCode.GenCode(name, t_array, qid_array, meth_array, umethodsTbl);
    ELSE
      returnCode := 1;
    END;

    IF cu # NIL THEN
      M3CConcTypeSpec.SetCurrentReveal(cu, ASTWalk.VisitMode.Exit);
    END;
    RETURN returnCode;
  END ProcessTypes;
</PRE>===========================================================================

<P><PRE>PROCEDURE <A NAME="FindUpdateMethods"><procedure>FindUpdateMethods</procedure></A> (VAR umt  : UpdateMethodsTbl.T;
                                 c    : M3Context.T;
                                 intfs: REF ARRAY OF TEXT   ): BOOLEAN =
  VAR
    cu      : M3AST_AS.Compilation_Unit;
    pragIter: M3CPragma.Iter;
    prag    : M3CPragma.T;
    pragText: TEXT;
    umTable : AtomAtomListTbl.T;
    valid                               := TRUE;
    intfAtom: Atom.T;
  BEGIN
    FOR i := 0 TO LAST(intfs^) DO
      intfAtom := Atom.FromText(intfs[i]);
      EVAL umt.get(intfAtom, umTable);
      IF M3Context.FindExact(c, intfs[i], M3CUnit.Type.Interface, cu) THEN
        (* intfAtom should really be the name of the Interface in the File
           and not just the basename of the file *)
        TRY
          pragIter := M3CPragma.NewIter(cu.lx_pragmas);
          WHILE M3CPragma.Next(pragIter, prag) DO
            IF M3CPragma.Match(prag, &quot;SHARED&quot;, pragText) THEN
              ParsePragma(umTable, pragText);
              EVAL umt.put(intfAtom, umTable);
</PRE><BLOCKQUOTE><EM><P>
              IF ...
                SOxCodeUtils.Message(<CODE>Double Interface-SHARED UPDATE </CODE>
                &amp; <CODE> METHODS pragma</CODE>);
                valid := FALSE;
              END;
</EM></BLOCKQUOTE><PRE>
            END                  (*IF match*)
          END;                   (*WHILE*)
        EXCEPT
          SOxCodeGenError.E =&gt;
            SOxCodeUtils.Message(
              &quot;Error in pragma \&quot;SHARED &quot; &amp; pragText &amp; &quot;\&quot;\n&quot;
                &amp; &quot;in interface &quot; &amp; intfs[i] &amp; &quot;!&quot;);
            valid := FALSE;
        END;
      END;
    END;
    RETURN valid;
  END FindUpdateMethods;

PROCEDURE <A NAME="UpdateMethods"><procedure>UpdateMethods</procedure></A> (VAR meths: AtomList.T;
                             qid  : Type.Qid;
                             umt  : UpdateMethodsTbl.T): BOOLEAN =
  VAR
    intf, typ: Atom.T;
    umTbl    : AtomAtomListTbl.T;
    valid                        := TRUE;
  BEGIN
    intf := qid.intf;
    typ := qid.item;
    valid := umt.get(intf, umTbl);
    IF valid THEN valid := umTbl.get(typ, meths); END;

    RETURN valid;
  END UpdateMethods;
</PRE>===========================================================================
 \subsubsection*{ParsePragma} Parse the pragma | &lt;*SHARED UPDATE METHODS
   meth1, meth2, ...*&gt; The pragma may appear more than once.  <CODE>txt</CODE> is set
   to the string that starts with <CODE>UPDATE...</CODE>.  <CODE>methods</CODE> will contains the
   accumulated list of methods.  They are separated by blanks.
<P>
   The pragma has a second form (only method stated is the keyword <CODE>ANY</CODE>)
   which is not checked in here. 
<PRE>PROCEDURE <A NAME="ParsePragma"><procedure>ParsePragma</procedure></A> (VAR mTbl: AtomAtomListTbl.T; txt: TEXT)
  RAISES {SOxCodeGenError.E} =
  &lt;*FATAL Rd.Failure, Thread.Alerted*&gt;

  PROCEDURE Add (VAR mTbl: AtomAtomListTbl.T; at: Atom.T; methname: TEXT)
    RAISES {SOxCodeGenError.E} =
    VAR methods: AtomList.T;
    BEGIN
      IF NOT mTbl.get(at, methods) THEN
        methods := AtomList.List1(Atom.FromText(methname))
      ELSE
        IF AtomList.Member(methods, Atom.FromText(methname)) THEN
          RAISE SOxCodeGenError.E(&quot;duplicate entry &quot; &amp; methname
                                    &amp; &quot; in SHARED UPDATE METHODS pragma&quot;);
        END;
        methods := AtomList.Cons(Atom.FromText(methname), methods)
      END;
      EVAL mTbl.put(at, methods);
    END Add;

  CONST IdChars = SET OF CHAR{'_', 'A'.. 'Z', 'a'.. 'z', '0'.. '9'};
  VAR
    rd             := TextRd.New(txt);
    methname: TEXT;
    typename: TEXT;
  BEGIN
    TRY
      Lex.Skip(rd);
      Lex.Match(rd, &quot;UPDATE&quot;);
      Lex.Skip(rd);
      Lex.Match(rd, &quot;METHODS&quot;);
      Lex.Skip(rd);

      (* First one is special: Has no ``,'' in front and &quot;methods&quot; may be
         &quot;NIL&quot; *)
      IF Rd.EOF(rd) THEN
        RAISE SOxCodeGenError.E(&quot;empty SHARED UPDATE METHODS pragma&quot;);
      ELSE
        typename := Lex.Scan(rd, IdChars);
        Lex.Match(rd, &quot;.&quot;);
        methname := Lex.Scan(rd, IdChars);
        Add(mTbl, Atom.FromText(typename), methname);
      END;                       (*IF*)

      (* Consume comma and read method names *)
      Lex.Skip(rd);
      WHILE NOT Rd.EOF(rd) DO
        Lex.Match(rd, &quot;,&quot;);
        Lex.Skip(rd);
        typename := Lex.Scan(rd, IdChars);
        Lex.Match(rd, &quot;.&quot;);
        methname := Lex.Scan(rd, IdChars);
        Add(mTbl, Atom.FromText(typename), methname);
        Lex.Skip(rd);
      END;
    EXCEPT
      Lex.Error =&gt;
        RAISE SOxCodeGenError.E(&quot;error in pragma: SHARED &quot; &amp; txt);
    END
  END ParsePragma;
</PRE>===========================================================================

<P>
<P><PRE>PROCEDURE <A NAME="ComputeType"><procedure>ComputeType</procedure></A> (VAR newType: Type.T;
                           h      : Handle;
                           ts     : M3AST_AS.TYPE_SPEC;
                           valid  : BOOLEAN;
                           qid    : Type.Qid            ): BOOLEAN =
  BEGIN
    SOxCodeUtils.Message(
      &quot;Processing &quot; &amp; Atom.ToText(qid.intf) &amp; &quot;.&quot; &amp; Atom.ToText(qid.item));
    IF valid THEN
      newType := ProcessM3Type(h, ts);
      TYPECASE newType OF
      | Type.Object =&gt;
          IF StubCode.BrandsOK(newType) THEN
            RETURN TRUE;
          ELSE
            SOxCodeUtils.Message(&quot;Brand errors -- no stubs produced&quot;);
          END;
      | Type.Opaque =&gt;
          SOxCodeUtils.Message(
            &quot;WARNING.  This type equivalent to &quot;
              &amp; &quot;SharedObj.T.\n       No stubs generated.&quot;);
      ELSE
        RAISE SOxCodeUtils.Error(&quot;Run time error -- shouldn't occur&quot;);
      END;
    ELSE
      SOxCodeUtils.Message(
        &quot;Not a legal shared object type: must be fully revealed except&quot;
        &amp; &quot; for direct parent of shared object.&quot;);
    END;
    RETURN FALSE;
  END ComputeType;

PROCEDURE <A NAME="InitAstTable"><procedure>InitAstTable</procedure></A> (astTable: RefRefTbl.T) =
  BEGIN
    EVAL astTable.put(M3CStdTypes.Integer(), Type.integer);
    EVAL astTable.put(M3CStdTypes.Longint(), Type.longint);
    EVAL astTable.put(M3CStdTypes.Real(), Type.real);
    EVAL astTable.put(M3CStdTypes.LongReal(), Type.longreal);
    EVAL astTable.put(M3CStdTypes.Extended(), Type.extended);
    EVAL astTable.put(M3CStdTypes.Null(), Type.null);
    EVAL astTable.put(M3CStdTypes.RefAny(), Type.refany);
    EVAL astTable.put(M3CStdTypes.Address(), Type.address);
    EVAL astTable.put(M3CStdTypes.Root(), Type.root);
    EVAL astTable.put(M3CStdTypes.Untraced_Root(), Type.untracedRoot);
    EVAL astTable.put(M3CStdTypes.Char(), Type.char);
    EVAL astTable.put(M3CStdTypes.WideChar(), Type.widechar);
    EVAL astTable.put(M3CStdTypes.Text(), Type.text);
    EVAL astTable.put(M3CStdTypes.Cardinal(), Type.cardinal);
    EVAL astTable.put(M3CStdTypes.Longcard(), Type.longcard);
    EVAL astTable.put(M3CStdTypes.Boolean(), Type.boolean);
    EVAL astTable.put(M3CStdTypes.Mutex(), Type.mutex);
  END InitAstTable;

PROCEDURE <A NAME="BuildMethods"><procedure>BuildMethods</procedure></A> (    t            : Type.Reference;
                            typeName     : Atom.T;
                        VAR methods      : ImportList.MethodList;
                            existingSuper: Type.T;
                            superName    : Atom.T;
                            n            : INTEGER                ) =
  PROCEDURE BuildAllMethods(    t        : Type.Reference;
                            typeName     : Atom.T;
                        VAR methods      : ImportList.MethodList;
                        VAR lastNewMethod: INTEGER;
                            existingSuper: Type.T;
                            superName    : Atom.T;
                            n            : INTEGER                ) =
    BEGIN
      IF t.name # NIL AND t.name.intf = sharedObjName.intf AND
        t.name.item = sharedObjName.item THEN
        methods := NEW(ImportList.MethodList, n);
        IF lastNewMethod &lt; 0 THEN lastNewMethod := n - 1; END;
      ELSE
        TYPECASE t OF
        | Type.Object (ot) =&gt;
          IF ot = existingSuper THEN lastNewMethod := n - 1; END;
          BuildAllMethods(ot.super, typeName, methods, lastNewMethod,
                       existingSuper, superName, n + NUMBER(ot.methods^));
          FOR i := 0 TO LAST(ot.methods^) DO
            methods[n].name := ot.methods[i].name;
            IF n &lt;= lastNewMethod THEN
              methods[n].intf := typeName;
            ELSE
              methods[n].intf := superName;
            END;
            methods[n].sig := ot.methods[i].sig;
            INC(n);
          END;
        ELSE
          RAISE SOxCodeUtils.Error(&quot;Run time error -- shouldn't occur&quot;);
        END;
      END;
    END BuildAllMethods;
  VAR allMethods: ImportList.MethodList;
      new : BOOLEAN;
      curr: INTEGER := 0;
      lastNewMethod := -1;
  BEGIN
    BuildAllMethods(t, typeName, allMethods, lastNewMethod,
                            existingSuper, superName, n);
    FOR i := 0 TO LAST(allMethods^) DO
      new := TRUE;
      FOR j := 0 TO i-1 DO
        IF Atom.Equal(allMethods[i].name, allMethods[j].name) THEN
          new := FALSE;
        END;
      END;
      IF new THEN INC(curr) END;
    END;
    methods := NEW(ImportList.MethodList, curr);
    curr := 0;
    FOR i := 0 TO LAST(allMethods^) DO
      new := TRUE;
      FOR j := 0 TO i-1 DO
        IF Atom.Equal(allMethods[i].name, allMethods[j].name) THEN
          new := FALSE;
        END;
      END;
      IF new THEN
        methods[curr] := allMethods[i];
        INC(curr);
      END;
    END;
  END BuildMethods;

PROCEDURE <A NAME="CheckMethods"><procedure>CheckMethods</procedure></A> (VAR ml      : ImportList.MethodList;
                        VAR umethods: AtomList.T;
                            t       : Type.Object;
                            intf    : Atom.T                 ): BOOLEAN =
  PROCEDURE IsIn (methList: ImportList.MethodList; mname: Atom.T):
    BOOLEAN =
    BEGIN
      FOR i := 0 TO NUMBER(methList^) - 1 DO
        IF methList[i].name = mname THEN RETURN TRUE; END;
      END;
      RETURN FALSE;
    END IsIn;

  VAR
    valid         := TRUE;
  BEGIN
    BuildMethods(t, intf, ml, NIL, NIL, 0);

    IF AtomList.Member(umethods, Atom.FromText(&quot;ANY&quot;)) THEN
      IF AtomList.Length(umethods) # 1 THEN
        SOxCodeUtils.Message(
          &quot;SHARED UPDATE METHODS ANY used with other methods&quot;);
        RETURN FALSE;
      END;
      umethods := NEW(AtomList.T); (* take all *)
      FOR i := NUMBER(t.methods^) - 1 TO 0 BY -1 DO
        umethods := AtomList.Cons(t.methods[i].name, umethods);
      END;
    ELSE
      FOR i := 0 TO AtomList.Length(umethods) - 1 DO
        IF NOT IsIn(ml, AtomList.Nth(umethods, i)) THEN
          SOxCodeUtils.Message(
            &quot;method &quot; &amp; Atom.ToText(AtomList.Nth(umethods, i))
              &amp; &quot; listed in SHARED UPDATE METHODS pragma not declared&quot;);
          valid := FALSE;
        END;
      END;
    END;

    IF NOT IsIn(ml, Atom.FromText(&quot;init&quot;)) THEN
      SOxCodeUtils.Message(&quot;shared object must have an init method&quot;);
      valid := FALSE;
    END;
    RETURN valid;
  END CheckMethods;
</PRE>===========================================================================

<P><PRE>PROCEDURE <A NAME="Node"><procedure>Node</procedure></A> (h: Handle; n: AST.NODE; vm: ASTWalk.VisitMode) =
  VAR typeSpec: M3AST_AS.TYPE_SPEC;
      supertypeSpec: M3AST_AS.TYPE_SPEC;
      typeName: TEXT;
      t       : Type.T;
      valid   : BOOLEAN;
      qid     : Type.Qid;
      msg     : TEXT;
  BEGIN
    IF vm = ASTWalk.VisitMode.Entry THEN
      TYPECASE n OF
      | M3AST_AS.TYPE_DECL(p) =&gt;
          typeName := M3CId.ToText(p.as_id.lx_symrep);
          M3CTypesMisc.GetTYPE_SPECFromM3TYPE(p.as_type, typeSpec);
          IF CheckSharedObj(typeSpec, valid, h, supertypeSpec, msg) THEN
            qid := NEW(Type.Qid, intf := h.intf,
                       item := Atom.FromText(typeName));
            IF ComputeType(t, h, supertypeSpec, valid, qid) THEN
              (* StubCode.GenStub(t, qid); *)
              RAISE SOxCodeUtils.Error(&quot;I have NO IDEA what this is &quot;
                                         &amp; &quot;good for -- Tobias.\n&quot;
                                         &amp; &quot;  Shouldn't ever get here&quot;
                                         &amp; &quot; -- Blair.\n&quot;);
            END;
          END;
      ELSE
      END;
    END;
  END Node;
</PRE>===========================================================================

<P><PRE>PROCEDURE <A NAME="ProcessM3Type"><procedure>ProcessM3Type</procedure></A> (h: Handle; m3type: M3AST_AS.M3TYPE): Type.T =
  VAR ts: M3AST_AS.TYPE_SPEC;
  BEGIN
    M3CTypesMisc.GetTYPE_SPECFromM3TYPE(m3type, ts);
    RETURN ProcessTypeSpec(h, ts);
  END ProcessM3Type;

PROCEDURE <A NAME="ProcessTypeSpec"><procedure>ProcessTypeSpec</procedure></A> (h: Handle; ts: M3AST_AS.TYPE_SPEC): Type.T =
  VAR r: REFANY;
  VAR t: Type.T;
  BEGIN
    IF h.astMap.get(ts, r) THEN
      RETURN NARROW(r, Type.T);
    ELSE
      TYPECASE ts OF
      | M3AST_AS.Real_type =&gt; t := Type.real;
      | M3AST_AS.LongReal_type =&gt; t := Type.longreal;
      | M3AST_AS.Extended_type =&gt; t := Type.extended;
      | M3AST_AS.Integer_type =&gt; t := Type.integer;
      | M3AST_AS.Longint_type =&gt; t := Type.longint;
      | M3AST_AS.WideChar_type =&gt; t := Type.widechar;
      | M3AST_AS.Null_type =&gt; t := Type.null;
      | M3AST_AS.RefAny_type =&gt; t := Type.refany;
      | M3AST_AS.Address_type =&gt; t := Type.address;
      | M3AST_AS.Root_type(rt) =&gt;
        TYPECASE rt.as_trace_mode OF
        | NULL =&gt; t := Type.root
        ELSE t :=  Type.untracedRoot
        END;
      | M3AST_AS.Packed_type (pt) =&gt;
        t := NEW(Type.Packed,
                 size := NARROW(pt.as_exp.sm_exp_value,
                                M3CBackEnd_C.Integer_value).sm_value,
                 base := ProcessM3Type(h, pt.as_type));
      | M3AST_AS.Array_type (at) =&gt;
        VAR
          ASTindexType: M3AST_SM.TYPE_SPEC_UNSET;
          eltTypeSpec : M3AST_SM.TYPE_SPEC_UNSET;
          openArray   : BOOLEAN;
        BEGIN
          EVAL M3ASTNext.Array(at, eltTypeSpec, openArray, ASTindexType);
          IF openArray THEN
            t := NEW(Type.OpenArray, index := NIL,
                     element := ProcessTypeSpec(h, eltTypeSpec));
            WITH openA    = NARROW(t, Type.OpenArray),
                 refArray = NEW(Type.Ref, traced := TRUE, target := t) DO
              openA.refArray := refArray;
              TYPECASE openA.element OF
              | Type.OpenArray (element) =&gt;
                openA.openDimensions := element.openDimensions + 1;
              ELSE
                openA.openDimensions := 1;
              END;
            END;
          ELSE
            t := NEW(Type.Array, index := ProcessM3Type(h, ASTindexType),
                     element := ProcessTypeSpec(h, eltTypeSpec));
          END;
        END;
      | M3AST_AS.Enumeration_type (enum) =&gt;
        VAR
          enumt := NEW(Type.UserDefined,
                       elts := NEW(REF ARRAY OF Atom.T, enum.sm_num_elements));
          iter := SeqM3AST_AS_Enum_id.NewIter(enum.as_id_s);
          elem: M3AST_AS.Enum_id;
        BEGIN
          FOR i := 1 TO enum.sm_num_elements DO
            EVAL SeqM3AST_AS_Enum_id.Next(iter, elem);
            enumt.elts[i-1] := Atom.FromText(M3CId.ToText(elem.lx_symrep));
          END;
          t := enumt;
        END;
      | M3AST_AS.Set_type (set) =&gt;
        t := NEW(Type.Set, range := ProcessM3Type(h, set.as_type));
      | M3AST_AS.Subrange_type (sub) =&gt;
        TYPECASE sub.sm_base_type_spec OF
        | M3AST_AS.Longint_type =&gt;
          WITH baseType = ProcessTypeSpec(h, sub.sm_base_type_spec),
               e1 = NARROW(sub.as_range, M3AST_AS.Range).as_exp1,
               e2 = NARROW(sub.as_range, M3AST_AS.Range).as_exp2,
               i1 = NARROW(e1.sm_exp_value,
                           M3CBackEnd_C.Longint_value).sm_value,
               i2 = NARROW(e2.sm_exp_value,
                           M3CBackEnd_C.Longint_value).sm_value DO
            t := NEW(Type.Subrange, base := baseType,
                     min := NEW(Value.Longint, val := i1),
                     max := NEW(Value.Longint, val := i2));
          END;
        ELSE
          WITH baseType = ProcessTypeSpec(h, sub.sm_base_type_spec),
               e1 = NARROW(sub.as_range, M3AST_AS.Range).as_exp1,
               e2 = NARROW(sub.as_range, M3AST_AS.Range).as_exp2,
               i1 = NARROW(e1.sm_exp_value,
                           M3CBackEnd_C.Integer_value).sm_value,
               i2 = NARROW(e2.sm_exp_value,
                           M3CBackEnd_C.Integer_value).sm_value DO
            t := NEW(Type.Subrange, base := baseType,
                     min := NEW(Value.Integer, val := i1),
                     max := NEW(Value.Integer, val := i2));
          END;
        END;
      | M3AST_AS.Record_type (rec) =&gt;
        t := NEW(Type.Record, fields := ProcessFields(h, rec.as_fields_s));
      | M3AST_AS.BRANDED_TYPE (bt) =&gt;
        VAR
          brandName: Atom.T  := NIL;
          branded            := FALSE;
          trace    : BOOLEAN;
        BEGIN
          IF bt.as_brand # NIL THEN
            IF bt.as_brand.as_exp # NIL THEN
              brandName :=
                  Atom.FromText(NARROW(bt.as_brand.as_exp.sm_exp_value,
                                       M3CBackEnd_C.Text_value).sm_value);
            END;
            branded := TRUE
          END;
          TYPECASE bt OF
          | M3AST_AS.Ref_type (ref) =&gt;
            TYPECASE ref.as_trace_mode OF
            | NULL =&gt; trace := TRUE;
            ELSE trace := FALSE;
            END;
            t := NEW(Type.Ref, traced := trace, branded := branded,
                     brand := brandName);
            AddToTable(h, ts, t);
            NARROW(t, Type.Ref).target := ProcessM3Type(h, ref.as_type);
          | M3AST_AS.Object_type (ob) =&gt;
            t := ProcessObject(h, ob, branded, brandName, trace);
          ELSE
            RAISE SOxCodeUtils.Error(&quot;Runtime error -- shouldn't occur&quot;);
          END;
        END;
      | M3AST_AS.Opaque_type (o) =&gt;
        IF o.sm_concrete_type_spec = NIL THEN
          WITH revSuperTs = M3CConcTypeSpec.CurrentReveal(o),
               revSuperType = NARROW(ProcessTypeSpec(h, revSuperTs),
                                     Type.Reference) DO
            t := NEW(Type.Opaque, revealedSuperType := revSuperType);
          END;
        ELSE
          WITH revTs = o.sm_concrete_type_spec DO
            t := ProcessTypeSpec(h, revTs);
            WITH tt = NARROW(t, Type.Object) DO
              tt.revIntf :=
                  Atom.FromText(M3CId.ToText(revTs.tmp_unit_id.lx_symrep));
            END;
          END;
        END;
      | M3AST_AS.Procedure_type (proc) =&gt;
        VAR
          formals : REF ARRAY OF Type.Formal;
          nFormals: INTEGER := 0;
          iter := M3ASTNext.NewIterFormal(proc.as_formal_param_s);
          formalParam: M3AST_AS.Formal_param;
          formalId   : M3AST_AS.FORMAL_ID;
          signature  : Type.Signature;
        BEGIN
          WHILE M3ASTNext.Formal(iter, formalParam, formalId) DO
            INC(nFormals)
          END;
          formals := NEW(REF ARRAY OF Type.Formal, nFormals);
          iter := M3ASTNext.NewIterFormal(proc.as_formal_param_s);
          FOR i := 0 TO nFormals-1 DO
            EVAL M3ASTNext.Formal(iter, formalParam, formalId);
            formals[i] := NEW(Type.Formal);
            formals[i].name :=
                Atom.FromText(M3CId.ToText(formalId.lx_symrep));
            formals[i].type := ProcessM3Type(h, formalId.sm_type_spec);
</PRE><BLOCKQUOTE><EM><P>
            formals[i].type := ProcessM3Type(h, formalParam.as_formal_type);
            IF formalParam.as_default # NIL THEN
              formals[i].default := AstToVal.Val(
                                        formalParam.as_default.sm_exp.value,
                                        formals[i].type);
            END;
</EM></BLOCKQUOTE><PRE>
            TYPECASE formalId OF
            | M3AST_AS.F_Value_id =&gt; formals[i].mode := Type.Mode.Value;
            | M3AST_AS.F_Var_id =&gt; formals[i].mode := Type.Mode.Var;
            | M3AST_AS.F_Readonly_id =&gt;
              formals[i].mode := Type.Mode.Readonly;
            ELSE
              RAISE SOxCodeUtils.Error(&quot;Run time error -- shouldn't occur&quot;);
            END;
            formals[i].outOnly := FALSE;
            (* Change to depend on &lt;*OUTPUT*&gt; *)
          END;
          signature.formals := formals;
          IF proc.as_result_type # NIL THEN
            signature.result := ProcessM3Type(h, proc.as_result_type);
          END;
          IF proc.as_raises = NIL THEN
            signature.raises := NEW(REF ARRAY OF Type.Exception, 0)
          ELSE
            TYPECASE proc.as_raises OF
            | M3AST_AS.Raisees_some (r) =&gt;
              VAR
                iter    := SeqM3AST_AS_Qual_used_id.NewIter(r.as_raisees_s);
                nRaises := SeqM3AST_AS_Qual_used_id.Length(r.as_raisees_s);
                raisee : M3AST_AS.Qual_used_id;
                arg    : M3AST_AS.Exc_id;
                argType: Type.T;
              BEGIN
                signature.raises := NEW(REF ARRAY OF Type.Exception, nRaises);
                FOR i := 0 TO nRaises - 1 DO
                  EVAL SeqM3AST_AS_Qual_used_id.Next(iter, raisee);
                  signature.raises[i] := NEW(Type.Exception);
                  signature.raises[i].qid := NEW(Type.Qid);
                  WITH qid = signature.raises[i].qid DO
                    qid.intf :=
                        Atom.FromText(
                            M3CId.ToText(
                                raisee.as_id.sm_def.tmp_unit_id.lx_symrep));
                    qid.item :=
                        Atom.FromText(M3CId.ToText(raisee.as_id.lx_symrep));
                  END;
                  IF raisee.as_id.sm_def = NIL THEN
                    signature.raises[i].arg := NIL
                  ELSE
                    arg := NARROW(raisee.as_id.sm_def, M3AST_AS.Exc_id);
                    IF arg.tmp_type = NIL THEN
                      signature.raises[i].arg := NIL;
                    ELSE
                      argType := ProcessM3Type(h, arg.tmp_type);
                      signature.raises[i].arg := argType;
</PRE><BLOCKQUOTE><EM><P>
                      IF argType.name = NIL THEN
                        argType.name := NEW(Type.Qid);
                        WITH id = NARROW(arg, M3AST_AS.Qual_used_id) DO
                          FillInIntf(h, argType.name, id.as_intf_id);
                          argType.name.item :=
                              Atom.FromText(M3CId.ToText(id.as_id.lx_symrep));
                        END;
                      END;
</EM></BLOCKQUOTE><PRE>
                    END;
                  END;
                END;
              END;
            | M3AST_AS.Raisees_any =&gt;
            ELSE
              signature.raises := NEW(REF ARRAY OF Type.Exception, 0)
            END;
          END;
          t := NEW(Type.Procedure, sig := signature);
        END;
      ELSE
      END;
    END;
    AddToTable(h, ts, t);
    RETURN t;
  END ProcessTypeSpec;

PROCEDURE <A NAME="AddToTable"><procedure>AddToTable</procedure></A> (h: Handle; ts: M3AST_AS.TYPE_SPEC; t: Type.T) =
  BEGIN
    EVAL h.astMap.put(ts, t);
    IF t.name = NIL THEN
      WITH symrep = NARROW(PropertyV.Get(
                               ts.tl_pset, TYPECODE(M3AST_LX.Symbol_rep)),
                           M3AST_LX.Symbol_rep) DO
        IF symrep # NIL THEN
          t.name := NEW(Type.Qid);
          t.name.intf := Atom.FromText(M3CId.ToText(ts.tmp_unit_id.lx_symrep));
          t.name.item := Atom.FromText(M3CId.ToText(symrep));
        END;
      END;
    END;
  END AddToTable;
</PRE><P>
PROCEDURE FillInIntf(h: Handle; qid: Type.Qid;
                     intfId: M3AST_AS.Used_interface_id) =
  BEGIN
    IF intfId = NIL THEN
      qid.intf := h.intf
    ELSE
      qid.intf := Atom.FromText(M3CId.ToText(intfId.lx_symrep));
    END;
  END FillInIntf;


<P> Check whether o is a subtype of SharedObj.T, and whether it is
   valid for stub generation.  To be valid, o must be a subtype of
   SharedObj.t, its first supertype must be opaque and the remaining
   supertypes must be fully revealed in the scope where stubs are
   generated.  <CODE>sts</CODE> will contain the type for the superType, which is
   what we will end up using to generate the code. 

<P><PRE>PROCEDURE <A NAME="CheckSharedObj"><procedure>CheckSharedObj</procedure></A> (    o    : M3AST_AS.TYPE_SPEC;
                          VAR valid: BOOLEAN;
                              h    : Handle;
                          VAR sts  : M3AST_AS.TYPE_SPEC;
                          VAR msg  : TEXT): BOOLEAN =
  VAR
    checkType, ts: M3AST_AS.TYPE_SPEC;
    iter         : SeqM3AST_AS_TYPE_SPEC.Iter;
  BEGIN
    valid := FALSE;
    msg := &quot;&quot;;
    IF o = NIL THEN msg := &quot;requested type is NIL&quot;; RETURN FALSE END;

    TYPECASE o OF
    | M3AST_AS.Root_type =&gt; msg := &quot;requested type is ROOT&quot;; RETURN FALSE
    | M3AST_AS.Opaque_type (ot) =&gt;
      (* can't make a shared object of the SharedObj.T! *)
      IF ot = h.sharedObjTypeSpec THEN
        msg := &quot;requested type is SharedObj.T&quot;;
        RETURN FALSE;
      END;
      (* the first level must be an opaque type, that we will reveal *)
      IF ot.sm_concrete_type_spec # NIL THEN
        msg := &quot;first level of requested type must be an unrevealed opaque type&quot;;
        RETURN FALSE
      END;
      M3CTypesMisc.GetTYPE_SPECFromM3TYPE(ot.as_type, sts);
      checkType := sts;
    ELSE
      msg := &quot;requested type is not an object&quot;;
      RETURN FALSE;
    END;

    LOOP
      IF checkType = NIL THEN
        msg := &quot;supertype of requested type is NIL&quot;;
        RETURN FALSE;
      END;
      TYPECASE checkType OF
      | M3AST_AS.Root_type =&gt; RETURN FALSE
      | M3AST_AS.Opaque_type (ot) =&gt;
        IF ot = h.sharedObjTypeSpec THEN
          valid := TRUE;
          RETURN TRUE;
        END;
        IF ot.sm_concrete_type_spec = NIL THEN
          iter := SeqM3AST_AS_TYPE_SPEC.NewIter(ot.sm_type_spec_s);
          WHILE SeqM3AST_AS_TYPE_SPEC.Next(iter, ts) DO
            IF CheckSharedObj(ts, valid, h, sts, msg) THEN
              valid := FALSE;
              RETURN TRUE;
            END;
          END;
          msg := &quot;supertype of requested type is not fully revealed&quot;;
          RETURN FALSE;
        ELSE
          checkType := ot.sm_concrete_type_spec;
        END;
      | M3AST_AS.Object_type (objt) =&gt;
        IF objt = h.sharedObjTypeSpec THEN
          valid := TRUE;
          RETURN TRUE;
        END;
</PRE><BLOCKQUOTE><EM><P>
        IF NOT SeqM3AST_AS_Fields.Empty(objt.as_fields_s) THEN
          fieldsFound := TRUE;
        END;
</EM></BLOCKQUOTE><PRE>
        IF objt.as_ancestor = NIL THEN
          msg := &quot;requested type does not inherit from SharedObj.T&quot;;
          RETURN FALSE;
        END;
        M3CTypesMisc.GetTYPE_SPECFromM3TYPE(objt.as_ancestor, checkType);
      ELSE
        msg := &quot;supertype of requested type is not an object&quot;;
        RETURN FALSE;
      END;
    END;
  END CheckSharedObj;

PROCEDURE <A NAME="ProcessObject"><procedure>ProcessObject</procedure></A> (h      : Handle;
                         o      : M3AST_AS.Object_type;
                         branded: BOOLEAN;
                         brand  : Atom.T;
                         traced : BOOLEAN): Type.T =
  VAR t := NEW(Type.Object);
  BEGIN
    AddToTable(h, o, t);
    t.branded := branded;
    t.brand := brand;
    t.traced := traced;
    IF o.as_ancestor # NIL THEN
      t.super := ProcessM3Type(h, o.as_ancestor);
    END;
    t.fields := ProcessFields(h, o.as_fields_s);
    t.methods := ProcessMethods(h, o.as_method_s);
    RETURN t;
  END ProcessObject;

PROCEDURE <A NAME="ProcessFields"><procedure>ProcessFields</procedure></A> (h: Handle; f: SeqM3AST_AS_Fields.T):
  REF ARRAY OF Type.Field =
  VAR
    nFields  : INTEGER                   := 0;
    fields   : REF ARRAY OF Type.Field;
    iter                                 := M3ASTNext.NewIterField(f);
    iterItems                            := SeqM3AST_AS_Fields.NewIter(f);
    iterIds  : SeqM3AST_AS_Field_id.Iter;
    astFields: M3AST_AS.Fields;
    fieldId  : M3AST_AS.Field_id;
    j        : INTEGER                   := 0;
  BEGIN
    WHILE M3ASTNext.Field(iter, fieldId) DO INC(nFields) END;
    fields := NEW(REF ARRAY OF Type.Field, nFields);
    WHILE SeqM3AST_AS_Fields.Next(iterItems, astFields) DO
      iterIds := SeqM3AST_AS_Field_id.NewIter(astFields.as_id_s);
      WHILE SeqM3AST_AS_Field_id.Next(iterIds, fieldId) DO
        fields[j] := NEW(Type.Field);
        fields[j].name := Atom.FromText(M3CId.ToText(fieldId.lx_symrep));
        IF astFields.as_type = NIL THEN
          fields[j].type := ProcessTypeSpec(h, fieldId.sm_type_spec)
        ELSE
          fields[j].type := ProcessM3Type(h, astFields.as_type);
        END;
        IF (*fieldId.vINIT_ID.sm_init_exp*) astFields.as_default # NIL THEN
          fields[j].default :=
              AstToVal.ProcessExp(h,
                                  (*fieldId.vINIT_ID.sm_init_exp);*)
                                  astFields.as_default);
        END;
        INC(j);
      END;
    END;
    RETURN fields;
  END ProcessFields;

PROCEDURE <A NAME="ProcessMethods"><procedure>ProcessMethods</procedure></A> (h: Handle; m: SeqM3AST_AS_Method.T):
  REF ARRAY OF Type.Method =
  VAR
    nMethods                            := SeqM3AST_AS_Method.Length(m);
    methods  : REF ARRAY OF Type.Method;
    iter                                := SeqM3AST_AS_Method.NewIter(m);
    astMethod: M3AST_AS.Method;
  BEGIN
    methods := NEW(REF ARRAY OF Type.Method, nMethods);
    FOR i := 0 TO nMethods-1 DO
      EVAL SeqM3AST_AS_Method.Next(iter, astMethod);
      methods[i] := NEW(Type.Method);
      methods[i].name :=
          Atom.FromText(M3CId.ToText(astMethod.as_id.lx_symrep));
      methods[i].sig :=
          NARROW(ProcessTypeSpec(h, astMethod.as_type), Type.Procedure).sig;
      IF astMethod.as_default # NIL THEN
</PRE><BLOCKQUOTE><EM><P>
        methods[i].default := AstToVal.Val(
                                  astMethod.vINIT_ID.sm_init_exp,
                                  methods[i].type).sm_exp_value
</EM></BLOCKQUOTE><PRE>
      END;
    END;
    RETURN methods;
  END ProcessMethods;

BEGIN
  sharedObjName.intf := Atom.FromText(&quot;SharedObj&quot;);
  sharedObjName.item := Atom.FromText(&quot;T&quot;);
END AstToType.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface AstToType is in:
</A><UL>
<LI><A HREF="AstToType.i3.html#0TOP0">sharedobjgen/src/AstToType.i3</A>
<LI><A HREF="../../stablegen/src/AstToType.i3.html#0TOP0">stablegen/src/AstToType.i3</A>
<LI><A HREF="../../stubgen/src/AstToType.i3.html#0TOP0">stubgen/src/AstToType.i3</A>
</UL>
<P>
<HR>
<A NAME="x2">interface FRefRefTbl is in:
</A><UL>
<LI><A HREF="FRefRefTbl.i3.html#0TOP0">sharedobjgen/src/FRefRefTbl.i3</A>
<LI><A HREF="../../stablegen/src/FRefRefTbl.i3.html#0TOP0">stablegen/src/FRefRefTbl.i3</A>
<LI><A HREF="../../stubgen/src/FRefRefTbl.i3.html#0TOP0">stubgen/src/FRefRefTbl.i3</A>
</UL>
<P>
<HR>
<A NAME="x3">interface StubCode is in:
</A><UL>
<LI><A HREF="StubCode.i3.html#0TOP0">sharedobjgen/src/StubCode.i3</A>
<LI><A HREF="../../stubgen/src/StubCode.i3.html#0TOP0">stubgen/src/StubCode.i3</A>
</UL>
<P>
<HR>
<A NAME="x4">interface StubGenTool is in:
</A><UL>
<LI><A HREF="StubGenTool.i3.html#0TOP0">sharedobjgen/src/StubGenTool.i3</A>
<LI><A HREF="../../stubgen/src/StubGenTool.i3.html#0TOP0">stubgen/src/StubGenTool.i3</A>
</UL>
<P>
<HR>
<A NAME="x5">interface AstToVal is in:
</A><UL>
<LI><A HREF="AstToVal.i3.html#0TOP0">sharedobjgen/src/AstToVal.i3</A>
<LI><A HREF="../../stubgen/src/AstToVal.i3.html#0TOP0">stubgen/src/AstToVal.i3</A>
</UL>
<P>
<HR>
<A NAME="x6">interface Type is in:
</A><UL>
<LI><A HREF="../../cm3ide/src/nodes/Type.i3.html#0TOP0">cm3ide/src/nodes/Type.i3</A>
<LI><A HREF="../../m3front/src/types/Type.i3.html#0TOP0">m3front/src/types/Type.i3</A>
<LI><A HREF="Type.i3.html#0TOP0">sharedobjgen/src/Type.i3</A>
<LI><A HREF="../../stablegen/src/Type.i3.html#0TOP0">stablegen/src/Type.i3</A>
<LI><A HREF="../../stubgen/src/Type.i3.html#0TOP0">stubgen/src/Type.i3</A>
</UL>
<P>
<HR>
<A NAME="x7">interface Value is in:
</A><UL>
<LI><A HREF="../../m3front/src/values/Value.i3.html#0TOP0">m3front/src/values/Value.i3</A>
<LI><A HREF="Value.i3.html#0TOP0">sharedobjgen/src/Value.i3</A>
<LI><A HREF="../../stablegen/src/Value.i3.html#0TOP0">stablegen/src/Value.i3</A>
<LI><A HREF="../../stubgen/src/Value.i3.html#0TOP0">stubgen/src/Value.i3</A>
</UL>
<P>
<HR>
<A NAME="x8">interface ImportList is in:
</A><UL>
<LI><A HREF="ImportList.i3.html#0TOP0">sharedobjgen/src/ImportList.i3</A>
<LI><A HREF="../../stablegen/src/ImportList.i3.html#0TOP0">stablegen/src/ImportList.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
