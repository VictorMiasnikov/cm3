<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: sharedobjgen/src/SOxModuleSOCode.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>sharedobjgen/src/SOxModuleSOCode.m3</H2></A><HR>
<inModule>
<PRE></PRE>                            -*- Mode: Modula-3 -*- 
 * 
 * For information about this program, contact Blair MacIntyre            
 * (bm@cs.columbia.edu) or Steven Feiner (feiner@cs.columbia.edu)         
 * at the Computer Science Dept., Columbia University,                    
 * 1214 Amsterdam Ave. Mailstop 0401, New York, NY, 10027.                
 *                                                                        
 * Copyright (C) 1995, 1996 by The Trustees of Columbia University in the 
 * City of New York.  Blair MacIntyre, Computer Science Department.       
 * See file COPYRIGHT-COLUMBIA for details.
 * 
 * Author          : Tobias Hoellerer (htobias)
 * Created On      : Fri Nov 10 17:37:04 EST 1995
 * Last Modified By: Blair MacIntyre
 * Last Modified On: Mon Apr  6 20:51:30 1998
 * Update Count    : 183
 * 
 * $Source: /opt/cvs/cm3/doc/help/gen_html/sharedobjgen/src/SOxModuleSOCode.m3.html,v $
 * $Date: 2010-04-29 17:19:56 $
 * $Author: wagner $
 * $Revision: 1.5 $
 * 
 * $Log: not supported by cvs2svn $
 * Revision 1.4.2.1  2010-04-15 21:00:27  wagner
 * update generated HTML doc to RC5
 *
 * Revision 1.3  2008-03-17 16:36:44  hosking
 * Update for LONGINT.  Match code base with stubgen.
 *
 * Revision 1.2  2001/12/03 17:23:37  wagner
 * add copyright notes and overrides
 *
 * added: sharedobjgen/COPYRIGHT
 * added: sharedobjgen/COPYRIGHT-COLUMBIA
 * added: sharedobjgen/src/COPYRIGHT-COLUMBIA
 * added: sharedobjgen/src/m3overrides
 * modified: sharedobjgen/src/SOxCodeFiles.i3
 * modified: sharedobjgen/src/SOxCodeFiles.m3
 * modified: sharedobjgen/src/SOxCodeGenError.i3
 * modified: sharedobjgen/src/SOxCodeGenError.m3
 * modified: sharedobjgen/src/SOxCodeUtils.i3
 * modified: sharedobjgen/src/SOxCodeUtils.m3
 * modified: sharedobjgen/src/SOxCoder.i3
 * modified: sharedobjgen/src/SOxDummyCode.i3
 * modified: sharedobjgen/src/SOxDummyCode.m3
 * modified: sharedobjgen/src/SOxIntfCBCode.i3
 * modified: sharedobjgen/src/SOxIntfCBCode.m3
 * modified: sharedobjgen/src/SOxIntfCBProxyCode.i3
 * modified: sharedobjgen/src/SOxIntfCBProxyCode.m3
 * modified: sharedobjgen/src/SOxIntfPklCode.i3
 * modified: sharedobjgen/src/SOxIntfPklCode.m3
 * modified: sharedobjgen/src/SOxIntfProxyCode.i3
 * modified: sharedobjgen/src/SOxIntfProxyCode.m3
 * modified: sharedobjgen/src/SOxModuleCBCode.i3
 * modified: sharedobjgen/src/SOxModuleCBCode.m3
 * modified: sharedobjgen/src/SOxModuleProxyCode.i3
 * modified: sharedobjgen/src/SOxModuleProxyCode.m3
 * modified: sharedobjgen/src/SOxModuleSOCode.i3
 * modified: sharedobjgen/src/SOxModuleSOCode.m3
 * modified: sharedobjgen/src/StubGenTool.i3
 * modified: sharedobjgen/src/StubGenTool.m3
 *
 * Revision 1.1.1.1  2001/12/02 13:15:54  wagner
 * Blair MacIntyre's sharedobjgen package
 *
 * Revision 1.9  1998/05/11 02:34:29  bm
 * bug fixes, added SharedObj.Wait
 *
 * Revision 1.8  1997/11/13 23:45:06  bm
 * Changed lock location of generated picklers, to allow recursion
 *
 * Revision 1.7  1997/10/22 14:45:13  bm
 * Bug fix.  Naming conflicts.
 *
 * Revision 1.6  1997/08/11 20:36:41  bm
 * Various fixes
 *
 * 
 * HISTORY
 

<P><PRE>MODULE <module><implements><A HREF="SOxModuleSOCode.i3.html">SOxModuleSOCode</A></implements></module>;

IMPORT <A HREF="SOxCodeUtils.i3.html">SOxCodeUtils</A>, <A HREF="SOxCoder.i3.html">SOxCoder</A>, <A HREF="../../libm3/src/formatter/Formatter.i3.html">Formatter</A>, <A HREF="#x1">ImportList</A>, <A HREF="SOxCodeGenError.i3.html">SOxCodeGenError</A>,
       <A HREF="#x2">Type</A>, <A HREF="SOxCodeFiles.i3.html">SOxCodeFiles</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="#x3">CodeForType</A>, <A HREF="../../libm3/src/atom/Atom.i3.html">Atom</A>, <A HREF="../../libm3/derived/AtomList.i3.html">AtomList</A>,
       <A HREF="../../listfuncs/derived/AtomListFuncs.i3.html">AtomListFuncs</A>, <A HREF="../../m3core/src/text/Text.i3.html">Text</A>, <A HREF="#x4">Value</A>, <A HREF="../../libm3/src/fmtlex/Fmt.i3.html">Fmt</A>, <A HREF="#x5">StubCode</A>;

REVEAL
  <A NAME="T">T</A> = SOxCoder.T BRANDED OBJECT
        initializers:= &quot;&quot;;
      OVERRIDES
        InitImports := initImports;
        Import      := import;
        Head        := head;
        Decls       := decls;
        Main        := main;
        Bottom      := bottom;
      END;

&lt;* FATAL Wr.Failure*&gt;

PROCEDURE <A NAME="PutLine"><procedure>PutLine</procedure></A> (fmtWr: Formatter.T; text: TEXT) =
  BEGIN
    Formatter.PutText(fmtWr, text);
    Formatter.NewLine(fmtWr, freshLine := FALSE);
  END PutLine;

PROCEDURE <A NAME="EndLine"><procedure>EndLine</procedure></A> (fmtWr: Formatter.T; text: TEXT) =
  BEGIN
    Formatter.PutText(fmtWr, text);
    Formatter.End(fmtWr);
    Formatter.NewLine(fmtWr, freshLine := FALSE);
  END EndLine;

VAR
  extraImports := ARRAY [1 .. 16] OF
                    Atom.T{
                    Atom.FromText(&quot;SharedObj&quot;),
                    Atom.FromText(&quot;SharedObjRep&quot;),
                    Atom.FromText(&quot;SharedObjStubLib&quot;),
                    Atom.FromText(&quot;WeakRef&quot;),
                    Atom.FromText(&quot;EventStubLib&quot;),
                    Atom.FromText(&quot;EventProtocol&quot;), Atom.FromText(&quot;Rd&quot;),
                    Atom.FromText(&quot;Wr&quot;), Atom.FromText(&quot;SharedObjError&quot;),
                    Atom.FromText(&quot;ThreadF&quot;), Atom.FromText(&quot;Thread&quot;),
                    Atom.FromText(&quot;Event&quot;),
                    Atom.FromText(&quot;Pickle2 AS Pickle&quot;),
                    Atom.FromText(&quot;EmbProxiedObj&quot;),
                    Atom.FromText(&quot;PickleStubs&quot;),
                    Atom.FromText(&quot;ObjectSpace&quot;)
</PRE><BLOCKQUOTE><EM><P>
                    Atom.FromText(<CODE>Time</CODE>), Atom.FromText(<CODE>Fmt</CODE>),
                    Atom.FromText(<CODE>IO</CODE>)
</EM></BLOCKQUOTE><PRE>
                    };
PROCEDURE <A NAME="initImports"><procedure>initImports</procedure></A> (&lt;*UNUSED*&gt; self    : T;
                                  basename: TEXT;
                                  imports : ImportList.T) =
  VAR
    imp := ARRAY [1 .. 1] OF
             Atom.T{Atom.FromText(SOxCodeUtils.FileName(
                                    basename, SOxCodeFiles.T.CB_I3))};
  BEGIN
    CodeForType.AugmentImportList(imports, extraImports);
    CodeForType.AugmentImportList(imports, imp);
  END initImports;

PROCEDURE <A NAME="import"><procedure>import</procedure></A> (&lt;*UNUSED*&gt; self    : T;
                             type    : Type.Object;
                             methods : ImportList.MethodList;
                             umethods: AtomList.T;
                             imports : ImportList.T           ) =
  BEGIN
    (* CodeForType.ImportLst(type, imports, methods, umethods); *)
    CodeForType.ImportSOLst(type, imports, methods, umethods);
  END import;

PROCEDURE <A NAME="head"><procedure>head</procedure></A> (self    : T;
                wr      : Formatter.T;
                fname   : TEXT;
                basename: TEXT;
                imports : ImportList.T ) =
  BEGIN
    WITH Put = Formatter.PutText,
         Tab = Formatter.Begin,
         Nl  = Formatter.NewLine  DO
      SOxCodeUtils.HeaderComment(wr, fname);
      self.basename := basename;
      self.fbasename :=
        SOxCodeUtils.FileName(basename, SOxCodeFiles.T.SO_M3);

      Put(wr, &quot;MODULE &quot; &amp; self.fbasename &amp; &quot; EXPORTS &quot;);
      Tab(wr, 0);
      PutLine(wr, SOxCodeUtils.FileName(basename,
                                        SOxCodeFiles.T.PKL_I3) &amp; &quot;, &quot;);
      EndLine(wr, self.basename &amp; &quot;, &quot; &amp; SOxCodeUtils.FileName(
                                           basename, SOxCodeFiles.T.PRX_I3)
                    &amp; &quot;;&quot;);

      CodeForType.ProduceImports(wr, imports);

      Nl(wr, freshLine := FALSE);
      PutLine(wr, &quot;CONST SharedObj_Protocol: EventProtocol.StubProtocol = 1;&quot;);

      PutLine(wr, &quot;EXCEPTION DuplicateSpecial;&quot;);
      Nl(wr, freshLine := TRUE);
    END;
  END head;

PROCEDURE <A NAME="decls"><procedure>decls</procedure></A> (           self    : T;
                            wr      : Formatter.T;
                            typeID  : Type.Qid;
                            stypeID : Type.Qid;
                 &lt;*UNUSED*&gt; implName: TEXT;
                            methods : ImportList.MethodList;
                            umethods: AtomList.T             ) =
  VAR
    typTxt               : TEXT;
    identfTxt, identfsTxt: TEXT;
    meth                 : Atom.T;
    firstMeth            : BOOLEAN;
  BEGIN
    WITH Put    = Formatter.PutText,
         Nl     = Formatter.NewLine,
         Tab    = Formatter.Begin,
         Br     = Formatter.Break,
         Grp    = Formatter.Group,
         EndTab = Formatter.End      DO
      typTxt := CodeForType.QidToText(typeID);
      identfTxt := CodeForType.QidToIdentf(typeID);
      identfsTxt := CodeForType.QidToIdentf(stypeID);

      Put(wr, &quot;TYPE &quot; &amp; identfTxt &amp; &quot;_SOMethods = {&quot;);
      Tab(wr, 0);
      firstMeth := TRUE;
      FOR i := 0 TO LAST(methods^) DO
        meth := methods[i].name;
        IF AtomList.Member(umethods, meth) THEN
          IF firstMeth THEN
            firstMeth := FALSE
          ELSE
            Put(wr, &quot;, &quot;);
            Br(wr);
          END;
          Put(wr, Atom.ToText(meth));
        END;
      END;
      EndLine(wr, &quot;};&quot;);
      Nl(wr, freshLine := FALSE);

      Tab(wr, 2);
      Put(wr, &quot;REVEAL&quot;);

      Nl(wr, freshLine := FALSE);
      PutLine(wr, identfTxt &amp; &quot; = &quot; &amp; identfsTxt &amp; &quot; BRANDED \&quot;Shared&quot;
                    &amp; &quot; &quot; &amp; self.basename &amp; &quot;.&quot; &amp; identfTxt &amp;
                    &quot; v1.0\&quot; OBJECT&quot;);

      Tab(wr, 2);
      PutLine(wr, &quot;OVERRIDES&quot;);

      IF SOxCodeUtils.genProxyCode THEN
        PutLine(wr, &quot;makeProxy := MakeProxy_&quot; &amp; identfTxt &amp; &quot;;&quot;);
      END;
      PutLine(wr, &quot;applyUpdate := ApplyUpdate_&quot; &amp; identfTxt &amp; &quot;;&quot;);
      FOR i := 0 TO LAST(methods^) DO
        meth := methods[i].name;
        Nl(wr, freshLine := FALSE);
        Grp(wr);
        Put(wr, Atom.ToText(meth) &amp; &quot; := &quot;);
        Put(wr, &quot;Shared_&quot; &amp; Atom.ToText(meth) &amp; &quot;_&quot; &amp; identfTxt &amp; &quot;;&quot;);
        EndTab(wr);
      END;
      EndTab(wr);
      Nl(wr, freshLine := FALSE);
      PutLine(wr, &quot;END;&quot;);

      EndTab(wr);
      Nl(wr, freshLine := FALSE);
    END;
  END decls;

PROCEDURE <A NAME="main"><procedure>main</procedure></A> (           self    : T;
                           wr      : Formatter.T;
                           typeID  : Type.Qid;
                           type    : Type.Object;
                           stypeID : Type.Qid;
                &lt;*UNUSED*&gt; implName: TEXT;
                           methods : ImportList.MethodList;
                           umethods: AtomList.T             )
  RAISES {SOxCodeGenError.E} =
  VAR
    methTxt, typTxt      : TEXT;
    identfTxt, identfsTxt: TEXT;
    meth                 : Atom.T;
    exceptions           : AtomList.T := NIL;
    SOexports := AtomList.List2(Atom.FromText(self.basename),
                                Atom.FromText(SOxCodeUtils.FileName(
                                                  self.basename,
                                                  SOxCodeFiles.T.PRX_I3)));
  BEGIN
    WITH Put    = Formatter.PutText,
         Br     = Formatter.Break,
         Nl     = Formatter.NewLine,
         Tab    = Formatter.Begin,
         EndTab = Formatter.End      DO
      typTxt := CodeForType.QidToText(typeID);
      identfTxt := CodeForType.QidToIdentf(typeID);
      identfsTxt := CodeForType.QidToIdentf(stypeID);

      FOR i := 0 TO LAST(methods^) DO
        IF AtomList.Member(umethods, methods[i].name) THEN
          CodeForType.AugmentExceptionList(exceptions,
                                           methods[i].sig.raises, SOexports);
        END;
      END;

      IF SOxCodeUtils.genProxyCode THEN
        Tab(wr, 2);
        PutLine(wr, &quot;PROCEDURE MakeProxy_&quot; &amp; identfTxt &amp;
          &quot; (self: &quot; &amp; identfTxt &amp; &quot;) =&quot;);
        Tab(wr, 2);
        PutLine(wr, &quot;BEGIN&quot;);
        Tab(wr, 2);
        PutLine(wr, &quot;IF MkProxy&quot; &amp; identfTxt &amp; &quot; # NIL THEN&quot;);
        EndLine(wr, &quot;MkProxy&quot; &amp; identfTxt &amp; &quot;(self);&quot;);
        EndLine(wr, &quot;END;&quot;);
        EndLine(wr, &quot;END MakeProxy_&quot; &amp; identfTxt &amp; &quot;;&quot;);
      END;
      Nl(wr, freshLine := FALSE);

      Tab(wr, 2);
      Put(wr, &quot;PROCEDURE ApplyUpdate_&quot; &amp; identfTxt &amp; &quot; (&quot;);
      Tab(wr, 0);
      Put(wr, &quot;self: &quot; &amp; identfTxt &amp; &quot;; &quot;);
      Br(wr);
      Put(wr, &quot;ev: Event.T; &quot;);
      Br(wr);
      Put(wr, &quot;h: EventStubLib.Handle) &quot;);
      EndTab(wr);
      Br(wr);
      Put(wr, &quot;RAISES {&quot;);
      Tab(wr, 0);
      Put(wr, &quot;SharedObj.Error, &quot;);
      EVAL AtomListFuncs.DeleteD(exceptions, Atom.FromText(&quot;SharedObj.Error&quot;));
      Br(wr);
      IF AtomListFuncs.DeleteD(exceptions,
                               Atom.FromText(&quot;SharedObj.Fatal&quot;)) # NIL THEN
        Put(wr, &quot;SharedObj.Fatal, &quot;);
        Br(wr);
      END;
      Put(wr, &quot;Event.Error, &quot;);
      Br(wr);
      Put(wr, &quot;Rd.Failure, &quot;);
      Br(wr);
      EndLine(wr, &quot;Thread.Alerted} =&quot;);

      Tab(wr, 2);
      PutLine(wr, &quot;BEGIN&quot;);

      Tab(wr, 2);
      PutLine(wr, &quot;IF ev.prot # SharedObj_Protocol THEN&quot;);
      EndLine(wr, &quot;EventStubLib.RaiseUnmarshalFailure();&quot;);
      PutLine(wr, &quot;END;&quot;);
      Tab(wr, 2);
      PutLine(wr, &quot;WITH meth = SharedObjStubLib.InInt32(h) DO&quot;);
      Tab(wr, 2);

      IF exceptions # NIL THEN
        PutLine(wr, &quot;TRY&quot;);
        Tab(wr, 2);
      END;
      PutLine(wr, &quot;TRY&quot;);
      PutLine(wr, &quot;SharedObjStubLib.AcquireWriteLock(self);&quot;);
      PutLine(wr, &quot;self.updating := ThreadF.MyId();&quot;);
      PutLine(wr, &quot;CASE meth OF&quot;);

      FOR i := 0 TO LAST(methods^) DO
        meth := methods[i].name;
        methTxt := Atom.ToText(meth);
        IF AtomList.Member(umethods, meth) THEN
          Put(wr, &quot;| &quot;);
          Tab(wr, 0);
          Put(wr, &quot;ORD(&quot; &amp; identfTxt &amp; &quot;_SOMethods.&quot; &amp; methTxt &amp; &quot;) =&gt; &quot;);
          Br(wr);
          EndLine(wr, &quot;Stub_&quot; &amp; methTxt &amp; &quot;_&quot; &amp; identfTxt &amp; &quot;(self, h);&quot;);
        END;
      END;
      Tab(wr, 2);
      PutLine(wr, &quot;ELSE&quot;);
      EndLine(wr, &quot;EventStubLib.RaiseUnmarshalFailure();&quot;);
      EndLine(wr, &quot;END;&quot;);
      Tab(wr, 2);
      PutLine(wr, &quot;FINALLY&quot;);
      PutLine(wr, &quot;self.updating := -1;&quot;);
      EndLine(wr, &quot;SharedObjStubLib.ReleaseWriteLock(self);&quot;);
      EndLine(wr, &quot;END;&quot;);
      IF exceptions # NIL THEN
        Tab(wr, 2);
        Put(wr, &quot;EXCEPT &quot;);
        Br(wr);
        WHILE exceptions # NIL DO
          Put(wr, Atom.ToText(exceptions.head));
          IF exceptions.tail # NIL THEN
            Put(wr, &quot;, &quot;);
          END;
          Br(wr);
          exceptions := exceptions.tail;
        END;
        Put(wr, &quot;=&gt; &quot;);
        Br(wr);
        EndLine(wr, &quot;(* ignore these exceptions quietly *)&quot;);
        EndLine(wr, &quot;END;&quot;);
      END;
      EndLine(wr, &quot;END;&quot;);
      EndLine(wr, &quot;END ApplyUpdate_&quot; &amp; identfTxt &amp; &quot;;&quot;);

      Nl(wr, freshLine := FALSE);
      Surrogates(self, wr, type, identfTxt, identfsTxt, methods, umethods);
      Stubs(self, wr, type, identfTxt, identfsTxt, methods, umethods);
      Callbacks(self, wr, type, identfTxt, identfsTxt, methods, umethods);
      Picklers(self, wr, type, identfTxt, identfsTxt);
    END;
  END main;

PROCEDURE <A NAME="bottom"><procedure>bottom</procedure></A> (self: T; wr: Formatter.T; &lt;*UNUSED*&gt; fname: TEXT) =
  BEGIN
    WITH Put    = Formatter.PutText,
         Nl = Formatter.NewLine DO
      Nl(wr, freshLine := FALSE);
      PutLine(wr, &quot;BEGIN&quot;);
      Put(wr, self.initializers);
      PutLine(wr, &quot;END &quot; &amp; self.fbasename &amp; &quot;.&quot;);
    END;
  END bottom;

TYPE Direction = {In, Out};

PROCEDURE <A NAME="PrintStubArgs"><procedure>PrintStubArgs</procedure></A> (wr : Formatter.T;
                         sig: Type.Signature;
                         dir: Direction       ) =
  BEGIN
    FOR j := 0 TO LAST(sig.formals^) DO
      Formatter.PutText(wr, &quot;, &quot;);
      Formatter.Break(wr);
      Formatter.PutText(wr, Atom.ToText(sig.formals[j].name) &amp; &quot;_arg&quot;);
      IF dir = Direction.In THEN
        TYPECASE sig.formals[j].type OF
        | Type.OpenArray =&gt; Formatter.PutText(wr, &quot;^&quot;);
        ELSE
        END;
      END;
    END;
  END PrintStubArgs;

PROCEDURE <A NAME="Surrogates"><procedure>Surrogates</procedure></A> (self: T;
                      wr      : Formatter.T;
                      t       : Type.Object;
                      identfTxt, identfsTxt: TEXT;
                      methods : ImportList.MethodList;
                      umethods: AtomList.T           )
  RAISES {SOxCodeGenError.E} =
  VAR
    procedureName: TEXT;
    uMeth                     : BOOLEAN;
    methTxt      : TEXT;
    meth                 : Atom.T;
    SOexports := AtomList.List2(Atom.FromText(self.basename),
                                Atom.FromText(SOxCodeUtils.FileName(
                                                  self.basename,
                                                  SOxCodeFiles.T.PRX_I3)));
  BEGIN
    WITH Put    = Formatter.PutText,
         Nl     = Formatter.NewLine,
         Tab    = Formatter.Begin,
         EndTab = Formatter.End      DO
      FOR i := 0 TO LAST(methods^) DO
        meth := methods[i].name;
        methTxt := Atom.ToText(meth);

        uMeth := AtomList.Member(umethods, meth);
        procedureName := &quot;Shared_&quot; &amp; Atom.ToText(methods[i].name) &amp;
                             &quot;_&quot; &amp; identfTxt;

        Tab(wr, 2);
        CodeForType.ProcHeader(wr, t, procedureName, methods[i].sig,
                               suffix := &quot;_arg&quot;, exports := SOexports);
        PutLine(wr, &quot; = &quot;);

        IF uMeth THEN
          Tab(wr, 4);
          PutLine(wr, &quot;VAR out: SharedObjStubLib.Handle;&quot;);
          PutLine(wr, &quot;id := ThreadF.MyId();&quot;);
          EndLine(wr, &quot;dataPresent: BOOLEAN; &lt;* NOWARN *&gt;&quot;);
          (* PutLine(wr, &quot;stubProt: StubLib.StubProtocol;&quot;); *)
</PRE><BLOCKQUOTE><EM><P>
          IF methods[i].sig.result # NIL THEN
            PutLine(wr, <CODE>res: </CODE> &amp;
              CodeForType.ToText(methods[i].sig.result) &amp; <CODE>;</CODE>);
          END;
</EM></BLOCKQUOTE><PRE>
</PRE><P>
          IF StubUtils.perfMon THEN
            PutLine(wr, <CODE>wridx, rdidx: INTEGER;</CODE> &amp; PerfComment);
          END;

        <PRE>END;
        Tab(wr, 2);
        PutLine(wr, &quot;BEGIN&quot;);
        IF Text.Equal(&quot;init&quot;, Atom.ToText(methods[i].name)) THEN
          PutLine(
            wr, &quot;(**************************************************)&quot;);
          PutLine(
            wr, &quot;(* This get's done once. After that, it's a noop. *)&quot;);
          PutLine(
            wr, &quot;(**************************************************)&quot;);
          PutLine(wr, &quot;self := NARROW(SharedObj.Init(self), &quot; &amp;
                                   identfTxt &amp; &quot;);&quot;);
          PutLine(wr, &quot;self.makeProxy();&quot;);
          PutLine(
            wr, &quot;(**************************************************)&quot;);
        END;
        PutLine(wr, &quot;IF NOT self.ok THEN &quot;
                      &amp; &quot;SharedObjError.RaiseDeadObject() END;&quot;);
        IF uMeth THEN
          Tab(wr, 2);
          PutLine(wr, &quot;TRY&quot;);
          PutLine(wr, &quot;SharedObjStubLib.AcquireReadLock(self);&quot;);
          Tab(wr, 2);
          PutLine(wr, &quot;IF self.updating = id THEN &quot;);
          PutLine(wr, &quot;(* do a simple, non-update call to the method *)&quot;);
          IF methods[i].sig.result # NIL THEN
            Put(wr, &quot;RETURN &quot;);
          END;
          Put(wr, identfsTxt &amp; &quot;.&quot; &amp; Atom.ToText(methods[i].name) &amp; &quot;(&quot;);
          Tab(wr, 0);
          Put(wr, &quot;self&quot;);
          PrintStubArgs(wr, methods[i].sig, Direction.Out);
          EndTab(wr);
          IF methods[i].sig.result # NIL THEN
            EndLine(wr, &quot;);&quot;);
          ELSE
            PutLine(wr, &quot;);&quot;);
            EndLine(wr, &quot;RETURN;&quot;);
          END;
          EndLine(wr, &quot;END;&quot;);
          Tab(wr, 2);
          PutLine(wr, &quot;FINALLY&quot;);
          EndLine(wr, &quot;SharedObjStubLib.ReleaseReadLock(self);&quot;);
          PutLine(wr, &quot;END;&quot;);
          (* &quot;SharedObjError.RaiseRecursiveUpdate(); END;&quot;); *)

          Tab(wr, 2);
          PutLine(wr, &quot;TRY&quot;);
</PRE><BLOCKQUOTE><EM><P>
          IF StubUtils.perfMon THEN
            PutLine(wr, <CODE>IF NetObjPerf.enabled THEN</CODE> &amp; PerfComment);
            PutLine(wr, <CODE>  NetObjPerf.StartCall(PerfUtil.ThreadId(), </CODE> &amp;
              Fmt.Int(NUMBER(methods[i].sig.formals^)) &amp; <CODE>);</CODE>);
            PutLine(wr, <CODE>END;</CODE>);
          END;
</EM></BLOCKQUOTE><PRE>
          PutLine(wr, &quot;out := SharedObjStubLib.StartCall(self);&quot;);
          Tab(wr, 2);
          PutLine(wr, &quot;IF SharedObjStubLib.MarshalArgs(out) THEN&quot;);
          PutLine(wr, &quot;SharedObjStubLib.OutInt32(out, ORD(&quot; &amp;
            identfTxt &amp; &quot;_SOMethods.&quot; &amp; Atom.ToText(methods[i].name) &amp; &quot;));&quot;);
</PRE><BLOCKQUOTE><EM><P>
          IF StubUtils.perfMon THEN
            PutLine(wr, <CODE>wridx := Wr.Index(c.wr);</CODE> &amp; PerfComment);
          END;
</EM></BLOCKQUOTE><PRE>
          FOR j := 0 TO LAST(methods[i].sig.formals^) DO
            WITH f = methods[i].sig.formals[j] DO
              MarshalTypedVal(wr, Atom.ToText(f.name) &amp; &quot;_arg&quot;,
                              &quot;SharedObjStubLib&quot;, f.type, Direction.Out,
                              calling := TRUE, maySuppress := TRUE);
            END;
          END;
</PRE><BLOCKQUOTE><EM><P>
          IF StubUtils.perfMon THEN
            PutLine(wr, <CODE>wridx := Wr.Index(c.wr) - wridx;</CODE> &amp; PerfComment);
          END;
</EM></BLOCKQUOTE><PRE>
          EndTab(wr);
          PutLine(wr, &quot;END;&quot;);
          PutLine(wr, &quot;SharedObjStubLib.SequenceCall(out, SharedObj_Protocol);&quot;);
          Tab(wr, 2);
          PutLine(wr, &quot;TRY&quot;);
          PutLine(wr, &quot;SharedObjStubLib.AcquireWriteLock(self);&quot;);
          PutLine(wr, &quot;self.updating := id;&quot;);
          Put(wr, &quot;Callback_pre_&quot; &amp; Atom.ToText(methods[i].name) &amp;
            &quot;_&quot; &amp; identfTxt &amp; &quot;(&quot;);
          Tab(wr, 0);
          Put(wr, &quot;self&quot;);
          PrintStubArgs(wr, methods[i].sig, Direction.Out);
          EndTab(wr);
          PutLine(wr, &quot;);&quot;);
          IF methods[i].sig.result # NIL THEN
            Tab(wr, 2);
            Put(wr, &quot;WITH res = &quot;);
          END;
          Put(wr, identfsTxt &amp; &quot;.&quot; &amp; Atom.ToText(methods[i].name) &amp; &quot;(&quot;);
          Tab(wr, 0);
          Put(wr, &quot;self&quot;);
          PrintStubArgs(wr, methods[i].sig, Direction.Out);
          EndTab(wr);
          IF methods[i].sig.result # NIL THEN
            PutLine(wr, &quot;) DO&quot;);
          ELSE
            PutLine(wr, &quot;);&quot;);
          END;
          Put(wr, &quot;Callback_post_&quot; &amp; Atom.ToText(methods[i].name) &amp;
            &quot;_&quot; &amp; identfTxt &amp; &quot;(&quot;);
          Tab(wr, 0);
          Put(wr, &quot;self&quot;);
          PrintStubArgs(wr, methods[i].sig, Direction.Out);
          EndTab(wr);
          IF methods[i].sig.result # NIL THEN
            PutLine(wr, &quot;);&quot;);
            EndLine(wr, &quot;RETURN res;&quot;);
            EndLine(wr, &quot;END;&quot;);
          ELSE
            EndLine(wr, &quot;);&quot;);
          END;
          Tab(wr, 2);
          PutLine(wr, &quot;FINALLY&quot;);
          PutLine(wr, &quot;self.updating := -1;&quot;);
          PutLine(wr, &quot;SharedObjStubLib.ReleaseWriteLock(self);&quot;);
          EndLine(wr, &quot;SharedObjStubLib.EndCall(out);&quot;);
          EndLine(wr, &quot;END;&quot;);
          PutLine(wr, &quot;EXCEPT&quot;);
          Put(wr, &quot;| Wr.Failure (ec) =&gt; SharedObjError.RaiseCommFailure(ec)&quot;);
          IF methods[i].sig.result # NIL THEN
            PutLine(wr, &quot;; &lt;*ASSERT FALSE*&gt;&quot;);
          ELSE
            PutLine(wr, &quot;;&quot;);
          END;
          Put(wr, &quot;| Thread.Alerted =&gt; SharedObjError.RaiseAlerted()&quot;);
          IF methods[i].sig.result # NIL THEN
            PutLine(wr, &quot;; &lt;*ASSERT FALSE*&gt;&quot;);
          ELSE
            PutLine(wr, &quot;;&quot;);
          END;
          EndLine(wr, &quot;END;&quot;);
</PRE><P>
          IF StubUtils.perfMon THEN
            PutLine(wr, <CODE>rdidx := Rd.Index(c.rd);</CODE> &amp; PerfComment);
          END;

        <PRE>ELSE
          Tab(wr, 2);
          PutLine(wr, &quot;TRY&quot;);
          PutLine(wr, &quot;SharedObjStubLib.AcquireReadLock(self);&quot;);
          IF methods[i].sig.result # NIL THEN
            Put(wr, &quot;RETURN &quot;);
          END;
          Put(wr, identfsTxt &amp; &quot;.&quot; &amp; Atom.ToText(methods[i].name) &amp; &quot;(&quot;);
          Tab(wr, 0);
          Put(wr, &quot;self&quot;);
          PrintStubArgs(wr, methods[i].sig, Direction.Out);
          EndTab(wr);
          EndLine(wr, &quot;);&quot;);
          Tab(wr, 2);
          PutLine(wr, &quot;FINALLY&quot;);
          EndLine(wr, &quot;SharedObjStubLib.ReleaseReadLock(self);&quot;);
          EndLine(wr, &quot;END;&quot;);
        END;
        EndLine(wr, &quot;END &quot; &amp; procedureName &amp; &quot;;&quot;);
        Nl(wr, freshLine := FALSE);
      END;
    END;
  END Surrogates;

PROCEDURE <A NAME="Stubs"><procedure>Stubs</procedure></A> (self: T;
                 wr      : Formatter.T;
                 t: Type.Object;
                 identfTxt, identfsTxt: TEXT;
                 methods : ImportList.MethodList;
                 umethods: AtomList.T           )
  RAISES {SOxCodeGenError.E} =
  VAR
    varType: Type.T;
    SOexports := AtomList.List2(Atom.FromText(self.basename),
                                Atom.FromText(SOxCodeUtils.FileName(
                                                  self.basename,
                                                  SOxCodeFiles.T.PRX_I3)));
  BEGIN
    FOR i := 0 TO LAST(methods^) DO
      WITH Put    = Formatter.PutText,
         Nl     = Formatter.NewLine,
         Tab    = Formatter.Begin,
         EndTab = Formatter.End,
</PRE><BLOCKQUOTE><EM><P>
         Br     = Formatter.Break,
</EM></BLOCKQUOTE><PRE>
         sig    = methods[i].sig,
         stubSig = StubCode.SigForStub(sig),
         meth = methods[i].name,
         methTxt = Atom.ToText(meth),
         procedureName = &quot;Stub_&quot; &amp; methTxt &amp; &quot;_&quot; &amp; identfTxt
       DO
        IF AtomList.Member(umethods, meth) THEN
          Tab(wr, 2);
          CodeForType.ProcHeader(wr, t, procedureName, stubSig,
                                 StubCode.PragmasForStub(),
                                 exports := SOexports);
          PutLine(wr, &quot; = &quot;);
          IF NUMBER(sig.formals^) &gt; 0 THEN
            Tab(wr, 6);
            Put(wr, &quot;  VAR &quot;);
            FOR j := 0 TO LAST(sig.formals^) DO
              WITH f = sig.formals[j] DO
                TYPECASE f.type OF
                | Type.OpenArray (oa) =&gt; varType := oa.refArray
                ELSE varType := f.type;
                END;
                WITH txt = Atom.ToText(f.name)&amp; &quot;_arg: &quot; &amp;
                     CodeForType.ToText(varType, exports := SOexports) &amp; &quot;;&quot; DO
                  PutLine(wr, txt);
                END;
              END;
            END;
            EndLine(wr, &quot;dataPresent: BOOLEAN &lt;* NOWARN *&gt;;&quot;);
          END;
          Tab(wr, 2);
          PutLine(wr, &quot;BEGIN&quot;);

          FOR j := 0 TO LAST(sig.formals^) DO
            WITH f = sig.formals[j] DO
              MarshalTypedVal(wr, Atom.ToText(f.name) &amp; &quot;_arg&quot;,
                              &quot;SharedObjStubLib&quot;, f.type, Direction.In,
                              calling := TRUE, maySuppress := TRUE);
            END;
          END;

          Put(wr, &quot;Callback_pre_&quot; &amp; methTxt &amp; &quot;_&quot; &amp; identfTxt &amp; &quot;(&quot;);
          Tab(wr, 0);
          Put(wr, &quot;self&quot;);
          PrintStubArgs(wr, sig, Direction.In);
          EndTab(wr);
          PutLine(wr, &quot;);&quot;);
          IF sig.result # NIL THEN
            Put(wr, &quot;EVAL &quot;);
          END;
          Put(wr, identfsTxt &amp; &quot;.&quot; &amp; methTxt &amp; &quot;(&quot;);
          Tab(wr, 0);
          Put(wr, &quot;self&quot;);
          PrintStubArgs(wr, sig, Direction.In);
          EndTab(wr);
          PutLine(wr, &quot;);&quot;);

          Put(wr, &quot;Callback_post_&quot; &amp; methTxt &amp;  &quot;_&quot; &amp; identfTxt &amp; &quot;(&quot;);
          Tab(wr, 0);
          Put(wr, &quot;self&quot;);
          PrintStubArgs(wr, sig, Direction.In);
          EndTab(wr);
          EndLine(wr, &quot;);&quot;);
          EndLine(wr, &quot;END &quot; &amp; procedureName &amp; &quot;;&quot;);
          Nl(wr, freshLine := FALSE);
        END;
      END;
    END;
  END Stubs;

VAR cbName := ARRAY [0..1] OF Text.T{ &quot;pre&quot;, &quot;post&quot; };

PROCEDURE <A NAME="Callbacks"><procedure>Callbacks</procedure></A> (self: T;
                     wr      : Formatter.T;
                     &lt;*UNUSED*&gt;t: Type.Object;
                     identfTxt: TEXT;
                     &lt;*UNUSED*&gt;identfsTxt: TEXT;
                     methods : ImportList.MethodList;
                     umethods: AtomList.T           ) =
  VAR
    SOexports := AtomList.List2(Atom.FromText(self.basename),
                                Atom.FromText(SOxCodeUtils.FileName(
                                                  self.basename,
                                                  SOxCodeFiles.T.PRX_I3)));
    procedureName: TEXT;
  BEGIN
    FOR i := 0 TO LAST(methods^) DO
      WITH Put    = Formatter.PutText,
         Nl     = Formatter.NewLine,
         EndTab = Formatter.End,
         Tab    = Formatter.Begin,
         sig = methods[i].sig,
         meth = methods[i].name,
         methTxt = Atom.ToText(meth)
       DO
        IF AtomList.Member(umethods, meth) THEN
          FOR j := FIRST(cbName) TO LAST(cbName) DO
            procedureName := &quot;Callback_&quot; &amp; cbName[j] &amp; &quot;_&quot; &amp; methTxt &amp;
                                 &quot;_&quot; &amp; identfTxt;

            Tab(wr, 2);
            Put(wr, &quot;PROCEDURE &quot; &amp; procedureName &amp; &quot;(&quot;);
            Tab(wr,0);
            Put(wr, &quot;self: &quot; &amp; identfTxt);
            CodeForType.PrintSig(wr, sig, NIL, suffix := &quot;_arg&quot;,
                                exports := SOexports);
            EndLine(wr, &quot;) =&quot;);
</PRE><BLOCKQUOTE><EM><P>
            CodeForType.ProcHeader(wr, t, procedureName, sig,
                                   suffix := <CODE>_arg</CODE>, exports := SOexports); 
</EM></BLOCKQUOTE><PRE>
            PutLine(wr, &quot;VAR cbs := self.callbacks;&quot;);
            Tab(wr, 2);
            PutLine(wr, &quot;BEGIN&quot;);
            Tab(wr, 2);
            PutLine(wr, &quot;WHILE cbs # NIL DO&quot;);
            Tab(wr, 2);
            PutLine(wr, &quot;IF cbs.head.ready THEN&quot;);
            Tab(wr, 2);
            PutLine(wr, &quot;WITH ref = WeakRef.ToRef(cbs.head.weakRef) DO&quot;);
            Tab(wr, 2);
            PutLine(wr, &quot;IF ref # NIL THEN&quot;);
            Tab(wr, 2);
            PutLine(wr, &quot;WITH cb = NARROW(ref, &quot; &amp;
              SOxCodeUtils.FileName(self.basename,
                                    SOxCodeFiles.T.CB_I3) &amp; &quot;.&quot; &amp;
                                    identfTxt &amp; &quot;) DO&quot;);
            Tab(wr, 2);
            Put(wr, &quot;IF NOT cb.&quot; &amp; cbName[j] &amp; &quot;_&quot; &amp; methTxt &amp; &quot;(&quot;);
            Tab(wr, 0);
            Put(wr, &quot;self&quot;);
            PrintStubArgs(wr, sig, Direction.Out);
            EndTab(wr);
            PutLine(wr, &quot;) THEN&quot;);
            EndLine(wr, &quot;cb.&quot; &amp; cbName[j] &amp; &quot;_anyChange(self);&quot;);
            EndLine(wr, &quot;END;&quot;);
            EndLine(wr, &quot;END;&quot;);
            EndLine(wr, &quot;END;&quot;);
            EndLine(wr, &quot;END;&quot;);
            PutLine(wr, &quot;END;&quot;);
            EndLine(wr, &quot;cbs := cbs.tail;&quot;);
            EndLine(wr, &quot;END;&quot;);
            EndLine(wr, &quot;END &quot; &amp; procedureName &amp; &quot;;&quot;);
            Nl(wr, freshLine := FALSE);
          END;
        END;
      END;
    END;
  END Callbacks;

PROCEDURE <A NAME="Picklers"><procedure>Picklers</procedure></A> (self: T;
                 wr      : Formatter.T;
                 t: Type.Object;
                 identfTxt, identfsTxt: TEXT) RAISES {SOxCodeGenError.E} =
  VAR
    procedureName: Text.T;
  BEGIN
    WITH Put    = Formatter.PutText,
         Nl     = Formatter.NewLine,
         EndTab = Formatter.End,
         Br     = Formatter.Break,
         Tab    = Formatter.Begin,
         nodata = (NUMBER(t.fields^) = 0) DO

      PutLine(wr, &quot;(* The pickling routine for this shared object.&quot; &amp;
        &quot; We will register a&quot;);
      PutLine(wr, &quot;   pickler for &quot; &amp; self.basename &amp; &quot;.&quot; &amp;
        identfsTxt &amp; &quot;, and then handle both &quot; &amp; identfsTxt &amp; &quot; and &quot; &amp;
        identfTxt &amp; &quot;.&quot;);
      PutLine(wr, &quot;   Pickling subtypes of &quot; &amp; identfTxt &amp; &quot; is illegal. *)&quot;);

      Tab(wr, 2);
      PutLine(wr, &quot;REVEAL&quot;);
      Put(wr, identfTxt &amp; &quot;Special = &quot;);
      Tab(wr, 0);
      PutLine(wr, &quot;SharedObj.Special BRANDED \&quot;&quot; &amp; self.basename &amp; &quot;.&quot; &amp;
        identfTxt &amp; &quot;Special\&quot; OBJECT&quot;);
      Tab(wr, 2);
      PutLine(wr, &quot;OVERRIDES&quot;);
      PutLine(wr, &quot;write := DefaultSpWrite_&quot; &amp; identfTxt &amp; &quot;;&quot;);
      EndLine(wr, &quot;read := DefaultSpRead_&quot; &amp; identfTxt &amp; &quot;;&quot;);
      EndLine(wr, &quot;END;&quot;);
      EndLine(wr, &quot;&quot;);

      Tab(wr, 2);
      PutLine(wr, &quot;TYPE&quot;);
      Put(wr, identfTxt &amp; &quot;_Special = &quot;);
      Tab(wr, 0);
      Tab(wr, 2);
      PutLine(wr, &quot;Pickle.Special OBJECT&quot;);
      PutLine(wr, &quot;mu: MUTEX;&quot;);
      PutLine(wr, &quot;sp: &quot; &amp; identfTxt &amp; &quot;Special;&quot;);
      EndLine(wr, &quot;registered: BOOLEAN := FALSE;&quot;);

      Tab(wr, 2);
      PutLine(wr, &quot;OVERRIDES&quot;);
      PutLine(wr, &quot;write := Write_&quot; &amp; identfTxt &amp; &quot;;&quot;);
      EndLine(wr, &quot;read := Read_&quot; &amp; identfTxt &amp; &quot;;&quot;);
      EndLine(wr, &quot;END;&quot;);
      EndLine(wr, &quot;&quot;);

      Tab(wr, 2);
      procedureName := &quot;DefaultSpWrite_&quot; &amp; identfTxt;
      Put(wr, &quot;PROCEDURE &quot; &amp; procedureName &amp; &quot; (&quot;);
      Tab(wr, 0);
      Put(wr, &quot;&lt;*UNUSED*&gt;self: &quot; &amp; identfTxt &amp; &quot;Special; &quot;);
      Br(wr);
      IF nodata THEN
        Put(wr, &quot;&lt;*UNUSED*&gt;&quot;);
      END;
      Put(wr, &quot;shobj: SharedObj.T; &quot;);
      Br(wr);
      IF nodata THEN
        Put(wr, &quot;&lt;*UNUSED*&gt;&quot;);
      END;
      PutLine(wr, &quot;out: Pickle.Writer)&quot;);
      EndTab(wr);
      IF nodata THEN
        PutLine(wr, &quot; =&quot;);
      ELSE
        PutLine(wr, &quot;RAISES {Pickle.Error, Wr.Failure, Thread.Alerted} =&quot;);
      END;
      Tab(wr, 2);
      IF NOT nodata THEN
        PutLine(wr, &quot;VAR&quot;);
        EndLine(wr, &quot;obj := NARROW(shobj, &quot; &amp; identfsTxt &amp; &quot;);&quot;);
        Tab(wr, 2);
      END;
      PutLine(wr, &quot;BEGIN&quot;);
      FOR j := 0 TO LAST(t.fields^) DO
        WITH f = t.fields[j] DO
          MarshalTypedVal(wr, &quot;obj.&quot; &amp; Atom.ToText(f.name),
                          &quot;PickleStubs&quot;, f.type, Direction.Out,
                          calling := TRUE, maySuppress := TRUE);
        END;
      END;
      EndTab(wr);
      Nl(wr, freshLine := FALSE);
      EndLine(wr, &quot;END &quot; &amp; procedureName &amp; &quot;;&quot;);
      Nl(wr, freshLine := FALSE);

      Tab(wr, 2);
      procedureName := &quot;Write_&quot; &amp; identfTxt;
      Put(wr, &quot;PROCEDURE &quot; &amp; procedureName &amp; &quot; (&quot;);
      Tab(wr, 0);
      Put(wr, &quot;&lt;*UNUSED*&gt;ts: &quot; &amp; identfTxt &amp; &quot;_Special; &quot;);
      Br(wr);
      Put(wr, &quot;ref: REFANY; &quot;);
      Br(wr);
      PutLine(wr, &quot;out: Pickle.Writer)&quot;);
      EndTab(wr);
      PutLine(wr, &quot;RAISES {Pickle.Error, Wr.Failure, Thread.Alerted} =&quot;);
      Tab(wr, 2);
      PutLine(wr, &quot;VAR&quot;);
      PutLine(wr, &quot;obj: &quot; &amp; identfsTxt &amp; &quot;;&quot;);
      PutLine(wr, &quot;sp: &quot; &amp; identfTxt &amp; &quot;Special;&quot;);
      EndLine(wr, &quot;tc := TYPECODE(ref);&quot;);
      Tab(wr, 2);
      PutLine(wr, &quot;BEGIN&quot;);
</PRE><P>
      PutLine(wr, <CODE>IO.Put(\</CODE>Pickle.Special for <CODE> &amp; 
        self.basename &amp; </CODE>.<CODE> &amp; identfsTxt &amp; </CODE>\\n\<CODE>);</CODE>);

      <PRE>Tab(wr, 2);
      PutLine(wr, &quot;IF tc # TYPECODE(&quot; &amp; identfsTxt &amp;
        &quot;) AND tc # TYPECODE(&quot; &amp; identfTxt &amp; &quot;) THEN&quot;);
      EndLine(wr, &quot;RAISE Pickle.Error(\&quot;Can't pickle subtypes of &quot; &amp;
        self.basename &amp; &quot;.&quot; &amp; identfTxt &amp; &quot;\&quot;);&quot;);
      PutLine(wr, &quot;END;&quot;);
      PutLine(wr, &quot;obj := NARROW(ref, &quot; &amp; identfsTxt &amp; &quot;);&quot;);
      PutLine(wr, &quot;out.writeType(tc);&quot;);
</PRE><BLOCKQUOTE><EM><P>
      PutLine(wr, <CODE>IO.Put(\</CODE>Pickle.Special.wr for <CODE> &amp; 
        self.basename &amp; </CODE>.<CODE> &amp; identfsTxt &amp; </CODE>: writing shared obj\\n\<CODE>);</CODE>);
</EM></BLOCKQUOTE><PRE>
      PutLine(wr, &quot;SharedObjStubLib.StartWritePickle(obj, out);&quot;);
      Tab(wr,2);
      PutLine(wr, &quot;LOCK sp&quot; &amp; identfTxt &amp; &quot;.mu DO&quot;);
      EndLine(wr, &quot;sp := sp&quot; &amp; identfTxt &amp; &quot;.sp;&quot;);
      PutLine(wr, &quot;END;&quot;);
      PutLine(wr, &quot;sp.write(obj, out);&quot;);

      EndLine(wr, &quot;SharedObjStubLib.EndWritePickle(obj, out);&quot;);
</PRE><BLOCKQUOTE><EM><P>
      EndLine(wr, <CODE>IO.Put(\</CODE>Pickle.Special.wr for <CODE> &amp; 
        self.basename &amp; </CODE>.<CODE> &amp; identfsTxt &amp; </CODE>: wrote shared obj\\n\<CODE>);</CODE>);
</EM></BLOCKQUOTE><PRE>
      EndLine(wr, &quot;END &quot; &amp; procedureName &amp; &quot;;&quot;);
      Nl(wr, freshLine := FALSE);

      Tab(wr, 2);
      procedureName := &quot;DefaultSpRead_&quot; &amp; identfTxt;
      Put(wr, &quot;PROCEDURE &quot; &amp; procedureName &amp; &quot; (&quot;);
      Tab(wr, 0);
      Put(wr, &quot;&lt;*UNUSED*&gt;self: &quot; &amp; identfTxt &amp; &quot;Special; &quot;);
      Br(wr);
      IF nodata THEN
        Put(wr, &quot;&lt;*UNUSED*&gt;&quot;);
      END;
      Put(wr, &quot;shobj: SharedObj.T; &quot;);
      Br(wr);
      IF nodata THEN
        Put(wr, &quot;&lt;*UNUSED*&gt;&quot;);
      END;
      Put(wr, &quot;in: Pickle.Reader) &quot;);
      Br(wr);
      EndTab(wr);
      IF nodata THEN
        PutLine(wr, &quot; =&quot;);
      ELSE
        Put(wr, &quot;RAISES {&quot;);
        Br(wr);
        Tab(wr, 0);
        Put(wr, &quot;Pickle.Error, &quot;);
        Br(wr);
        Put(wr, &quot;Rd.EndOfFile, &quot;);
        Br(wr);
        Put(wr, &quot;Rd.Failure, &quot;);
        Br(wr);
        EndLine(wr, &quot;Thread.Alerted} =&quot;);
      END;
      Tab(wr, 2);
      IF NOT nodata THEN
        PutLine(wr, &quot;VAR&quot;);
        EndLine(wr, &quot;obj := NARROW(shobj, &quot; &amp; identfsTxt &amp; &quot;);&quot;);
        Tab(wr, 2);
      END;
      PutLine(wr, &quot;BEGIN&quot;);
      FOR j := 0 TO LAST(t.fields^) DO
        WITH f = t.fields[j] DO
          MarshalTypedVal(wr, &quot;obj.&quot; &amp; Atom.ToText(f.name),
                          &quot;PickleStubs&quot;, f.type, Direction.In,
                          calling := TRUE, maySuppress := TRUE);
        END;
      END;
      EndTab(wr);
      Nl(wr, freshLine := FALSE);
      EndLine(wr, &quot;END &quot; &amp; procedureName &amp; &quot;;&quot;);
      Nl(wr, freshLine := FALSE);

      Tab(wr, 2);
      procedureName := &quot;Read_&quot; &amp; identfTxt;
      Put(wr, &quot;PROCEDURE &quot; &amp; procedureName &amp; &quot; (&quot;);
      Tab(wr, 0);
      Put(wr, &quot;&lt;*UNUSED*&gt;ts: &quot; &amp; identfTxt &amp; &quot;_Special; in: Pickle.Reader; &quot;);
      Br(wr);
      Put(wr, &quot;id: Pickle.RefID):&quot;);
      Br(wr);
      EndTab(wr);
      Put(wr, &quot;REFANY RAISES {&quot;);
      Br(wr);
      Tab(wr, 0);
      Put(wr, &quot;Pickle.Error, &quot;);
      Br(wr);
      Put(wr, &quot;Rd.EndOfFile, &quot;);
      Br(wr);
      Put(wr, &quot;Rd.Failure, &quot;);
      Br(wr);
      EndLine(wr, &quot;Thread.Alerted} =&quot;);
      Tab(wr, 2);
      PutLine(wr, &quot;VAR&quot;);
      PutLine(wr, &quot;space: ObjectSpace.T;&quot;);
      PutLine(wr, &quot;obj: &quot; &amp; identfsTxt &amp; &quot;;&quot;);
      PutLine(wr, &quot;sp: &quot; &amp; identfTxt &amp; &quot;Special;&quot;);
      PutLine(wr, &quot;proxy: EmbProxiedObj.Proxy;&quot;);
      EndLine(wr, &quot;tc := in.readType();&quot;);
      Tab(wr, 2);
      PutLine(wr, &quot;BEGIN&quot;);
      Tab(wr, 2);
      PutLine(wr, &quot;IF tc = TYPECODE(&quot; &amp; identfTxt &amp; &quot;) THEN&quot;);
</PRE><BLOCKQUOTE><EM><P>
      PutLine(wr, <CODE>IO.Put(\</CODE>Pickle.Special.rd for <CODE> &amp; 
        self.basename &amp; </CODE>.<CODE> &amp; identfsTxt &amp; </CODE>: shared obj\\n\<CODE>);</CODE>);
</EM></BLOCKQUOTE><PRE>
      EndLine(wr, &quot;obj := NEW(&quot; &amp; identfTxt &amp; &quot;);&quot;);
      Tab(wr, 2);
      PutLine(wr, &quot;ELSIF tc = TYPECODE(&quot; &amp; identfsTxt &amp; &quot;) THEN&quot;);
</PRE><BLOCKQUOTE><EM><P>
      PutLine(wr, <CODE>IO.Put(\</CODE>Pickle.Special.rd for <CODE> &amp; 
        self.basename &amp; </CODE>.<CODE> &amp; identfsTxt &amp; </CODE>: non-shared obj\\n\<CODE>);</CODE>);
</EM></BLOCKQUOTE><PRE>
      EndLine(wr, &quot;obj := NEW(&quot; &amp; identfsTxt &amp; &quot;);&quot;);
      Tab(wr, 2);
      PutLine(wr, &quot;ELSE&quot;);
      EndLine(wr, &quot;RAISE Pickle.Error(\&quot;Can't unpickle subtypes of &quot; &amp;
        self.basename &amp; &quot;.&quot; &amp; identfTxt &amp; &quot;\&quot;);&quot;);
      PutLine(wr, &quot;END;&quot;);
</PRE><P>
      PutLine(wr, <CODE>IO.Put(\</CODE>Pickle.Special.rd for <CODE> &amp; 
        self.basename &amp; </CODE>.<CODE> &amp; identfsTxt &amp; </CODE>: reading space\\n\<CODE>);</CODE>);

      <PRE>PutLine(wr, &quot;space := in.read();&quot;);
</PRE><BLOCKQUOTE><EM><P>
      PutLine(wr, <CODE>IO.Put(\</CODE>Pickle.Special.rd for <CODE> &amp; 
        self.basename &amp; </CODE>.<CODE> &amp; identfsTxt &amp; </CODE>: reading shared obj\\n\<CODE>);</CODE>);
</EM></BLOCKQUOTE><PRE>
      PutLine(wr, &quot;SharedObjStubLib.StartReadPickle(obj, in, space);&quot;);

      Tab(wr,2);
      PutLine(wr, &quot;LOCK sp&quot; &amp; identfTxt &amp; &quot;.mu DO&quot;);
      EndLine(wr, &quot;sp := sp&quot; &amp; identfTxt &amp; &quot;.sp;&quot;);
      PutLine(wr, &quot;END;&quot;);
      PutLine(wr, &quot;sp.read(obj, in);&quot;);

      Tab(wr, 2);
      PutLine(wr, &quot;IF tc = TYPECODE(&quot; &amp; identfTxt &amp; &quot;) THEN&quot;);
</PRE><BLOCKQUOTE><EM><P>
      PutLine(wr, <CODE>IO.Put(\</CODE>Pickle.Special.rd for <CODE> &amp; 
        self.basename &amp; </CODE>.<CODE> &amp; identfsTxt &amp; </CODE>: setup shared obj\\n\<CODE>);</CODE>);
</EM></BLOCKQUOTE><PRE>
      PutLine(wr, &quot;obj := SharedObjStubLib.SetupNewCopy(obj, in, id, space);&quot;);
      PutLine(wr, &quot;proxy := PickleStubs.InRef(in);&quot;);
      Tab(wr, 2);
      PutLine(wr, &quot;IF obj.proxy = NIL THEN&quot;);
      EndLine(wr, &quot;obj.proxy := proxy;&quot;);
      PutLine(wr, &quot;END;&quot;);
      EndLine(wr, &quot;obj.makeProxy();&quot;);
      Tab(wr, 2);
      PutLine(wr, &quot;ELSE&quot;);
      PutLine(wr, &quot;obj.proxy := NIL;&quot;);
      EndLine(wr, &quot;obj.proxy := PickleStubs.InRef(in);&quot;);
      PutLine(wr, &quot;END;&quot;);
</PRE> <P>
      PutLine(wr, <CODE>IO.Put(\</CODE>Pickle.Special.rd for <CODE> &amp; 
        self.basename &amp; </CODE>.<CODE> &amp; identfsTxt &amp; </CODE>: done\\n\<CODE>);</CODE>);

      <PRE>EndLine(wr, &quot;RETURN obj;&quot;);
      EndLine(wr, &quot;END &quot; &amp; procedureName &amp; &quot;;&quot;);
      Nl(wr, freshLine := FALSE);

      Tab(wr, 2);
      procedureName := &quot;RegisterSpecial_&quot; &amp; identfTxt;
      Put(wr, &quot;PROCEDURE &quot; &amp; procedureName &amp; &quot; (&quot;);
      PutLine(wr, &quot;sp: &quot; &amp; identfTxt &amp; &quot;Special) =&quot;);
      PutLine(wr, &quot;&lt;* FATAL DuplicateSpecial *&gt;&quot;);
      Tab(wr, 2);
      PutLine(wr, &quot;BEGIN&quot;);
      PutLine(wr, &quot;(* we will need to NEW it here if RegisterSpecial_&quot; &amp;
        identfTxt);
      PutLine(wr, &quot;   is called from &quot; &amp; self.basename &amp; &quot; *)&quot;);
      Tab(wr, 2);
      PutLine(wr, &quot;IF sp&quot; &amp; identfTxt &amp; &quot; = NIL THEN&quot;);
      Put(wr, &quot;sp&quot; &amp; identfTxt &amp; &quot; := NEW(&quot;);
      Tab(wr, 0);
      Put(wr, identfTxt &amp; &quot;_Special, &quot;);
      Br(wr);
      Put(wr, &quot;sc := TYPECODE(&quot; &amp; identfsTxt &amp; &quot;), &quot;);
      Br(wr);
      Put(wr, &quot;mu := NEW(MUTEX)&quot;);
      EndTab(wr);
      EndLine(wr, &quot;);&quot;);
      PutLine(wr, &quot;END;&quot;);

      Tab(wr, 2);
      PutLine(wr, &quot;LOCK sp&quot; &amp; identfTxt &amp; &quot;.mu DO&quot;);
      Tab(wr, 2);
      PutLine(wr, &quot;IF sp&quot; &amp; identfTxt &amp; &quot;.registered THEN&quot;);
      EndLine(wr, &quot;RAISE DuplicateSpecial;&quot;);
      PutLine(wr, &quot;END;&quot;);
      PutLine(wr, &quot;sp&quot; &amp; identfTxt &amp; &quot;.registered := TRUE;&quot;);
      EndLine(wr, &quot;sp&quot; &amp; identfTxt &amp; &quot;.sp := sp;&quot;);
      EndLine(wr, &quot;END;&quot;);
      EndLine(wr, &quot;END &quot; &amp; procedureName &amp; &quot;;&quot;);
      Nl(wr, freshLine := FALSE);

      Tab(wr, 2);
      PutLine(wr, &quot;VAR&quot;);
      EndLine(wr, &quot;sp&quot; &amp; identfTxt &amp; &quot;: &quot; &amp; identfTxt &amp; &quot;_Special := NIL;&quot;);

      (* Add to the initializers *)
      self.initializers := self.initializers &amp;
         &quot;  IF sp&quot; &amp; identfTxt &amp; &quot; = NIL THEN\n    sp&quot; &amp; identfTxt &amp;
         &quot; := NEW(&quot; &amp; identfTxt &amp; &quot;_Special,\n       sc := TYPECODE(&quot; &amp;
         identfsTxt &amp; &quot;),\n      mu := NEW(MUTEX),\n&quot; &amp;
         &quot;      sp := NEW(&quot; &amp; identfTxt &amp;
         &quot;Special));\n  END;\n  Pickle.RegisterSpecial(sp&quot; &amp; identfTxt &amp; &quot;);\n&quot;;
    END;
  END Picklers;

PROCEDURE <A NAME="MarshalTypedVal"><procedure>MarshalTypedVal</procedure></A> (fmtWr      : Formatter.T;
                           varName    : TEXT;
                           libName    : TEXT;
                           t          : Type.T;
                           d          : Direction;
                           calling    : BOOLEAN;
                           indexDepth                 := 0;
                           maySuppress                := FALSE)
  RAISES {SOxCodeGenError.E} =
  BEGIN
    TYPECASE t OF
    | Type.Char (ch) =&gt;
        Enumeration(fmtWr, varName, libName, ch, d, 0, ORD(LAST(CHAR)));
    | Type.UserDefined (ud) =&gt;
        Enumeration(fmtWr, varName, libName, t, d, 0, LAST(ud.elts^));
    | Type.Subrange (sub) =&gt;
        IF t = Type.integer THEN
          StubLibCall(fmtWr, &quot;Integer&quot;, varName, libName, d);
        ELSIF t = Type.longint THEN
          StubLibCall(fmtWr, &quot;Longint&quot;, varName, libName, d);
        ELSE
          SubRange(fmtWr, varName, libName, t, d, sub.min, sub.max);
        END;
    | Type.Real =&gt; StubLibCall(fmtWr, &quot;Real&quot;, varName, libName, d);
    | Type.LongReal =&gt; StubLibCall(fmtWr, &quot;Longreal&quot;, varName, libName, d);
    | Type.Extended =&gt; StubLibCall(fmtWr, &quot;Extended&quot;, varName, libName, d);
    | Type.Reference (r) =&gt;
        IF Type.MayBeRefAny(r) OR NOT Type.NamedType(r) THEN
          StubLibCall(fmtWr, &quot;Ref&quot;, varName, libName, d, &quot;, -1&quot;);
        ELSE
          StubLibCall(fmtWr, &quot;Ref&quot;, varName, libName, d,
                      &quot;, TYPECODE(&quot; &amp; CodeForType.ToText(r) &amp; &quot;)&quot;);
        END;
    | Type.Array (a) =&gt;
        IF a.index = NIL THEN
          MarshalOpenArray(fmtWr, varName, libName, t, d, calling,
                           indexDepth, maySuppress);
        ELSE
          BeginOutOnly(fmtWr, libName, t, d, maySuppress);
          Formatter.Begin(fmtWr, 2);
          PutLine(fmtWr, &quot;FOR i&quot; &amp; Fmt.Int(indexDepth) &amp; &quot; := FIRST(&quot;
                           &amp; CodeForType.ToText(a.index) &amp; &quot;) TO LAST(&quot;
                           &amp; CodeForType.ToText(a.index) &amp; &quot;) DO&quot;);
          MarshalTypedVal(
            fmtWr, varName &amp; &quot;[i&quot; &amp; Fmt.Int(indexDepth) &amp; &quot;]&quot;, libName,
            a.element, d, calling, indexDepth + 1);
          EndLine(fmtWr, &quot;END;&quot;);
          EndOutOnly(fmtWr, maySuppress);
        END;
    | Type.Packed (p) =&gt;
        BeginOutOnly(fmtWr, libName, t, d, maySuppress);
        MarshalTypedVal(
          fmtWr, varName, libName, p.base, d, calling, indexDepth);
        EndOutOnly(fmtWr, maySuppress);
    | Type.Record (rec) =&gt;
        BeginOutOnly(fmtWr, libName, t, d, maySuppress);
        FOR i := 0 TO LAST(rec.fields^) DO
          MarshalTypedVal(
            fmtWr, varName &amp; &quot;.&quot; &amp; Atom.ToText(rec.fields[i].name),
            libName, rec.fields[i].type, d, calling, indexDepth);
        END;
        EndOutOnly(fmtWr, maySuppress);
    | Type.Set (s) =&gt;
        BeginOutOnly(fmtWr, libName, t, d, maySuppress);
        IF d = Direction.In THEN
          PutLine(fmtWr, varName &amp; &quot;:=&quot; &amp; CodeForType.ToText(s) &amp; &quot;{};&quot;);
          Formatter.Begin(fmtWr, 2);
          PutLine(fmtWr, &quot;FOR i&quot; &amp; Fmt.Int(indexDepth) &amp; &quot; := FIRST(&quot;
                           &amp; CodeForType.ToText(s.range) &amp; &quot;) TO LAST(&quot;
                           &amp; CodeForType.ToText(s.range) &amp; &quot;) DO&quot;);
          Formatter.Begin(fmtWr, 2);
          PutLine(fmtWr, &quot;IF &quot; &amp; libName &amp; &quot;.InBoolean(in) THEN&quot;);
          PutLine(fmtWr, varName &amp; &quot; := &quot; &amp; varName &amp; &quot; + &quot;
                           &amp; CodeForType.ToText(s) &amp; &quot;{i&quot;
                           &amp; Fmt.Int(indexDepth) &amp; &quot;};&quot;);
          EndLine(fmtWr, &quot;END&quot;)
        ELSE
          Formatter.Begin(fmtWr, 2);
          PutLine(fmtWr, &quot;FOR i&quot; &amp; Fmt.Int(indexDepth) &amp; &quot; := FIRST(&quot;
                           &amp; CodeForType.ToText(s.range) &amp; &quot;) TO LAST(&quot;
                           &amp; CodeForType.ToText(s.range) &amp; &quot;) DO&quot;);
          PutLine(fmtWr, libName &amp; &quot;.OutBoolean(out, i&quot; &amp; Fmt.Int(indexDepth)
                           &amp; &quot; IN &quot; &amp; varName &amp; &quot;);&quot;);
        END;
        EndLine(fmtWr, &quot;END;&quot;);
        EndOutOnly(fmtWr, maySuppress);
    | Type.Procedure =&gt;
        RAISE SOxCodeGenError.E(&quot;Can't have a procedure as argument or result &quot;
                                &amp; &quot;of a network object method.&quot;);
    ELSE
      RAISE SOxCodeGenError.E(&quot;Run time error -- shouldn't occur&quot;);
    END;
  END MarshalTypedVal;

PROCEDURE <A NAME="SubRange"><procedure>SubRange</procedure></A> (fmtWr   : Formatter.T;
                    varName : TEXT;
                    libName : TEXT;
                    t       : Type.Subrange;
                    d       : Direction;
                    min, max: Value.T) RAISES {SOxCodeGenError.E}=
  BEGIN
    IF t = Type.longint OR t.base = Type.longint THEN
      WITH min = NARROW(min, Value.Longint).val,
           max = NARROW(max, Value.Longint).val DO
        StubLibCall(fmtWr, &quot;Longint&quot;, varName, libName, d,
                    &quot;, &quot; &amp; Fmt.LongInt(min) &amp; &quot;, &quot; &amp; Fmt.LongInt(max));
      END;
    ELSIF t = Type.integer OR t.base = Type.integer THEN
      WITH min = NARROW(min, Value.Integer).val,
           max = NARROW(max, Value.Integer).val DO
        StubLibCall(fmtWr, &quot;Integer&quot;, varName, libName, d,
                    &quot;, &quot; &amp; Fmt.Int(min) &amp; &quot;, &quot; &amp; Fmt.Int(max));
      END;
    ELSE
      TYPECASE t.base OF
      | Type.Enumeration =&gt;
        WITH min = NARROW(min, Value.Integer).val,
             max = NARROW(max, Value.Integer).val DO
          Enumeration(fmtWr, varName, libName, t.base, d, min, max);
        END;
      | Type.Subrange =&gt;
        SubRange(fmtWr, varName, libName, t.base, d, min, max);
      ELSE
        RAISE SOxCodeGenError.E(&quot;Run time error -- shouldn't occur&quot;);
      END;
    END;
  END SubRange;

PROCEDURE <A NAME="Enumeration"><procedure>Enumeration</procedure></A> (fmtWr   : Formatter.T;
                       varName : TEXT;
                       libName : TEXT;
                       t       : Type.Enumeration;
                       d       : Direction;
                       min, max: INTEGER           ) =
  BEGIN
    IF d = Direction.In THEN
      PutLine(fmtWr, varName &amp; &quot; := VAL(&quot; &amp; libName &amp; &quot;.InInteger(in, &quot;
                       &amp; Fmt.Int(min) &amp; &quot;,&quot; &amp; Fmt.Int(max) &amp; &quot;), &quot;
                       &amp; CodeForType.ToText(t) &amp; &quot;);&quot;);
    ELSE
      PutLine(fmtWr, libName &amp; &quot;.OutInteger(out, ORD(&quot; &amp; varName &amp; &quot;));&quot;);
    END;
  END Enumeration;

PROCEDURE <A NAME="StubLibCall"><procedure>StubLibCall</procedure></A> (fmtWr  : Formatter.T;
                       proc   : TEXT;
                       varName: TEXT;
                       libName: TEXT;
                       d      : Direction;
                       extra                  := &quot;&quot;) =
  BEGIN
    IF d = Direction.In THEN
      PutLine(fmtWr, varName &amp; &quot; := &quot; &amp; libName &amp; &quot;.In&quot; &amp; proc &amp; &quot;(in&quot;
                       &amp; extra &amp; &quot;);&quot;);
    ELSE
      PutLine(fmtWr, libName &amp; &quot;.Out&quot; &amp; proc &amp; &quot;(out, &quot; &amp; varName &amp; &quot;);&quot;);
    END;
  END StubLibCall;

PROCEDURE <A NAME="StubLibCallNoRep"><procedure>StubLibCallNoRep</procedure></A> (fmtWr  : Formatter.T;
                            proc   : TEXT;
                            varName: TEXT;
                            libName: TEXT;
                            d      : Direction;
                            extra                  := &quot;&quot;) =
  BEGIN
    IF d = Direction.In THEN
      PutLine(fmtWr, varName &amp; &quot; := &quot; &amp; libName &amp; &quot;.In&quot; &amp; proc &amp; &quot;(in&quot;
                       &amp; extra &amp; &quot;);&quot;);
    ELSE
      PutLine(fmtWr, libName &amp; &quot;.Out&quot; &amp; proc &amp; &quot;(out, &quot; &amp; varName &amp; &quot;);&quot;);
    END;
  END StubLibCallNoRep;

PROCEDURE <A NAME="BeginOutOnly"><procedure>BeginOutOnly</procedure></A> (           fmtWr      : Formatter.T;
                                   libName    : TEXT;
                        &lt;*UNUSED*&gt; t          : Type.T;
                                   d          : Direction;
                                   maySuppress: BOOLEAN      ) =
  VAR dataPresent := TRUE;       (* Could check for size *)
  (* When recognizing pragma, dataPresent determined by
     methods[i].formals[j].outOnly *)
  BEGIN
    IF maySuppress THEN
      IF d = Direction.Out THEN
        PutLine(fmtWr, &quot;dataPresent := &quot; &amp; Fmt.Bool(dataPresent) &amp; &quot;;&quot;);
      END;
      StubLibCallNoRep(fmtWr, &quot;Boolean&quot;, &quot;dataPresent&quot;, libName, d);
      Formatter.Begin(fmtWr, 2);
      PutLine(fmtWr, &quot;IF dataPresent THEN &quot;);
    END;
  END BeginOutOnly;

PROCEDURE <A NAME="EndOutOnly"><procedure>EndOutOnly</procedure></A> (fmtWr: Formatter.T; maySuppress: BOOLEAN) =
  BEGIN
    IF maySuppress THEN PutLine(fmtWr, &quot;END;&quot;); Formatter.End(fmtWr); END;
  END EndOutOnly;

PROCEDURE <A NAME="MarshalOpenArray"><procedure>MarshalOpenArray</procedure></A> (fmtWr      : Formatter.T;
                            varName    : TEXT;
                            libName    : TEXT;
                            a          : Type.OpenArray;
                            d          : Direction;
                            calling    : BOOLEAN;
                            indexDepth : INTEGER;
                            maySuppress: BOOLEAN         )
  RAISES {SOxCodeGenError.E} =
  VAR
    nDimensions                        := a.openDimensions;
    aName, baseName, boundList: Text.T;
    component                 : Type.T;
  BEGIN
    WITH Put    = Formatter.PutText,
         Tab    = Formatter.Begin,
         EndTab = Formatter.End      DO
      IF calling THEN            (* Must marshal/unmarshal array bounds *)
        IF d = Direction.Out THEN
          StubLibCall(
            fmtWr, &quot;Integer&quot;, &quot;NUMBER(&quot; &amp; varName &amp; &quot;)&quot;, libName, d);
          aName := varName &amp; &quot;[0&quot;;
          FOR i := 2 TO nDimensions DO
            StubLibCall(
              fmtWr, &quot;Integer&quot;, &quot;NUMBER(&quot; &amp; aName &amp; &quot;])&quot;, libName, d);
            aName := aName &amp; &quot;, 0&quot;;
          END;
          baseName := varName;
        ELSE
          Put(fmtWr, &quot;WITH n1 = &quot; &amp; libName &amp; &quot;.InInteger(in)&quot;);
          boundList := &quot;n1&quot;;
          FOR i := 2 TO nDimensions DO
            PutLine(fmtWr, &quot;,&quot;);
            Put(fmtWr, &quot;    n&quot; &amp; Fmt.Int(i) &amp; &quot; = &quot; &amp; libName
                         &amp; &quot;.InInteger(in)&quot;);
            boundList := boundList &amp; &quot;, n&quot; &amp; Fmt.Int(i);
          END;
          PutLine(fmtWr, &quot; DO&quot;);
          PutLine(fmtWr, &quot;  &quot; &amp; varName &amp; &quot; := NEW(&quot;
                           &amp; CodeForType.ToText(a.refArray) &amp; &quot;, &quot;
                           &amp; boundList &amp; &quot;);&quot;);
          PutLine(fmtWr, &quot;END;&quot;);
          baseName := varName &amp; &quot;^&quot;;
        END;
      ELSE
        IF d = Direction.Out THEN
          baseName := varName &amp; &quot;^&quot;;
        ELSE
          baseName := varName;
        END;
      END;

      (* Suppress actual data for &lt;*OUTPUT*&gt; params on call *)
      BeginOutOnly(fmtWr, libName, a, d, maySuppress);

      Tab(fmtWr, 2);
      PutLine(fmtWr, &quot;FOR n1 := 0 TO LAST(&quot; &amp; baseName &amp; &quot;) DO&quot;);
      aName := varName &amp; &quot;[n1&quot;;
      component := a.element;
      FOR i := 2 TO nDimensions DO
        Tab(fmtWr, 2);
        PutLine(
          fmtWr, &quot;FOR n&quot; &amp; Fmt.Int(i) &amp; &quot; := 0 TO LAST(&quot; &amp; aName &amp; &quot;]) DO&quot;);
        aName := aName &amp; &quot;,  n&quot; &amp; Fmt.Int(i);
        component := NARROW(component, Type.OpenArray).element;
      END;
      MarshalTypedVal(
        fmtWr, aName &amp; &quot;]&quot;, libName, component, d, calling, indexDepth);
      FOR i := 1 TO nDimensions DO
        EndTab(fmtWr);
        PutLine(fmtWr, &quot;END;&quot;);  (* End FOR Loop *)
      END;
      EndOutOnly(fmtWr, maySuppress);
    END;
  END MarshalOpenArray;

BEGIN
END SOxModuleSOCode.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface ImportList is in:
</A><UL>
<LI><A HREF="ImportList.i3.html#0TOP0">sharedobjgen/src/ImportList.i3</A>
<LI><A HREF="../../stablegen/src/ImportList.i3.html#0TOP0">stablegen/src/ImportList.i3</A>
</UL>
<P>
<HR>
<A NAME="x2">interface Type is in:
</A><UL>
<LI><A HREF="../../cm3ide/src/nodes/Type.i3.html#0TOP0">cm3ide/src/nodes/Type.i3</A>
<LI><A HREF="../../m3front/src/types/Type.i3.html#0TOP0">m3front/src/types/Type.i3</A>
<LI><A HREF="Type.i3.html#0TOP0">sharedobjgen/src/Type.i3</A>
<LI><A HREF="../../stablegen/src/Type.i3.html#0TOP0">stablegen/src/Type.i3</A>
<LI><A HREF="../../stubgen/src/Type.i3.html#0TOP0">stubgen/src/Type.i3</A>
</UL>
<P>
<HR>
<A NAME="x3">interface CodeForType is in:
</A><UL>
<LI><A HREF="CodeForType.i3.html#0TOP0">sharedobjgen/src/CodeForType.i3</A>
<LI><A HREF="../../stubgen/src/CodeForType.i3.html#0TOP0">stubgen/src/CodeForType.i3</A>
</UL>
<P>
<HR>
<A NAME="x4">interface Value is in:
</A><UL>
<LI><A HREF="../../m3front/src/values/Value.i3.html#0TOP0">m3front/src/values/Value.i3</A>
<LI><A HREF="Value.i3.html#0TOP0">sharedobjgen/src/Value.i3</A>
<LI><A HREF="../../stablegen/src/Value.i3.html#0TOP0">stablegen/src/Value.i3</A>
<LI><A HREF="../../stubgen/src/Value.i3.html#0TOP0">stubgen/src/Value.i3</A>
</UL>
<P>
<HR>
<A NAME="x5">interface StubCode is in:
</A><UL>
<LI><A HREF="StubCode.i3.html#0TOP0">sharedobjgen/src/StubCode.i3</A>
<LI><A HREF="../../stubgen/src/StubCode.i3.html#0TOP0">stubgen/src/StubCode.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
