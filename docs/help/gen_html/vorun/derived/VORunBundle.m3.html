<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: vorun/derived/VORunBundle.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>vorun/derived/VORunBundle.m3</H2></A><HR>
<inModule>
<PRE>MODULE <module><implements><A HREF="VORunBundle.i3.html">VORunBundle</A></implements></module>;
</PRE><BLOCKQUOTE><EM> Generated by m3bundle; see its manpage. </EM></BLOCKQUOTE><PRE>

IMPORT <A HREF="../../libm3/src/bundleintf/Bundle.i3.html">Bundle</A>, <A HREF="../../libm3/src/bundleintf/BundleRep.i3.html">BundleRep</A>, <A HREF="../../m3core/src/text/Text.i3.html">Text</A>;
IMPORT <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="../../libm3/src/rw/TextWr.i3.html">TextWr</A>;

TYPE T = Bundle.T OBJECT OVERRIDES
           get      := LookUp;
           getNames := GetNames;
         END;

TYPE Texts = REF ARRAY OF TEXT;

VAR
  bundle: T     := NIL;
  names : Texts := NIL;

PROCEDURE <A NAME="Get"><procedure>Get</procedure></A>(): Bundle.T =
  BEGIN
    IF (bundle = NIL) THEN bundle := NEW (T) END;
    RETURN bundle;
  END Get;

PROCEDURE <A NAME="GetNames"><procedure>GetNames</procedure></A> (&lt;*UNUSED*&gt; self: T): Texts =
  BEGIN
    IF names = NIL THEN
      names := NEW (Texts, NUMBER (Names));
      names^ := Names;
    END;
    RETURN names;
  END GetNames;

PROCEDURE <A NAME="LookUp"><procedure>LookUp</procedure></A> (&lt;*UNUSED*&gt; self: T;  element: TEXT): TEXT =
  BEGIN
    FOR i := 0 TO LAST (Names)-1 DO
      IF Text.Equal (Names[i], element) THEN
        IF Elements[i] = NIL THEN Elements[i] := GetElt (i) END;
        RETURN Elements[i];
      END;
    END;
    RETURN NIL;
  END LookUp;

CONST Names = ARRAY [0..5] OF TEXT {
  &quot;vocheckpt.obl&quot;,
  &quot;vorestrict.obl&quot;,
  &quot;vowidgets.obl&quot;,
  &quot;volib.obl&quot;,
  &quot;templates.obl&quot;,
  NIL
};

VAR Elements := ARRAY [0..5] OF TEXT {
  NIL (* E0 .. E0_1 *),
  NIL (* E1 .. E1_1 *),
  NIL (* E2 .. E2_5 *),
  NIL (* E3 .. E3_14 *),
  NIL (* E4 .. E4_3 *),
  NIL
};

PROCEDURE <A NAME="GetElt"><procedure>GetElt</procedure></A> (n: INTEGER): TEXT =
  &lt;*FATAL Thread.Alerted, Wr.Failure *&gt;
  VAR wr := TextWr.New ();
  BEGIN
    CASE n OF
    | 0 =&gt;
        Wr.PutText (wr, E0);
        Wr.PutText (wr, E0_0);
        Wr.PutText (wr, E0_1);
    | 1 =&gt;
        Wr.PutText (wr, E1);
        Wr.PutText (wr, E1_0);
        Wr.PutText (wr, E1_1);
    | 2 =&gt;
        Wr.PutText (wr, E2);
        Wr.PutText (wr, E2_0);
        Wr.PutText (wr, E2_1);
        Wr.PutText (wr, E2_2);
        Wr.PutText (wr, E2_3);
        Wr.PutText (wr, E2_4);
        Wr.PutText (wr, E2_5);
    | 3 =&gt;
        Wr.PutText (wr, E3);
        Wr.PutText (wr, E3_0);
        Wr.PutText (wr, E3_1);
        Wr.PutText (wr, E3_2);
        Wr.PutText (wr, E3_3);
        Wr.PutText (wr, E3_4);
        Wr.PutText (wr, E3_5);
        Wr.PutText (wr, E3_6);
        Wr.PutText (wr, E3_7);
        Wr.PutText (wr, E3_8);
        Wr.PutText (wr, E3_9);
        Wr.PutText (wr, E3_10);
        Wr.PutText (wr, E3_11);
        Wr.PutText (wr, E3_12);
        Wr.PutText (wr, E3_13);
        Wr.PutText (wr, E3_14);
    | 4 =&gt;
        Wr.PutText (wr, E4);
        Wr.PutText (wr, E4_0);
        Wr.PutText (wr, E4_1);
        Wr.PutText (wr, E4_2);
        Wr.PutText (wr, E4_3);
    ELSE (*skip*)
    END;
    RETURN TextWr.ToText (wr);
  END GetElt;

CONST E0 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Tue Jan &quot;
 &amp; &quot;10 11:50:06 PST 1995 by mhb     *)\n\nmodule vocheckpt;\n(* used by mod&quot;
 &amp; &quot;ule \&quot;volib\&quot; *)\nsys_pushSilence();\n\n(* Stuff to checkpoint\n\n\t== &quot;
 &amp; &quot;all other attributes are set by method calls ==\n\n\tboolean ::=  initi&quot;
 &amp; &quot;alValue := b.getValue();\n\tbrowser ::= Selections/Selection\n\tchoice &quot;
 &amp; &quot;::=  initialValue := c.getValue();\n\tfilebrowser ::=  Value := fb.getF&quot;
 &amp; &quot;ilename();\n\tform =&gt; (checkpoint open/close state of anchored forms)\n&quot;
 &amp; &quot;\thscroll ::= Val := h.getValue();\n\tnumeric ::= Val := n.getValue();\n&quot;
 &amp; &quot;\ttextedit ::=  teContents :=  text_encode(t.getText());\n\ttypein  ::=&quot;
 &amp; &quot;  tyInit := text_encode(t.getText());\n\tvscroll  ::=  Val := v.getValu&quot;
 &amp; &quot;e();\n\t\n*)\n(* generic routine - forward declaration *)\nvar checkptS&quot;
 &amp; &quot;X = 0;\nlet childOffRed = 20;\n\nlet genericCP = proc(nv)\n\tlet width &quot;
 &amp; &quot;= form_getInt(nv.form, nv.name &amp; \&quot;filter\&quot;, \&quot;EastEdge\&quot;) -\n\t\t\t   &quot;
 &amp; &quot; form_getInt(nv.form, nv.name &amp; \&quot;filter\&quot;, \&quot;WestEdge\&quot;);\n\tlet heigh&quot;
 &amp; &quot;t = form_getInt(nv.form, nv.name &amp; \&quot;filter\&quot;, \&quot;SouthEdge\&quot;) -\n\t\t\t&quot;
 &amp; &quot;    form_getInt(nv.form, nv.name &amp; \&quot;filter\&quot;, \&quot;NorthEdge\&quot;);\n\n\tif &quot;
 &amp; &quot;(width isnot 0) and (height isnot 0) then\n\t(* true when the widget is&quot;
 &amp; &quot; mapped *)\n\t\tnv.height := height; nv.width := width;\n\t\tif nv.clas&quot;
 &amp; &quot;s is \&quot;form\&quot; then nv.InitialState := \&quot;Active\&quot;; end;\n\t\tlet p = nv.&quot;
 &amp; &quot;parent;\n\t\tif p isnot 0 then\n\t\t\tnv.x := form_getInt(nv.form, nv.n&quot;
 &amp; &quot;ame &amp; \&quot;filter\&quot;, \&quot;WestEdge\&quot;) -\n\t\t\t\t     form_getInt(p.form, p.n&quot;
 &amp; &quot;ame &amp; \&quot;filter\&quot;, \&quot;WestEdge\&quot;);\n\t\t\tnv.y := form_getInt(nv.form, nv&quot;
 &amp; &quot;.name &amp; \&quot;filter\&quot;, \&quot;NorthEdge\&quot;) -\n\t\t\t\t     form_getInt(p.form, &quot;
 &amp; &quot;p.name &amp; \&quot;filter\&quot;, \&quot;NorthEdge\&quot;);\n\t\t\tif p.class is \&quot;form\&quot; then&quot;
 &amp; &quot;\n\t\t\t\tif p.ParentForm is 0 then\n\t\t\t\t\tnv.y := nv.y + childOffR&quot;
 &amp; &quot;ed;\n\t\t\t\tend;\n\t\t\tend;\n\t\telse\t\n\t\t\tnv.x := form_getInt(nv&quot;
 &amp; &quot;.form, nv.name &amp; \&quot;filter\&quot;, \&quot;WestEdge\&quot;);\n\t\t\tnv.y := form_getInt(&quot;
 &amp; &quot;nv.form, nv.name &amp; \&quot;filter\&quot;, \&quot;NorthEdg&quot;;

CONST E0_0 =
   &quot;e\&quot;);\n\t\tend;\n\telsif nv.class is \&quot;form\&quot; then\n\t\tnv.InitialState&quot;
 &amp; &quot; := \&quot;Vanish\&quot;;\n\t\t(* otherwise this widget may be unmapped because a&quot;
 &amp; &quot; parent is unmapped *)\n\tend;\nend;\n\nlet splitCP = proc(nv)\n\tgener&quot;
 &amp; &quot;icCP(nv);\n\tforeach child in nv.children do\n\t\tcheckptSX(child);\t\t&quot;
 &amp; &quot;\n\tend;\n\nend;\n\nlet formCP = proc(nv)\n\n\n\tlet oldwidth = nv.widt&quot;
 &amp; &quot;h;\n\tlet oldheight = nv.height;\n\n\tsplitCP(nv); (* will also do gene&quot;
 &amp; &quot;ric *)\n\n\n\tlet incwidth = nv.width - oldwidth;\n\tlet incheight = nv&quot;
 &amp; &quot;.height - oldheight;\n\t\n\tnv.ShrinkX := nv.ShrinkX + incwidth;\n\tnv.&quot;
 &amp; &quot;StretchX := nv.StretchX - incwidth;\n\tnv.ShrinkY := nv.ShrinkY + inche&quot;
 &amp; &quot;ight;\n\tnv.StretchY := nv.StretchY - incheight;\n\n\tif nv.ShrinkX &lt; 0&quot;
 &amp; &quot; then nv.ShrinkX := 0 end;\n\tif nv.ShrinkY &lt; 0 then nv.ShrinkY := 0 en&quot;
 &amp; &quot;d;\n\tif nv.StretchX &lt; 0 then nv.StretchX := 0 end;\n\tif nv.StretchY &lt;&quot;
 &amp; &quot; 0 then nv.StretchY := 0 end;\n\t\n\n\tforeach child in nv.ChildForms d&quot;
 &amp; &quot;o\n\t\tcheckptSX(child);\t\t\n\tend;\n\t(* if this is an anchored form &quot;
 &amp; &quot;... *)\n\tlet pf = nv.ParentForm;\n\tif pf isnot 0 then\n\t\tnv.x := fo&quot;
 &amp; &quot;rm_getInt(nv.form, nv.name &amp; \&quot;filter\&quot;, \&quot;WestEdge\&quot;) -\n\t\t\t     fo&quot;
 &amp; &quot;rm_getInt(pf.form, pf.name &amp; \&quot;filter\&quot;, \&quot;WestEdge\&quot;);\n\t\tnv.y := fo&quot;
 &amp; &quot;rm_getInt(nv.form, nv.name &amp; \&quot;filter\&quot;, \&quot;NorthEdge\&quot;) -\n\t\t\t     f&quot;
 &amp; &quot;orm_getInt(pf.form, pf.name &amp; \&quot;filter\&quot;, \&quot;NorthEdge\&quot;);\t\t\n\telse\n&quot;
 &amp; &quot;\t\t(* Need to compensate for absence of title in top level form.\n\t\t&quot;
 &amp; &quot;    The s-expression is computed after reducing the given height\n\t\t &quot;
 &amp; &quot;   by childOffRed, so when we are computing the height from the\n\t\t  &quot;
 &amp; &quot;   vbt we need to add this amount  *)\n\t\n\t\tnv.height := nv.height +&quot;
 &amp; &quot; childOffRed;\n        end;\n\tnv.CheckpointedXY := true;\nend;\n\n(* p&quot;
 &amp; &quot;rocedure dispatching kludge *)\ncheckptSX := proc(wid)\n\tvar dogeneric&quot;
 &amp; &quot; = true;\n\tif wid.class is \&quot;form\&quot; then\n\t\tformCP(wid);\n\t\tdogene&quot;
 &amp; &quot;ric := false;\n    \telsif wid.class is \&quot;frame\&quot; then\n\t\tsplitCP(wid&quot;
 &amp; &quot;);\n\t\tdogeneric := false;\n\telsif wid.class is \&quot;boolean\&quot;  then\n\t&quot;
 &amp; &quot;\twid.initialValue := wid.getValue();\n\telsif wid.class is \&quot;browser\&quot;&quot;
 &amp; &quot; then\n\t\t\t(* getSelection automatically does the checkpointing! *)\n&quot;
 &amp; &quot;\t\t\twid.getSelection();\n\t\t\tok\n\telsif wid.class is \&quot;choi&quot;;

CONST E0_1 =
   &quot;ce\&quot; then\n\t\twid.initialValue := wid.getValue();\n\telsif wid.class i&quot;
 &amp; &quot;s  \&quot;filebrowser\&quot; then \n\t\twid.Value := text_encode(wid.getFilename(&quot;
 &amp; &quot;));\n\telsif wid.class is \&quot;hscroll\&quot; then\n\t\t wid.Val := wid.getValu&quot;
 &amp; &quot;e();\n\telsif wid.class is \&quot;numeric\&quot; then\n\t\twid.Val := wid.getValu&quot;
 &amp; &quot;e();\n\telsif wid.class is \&quot;textedit\&quot; then\n\t\twid.teContents :=  te&quot;
 &amp; &quot;xt_encode(wid.getText());\n\telsif wid.class is \&quot;typein\&quot; then\n\t\twi&quot;
 &amp; &quot;d.tyInit := text_encode(wid.getText());\n\telsif wid.class is \&quot;vscroll&quot;
 &amp; &quot;\&quot; then  \n\t\twid.Val := wid.getValue();\n\tend;\n\tif dogeneric then\n&quot;
 &amp; &quot;\t\tgenericCP(wid);\n\tend;\n\tok;\t\nend;\n\n\nlet rebuildWidget = pro&quot;
 &amp; &quot;c(wid)\n\t(* not applicable to forms *)\n\t(* assume already checkpoint&quot;
 &amp; &quot;ed *)\n\tlet f = wid.form;\n\tlet widpar = wid.parent;\n\n\tvar offsetR&quot;
 &amp; &quot;ed = 0;\n\tif widpar.class is \&quot;form\&quot; then\n\t\tif widpar.ParentForm i&quot;
 &amp; &quot;s 0 then\n\t\t\toffsetRed := 20;\n\t\tend\n\tend;\n\tlet name = wid.nam&quot;
 &amp; &quot;e &amp; \&quot;top\&quot;;\n\tlet zname = widpar.name &amp; \&quot;zsplit\&quot;;\n\tlet lev = form&quot;
 &amp; &quot;_childIndex(f, zname, name);\n\n        let nsx = computeSX(wid); (* th&quot;
 &amp; &quot;is mutates the name *)\n\tvar visibility = \&quot;\&quot;;\n\t\tif wid.InitialSta&quot;
 &amp; &quot;te isnot \&quot;Vanish\&quot; then\n\t\t\tvisibility := \&quot;Open\&quot;;\n\t\tend;\n\tle&quot;
 &amp; &quot;t newsx =  \&quot;(ZChild %\&quot; &amp; wid.name &amp; \&quot;top (At \&quot; &amp; fmt_int(wid.x) &amp; \&quot;&quot;
 &amp; &quot;  \&quot;\n                      &amp; fmt_int(wid.y - offsetRed) &amp; \&quot;  NW Absol&quot;
 &amp; &quot;ute)  \&quot; &amp; visibility &amp; \&quot;\\n \&quot; &amp;\n                      ResizeString(&quot;
 &amp; &quot;wid) &amp; nsx &amp; \&quot;)\&quot;;\n\n\tform_delete(f, \tzname, name);\n\tform_insert(&quot;
 &amp; &quot;f, zname, newsx, lev);\n\twid.SELF.VOAttachCBacks(); (* all callbacks *&quot;
 &amp; &quot;)\nend;\n\nlet refreshWidget = proc(wid) \n\tcheckptSX(wid);\n\trebuild&quot;
 &amp; &quot;Widget(wid);\nend;\n\nsys_popSilence();\n&quot;;

CONST E1 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Tue Jan &quot;
 &amp; &quot;10 11:50:14 PST 1995 by mhb     *)\n\nmodule vorestrict;\n\nsys_pushSil&quot;
 &amp; &quot;ence();\n\nvar isAllowed = 0;\nvar isBlocked = 0;\n\n(\nvar allowList =&quot;
 &amp; &quot; [];\nvar blockList = [];\nlet nullstring = proc(t)\n\tlet len = text_l&quot;
 &amp; &quot;ength(t);\n\tvar null = true;\n\tfor i = 0 to len-1 do\n\t\tlet c = tex&quot;
 &amp; &quot;t_char(t, i);\n\t\tnull := null and (c is \' \')\n\t\t\t\tor (c is \'\\&quot;
 &amp; &quot;t\');\n\tend;\n\tnull;\nend;\n\n(* test if a is a postfix of b *)\nlet &quot;
 &amp; &quot;postfix = proc(a,b) \n\tlet alen = text_length(a);\n\tlet blen = text_l&quot;
 &amp; &quot;ength(b);\n\tif (alen &gt; blen) then\n\t\tfalse;\n\telse\n\t\ta is text_s&quot;
 &amp; &quot;ub(b, blen-alen, alen);\t\t\t\n\tend;\nend;\n\n(* test if a is a prefix&quot;
 &amp; &quot; of b *)\nlet prefix = proc(a,b)\n\tlet alen = text_length(a);\n\tlet b&quot;
 &amp; &quot;len = text_length(b);\n\tif (alen &gt; blen) then\n\t\tfalse;\n\telse\n\t\t&quot;
 &amp; &quot;a is text_sub(b, 0, alen);\t\t\t\n\tend;\n end;\n\nlet equal = proc(a,b&quot;
 &amp; &quot;) a is b end;\n\ntry \nlet txt = volibLocal.LoadFile(sys_getEnvVar(\&quot;HO&quot;
 &amp; &quot;ME\&quot;)\n\t&amp; \&quot;/.vorestrict\&quot;);\nlet list = text_explode(\&quot;\\n\&quot;, txt);\n&quot;
 &amp; &quot;var curmode = \&quot;\&quot;;\n\nforeach line in list do\n\tif not (nullstring(li&quot;
 &amp; &quot;ne)) then\n\t\tlet teline = text_explode(\&quot; \\t\&quot;, line);\n\t\tif text_&quot;
 &amp; &quot;char(teline[0], 0) is \'#\' then\n\t\t   ok; (* comment ignore *)\n\t\t&quot;
 &amp; &quot;elsif \n\t\t     text_char(teline[0], 0) is \'@\' then\t\n\t\t\tcurmode&quot;
 &amp; &quot; := teline[0];\n\t\telse\n\t\t\tvar thislist = [];\n\t\t\tvar flexible &quot;
 &amp; &quot;= false;\n\t\t\tforeach word in text_explode(\&quot; \\t\&quot;, line) do\n\t\t\t&quot;
 &amp; &quot;\tif word is \&quot;...\&quot; then flexible := true;\n\t\t\t\telsif text_char(wo&quot;
 &amp; &quot;rd, text_length(word)-1)\n\t\t\t\t\tis \'*\' then\n\t\t\t\tthislist := &quot;
 &amp; &quot;thislist @ \n\t\t\t\t[{pattern =&gt;  text_sub(word, 0,\n\t\t\t\t\t\ttext_&quot;
 &amp; &quot;length(word) -1),\n\t\t\t\t  check =&gt; \&quot;isPrefix?\&quot;}];\n\t\t\t\t   \n\t&quot;
 &amp; &quot;\t\t\telsif text_char(word,0) is \'*\' then\n\t\t\t\tthislist := thisli&quot;
 &amp; &quot;st @\n                                [{pattern =&gt;  text_sub(word, 1,\n&quot;
 &amp; &quot;                                                text_length(word) -1),\n&quot;
 &amp; &quot;                 &quot;;

CONST E1_0 =
   &quot;                 check =&gt; \&quot;isPostfix?\&quot;}];\n\t\t\t\telse\n\t\t\t\tthis&quot;
 &amp; &quot;list := thislist @\n\t\t\t\t[{pattern =&gt; word, check =&gt; \&quot;isEqual?\&quot;}]\n&quot;
 &amp; &quot;\t\t\t\tend;\n\t\t\tend;\n\t\t\tif curmode is \&quot;@allow\&quot; then\n\t\t\t\t&quot;
 &amp; &quot;allowList := allowList @ \n\t\t\t\t[{FlexibleArity =&gt; flexible,\n\t\t\t&quot;
 &amp; &quot;           Words =&gt; thislist } ];\n\t\t\telsif curmode is \&quot;@block\&quot; th&quot;
 &amp; &quot;en\n\t\t\t\tblockList := blockList @ \n\t\t\t\t[{FlexibleArity =&gt; flexi&quot;
 &amp; &quot;ble,\n\t\t\t\t   Words =&gt; thislist}];\n\t\t\tend;\n\t\tend;\n\tend;\nen&quot;
 &amp; &quot;d;\nexcept\nelse\nend; \n\nlet matches = proc(datum, cmd)\n\tif  \n\t  &quot;
 &amp; &quot;    (cmd.FlexibleArity  and  (#(datum) &gt;= #(cmd.Words)))\n\t\tor \n\t  &quot;
 &amp; &quot;    (#(datum) is #(cmd.Words))\n       then\n\t\t  var matches = true;\n&quot;
 &amp; &quot;\t\t  for i = 0 to #(cmd.Words)-1 do\n\t\t     let chk = cmd.Words[i].c&quot;
 &amp; &quot;heck;\n\t\t     if chk is \&quot;isEqual?\&quot; then \n\t\t\tmatches := matches &quot;
 &amp; &quot;and equal(datum[i], cmd.Words[i].pattern);\n\t\t     elsif chk is \&quot;isP&quot;
 &amp; &quot;refix?\&quot; then \n\t\t\tmatches := matches and prefix(cmd.Words[i].patter&quot;
 &amp; &quot;n, datum[i]);\n\t\t     else\n\t\t \tmatches := matches and postfix(cmd&quot;
 &amp; &quot;.Words[i].pattern, datum[i]);\n\t\t     end;\n\t\t  end;  \t   \n \t\tm&quot;
 &amp; &quot;atches;\n\telse\n\t \tfalse;\n\tend;\nend;\n\nisAllowed := proc(cmd)\n\t&quot;
 &amp; &quot;var allowed = false;\n\tforeach i in allowList do\n\t\tallowed := allow&quot;
 &amp; &quot;ed or matches(cmd, i);\n\tend;\n\tallowed;\nend;\n\nisBlocked := proc(c&quot;
 &amp; &quot;md)\n\tvar blocked = false;\n\tforeach i in blockList do\n\t\tblocked :&quot;
 &amp; &quot;= blocked or matches(cmd, i);\n\tend;\n\tblocked;\nend;\n\n);\n\n\nlet &quot;
 &amp; &quot;prcs = process_new(processor, [\&quot;voquery\&quot;], false);\n\nlet inpipe = pr&quot;
 &amp; &quot;ocess_out(prcs);\nlet outpipe = process_in(prcs);\n\nlet askUser = proc&quot;
 &amp; &quot;(mesg)\n\twr_putText(outpipe, mesg &amp; \&quot;\\n\&quot;);\n\twr_flush(outpipe);\n\t&quot;
 &amp; &quot;rd_getChar(inpipe) is \'y\';\nend;\n\n\nlet protViolation  = exception(&quot;
 &amp; &quot;\&quot;Protection Violation\&quot;);\n\n(* Redefine the restriction procs *)\npro&quot;
 &amp; &quot;cessNew := proc(nameAndArgs, mergeOut) \n\tlet cmdlist = [\&quot;processNew\&quot;&quot;
 &amp; &quot;] @ nameAndArgs;\n\tif isAllowed(cmdlist) then\n\t\tprocess_new(process&quot;
 &amp; &quot;or, nameAndArgs, mergeOut);\n\telsif not (isBlocked(cmdlist)) then\n\t\t&quot;
 &amp; &quot;let msg = \&quot;Start Process : \&quot; &amp; text_implode(\' \', nameAndArgs) &amp; \&quot; &quot;
 &amp; &quot;?\&quot;;\n\t\tif askUser(msg) then\n\t\t\tprocess_new(processor, nameAndArg&quot;
 &amp; &quot;s, mergeOut)\n\t\telse\n\t\t\t ra&quot;;

CONST E1_1 =
   &quot;ise(protViolation)\n\t\tend;\n\telse\n\t\traise(protViolation)\t\n\tend&quot;
 &amp; &quot;;\nend;\n \n\nrdOpen := proc(fnm) \n\tlet cmdlist = [\&quot;rdOpen\&quot;,  fnm];&quot;
 &amp; &quot;\n\tif isAllowed(cmdlist) then\n\t\t\trd_open(fileSys, fnm);\n\telsif n&quot;
 &amp; &quot;ot (isBlocked(cmdlist)) then\n\t\tlet msg = \&quot;Read File: \&quot; &amp; fnm &amp; \&quot; &quot;
 &amp; &quot;?\&quot;;\n\t\tif askUser(msg) then\n\t\t\trd_open(fileSys, fnm);\n\t\telse\n&quot;
 &amp; &quot;\t\t\t raise(protViolation)\n\t\tend;\n\telse\n\t\traise(protViolation)&quot;
 &amp; &quot;;\n\tend;\nend;\n \nwrOpen := proc(fnm) \n\tlet cmdlist = [\&quot;wdOpen\&quot;, &quot;
 &amp; &quot; fnm];\n\tif isAllowed(cmdlist) then\n\t\t\twr_open(fileSys, fnm);\n\te&quot;
 &amp; &quot;lsif not (isBlocked(cmdlist)) then\n\t\tlet msg = \&quot;Write File: \&quot; &amp; fn&quot;
 &amp; &quot;m &amp; \&quot; ?\&quot;;\n\t\tif askUser(msg) then\n\t\t\twr_open(fileSys, fnm);\n\t&quot;
 &amp; &quot;\telse\n\t\t\t raise(protViolation)\n\t\tend;\n\telse\n\t\traise(protVi&quot;
 &amp; &quot;olation);\n\tend;\nend;\n\nwrOpenAppend := proc(fnm) \n\tlet cmdlist = &quot;
 &amp; &quot;[\&quot;wrOpenAppend\&quot;,  fnm];\n\tif isAllowed(cmdlist) then\n\t\t\twr_openA&quot;
 &amp; &quot;ppend(fileSys, fnm);\n\telsif not (isBlocked(cmdlist)) then\n\t\tlet ms&quot;
 &amp; &quot;g = \&quot;Append to File: \&quot; &amp; fnm &amp; \&quot; ?\&quot;;\n\t\tif askUser(msg) then\n\t\t&quot;
 &amp; &quot;\twr_openAppend(fileSys, fnm);\n\t\telse\n\t\t\t raise(protViolation)\n&quot;
 &amp; &quot;\t\tend;\n\telse\n\t\traise(protViolation);\n\tend;\nend;\n\nvolibLocal&quot;
 &amp; &quot;.processNew := meth(s, n , mer)\n\tprocessNew(n, mer)\nend;\n\nvolibLoc&quot;
 &amp; &quot;al.rdOpen := meth(s, fnm)\n\trdOpen(fnm)\nend;\n\nvolibLocal.wrOpen := &quot;
 &amp; &quot;meth(s, fnm)\n\twrOpen(fnm)\nend;\n\nvolibLocal.wrOpenAppend := meth(s,&quot;
 &amp; &quot; fnm)\n\twrOpenAppend(fnm)\nend;\n\n(* After this if  processor, fileSy&quot;
 &amp; &quot;s and fileSysReader\n    are hidden these three procedures are the only&quot;
 &amp; &quot;\n    means of accessing the processor/filesystem *)\n\nsys_popSilence(&quot;
 &amp; &quot;);\n&quot;;

CONST E2 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Tue Jan &quot;
 &amp; &quot;10 11:50:26 PST 1995 by mhb     *)\n\nmodule vowidgets;\n(* used by mod&quot;
 &amp; &quot;ule \&quot;volib\&quot; *)\n(* requires module \&quot;templates\&quot; *)\n\nsys_pushSilenc&quot;
 &amp; &quot;e();\n\n(* generic routine - forward declaration *)\nvar computeSX = 0;&quot;
 &amp; &quot;\n\n(* find and replace *)\nlet rep = proc(sx , pattern, newval)\n\ttex&quot;
 &amp; &quot;t_replaceAll(\&quot;$\&quot; &amp; pattern &amp; \&quot;$\&quot;, newval, sx);\nend;\n\nlet replist&quot;
 &amp; &quot; = proc(s, plist)\n\tvar sx = s;\n\tforeach tuple in plist do\n\t\tsx :&quot;
 &amp; &quot;= rep(sx, tuple[0], tuple[1]); \n\tend;\n\tsx;\nend;\n\nlet ResizeStrin&quot;
 &amp; &quot;g = proc(ch) \n\tlet model = ch.ResizeModel;\n\tif text_equal(model, \&quot;&quot;
 &amp; &quot;CenterPin\&quot;) then\n\t\&quot;FixedHV\&quot;;\n\telsif text_equal(model, \&quot;HScaled\&quot;&quot;
 &amp; &quot;) then\n\t\&quot;FixedV\&quot;;\n\telsif text_equal(model, \&quot;VScaled\&quot;) then\n\t\&quot;&quot;
 &amp; &quot;FixedH\&quot;;\n\telse \&quot;Scaled\&quot;;\n\tend;\nend;\n\nlet mutateName = proc(wi&quot;
 &amp; &quot;d)\n\tlet ix = text_findLast(\&quot;vq\&quot;, wid.name, 1000);\n\tif ix is -1 th&quot;
 &amp; &quot;en\n\t\twid.name := wid.name &amp; \&quot;vq0\&quot;;\n\telse\t\n\t\tlet num = text_s&quot;
 &amp; &quot;ub(wid.name, ix+2, text_length(wid.name)-ix+2);\n\t\tlet no = text_toIn&quot;
 &amp; &quot;t(num) + 1;\n\t\twid.name :=  text_sub(wid.name, 0, ix+2) &amp;  fmt_int(no&quot;
 &amp; &quot;); \n\tend;\nend;\n\nlet genericSX = proc(v, s)\n\tvar sx =  replist(s,&quot;
 &amp; &quot;[ [\&quot;XSpan\&quot;, fmt_int(v.width)],\n\t\t\t\t  \t [\&quot;YSpan\&quot;, fmt_int(v.he&quot;
 &amp; &quot;ight)],\n\t\t\t\t\t [\&quot;RimPen\&quot;, fmt_int(v.Rim)],\n\t\t\t\t\t [\&quot;Border&quot;
 &amp; &quot;Pen\&quot;, fmt_int(v.Border)],\n\t\t\t\t\t [\&quot;BgColor\&quot;, v.BgColor],\n\t\t\t&quot;
 &amp; &quot;\t\t [\&quot;FgColor\&quot;, v.FgColor],\n\t\t\t\t\t [\&quot;Font\&quot;, v.Font],\n\t\t\t\t&quot;
 &amp; &quot;\t [\&quot;FilterState\&quot;, v.InitialState],\n\t\t\t\t\t]);\t\n\tif text_equal&quot;
 &amp; &quot;(v.Embellishment, \&quot;None\&quot;) then\n\t\tsx := rep(sx, \&quot;FrameStyle\&quot;, \&quot;(&quot;
 &amp; &quot;ShadowSize 0)\&quot;);\n\telse\n\t\tsx := rep(sx, \&quot;FrameStyle\&quot;, v.Embellis&quot;
 &amp; &quot;hment);\n\tend;\n\tsx := \ttext_replaceAll(\&quot;%@\&quot;, \&quot;%\&quot; &amp; v.name, sx);&quot;
 &amp; &quot;\n\tsx;\nend;\n\nlet splitSX = proc(nv, s)\n\tvar sx = s;\n\tvar footer&quot;
 &amp; &quot; = \&quot;)\\n\&quot;;\n\tvar includeTitleBar = true;\n\tvar childOffRed = 0;\n\n&quot;
 &amp; &quot;\tsx := rep(sx, \&quot;ZSplitHeader\&quot;, \&quot;(ZSplit %@zsplit\\n (ZBackground %@&quot;
 &amp; &quot;zback\\n\&quot;);\n\tif tex&quot;;

CONST E2_0 =
   &quot;t_equal(nv.class, \&quot;form\&quot;) then\n\t\tif nv.ParentForm is 0 then \n\t\t&quot;
 &amp; &quot;\tchildOffRed := 20;\n\t\t\tsx := rep(sx, \&quot;YSpan\&quot;, fmt_int(nv.height-&quot;
 &amp; &quot;childOffRed));\n\t\t\tincludeTitleBar := false;\n\t\tend\n\tend;\t\t\n\t&quot;
 &amp; &quot;foreach child in nv.children do\n\t\tlet csx = computeSX(child);\n\t\tv&quot;
 &amp; &quot;ar visibility = \&quot;\&quot;;\n\t\tif child.InitialState isnot \&quot;Vanish\&quot; then\n&quot;
 &amp; &quot;\t\t\tvisibility := \&quot;Open\&quot;;\n\t\tend;\n\t\tfooter := footer &amp; \&quot;(ZChi&quot;
 &amp; &quot;ld %\&quot; &amp; child.name &amp; \&quot;top (At \&quot; &amp; fmt_int(child.x) &amp; \&quot;  \&quot;\n       &quot;
 &amp; &quot;               &amp; fmt_int(child.y - childOffRed) &amp; \&quot;  NW Absolute) \&quot; &amp;&quot;
 &amp; &quot; visibility &amp; \&quot;\\n \&quot; &amp;\n                      ResizeString(child) &amp;\n&quot;
 &amp; &quot;                      csx &amp; \&quot;\\n    )\\n\&quot;;\n\tend;\n\tif text_equal(n&quot;
 &amp; &quot;v.class, \&quot;form\&quot;) then\n\t\tforeach ch in nv.ChildForms do\n\t\t\tfoot&quot;
 &amp; &quot;er := footer &amp; computeSX(ch);\n\t\tend\n\tend;\n\tfooter := footer &amp; \&quot;&quot;
 &amp; &quot;)\\n\&quot;;\n\tsx := rep(sx, \&quot;ZSplitFooter\&quot;, footer);\n\tsx := rep(sx, \&quot;&quot;
 &amp; &quot;TextureFile\&quot;, nv.Texture);\n\tif text_equal(nv.class, \&quot;form\&quot;) then\n&quot;
 &amp; &quot;\t\tif includeTitleBar then \n\t\t\tsx := rep(sx, \&quot;IncludeTitleBar\&quot;, &quot;
 &amp; &quot;\&quot;($TitleBar$)\&quot;);\n\t\telse\n\t\t\tsx := rep(sx, \&quot;IncludeTitleBar\&quot;, &quot;
 &amp; &quot;\&quot;\&quot;);\n\t\tend;\n\t\tsx := rep(sx, \&quot;TitleBar\&quot;, nv.name &amp; \&quot;TitleBar\&quot;&quot;
 &amp; &quot;);\n\tend;\n\tgenericSX(nv, sx);\nend;\n\nlet menuSX = proc(nv)\n\t(* a&quot;
 &amp; &quot;ssert: nv is a formnode with a menu *)\n\tvar sx = Templates.menu;\n\ts&quot;
 &amp; &quot;x := replist(sx, [[\&quot;MenuBgColor\&quot;, nv.MenuBgColor],\n\t\t\t\t\t    [\&quot;&quot;
 &amp; &quot;MenuFgColor\&quot;, nv.MenuFgColor],\n\t\t\t\t\t     [\&quot;MenuFont\&quot;, nv.MenuF&quot;
 &amp; &quot;ont]]);\n\tvar menuDef = \&quot;\&quot;;\n\tlet first = 0;\n\tlet last = #(nv.Men&quot;
 &amp; &quot;u)-1;\n\tvar i = first;\n\tloop\n\t\tif  i &gt; last then exit; end;\n\t\t&quot;
 &amp; &quot;let m = nv.Menu[i];\n\t\tmutateName(m);\n\t\tif (m.Level is 0) and not &quot;
 &amp; &quot;(text_equal(m.name, \&quot;RIDGE\&quot;)) then\n\t\t\tvar ctr = 0;\n\t\t\tvar ix &quot;
 &amp; &quot;= i+1;\n\t\t\tvar pulldownDef = \&quot;(VBox \\n\&quot;; (* start creation of pul&quot;
 &amp; &quot;ldown *)\n\t\t\tif ix &lt;= last then\n\t\t\t  \tloop\n\t\t\t\t\tlet mx = &quot;
 &amp; &quot;nv.Menu[ix];\n\t\t\t\t\tif (ix &gt; last) or (mx.Level is 0) then exit; en&quot;
 &amp; &quot;d;\n\t\t\t\t\tif mx.Level is 1 then\n\t\t\t\t\t\tif text_equal(mx.name,&quot;
 &amp; &quot; \&quot;RIDGE\&quot;) then\n\t\t\t\t\t\t \tpulldownDef := pulldownDef &amp; \&quot;Ridge\\&quot;
 &amp; &quot;n\&quot;;\t\n\t\t\t\t\t\telse\n\t\t\t\t\t\tpulldownDef :=\n              \t\t&quot;
 &amp; &quot;\t\t\t      pulldownDef &amp; \&quot;(MenuButton \&quot; &amp; mx.name\n                \t&quot;
 &amp; &quot;\t\t\t\t &quot;;

CONST E2_1 =
   &quot;     &amp; \&quot;Filter \&quot; &amp; mx.initialState &amp; \&quot; \&quot;\n                 \t\t\t\t&quot;
 &amp; &quot;\t      &amp; mx.name &amp; \&quot; \&quot; &amp; mx.name &amp; \&quot;Label \&quot;\n                     &quot;
 &amp; &quot;\t\t\t\t\t      &amp; \&quot;\\\&quot;\&quot; &amp; mx.Label &amp; \&quot;\\\&quot;)\\n\&quot;\n                \t&quot;
 &amp; &quot;\t\t\tend;\t\n\t\t\t\t\t        ctr := ctr + 1;\n\t\t\t\t\tend;\n\t\t\t&quot;
 &amp; &quot;\t\tix := ix +1;\n\t\t\t\tend;\n\t\t\t\tpulldownDef := pulldownDef &amp; \&quot;&quot;
 &amp; &quot;)\\n\&quot;; (* close VBox *)\n\t\t\tend; (* if ix &lt;= last  *)\n\t\t        &quot;
 &amp; &quot;if ctr &gt; 0 then \n\t\t\t\t menuDef :=\n         \t\t\t     menuDef &amp; \&quot;&quot;
 &amp; &quot;(PullDownMenuItem \&quot; &amp; m.name &amp; \&quot;Filter \&quot;\n           \t\t\t     &amp; m.&quot;
 &amp; &quot;initialState &amp; \&quot; \&quot; &amp; m.name &amp; \&quot; \&quot;\n             \t\t\t     &amp; m.name&quot;
 &amp; &quot; &amp; \&quot;Label \&quot; &amp; \&quot;\\\&quot;\&quot; &amp; m.Label &amp; \&quot;\\\&quot;\\n\&quot;\n              \t\t\t &quot;
 &amp; &quot;    &amp; pulldownDef &amp; \&quot;)\\n\&quot;;\n\t\t\telse\n\t\t\t\tmenuDef :=\n     \t\t&quot;
 &amp; &quot;\t\t         menuDef &amp; \&quot;(MenuItem \&quot; &amp; m.name &amp; \&quot;Filter \&quot;\n         &quot;
 &amp; &quot;     \t\t\t\t  &amp; m.initialState &amp; \&quot; \&quot; &amp; m.name &amp; \&quot; \&quot;\n             &quot;
 &amp; &quot;  \t\t\t\t  &amp; m.name &amp; \&quot;Label \&quot; &amp; \&quot;\\\&quot;\&quot; &amp; m.Label &amp; \&quot;\\\&quot;)\\n\&quot;;\n&quot;
 &amp; &quot;\t\t\tend;\n\t\t\ti := ix -1;\n\t\tend;\n\t\ti := i +1;\n\tend;\t\n\tre&quot;
 &amp; &quot;p(sx, \&quot;MenuItems\&quot;, menuDef);\nend;\n\n\nlet booleanSX = proc(nv)\n\tv&quot;
 &amp; &quot;ar sx = Templates.boolean;\n\tsx := rep(sx, \&quot;fbstyle\&quot;, nv.feedbackSty&quot;
 &amp; &quot;le);\n\tif nv.initialValue then\n\t\tsx :=rep(sx, \&quot;initValue\&quot;, \&quot;TRUE&quot;
 &amp; &quot;\&quot;);\n\telse\n\t\tsx:=rep(sx, \&quot;initValue\&quot;, \&quot;FALSE\&quot;);\t\n\tend;\n\ti&quot;
 &amp; &quot;f nv.textLabel then\n\t\tsx:=rep(sx, \&quot;BooleanContents\&quot;, \&quot;Text %@text&quot;
 &amp; &quot; \\\&quot;\&quot; &amp; nv.textString &amp; \&quot;\\\&quot;\&quot;);\n\telse\n\t\tsx:=rep(sx, \&quot;Boolean&quot;
 &amp; &quot;Contents\&quot;,\&quot;Pixmap %@pixmap \\\&quot;\&quot; &amp; nv.pixmap &amp; \&quot;\\\&quot;\&quot;);\n\tend;\t\n&quot;
 &amp; &quot;\tgenericSX(nv, sx);\nend;\n\nlet browserSX = proc(nv)\n\tvar sx = Temp&quot;
 &amp; &quot;lates.browser;\n\tif nv.Multiplicity then\n\t\tsx:=rep(sx, \&quot;typeOfBrow&quot;
 &amp; &quot;ser\&quot;, \&quot;MultiBrowser\&quot;);\n\t\tif #(nv.Selections) is 0 then\n\t\t\tsx:&quot;
 &amp; &quot;=rep(sx, \&quot;ValueList\&quot;, \&quot;\&quot;);\n\t\telse\n\t\t\tvar values = \&quot;\&quot;;\n\t\t&quot;
 &amp; &quot;\tforeach i in nv.Selections do\n\t\t\t\t values := values &amp; fmt_int(i)&quot;
 &amp; &quot; &amp; \&quot; \&quot;;\n\t\t\tend;\n\t\t\tsx := rep(sx, \&quot;ValueList\&quot;, \&quot;(Value \&quot; &amp;&quot;
 &amp; &quot; values  &amp; \&quot; )\&quot; );\n\t\tend;\n\telse\n\t\tsx:=rep(sx, \&quot;typeOfBrowser&quot;
 &amp; &quot;\&quot;, \&quot;Browser\&quot;);\t\n\t\tif nv.Selection is -1 then\n\t\t\tsx := rep(sx&quot;
 &amp; &quot;, \&quot;ValueList\&quot;, \&quot;\&quot;);\n\t\telse\n\t\t\tsx := rep(sx, \&quot;ValueList\&quot;,  &quot;
 &amp; &quot;\&quot;(Value \&quot; &amp; fmt_int(nv.Selection) &amp; \&quot; )\&quot; );\n\t\tend;\n\tend;\n\tif&quot;
 &amp; &quot; nv.Quick then\n\t\tsx := rep(sx, \&quot;quick\&quot;, \&quot;Quick\&quot;);\n\telse\n\t\ts&quot;
 &amp; &quot;x := rep(sx, &quot;;

CONST E2_2 =
   &quot;\&quot;quick\&quot;, \&quot;\&quot;);\n\tend;\n\n\tif #(nv.Contents) is 0 then\n\t\t\tsx:=r&quot;
 &amp; &quot;ep(sx, \&quot;Items\&quot;, \&quot;\&quot;);\n\t\telse\n\t\t\tvar items = \&quot;\&quot;;\n\t\t\tfore&quot;
 &amp; &quot;ach item in nv.Contents do\n\t\t\t\t items := items &amp; \&quot;\\\&quot;\&quot; &amp; item &amp;&quot;
 &amp; &quot;  \&quot;\\\&quot; \&quot;;\n\t\t\tend;\n\t\t\tsx := rep(sx, \&quot;Items\&quot;, items );\n\t\t&quot;
 &amp; &quot;end;\n\tgenericSX(nv, sx);\nend;\n\nlet buttonSX = proc(nv)\n\tvar sx =&quot;
 &amp; &quot; Templates.button;\n\tif nv.Guard then\n\t\tsx := replist(sx, [[\&quot;Guard&quot;
 &amp; &quot;Header\&quot;, \&quot;(Guard %@guard \&quot;],\n\t\t\t\t\t    [\&quot;GuardFooter\&quot;, \&quot;)\&quot;]&quot;
 &amp; &quot;]);\n\telse\n\t\tsx := replist(sx, [[\&quot;GuardHeader\&quot;, \&quot;\&quot;],\n\t\t\t\t\t&quot;
 &amp; &quot;    [\&quot;GuardFooter\&quot;, \&quot;\&quot;]]);\t\n\tend;\n\tif nv.Trill then\n\t\tsx :=&quot;
 &amp; &quot; rep(sx, \&quot;Trill\&quot;, \&quot;\&quot;);\n\telse\n\t\tsx := rep(sx, \&quot;Trill\&quot;, \&quot;\&quot;);&quot;
 &amp; &quot;\n\tend;\t\t\t\n\tif nv.textLabel then\n\t\tsx := rep(sx, \&quot;ButtonConte&quot;
 &amp; &quot;nts\&quot;,\&quot;Text %@text \\\&quot;\&quot; &amp; nv.textString &amp; \&quot;\\\&quot;\&quot; );\n\telse\n\t\ts&quot;
 &amp; &quot;x := rep(sx, \&quot;ButtonContents\&quot;,\n\t\t\t\t\t       \&quot;Pixmap Accurate %@&quot;
 &amp; &quot;pixmap \\\&quot;\&quot; &amp; nv.pixmap &amp; \&quot;\\\&quot;\&quot;);\n\tend;\t\n\tgenericSX(nv, sx);\t&quot;
 &amp; &quot;\t\nend;\n\nlet choiceSX = proc(nv)\n\tvar sx = Templates.choice;\n\tsx&quot;
 &amp; &quot;:=rep(sx, \&quot;fbstyle\&quot;, nv.feedbackStyle);\n\tif nv.initialValue then\n\t&quot;
 &amp; &quot;\tsx:=rep(sx, \&quot;initValue\&quot;, \&quot;TRUE\&quot;);\n\telse\n\t\tsx:=rep(sx, \&quot;init&quot;
 &amp; &quot;Value\&quot;, \&quot;FALSE\&quot;);\t\n\tend;\n\tif nv.textLabel then\n\t\tsx:=rep(sx,&quot;
 &amp; &quot; \&quot;ChoiceContents\&quot;, \&quot;Text %@text \\\&quot;\&quot; &amp; nv.textString &amp; \&quot;\\\&quot;\&quot;);\n&quot;
 &amp; &quot;\telse\n\t\tsx:=rep(sx, \&quot;ChoiceContents\&quot;,\&quot;Pixmap %@pixmap \\\&quot;\&quot; &amp; n&quot;
 &amp; &quot;v.pixmap &amp; \&quot;\\\&quot;\&quot;);\n\tend;\t\n\tgenericSX(nv, sx);\t\nend;\n\nlet fi&quot;
 &amp; &quot;lebrowserSX = proc(nv)\n\tvar sx = Templates.filebrowser;\n\tif nv.Read&quot;
 &amp; &quot;Only then\n\t\tsx := rep(sx, \&quot;ReadOnly\&quot;, \&quot;ReadOnly\&quot;);\n\telse\n\t\t&quot;
 &amp; &quot;sx :=  rep(sx, \&quot;ReadOnly\&quot;, \&quot;\&quot;);\n\tend;\n\tsx := replist(sx, [[\&quot;La&quot;
 &amp; &quot;belFont\&quot;, nv.LabelFont],\n\t\t\t\t     [\&quot;Initial\&quot;, nv.Value],\n\t\t\t&quot;
 &amp; &quot;\t     [\&quot;fbName1\&quot;, nv.name],\n\t\t\t\t     [\&quot;fbName2\&quot;, nv.name],\n\t&quot;
 &amp; &quot;\t\t\t     [\&quot;ActionLabel\&quot;, nv.ActionLabel]]);\n\tif #(nv.Suffixes) is&quot;
 &amp; &quot; 0 then\n\t\tsx := rep(sx, \&quot;Suffixes\&quot;, \&quot;\\\&quot;\\\&quot;\&quot;);\n\telse\n\t\tva&quot;
 &amp; &quot;r suffixList = \&quot;\&quot;;\n\t\tforeach suf in nv.Suffixes do\n\t\t\tsuffixLi&quot;
 &amp; &quot;st := suffixList &amp; \&quot; \\\&quot;\&quot; &amp; suf &amp;\n\t\t\t\t\&quot;\\\&quot; \&quot;;\n\t\tend;\n\t\t&quot;
 &amp; &quot;sx := rep(sx, \&quot;Suffixes\&quot;, suffixList);\n\tend;\n\tgenericSX(nv, sx);\n&quot;
 &amp; &quot;end;\n\nlet formSX = proc(nv)\n\tvar sx = Templates.form;\n\t(* plug in&quot;
 &amp; &quot; all the appropriate values *)\n\tvar location = \&quot;\&quot;;\n\n\tif nv.Check&quot;
 &amp; &quot;pointedX&quot;;

CONST E2_3 =
   &quot;Y then\n\t\tlocation :=\&quot; (At  \&quot; &amp; fmt_int(nv.x) &amp; \&quot; \&quot; &amp; fmt_int(nv.&quot;
 &amp; &quot;y) &amp; \&quot;  NW Absolute) \&quot;;\n\tend;\n\n\tif nv.InitialState isnot \&quot;Vanis&quot;
 &amp; &quot;h\&quot; then\n\t\tsx := rep(sx, \&quot;ZChildState\&quot;, location &amp; \&quot;Open\&quot;);\n\te&quot;
 &amp; &quot;lse\n\t\tsx := rep(sx, \&quot;ZChildState\&quot;, location);\n\tend;\n\tif nv.Has&quot;
 &amp; &quot;Menu then\n\t\tsx := rep(sx, \&quot;MenuStructure\&quot;, \n\t\t\t\t\tmenuSX(nv))&quot;
 &amp; &quot;;\n\telse\n\t\tsx := rep(sx, \&quot;MenuStructure\&quot;, \&quot;\&quot;);\t\n\tend;\n\tsx &quot;
 &amp; &quot;:= replist(sx,\n\t [ [\&quot;XStretch\&quot;, fmt_int(nv.StretchX)],\n\t   [\&quot;YSt&quot;
 &amp; &quot;retch\&quot;, fmt_int(nv.StretchY)],\n\t   [\&quot;XShrink\&quot;, fmt_int(nv.ShrinkX)&quot;
 &amp; &quot;],\n\t   [\&quot;YShrink\&quot;, fmt_int(nv.ShrinkY)],\n\t   [\&quot;TitleBgColor\&quot;, n&quot;
 &amp; &quot;v.TitleBgColor],\n\t   [\&quot;TitleFgColor\&quot;, nv.TitleFgColor],\n\t   [\&quot;Ti&quot;
 &amp; &quot;tleString\&quot;, nv.TitleString],\n\t]);\n\tsplitSX(nv, sx);\nend;\n\nlet f&quot;
 &amp; &quot;rameSX = proc(nv)\n\tvar sx = Templates.frame;\t\n\tsplitSX(nv, sx);\ne&quot;
 &amp; &quot;nd;\n\nlet numericSX = proc(nv)\n\tvar sx = Templates.numeric;\n\tsx :=&quot;
 &amp; &quot; replist(sx, [[\&quot;Value\&quot;, fmt_int(nv.Val)],\n\t\t\t\t    [\&quot;Min\&quot;, fmt_&quot;
 &amp; &quot;int(nv.Min)],\n\t\t\t\t    [\&quot;Max\&quot;, fmt_int(nv.Max)]\n\t\t\t\t]);\n\ti&quot;
 &amp; &quot;f nv.AllowEmpty then\n\t\tsx := rep(sx, \&quot;AllowEmpty\&quot;, \&quot;AllowEmpty\&quot;)&quot;
 &amp; &quot;;\n\telse\n\t\tsx := rep(sx, \&quot;AllowEmpty\&quot;, \&quot;\&quot;);\t\n\tend;\n\tif nv.&quot;
 &amp; &quot;HideButtons then\n\t\tsx := rep(sx, \&quot;HideButtons\&quot;, \&quot;HideButtons\&quot;);\n&quot;
 &amp; &quot;\telse\n\t\tsx := rep(sx, \&quot;HideButtons\&quot;, \&quot;\&quot;);\t\n\tend;\n\tgenericS&quot;
 &amp; &quot;X(nv, sx);\nend;\n\nlet scrollerSX = proc(nv, s)\n\tvar sx = s;\n\tsx :&quot;
 &amp; &quot;= replist(sx, [[\&quot;Value\&quot;, fmt_int(nv.Val)],\n\t\t\t\t    [\&quot;Min\&quot;, fmt&quot;
 &amp; &quot;_int(nv.Min)],\n\t\t\t\t    [\&quot;Max\&quot;, fmt_int(nv.Max)],\n\t\t\t\t    [\&quot;&quot;
 &amp; &quot;Thumb\&quot;, fmt_int(nv.Thumb)],\n\t\t\t\t    [\&quot;Step\&quot;, fmt_int(nv.Step)],&quot;
 &amp; &quot;\n\t\t\t\t\t]);\n\tgenericSX(nv, sx);\nend;\n\nlet textSX = proc(nv)\n\t&quot;
 &amp; &quot;var sx = Templates.text;\n\tsx := replist(sx, [[\&quot;Alignment\&quot;, nv.tOrie&quot;
 &amp; &quot;ntation],\n\t\t\t\t    [\&quot;Initial\&quot;, nv.tVal]]);\n\tgenericSX(nv, sx);\n&quot;
 &amp; &quot;end;\n\nlet texteditSX = proc(nv)\n\tvar sx = Templates.textedit;\n\tif&quot;
 &amp; &quot; nv.teReadOnly then\n\t\tsx := rep(sx, \&quot;ReadOnly\&quot;, \&quot;ReadOnly\&quot;);\n\t&quot;
 &amp; &quot;else\n\t\tsx := rep(sx, \&quot;ReadOnly\&quot;, \&quot;\&quot;);\t\n\tend;\n\tif nv.teClip &quot;
 &amp; &quot;then\n\t\tsx := rep(sx, \&quot;Clip\&quot;, \&quot;Clip\&quot;);\n\telse\n\t\tsx := rep(sx,&quot;
 &amp; &quot; \&quot;Clip\&quot;, \&quot;\&quot;);\t\n\tend;\n\tif nv.teHasScrollbar then\n\t\tsx := rep&quot;
 &amp; &quot;(sx, \&quot;NoScrollbar\&quot;, \&quot;\&quot;);\n\telse\n\t\tsx := rep(sx, \&quot;NoScrollbar\&quot;&quot;
 &amp; &quot;, \&quot;NoScrollbar\&quot;);\t\n\te&quot;;

CONST E2_4 =
   &quot;nd;\n\tif nv.getFromFile then\n\t\tsx := rep(sx, \&quot;Initial\&quot;, \&quot;From \\&quot;
 &amp; &quot;\&quot;\&quot; &amp; nv.teFromFile &amp; \&quot;\\\&quot;\&quot;)\n\telse\n\t\tsx := rep(sx, \&quot;Initial\&quot;&quot;
 &amp; &quot;, \&quot;Value \\\&quot;\&quot; &amp; text_replaceAll(\&quot;\\n\&quot;, \&quot;\\\\n\&quot;,nv.teContents ) &amp;&quot;
 &amp; &quot; \&quot;\\\&quot;\&quot;)\n\tend;\n\tgenericSX(nv, sx);\nend;\n\nlet typeinSX = proc(n&quot;
 &amp; &quot;v)\n\tvar sx = Templates.typein;\n\tif nv.tyReadOnly then\n\t\tsx := re&quot;
 &amp; &quot;p(sx, \&quot;ReadOnly\&quot;, \&quot;ReadOnly\&quot;);\n\telse\n\t\tsx := rep(sx, \&quot;ReadOnl&quot;
 &amp; &quot;y\&quot;, \&quot;\&quot;);\t\t\n\tend;\n\tif nv.tyExpand then\n\t\tsx := rep(sx, \&quot;Exp&quot;
 &amp; &quot;andOnDemand\&quot;, \&quot;ExpandOnDemand\&quot;);\n\telse\n\t\tsx := rep(sx, \&quot;Expand&quot;
 &amp; &quot;OnDemand\&quot;, \&quot;\&quot;);\t\t\n\tend;\n\tsx := rep(sx, \&quot;Initial\&quot;, nv.tyInit)&quot;
 &amp; &quot;;\n\tgenericSX(nv, sx);\nend;\n\nlet videoSX = proc(nv)\n\tvar sx = Tem&quot;
 &amp; &quot;plates.video;\n\tif nv.Source is \&quot;\&quot; then\n\t\tsx := rep(sx, \&quot;PlayVid&quot;
 &amp; &quot;eo\&quot;, \&quot;1\&quot;);\n\telse\n\t\tsx := rep(sx, \&quot;PlayVideo\&quot;, \&quot;0\&quot;);\n\tend;&quot;
 &amp; &quot;\n\tsx := replist(sx, [ [\&quot;VideoSource\&quot;, nv.Source],\n\t\t\t\t      [\&quot;&quot;
 &amp; &quot;Quality\&quot;, fmt_int(nv.Quality)],\n\t\t\t\t      [\&quot;Width\&quot;, fmt_int(nv.&quot;
 &amp; &quot;Width)],\n\t\t\t\t      [\&quot;Height\&quot;, fmt_int(nv.Height)],\n\t\t\t\t    &quot;
 &amp; &quot;  [\&quot;Colours\&quot;, fmt_int(nv.Colours)],\n\t\t\t\t      [\&quot;MSecs\&quot;, fmt_in&quot;
 &amp; &quot;t(nv.MSecs)],\n\t\t\t\t      [\&quot;AudioSource\&quot;, nv.AuSource],\n\t\t\t\t &quot;
 &amp; &quot;     [\&quot;Volume\&quot;, fmt_int(nv.Volume)],\n\t\t\t\t]); \n\tif nv.Synchrono&quot;
 &amp; &quot;us then\n\t\tsx := rep(sx, \&quot;Synchronous\&quot;, \&quot;Synchronous\&quot;);\t\n\telse&quot;
 &amp; &quot;\n\t\tsx := rep(sx, \&quot;Synchronous\&quot;, \&quot;\&quot;);\t\n\tend;\n\tif nv.FixedSiz&quot;
 &amp; &quot;e then\n\t\tsx := rep(sx, \&quot;FixedSize\&quot;, \&quot;FixedSize\&quot;);\t\n\telse\n\t\t&quot;
 &amp; &quot;sx := rep(sx, \&quot;FixedSize\&quot;, \&quot;\&quot;);\t\n\tend;\n\tif nv.Paused then\n\t\t&quot;
 &amp; &quot;sx := rep(sx, \&quot;Paused\&quot;, \&quot;Paused\&quot;);\t\n\telse\n\t\tsx := rep(sx, \&quot;P&quot;
 &amp; &quot;aused\&quot;, \&quot;\&quot;);\t\n\tend;\n\tif nv.Mute then\n\t\tsx := rep(sx, \&quot;Mute\&quot;&quot;
 &amp; &quot;, \&quot;Mute\&quot;);\t\n\telse\n\t\tsx := rep(sx, \&quot;Mute\&quot;, \&quot;\&quot;);\t\n\tend;\n\t&quot;
 &amp; &quot;if nv.IgnoreMapping then\n\t\tsx := rep(sx, \&quot;IgnoreMapping\&quot;, \&quot;Ignore&quot;
 &amp; &quot;Mapping\&quot;);\t\n\telse\n\t\tsx := rep(sx, \&quot;IgnoreMapping\&quot;, \&quot;\&quot;);\t\n\t&quot;
 &amp; &quot;end;\n\tgenericSX(nv, sx);\nend;\n\n\n(* procedure dispatching kludge *&quot;
 &amp; &quot;)\ncomputeSX := proc(wid)\n\tmutateName(wid); (* unique sx-expression w&quot;
 &amp; &quot;ill result *)\t\n        if wid.class is \&quot;boolean\&quot; then\n\t\tbooleanS&quot;
 &amp; &quot;X(wid);\n        elsif wid.class is \&quot;button\&quot; then\n\t\tbuttonSX(wid);&quot;
 &amp; &quot;\n\telsif wid.class is \&quot;browser\&quot; then\n\t\tbrowserSX(wid);\n\telsif w&quot;
 &amp; &quot;id.class is \&quot;choice\&quot; then\n\t\tchoiceSX(wid);\n\t&quot;;

CONST E2_5 =
   &quot;elsif wid.class is \&quot;filebrowser\&quot; then\n\t\tfilebrowserSX(wid);\n\tels&quot;
 &amp; &quot;if wid.class is \&quot;form\&quot; then\n\t\tformSX(wid);\n\telsif wid.class is \&quot;&quot;
 &amp; &quot;frame\&quot; then\n\t\tframeSX(wid);\n\telsif wid.class is \&quot;hscroll\&quot; then\n&quot;
 &amp; &quot;\t\tscrollerSX(wid, Templates.hscroll);\n\telsif wid.class is \&quot;numeric&quot;
 &amp; &quot;\&quot; then\n\t\tnumericSX(wid);\n\telsif wid.class is \&quot;text\&quot; then\n\t\tt&quot;
 &amp; &quot;extSX(wid);\n\telsif wid.class is \&quot;textedit\&quot; then\n\t\ttexteditSX(wid&quot;
 &amp; &quot;);\n\telsif wid.class is \&quot;typein\&quot; then\n\t\ttypeinSX(wid);\n        e&quot;
 &amp; &quot;lsif wid.class is \&quot;video\&quot; then\n\t\tvideoSX(wid);\n\telsif wid.class &quot;
 &amp; &quot;is \&quot;vscroll\&quot; then\n\t\tscrollerSX(wid, Templates.vscroll);\n\tend;\n\t&quot;
 &amp; &quot;\nend;\n\nsys_popSilence();&quot;;

CONST E3 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Tue Jan &quot;
 &amp; &quot;10 11:50:10 PST 1995 by mhb     *)\n\n(* Mandatory Include for all Visu&quot;
 &amp; &quot;al Obliq Programs *)\n\n(* Naming Convention for Online Listing within &quot;
 &amp; &quot;the VO Editor : \n\n   A comment that begins/ends with \&quot;:\&quot; contains t&quot;
 &amp; &quot;he signature of  an additional volib  proc.\n   A comment that begins/e&quot;
 &amp; &quot;nds with \&quot;=\&quot; contains the name of a widget-class\n   and may be follo&quot;
 &amp; &quot;wed by one or more method signatures.\n   A comment that begins/ends wi&quot;
 &amp; &quot;th \&quot;-\&quot; contains the signature of a method\n  and is associated with t&quot;
 &amp; &quot;he last widget-class name seen.\n   Null method signatures are ignored.&quot;
 &amp; &quot;\n*)\n\nmodule volib;\n\nsys_pushSilence();\n(* assert - must begin wit&quot;
 &amp; &quot;h a \\n\' *)\nlet unpkList = proc(s)\n\tlet ar = text_explode(\&quot;\\n\&quot;, &quot;
 &amp; &quot;s);\n\tlet n = #(ar) -1; \n\tarray_sub(ar, 1, n);\nend;\n\nlet pkList =&quot;
 &amp; &quot; proc(ar)\n\tlet n = text_implode(\'\\n\', ar);\n\tn;\nend;\n\nlet voli&quot;
 &amp; &quot;bLocal = {\n\n  HOSTNAME =&gt; sys_address,\n           \n  Join =&gt; ok,\n\n&quot;
 &amp; &quot;  (*: LoadFile(filename:text) returns text :*)\n  LoadFile =&gt; meth(s, f&quot;
 &amp; &quot;ilename)\n    let r = rd_open(fileSys, filename);\n    let contents = r&quot;
 &amp; &quot;d_getText(r, rd_length(r));\n    rd_close(r);\n    contents\n    end,\n&quot;
 &amp; &quot;\n  (*: SaveFile(t:text, f:filename) returns boolean :*)\n  SaveFile =&gt;&quot;
 &amp; &quot; meth(s, t, filename)\n     try\n       let w = wr_open(fileSys, filena&quot;
 &amp; &quot;me);\n       wr_putText(w, t);\n       wr_close(w);\n       true;\n    &quot;
 &amp; &quot; except else\n       false;\n     end\n    end,\n\n(*=       boolean   &quot;
 &amp; &quot;     =*)\n  booleanNew =&gt; meth(s,   n)\n  {\n    SELF =&gt; 0,\n    form =&quot;
 &amp; &quot;&gt; 0, \n    name =&gt; n,\n    class =&gt; \&quot;boolean\&quot;,\n\n    (* Generic Attr&quot;
 &amp; &quot;ibutes *)\n    parent =&gt; 0,\n\n    x =&gt; 0, y =&gt; 0, width =&gt;0, height =&gt;&quot;
 &amp; &quot;0, BgColor =&gt;\&quot;\&quot;, FgColor =&gt; \&quot;\&quot;,\n    Font =&gt; \&quot;\&quot;, Rim =&gt; 0, Border&quot;
 &amp; &quot; =&gt; 0, Embellishment =&gt; \&quot;\&quot;,\n    InitialState =&gt; \&quot;\&quot;, ResizeModel =&gt;&quot;
 &amp; &quot; \&quot;\&quot;, \t\n\n    (* Widget Attributes *)\n    tex&quot;;

CONST E3_0 =
   &quot;tLabel  =&gt; true, textString=&gt;\&quot;\&quot;, \n    pixmap =&gt; \&quot;\&quot;, initialValue =&quot;
 &amp; &quot;&gt; false, feedbackStyle =&gt; \&quot;\&quot;,\n\n    (*- getValue() returns boolean -&quot;
 &amp; &quot;*)\n    getValue =&gt; meth(s) \n     form_getBoolean(s.form, s.name) end,&quot;
 &amp; &quot;\n    (*- setValue(booleanval) -*)\n    setValue =&gt; meth(s, val) \n    &quot;
 &amp; &quot;  \ts.textLabel  :=  val; \n\tform_putBoolean(s.form, s.name, val); ok &quot;
 &amp; &quot;end,\t\n    (*- setLabel(tx:text) -*)\n    setLabel =&gt; meth(s, val) \t\n&quot;
 &amp; &quot;\ts.textString := val;\n      \tform_putText(s.form, s.name &amp; \&quot;text\&quot;,&quot;
 &amp; &quot; \&quot;\&quot;, val, false); ok end,\n    (*- makeDormant() -*)\n    makeDormant&quot;
 &amp; &quot; =&gt; meth(s) \n     s.InitialState := \&quot;Dormant\&quot;;\n      form_putReacti&quot;
 &amp; &quot;vity(s.form, s.name &amp; \&quot;filter\&quot;, \&quot;dormant\&quot;); ok end,\n    (*- makePa&quot;
 &amp; &quot;ssive() -*)\n    makePassive =&gt; meth(s) \n     s.InitialState := \&quot;Pass&quot;
 &amp; &quot;ive\&quot;;\n      form_putReactivity(s.form, s.name &amp; \&quot;filter\&quot;, \&quot;passive&quot;
 &amp; &quot;\&quot;); ok end,\n    (*- makeActive() -*)\n    makeActive =&gt; meth(s) \n   &quot;
 &amp; &quot;   s.InitialState := \&quot;Active\&quot;;\t\n      form_putReactivity(s.form, s.&quot;
 &amp; &quot;name &amp; \&quot;filter\&quot;, \&quot;active\&quot;); \n      form_popUp(s.form, s.name &amp; \&quot;t&quot;
 &amp; &quot;op\&quot;);\n      ok end,\n    (*- makeInvisible() -*)\n    makeInvisible =&quot;
 &amp; &quot;&gt; meth(s) \n      s.InitialState := \&quot;Vanish\&quot;;\n      refreshWidget( s&quot;
 &amp; &quot;);\n    \tok end,   \n     (*- -*)\n  } \n  end,\n\n(*=       browser  &quot;
 &amp; &quot; =*)\n  browserNew =&gt; meth(s,  n)\n  { \n    SELF =&gt; 0,\n    form =&gt; 0,&quot;
 &amp; &quot; \n    name =&gt; n,\n    class =&gt; \&quot;browser\&quot;,\n\n (* Generic Attributes &quot;
 &amp; &quot;*)\t\n    parent =&gt; 0,\n\n    x =&gt; 0, y =&gt; 0, width =&gt;0, height =&gt;0, Bg&quot;
 &amp; &quot;Color =&gt;\&quot;\&quot;, FgColor =&gt; \&quot;\&quot;,\n    Font =&gt; \&quot;\&quot;, Rim =&gt; 0, Border =&gt; 0&quot;
 &amp; &quot;, Embellishment =&gt; \&quot;\&quot;,\n    InitialState =&gt; \&quot;\&quot;, ResizeModel =&gt; \&quot;\&quot;&quot;
 &amp; &quot;, \n \n  (* Widget Attributes *)\n   Quick =&gt; false, Multiplicity =&gt; fa&quot;
 &amp; &quot;lse, Contents =&gt; [],\n   Selections =&gt; [], Selection =&gt; -1, (* not guar&quot;
 &amp; &quot;anteed to be up to date *)\n\n    (*- numElements() returns integer -*)&quot;
 &amp; &quot;\n    numElements =&gt; meth(s)\n\t#(s.getElements());\n    end,\n   \n   &quot;
 &amp; &quot; (*- getElements() returns [text] -*)\n    getElements =&gt; meth(s)\n\tco&quot;
 &amp; &quot;py(s.Contents);\n    end,\n  \n    (*- putElements(elems:[text]) -*)\n &quot;
 &amp; &quot;   putElements =&gt; meth(s, ar)\n\ts.Contents := copy(ar);\n\ts.Select&quot;;

CONST E3_1 =
   &quot;ions := [];\n\ts.Selection := -1;\n\tform_putText(s.form, s.name, \&quot;Ite&quot;
 &amp; &quot;ms\&quot;, pkList(s.Contents), false);\n\tok\n   end,\n\n   (*- getElement(a&quot;
 &amp; &quot;tPosition:integer) returns text -*)\n   getElement =&gt; meth(s, n)\n\ts.C&quot;
 &amp; &quot;ontents[n];\n   end,\n   (*- isQuick() returns boolean -*)\n   isQuick &quot;
 &amp; &quot;=&gt; meth(s)\n\ts.Quick;\n   end,\n   (*- setQuickness(q:boolean) -*)\n  &quot;
 &amp; &quot; setQuickness =&gt; meth(s, q)\n\ts.Quick := q;\n\trefreshWidget(s);\n   e&quot;
 &amp; &quot;nd,\n   (*- putElement(atPosition:integer, elem:text) -*)\n   putElemen&quot;
 &amp; &quot;t =&gt; meth(s, n, el)\n\ts.Contents[n] := el;\n\t(* update array *)\n\tfo&quot;
 &amp; &quot;rm_putText(s.form, s.name, \&quot;Items\&quot;,  pkList(s.Contents), false);\n\ts&quot;
 &amp; &quot;.getSelection(); (* to checkpoint selected items *)\n\tif s.Multiplicit&quot;
 &amp; &quot;y then\n\t\tforeach i in s.Selections do\n\t\t\tform_putText(s.form, s.&quot;
 &amp; &quot;name, \&quot;SelectAlso\&quot;, s.Contents[i], false);\n\t\tend;\n\telse\n\t\tif &quot;
 &amp; &quot;s.Selection isnot -1 then\n\t\t\tform_putText(s.form, s.name, \&quot;Select\&quot;&quot;
 &amp; &quot;, s.Contents[s.Selection], false);\n\t\tend;\n\tend;\n\tok\n   end,\n\n&quot;
 &amp; &quot;  (*- appendElement(elem:text) -*)\n   appendElement =&gt; meth(s, el)\n\t&quot;
 &amp; &quot;s.Contents := s.Contents @ [el];\n\ts.putElement(#(s.Contents) - 1, el)&quot;
 &amp; &quot;;\n\tok\n   end,\n\n (*- prependElement(elem:text) -*)\n  prependElemen&quot;
 &amp; &quot;t =&gt; meth(s, el)\t\n\ts.insertElement(0, el);\n\tok\n   end,\t\n\n (*- &quot;
 &amp; &quot;deleteElement(atPosition:integer) returns boolean -*)\n  deleteElement &quot;
 &amp; &quot;=&gt; meth(s, n)\n\ttry\n\t\tlet ar = s.getElements();\n\t\tlet sz = #(ar)&quot;
 &amp; &quot;;\n\t\tlet newar = array_sub(ar, 0, n) @ array_sub(ar, n+1, (sz-n)-1);\n&quot;
 &amp; &quot;\t\ts.putElements(newar);\t\t\t\t\n\t\ttrue;\n\texcept\t\n\telse\n\t\tf&quot;
 &amp; &quot;alse;\n\tend; \n  end,\n\n (*- insertElement(atPosition:integer, elem:t&quot;
 &amp; &quot;ext) returns boolean -*)\n  insertElement =&gt;meth(s, n, el)\n\ttry\n\t\t&quot;
 &amp; &quot;let ar = s.Contents;\n\t\tlet sz = #(ar);\n\t\ts.Contents := array_sub(&quot;
 &amp; &quot;ar, 0, n) @ [el]  @ array_sub(ar, n, (sz-n));\n\t\t(* update selections&quot;
 &amp; &quot; *)\n\t\ts.getSelection(); (* to checkpoint selected items *)\n\t\tif s&quot;
 &amp; &quot;.Multiplicity then\n\t\t\tfor i = 0 to #(s.Selections) do\n\t\t\t\tif s&quot;
 &amp; &quot;.Selections[i] &gt;= n then\n\t\t\t\t\ts.Selections[i] := s.Selections[i]+&quot;
 &amp; &quot;1;\n\t\t\t\tend \n\t\t\tend;\n\t\telse\n\t\t\tif s.Selection &gt;= n then\n&quot;
 &amp; &quot;\t\t\t\ts.Selection := s.Selection + 1;\n\t\t\tend;\n\t\tend&quot;;

CONST E3_2 =
   &quot;;\t\t\t\t\n\t\ts.putElements(n, el);\n\t\ttrue;\n\texcept\n\telse\t\n\t&quot;
 &amp; &quot;\tfalse;\n\tend; \n  end,\n\n (*- selectString(st:text)  -*)\n (*-\t in&quot;
 &amp; &quot;crementalif not present turns off all -*)\n  selectString =&gt;meth(s, st)&quot;
 &amp; &quot;\n\tvar op = \&quot;Select\&quot;;\n\tif s.Multiplicity then\n\t\tforeach i in s.&quot;
 &amp; &quot;Contents do \n\t\t\tif i is st then\t\n\t\t\t\top := \&quot;SelectAlso\&quot;;\n\t&quot;
 &amp; &quot;\t\tend;\n\t\tend;\n\tend;\n\tform_putText(s.form, s.name, op, st, fals&quot;
 &amp; &quot;e);\n\tok;\n  end,\n\n\n(*- getSelection() returns selection(s) as text&quot;
 &amp; &quot; -*)\n(*- \t with \'\\n\' seperators  -*)\n   getSelection =&gt;meth(wid)\t&quot;
 &amp; &quot;\n\tlet sel = form_getText(wid.form, wid.name, \&quot;Select\&quot;);\n\t(* check&quot;
 &amp; &quot;point selections - side effect *)\n\tif wid.Multiplicity then\t\n\t\t\t&quot;
 &amp; &quot;\twid.Selections :=[];\n\t\t\t\tforeach item in wid.getSelItems() do\n\t&quot;
 &amp; &quot;\t\t\t\tfor i = 0 to #(wid.Contents) - 1 do\n\t\t\t\t\t\tif item is wid&quot;
 &amp; &quot;.Contents[i] then\n\t\t\t\t\t\t\twid.Selections := wid.Selections @ [i]&quot;
 &amp; &quot;;\n\t\t\t\t\t\tend;\n\t\t\t\t\tend;\n\t\t\t\tend;\n\t\t\telse\n\t\t\t\t&quot;
 &amp; &quot;wid.Selection :=  -1;\n\t\t\t\tif sel isnot \&quot;\&quot; then\n\t\t\t\t\tfor i &quot;
 &amp; &quot;= 0 to #(wid.Contents) - 1 do\n\t\t\t\t\t\tif sel is wid.Contents[i] th&quot;
 &amp; &quot;en\n\t\t\t\t\t\t\twid.Selection := i\n\t\t\t\t\t\tend;\n\t\t\t\t\tend;\n&quot;
 &amp; &quot;\t\t\t\tend;\n\t\t\tend;\n\tsel\n   end,\n\n (*- getSelItems() returns &quot;
 &amp; &quot;array of text -*)\n   getSelItems =&gt;meth(s)\t\n\tlet sel = form_getText&quot;
 &amp; &quot;(s.form, s.name, \&quot;Select\&quot;);\n\tif sel is \&quot;\&quot; then\n\t\t[]\n\telse\n\t&quot;
 &amp; &quot;\tunpkList(\&quot;\\n\&quot; &amp; sel);\n\tend;\n   end,\t\n\n   (*- toggleMultiplic&quot;
 &amp; &quot;ity() switches between Uni/Multi browser-*)\n   toggleMultiplicity =&gt;me&quot;
 &amp; &quot;th(s)\t\n\tcheckptSX(s);\n\ts.Multiplicity := not(s.Multiplicity);\n\tr&quot;
 &amp; &quot;ebuildWidget( s);\n\tok\n   end,\t\n   (*- makeDormant() -*)\n    makeD&quot;
 &amp; &quot;ormant =&gt; meth(s) \n     s.InitialState := \&quot;Dormant\&quot;;\n      form_put&quot;
 &amp; &quot;Reactivity(s.form, s.name &amp; \&quot;filter\&quot;, \&quot;dormant\&quot;); ok end,\n    (*- &quot;
 &amp; &quot;makePassive() -*)\n    makePassive =&gt; meth(s) \n     s.InitialState := &quot;
 &amp; &quot;\&quot;Passive\&quot;;\n      form_putReactivity(s.form, s.name &amp; \&quot;filter\&quot;, \&quot;p&quot;
 &amp; &quot;assive\&quot;); ok end,\n    (*- makeActive() -*)\n    makeActive =&gt; meth(s)&quot;
 &amp; &quot; \n      s.InitialState := \&quot;Active\&quot;;\t\n      form_putReactivity(s.fo&quot;
 &amp; &quot;rm, s.name &amp; \&quot;filter\&quot;, \&quot;active\&quot;); \n      form_popUp(s.form, s.name&quot;
 &amp; &quot; &amp; \&quot;top\&quot;);\n      ok end,\n    (*- makeInvisible() -*)\n    m&quot;;

CONST E3_3 =
   &quot;akeInvisible =&gt; meth(s) \n      s.InitialState := \&quot;Vanish\&quot;;\n      re&quot;
 &amp; &quot;freshWidget( s);\n    \tok end,\n  (*- -*)\n  } \n  end,\n\n (*= button&quot;
 &amp; &quot; =*)\n  buttonNew =&gt; meth(s, n)\n  { \n    SELF =&gt; 0,\n    form =&gt; 0, \n&quot;
 &amp; &quot;    name =&gt; n,\n    class =&gt; \&quot;button\&quot;,\n\n    (* Generic Attributes *&quot;
 &amp; &quot;)\n    parent =&gt; 0,\n\n    x =&gt; 0, y =&gt; 0, width =&gt;0, height =&gt;0, BgCol&quot;
 &amp; &quot;or =&gt;\&quot;\&quot;, FgColor =&gt; \&quot;\&quot;,\n    Font =&gt; \&quot;\&quot;, Rim =&gt; 0, Border =&gt; 0, E&quot;
 &amp; &quot;mbellishment =&gt; \&quot;\&quot;,\n    InitialState =&gt; \&quot;\&quot;, ResizeModel =&gt; \&quot;\&quot;, \n&quot;
 &amp; &quot;\n   (* Widget Attributes *)\n   textLabel =&gt; true, textString =&gt; \&quot;\&quot;,&quot;
 &amp; &quot; pixmap =&gt; \&quot;\&quot;,\n   Guard =&gt; false, Trill =&gt; false,\n\n    (*- makeDor&quot;
 &amp; &quot;mant() -*)\n    makeDormant =&gt; meth(s) \n     s.InitialState := \&quot;Dorma&quot;
 &amp; &quot;nt\&quot;;\n      form_putReactivity(s.form, s.name &amp; \&quot;filter\&quot;, \&quot;dormant\&quot;&quot;
 &amp; &quot;); ok end,\n    (*- makePassive() -*)\n    makePassive =&gt; meth(s) \n   &quot;
 &amp; &quot;  s.InitialState := \&quot;Passive\&quot;;\n      form_putReactivity(s.form, s.na&quot;
 &amp; &quot;me &amp; \&quot;filter\&quot;, \&quot;passive\&quot;); ok end,\n    (*- makeActive() -*)\n    m&quot;
 &amp; &quot;akeActive =&gt; meth(s) \n      s.InitialState := \&quot;Active\&quot;;\t\n      for&quot;
 &amp; &quot;m_putReactivity(s.form, s.name &amp; \&quot;filter\&quot;, \&quot;active\&quot;); \n      form_&quot;
 &amp; &quot;popUp(s.form, s.name &amp; \&quot;top\&quot;);\n      ok end,\n    (*- makeInvisible(&quot;
 &amp; &quot;) -*)\n    makeInvisible =&gt; meth(s) \n      s.InitialState := \&quot;Vanish\&quot;&quot;
 &amp; &quot;;\n      refreshWidget( s);\n    \tok end,\n    \n    (*- putText(tx:te&quot;
 &amp; &quot;xt) -*)\n    putText =&gt; meth(s, val) \t\n      s.textString := val;\t\n&quot;
 &amp; &quot;      if not (s.textLabel) then\n\ts.textLabel := true;\n\trefreshWidge&quot;
 &amp; &quot;t( s);\n      else\n\tform_putText(s.form, s.name &amp; \&quot;text\&quot;, \&quot;\&quot;, val&quot;
 &amp; &quot;, false); \n     end;\n    ok end,\n    (*- putBgColor(clr:text) -*)\n &quot;
 &amp; &quot;   putBgColor =&gt; meth(s, val) \t\n      s.BgColor := val;\n      form_p&quot;
 &amp; &quot;utText(s.form, s.name &amp; \&quot;text\&quot;, \&quot;BgColor\&quot;, val, false); ok end,\n  &quot;
 &amp; &quot;  (*- getText() returns text -*)\n    getText =&gt; meth(s) \n\ts.textStri&quot;
 &amp; &quot;ng\n    end,\n   (*- putPixmap(filename:text) -*)\n    putPixmap =&gt; met&quot;
 &amp; &quot;h(s, val) \t\n      s.pixmap := val;\n      if s.textLabel then\n\ts.te&quot;
 &amp; &quot;xtLabel := false;\n\trefreshWidget( s);\n      else\n\tform_putText(s.f&quot;
 &amp; &quot;orm, s.name &amp; \&quot;pixmap\&quot;, \&quot;\&quot;, val, false); \n     end;\n      ok end,&quot;
 &amp; &quot;\n   (*- &quot;;

CONST E3_4 =
   &quot;-*)\n  } \n  end,\n\n (*= choice  =*)\n  choiceNew =&gt; meth(s,  n)\n  { &quot;
 &amp; &quot;\n    SELF =&gt; 0,\n    form =&gt; 0, \n    name =&gt; n,\n    class =&gt; \&quot;choic&quot;
 &amp; &quot;e\&quot;,\n\n   (* Generic Attributes *)\n    parent =&gt; 0,\n\n    x =&gt; 0, y &quot;
 &amp; &quot;=&gt; 0, width =&gt;0, height =&gt;0, BgColor =&gt;\&quot;\&quot;, FgColor =&gt; \&quot;\&quot;,\n    Font&quot;
 &amp; &quot; =&gt; \&quot;\&quot;, Rim =&gt; 0, Border =&gt; 0, Embellishment =&gt; \&quot;\&quot;,\n    InitialSta&quot;
 &amp; &quot;te =&gt; \&quot;\&quot;, ResizeModel =&gt; \&quot;\&quot;, \n\n     (* Widget Attributes *)\n    &quot;
 &amp; &quot;textLabel =&gt; true, textString =&gt; \&quot;\&quot;, pixmap =&gt; \&quot;\&quot;, \n    initialVal&quot;
 &amp; &quot;ue =&gt; false, feedbackStyle =&gt; \&quot;CheckBox\&quot;, \n  \n \n    (*- getValue()&quot;
 &amp; &quot; returns boolean -*)\n    getValue =&gt; meth(s) \n      form_getBoolean(s&quot;
 &amp; &quot;.form, s.name) end,\n    (*- setValue(booleanval) -*)\n    setValue =&gt; &quot;
 &amp; &quot;meth(s, val) \n      form_putBoolean(s.form, s.name, val); ok end,\n   &quot;
 &amp; &quot; (*- setLabel(tx:text) -*)\n    setLabel =&gt; meth(s, val) \n      s.text&quot;
 &amp; &quot;String := val;\t\n      form_putText(s.form, s.name &amp; \&quot;text\&quot;, \&quot;\&quot;, v&quot;
 &amp; &quot;al, false); ok end,\n     (*- makeDormant() -*)\n    makeDormant =&gt; met&quot;
 &amp; &quot;h(s) \n     s.InitialState := \&quot;Dormant\&quot;;\n      form_putReactivity(s.&quot;
 &amp; &quot;form, s.name &amp; \&quot;filter\&quot;, \&quot;dormant\&quot;); ok end,\n    (*- makePassive()&quot;
 &amp; &quot; -*)\n    makePassive =&gt; meth(s) \n     s.InitialState := \&quot;Passive\&quot;;\n&quot;
 &amp; &quot;      form_putReactivity(s.form, s.name &amp; \&quot;filter\&quot;, \&quot;passive\&quot;); ok &quot;
 &amp; &quot;end,\n    (*- makeActive() -*)\n    makeActive =&gt; meth(s) \n      s.Ini&quot;
 &amp; &quot;tialState := \&quot;Active\&quot;;\t\n      form_putReactivity(s.form, s.name &amp; \&quot;&quot;
 &amp; &quot;filter\&quot;, \&quot;active\&quot;); \n      form_popUp(s.form, s.name &amp; \&quot;top\&quot;);\n &quot;
 &amp; &quot;     ok end,\n    (*- makeInvisible() -*)\n    makeInvisible =&gt; meth(s)&quot;
 &amp; &quot; \n      s.InitialState := \&quot;Vanish\&quot;;\n      refreshWidget( s);\n    \t&quot;
 &amp; &quot;ok end,    \n  (*- -*)\n  } \n  end,\n\n (*= filebrowser =*)\n  filebro&quot;
 &amp; &quot;wserNew =&gt; meth(s,   n)\n  { \n    SELF =&gt; 0,\n    form =&gt; 0, \n    nam&quot;
 &amp; &quot;e =&gt; n,\n    class =&gt; \&quot;filebrowser\&quot;,\n\n   (* Generic Attributes *)\n&quot;
 &amp; &quot;    parent =&gt; 0,\n\n    x =&gt; 0, y =&gt; 0, width =&gt;0, height =&gt;0, BgColor &quot;
 &amp; &quot;=&gt;\&quot;\&quot;, FgColor =&gt; \&quot;\&quot;,\n    Font =&gt; \&quot;\&quot;, Rim =&gt; 0, Border =&gt; 0, Embe&quot;
 &amp; &quot;llishment =&gt; \&quot;\&quot;,\n    InitialState =&gt; \&quot;\&quot;, ResizeModel =&gt; \&quot;\&quot;, \n\n&quot;
 &amp; &quot;    (* Widget Attributes *)\n    LabelFont =&gt; \&quot;\&quot;, ReadOnly =&gt; false,\n&quot;
 &amp; &quot;    V&quot;;

CONST E3_5 =
   &quot;alue =&gt; \&quot;.\&quot;, Suffixes =&gt; [], ActionLabel =&gt; \&quot;\&quot;,\n\n    (*- getFilen&quot;
 &amp; &quot;ame() returns text -*)\n    getFilename =&gt; meth(s) \n      form_getText&quot;
 &amp; &quot;(s.form, s.name, \&quot;\&quot;) end,    \n\n    (*- setFilename(fnm:text) -*)\n &quot;
 &amp; &quot;   setFilename =&gt; meth(s, fnm) \n      form_putText(s.form, s.name, \&quot;\&quot;&quot;
 &amp; &quot;,fnm, false ); ok end,    \n\n    (*- setActionLabel(lab:text)  -*)\n  &quot;
 &amp; &quot;   setActionLabel =&gt; meth(s, lab)\n\ts.ActionLabel := lab;\n\trefreshWi&quot;
 &amp; &quot;dget( s);\n\tok end,\n      (*- makeDormant() -*)\n    makeDormant =&gt; m&quot;
 &amp; &quot;eth(s) \n     s.InitialState := \&quot;Dormant\&quot;;\n      form_putReactivity(&quot;
 &amp; &quot;s.form, s.name &amp; \&quot;filter\&quot;, \&quot;dormant\&quot;); ok end,\n    (*- makePassive&quot;
 &amp; &quot;() -*)\n    makePassive =&gt; meth(s) \n     s.InitialState := \&quot;Passive\&quot;&quot;
 &amp; &quot;;\n      form_putReactivity(s.form, s.name &amp; \&quot;filter\&quot;, \&quot;passive\&quot;); &quot;
 &amp; &quot;ok end,\n    (*- makeActive() -*)\n    makeActive =&gt; meth(s) \n      s.&quot;
 &amp; &quot;InitialState := \&quot;Active\&quot;;\t\n      form_putReactivity(s.form, s.name &quot;
 &amp; &quot;&amp; \&quot;filter\&quot;, \&quot;active\&quot;); \n      form_popUp(s.form, s.name &amp; \&quot;top\&quot;)&quot;
 &amp; &quot;;\n      ok end,\n    (*- makeInvisible() -*)\n    makeInvisible =&gt; met&quot;
 &amp; &quot;h(s) \n      s.InitialState := \&quot;Vanish\&quot;;\n      refreshWidget( s);\n &quot;
 &amp; &quot;   \tok end,\t   \n    (*- -*)\n  } \n  end,\n\n (*= form =*)\n  formNe&quot;
 &amp; &quot;w =&gt; meth(s,  n)\n  { \n    SELF =&gt; 0,\n    form =&gt; 0, \n    name =&gt; n,&quot;
 &amp; &quot;\n    class =&gt; \&quot;form\&quot;,\n\n   (* Generic Attributes *)\n    parent =&gt; &quot;
 &amp; &quot;0,\n\n    x =&gt; 0, y =&gt; 0, width =&gt;0, height =&gt;0, BgColor =&gt;\&quot;\&quot;, FgColo&quot;
 &amp; &quot;r =&gt; \&quot;\&quot;,\n    Font =&gt; \&quot;\&quot;, Rim =&gt; 0, Border =&gt; 0, Embellishment =&gt; \&quot;&quot;
 &amp; &quot;\&quot;,\n    InitialState =&gt; \&quot;\&quot;, ResizeModel =&gt; \&quot;\&quot;, \t\n\n    (* Split &quot;
 &amp; &quot;Attributes *)\n    Texture =&gt; \&quot;\&quot;, children =&gt; [],\n\n    (* Form Attr&quot;
 &amp; &quot;ibutes *)\n    ParentForm =&gt; 0, ChildForms =&gt; [],\n    HasMenu =&gt; false&quot;
 &amp; &quot;, MenuBgColor =&gt; \&quot;\&quot;, MenuFgColor =&gt; \&quot;\&quot;,\n    MenuFont =&gt; \&quot;\&quot;, Menu&quot;
 &amp; &quot; =&gt; [],\n    TitleBgColor =&gt; \&quot;\&quot;,  TitleFgColor =&gt; \&quot;\&quot;,\n    TitleStr&quot;
 &amp; &quot;ing =&gt; \&quot;\&quot;, StretchX =&gt; 0, StretchY =&gt; 0,\n    ShrinkX =&gt; 0,  ShrinkY &quot;
 &amp; &quot;=&gt; 0,\n\n    CheckpointedXY =&gt; false, (* if false pops up in default po&quot;
 &amp; &quot;sition *)\n \n    (*- show(), shows form (toplevel or anchored)-*)\n   &quot;
 &amp; &quot; show =&gt; meth(s) \n      if s.ParentForm is 0 then\n\tif  s.form is 0 t&quot;
 &amp; &quot;hen&quot;;

CONST E3_6 =
   &quot;\n\t\ts.SELF.FORM := form_new(computeSX(s));\n\t\ts.SELF.VOAttachCBacks&quot;
 &amp; &quot;();   \n\t\tform_show(s.form);\n\tend\n      else\n\t s.popUp();\n     &quot;
 &amp; &quot; end;\n   ok end,\n    (*- hide(), hides form (toplevel or anchored) -*&quot;
 &amp; &quot;)\n    hide =&gt; meth(s) \n     if s.ParentForm is 0  then\n\tif  s.form &quot;
 &amp; &quot;isnot 0 then\n\t      checkptSX(s);\n\t      form_hide(s.form); \n     &quot;
 &amp; &quot;  \t      s.SELF.FORM := 0;\n\tend\n      else \n\t  s.close();    \n  &quot;
 &amp; &quot;    end;\n     ok end,\n    (*- putTitleString(titstr:text) -*)\n    pu&quot;
 &amp; &quot;tTitleString =&gt; meth(s, val)\n      s.TitleString := val;\n      form_p&quot;
 &amp; &quot;utText(s.form, s.name &amp; \&quot;titlestring\&quot;, \&quot;\&quot;, val, false); ok end,\n  &quot;
 &amp; &quot;  (*- putBgColor(clr:text) -*)\n    putBgColor =&gt; meth(s, val) \t\n    &quot;
 &amp; &quot;  s.BgColor := val;\n      form_putText(s.form, s.name &amp; \&quot;background\&quot;&quot;
 &amp; &quot;, \&quot;BgColor\&quot;, val, false); ok \n      end,\n    (*- getText() returns &quot;
 &amp; &quot;text -*)\n    getText =&gt; meth(s) \n      form_getText(s.form, s.name &amp; &quot;
 &amp; &quot;\&quot;titlestring\&quot;, \&quot;\&quot;) end,\n     (*- popUp(), shows anchored form -*)\n&quot;
 &amp; &quot;    popUp =&gt; meth(s)\n      form_popUp(s.form, s.name); \n      form_pu&quot;
 &amp; &quot;tReactivity(s.form, s.name &amp; \&quot;filter\&quot;, \&quot;active\&quot;); \n      ok end,\n&quot;
 &amp; &quot;    (*- close(), hides anchored form -*)\n    close =&gt; meth(s) \n      &quot;
 &amp; &quot;form_popDown(s.form, s.name); ok end,\n    (*- hasSelectedChoice() retu&quot;
 &amp; &quot;rns boolean -*)\n    hasSelectedChoice =&gt; meth(s)\n\ttry\n\t   s.getCho&quot;
 &amp; &quot;ice();   true;\n        except else false end;\n    end,\t \n    (*- ge&quot;
 &amp; &quot;tChoice() : text, exception if none selected. -*)\n    (*- - return val&quot;
 &amp; &quot;ue is name of choice, not label -*)\n    getChoice =&gt; meth(s)\n \tform_&quot;
 &amp; &quot;getChoice(s.form, s.name &amp; \&quot;radio\&quot;)  end,\n     (*- putChoice(textnam&quot;
 &amp; &quot;e:text),  exception if nonexistent -*)\n     (*- - \ttextname is the  n&quot;
 &amp; &quot;ame(not label) of the choice -*)\n    putChoice =&gt; meth(s, item)\n \tfo&quot;
 &amp; &quot;rm_putChoice(s.form, s.name &amp; \&quot;radio\&quot;, item); ok\n    end,\t\n    (*-&quot;
 &amp; &quot; -*)\n  } \n  end,\n\n  (*= frame =*)\n  frameNew =&gt; meth(s,  n)\n  { \n&quot;
 &amp; &quot;    SELF =&gt; 0,\n    form =&gt; 0, \n    name =&gt; n,\n    class =&gt; \&quot;frame\&quot;&quot;
 &amp; &quot;,\n\n    (* Generic Attributes *)\n    parent =&gt; 0,\n\n    x =&gt; 0, y =&gt;&quot;
 &amp; &quot; 0, width =&gt;0, height =&gt;0, BgColor =&gt;\&quot;\&quot;, FgColor =&gt; \&quot;\&quot;&quot;;

CONST E3_7 =
   &quot;,\n    Font =&gt; \&quot;\&quot;, Rim =&gt; 0, Border =&gt; 0, Embellishment =&gt; \&quot;\&quot;,\n   &quot;
 &amp; &quot; InitialState =&gt; \&quot;\&quot;, ResizeModel =&gt; \&quot;\&quot;, \t\n\n    Texture =&gt; \&quot;\&quot;, &quot;
 &amp; &quot;children =&gt; 0,\t\n\n    (*- hasSelectedChoice() returns boolean -*)\n  &quot;
 &amp; &quot;  hasSelectedChoice =&gt; meth(s)\n\ttry\n\t   s.getChoice();   true;\n   &quot;
 &amp; &quot;     except else false end;\n   end,\t \n    (*- getChoice() returns te&quot;
 &amp; &quot;xt, raises exception if unselected -*)\n    (*- -\tThe return value is &quot;
 &amp; &quot;the name of the choice, not its label -*)\n    getChoice =&gt; meth(s)\n \t&quot;
 &amp; &quot;form_getChoice(s.form, s.name &amp; \&quot;radio\&quot;)  end,\n    (*- putChoice(tex&quot;
 &amp; &quot;tname: text), raises exception if nonexistant -*)\n    (*- - \ttextname&quot;
 &amp; &quot; is a text containing the name (not label) of the choice -*)\n    putCh&quot;
 &amp; &quot;oice =&gt; meth(s, item)\n \tform_putChoice(s.form, s.name &amp; \&quot;radio\&quot;, it&quot;
 &amp; &quot;em); ok\n    end,\t\n    (*- makeActive() -*)\n    makeActive =&gt; meth(s&quot;
 &amp; &quot;) \n      s.InitialState := \&quot;Active\&quot;;\t\n      form_putReactivity(s.f&quot;
 &amp; &quot;orm, s.name &amp; \&quot;filter\&quot;, \&quot;active\&quot;); \n      form_popUp(s.form, s.nam&quot;
 &amp; &quot;e &amp; \&quot;top\&quot;);\n      ok end,\n    (*- makeInvisible() -*)\n    makeInvi&quot;
 &amp; &quot;sible =&gt; meth(s) \n      s.InitialState := \&quot;Vanish\&quot;;\n      refreshWi&quot;
 &amp; &quot;dget( s);\n    \tok end,\n    \n    (*- -*)\n  } \n  end,\n\n (*= hscro&quot;
 &amp; &quot;ll =*)\n  hscrollNew =&gt; meth(s,  n)\n  { \n    SELF =&gt; 0,\n    form =&gt; &quot;
 &amp; &quot;0, \n    name =&gt; n,\n    class =&gt; \&quot;hscroll\&quot;,\n\n   (* Generic Attribu&quot;
 &amp; &quot;tes *)\n    parent =&gt; 0,\n\n    x =&gt; 0, y =&gt; 0, width =&gt;0, height =&gt;0, &quot;
 &amp; &quot;BgColor =&gt;\&quot;\&quot;, FgColor =&gt; \&quot;\&quot;,\n    Font =&gt; \&quot;\&quot;, Rim =&gt; 0, Border =&gt;&quot;
 &amp; &quot; 0, Embellishment =&gt; \&quot;\&quot;,\n    InitialState =&gt; \&quot;\&quot;, ResizeModel =&gt; \&quot;&quot;
 &amp; &quot;\&quot;, \n\n   (* Widget Attributes *)\n   Min =&gt; 0, Max =&gt; 0, Val =&gt; 0,\n &quot;
 &amp; &quot;  Thumb =&gt; 0, Step =&gt; 0,\n\n   (*- getValue() returns integer -*)\n    &quot;
 &amp; &quot;getValue =&gt; meth(s) \n      form_getInt(s.form, s.name , \&quot;\&quot;) end,\n  &quot;
 &amp; &quot;  (*- getMin() returns integer -*)\n    getMin =&gt; meth(s) \n      form_&quot;
 &amp; &quot;getInt(s.form, s.name , \&quot;Min\&quot;) end,\n    (*- getMax() returns integer&quot;
 &amp; &quot; -*)\n    getMax =&gt; meth(s) \n      form_getInt(s.form, s.name , \&quot;Max\&quot;&quot;
 &amp; &quot;) end,\n    (*- setValue(val) -*)\n    setValue =&gt; meth(s, val) \n     &quot;
 &amp; &quot; form_putInt(s.form, s.name , \&quot;\&quot;, val); ok  end,\n    (*- setMi&quot;;

CONST E3_8 =
   &quot;n(minval) -*)\n    setMin =&gt; meth(s, val) \n\ts.Min := val;\n      form&quot;
 &amp; &quot;_putInt(s.form, s.name , \&quot;Min\&quot;, val); ok end,\n    (*- setMax(maxval)&quot;
 &amp; &quot;  -*)\n    setMax =&gt; meth(s, val) \n\ts.Max := val;\n      form_putInt(&quot;
 &amp; &quot;s.form, s.name , \&quot;Max\&quot;, val); ok  end,\n    (*- -*)\n  } \n  end,\n\n&quot;
 &amp; &quot;  (*= menuitem =*)\n  menuItemNew =&gt; meth(s,   l, n, lev, initst)\n  { &quot;
 &amp; &quot;\n    SELF =&gt; 0,\n    form =&gt; 0, \n    Label =&gt; l,\n    name =&gt; n,\n   &quot;
 &amp; &quot; class =&gt; \&quot;menuItem\&quot;,\n\n    Level =&gt; lev,\n    initialState =&gt; inits&quot;
 &amp; &quot;t,\n\n    (*- setLabel(tx:text) -*)\n    setLabel =&gt; meth(s, val) \t\n\t&quot;
 &amp; &quot;s.Label := val;\n      form_putText(s.form, s.name &amp; \&quot;Label\&quot;, \&quot;\&quot;, v&quot;
 &amp; &quot;al, false); ok end,\n    (*- makeDormant() -*)\n    makeDormant =&gt; meth&quot;
 &amp; &quot;(s) \n     s.InitialState := \&quot;Dormant\&quot;;\n      form_putReactivity(s.f&quot;
 &amp; &quot;orm, s.name &amp; \&quot;filter\&quot;, \&quot;dormant\&quot;); ok end,\n    (*- makePassive() &quot;
 &amp; &quot;-*)\n    makePassive =&gt; meth(s) \n      s.InitialState := \&quot;Passive\&quot;;\n&quot;
 &amp; &quot;      form_putReactivity(s.form, s.name &amp; \&quot;filter\&quot;, \&quot;passive\&quot;); ok &quot;
 &amp; &quot;end,\n    (*- makeActive() -*)\n    makeActive =&gt; meth(s) \n      s.Ini&quot;
 &amp; &quot;tialState := \&quot;Active\&quot;;\t\n      form_putReactivity(s.form, s.name &amp; \&quot;&quot;
 &amp; &quot;filter\&quot;, \&quot;active\&quot;); ok end,\n     (*- makeInvisible() -*)\n    makeI&quot;
 &amp; &quot;nvisible =&gt; meth(s) \n      s.InitialState := \&quot;Vanish\&quot;;\t\n      form&quot;
 &amp; &quot;_putReactivity(s.form, s.name &amp; \&quot;filter\&quot;, \&quot;vanished\&quot;); ok end,\n   &quot;
 &amp; &quot;(*- -*)\n  } \n  end,\n\n  (*= numeric =*)\n  numericNew =&gt; meth(s,  n)&quot;
 &amp; &quot;\n  { \n    SELF =&gt; 0,\n    form =&gt; 0, \n    name =&gt; n,\n    class =&gt; \&quot;&quot;
 &amp; &quot;numeric\&quot;,\n\n   (* Generic Attributes *)\n    parent =&gt; 0,\n\n    x =&gt;&quot;
 &amp; &quot; 0, y =&gt; 0, width =&gt;0, height =&gt;0, BgColor =&gt;\&quot;\&quot;, FgColor =&gt; \&quot;\&quot;,\n  &quot;
 &amp; &quot;  Font =&gt; \&quot;\&quot;, Rim =&gt; 0, Border =&gt; 0, Embellishment =&gt; \&quot;\&quot;,\n    Init&quot;
 &amp; &quot;ialState =&gt; \&quot;\&quot;, ResizeModel =&gt; \&quot;\&quot;, \n\n   (* Widget Attributes *)\n&quot;
 &amp; &quot;   AllowEmpty =&gt; false, HideButtons =&gt; false,\n   Min =&gt; 0, Max =&gt; 0, V&quot;
 &amp; &quot;al =&gt; 0, \n\n   (*- getValue() returns integer -*)\n    getValue =&gt; met&quot;
 &amp; &quot;h(s) \n      form_getInt(s.form, s.name , \&quot;\&quot;) end,\n    (*- getMin() &quot;
 &amp; &quot;returns integer -*)\n    getMin =&gt; meth(s) \n      form_getInt(s.form, &quot;
 &amp; &quot;s.name , \&quot;Min\&quot;) end,\n    (*- getMax() returns integer -*)\n    get&quot;;

CONST E3_9 =
   &quot;Max =&gt; meth(s) \n      form_getInt(s.form, s.name , \&quot;Max\&quot;) end,\n    &quot;
 &amp; &quot;(*- setValue(val) -*)\n    setValue =&gt; meth(s, val) \n      form_putInt&quot;
 &amp; &quot;(s.form, s.name , \&quot;\&quot;, val); ok  end,\n    (*- setMin(minval) -*)\n   &quot;
 &amp; &quot; setMin =&gt; meth(s, val)\n\ts.Min := val; \n      form_putInt(s.form, s.&quot;
 &amp; &quot;name , \&quot;Min\&quot;, val); ok end,\n    (*- setMax(maxval)  -*)\n    setMax &quot;
 &amp; &quot;=&gt; meth(s, val) \n      s.Max := val;\n      form_putInt(s.form, s.name&quot;
 &amp; &quot; , \&quot;Max\&quot;, val); ok  end,\n    (*- -*)\n  } \n  end,\n\n(*= text =*) \n&quot;
 &amp; &quot;  textNew =&gt; meth(s,  n)\n  { \n    SELF =&gt; 0,\n    form =&gt; 0, \n    na&quot;
 &amp; &quot;me =&gt; n,\n    class =&gt; \&quot;text\&quot;,\n\n   (* Generic Attributes *)\n    pa&quot;
 &amp; &quot;rent =&gt; 0,\n\n    x =&gt; 0, y =&gt; 0, width =&gt;0, height =&gt;0, BgColor =&gt;\&quot;\&quot;&quot;
 &amp; &quot;, FgColor =&gt; \&quot;\&quot;,\n    Font =&gt; \&quot;\&quot;, Rim =&gt; 0, Border =&gt; 0, Embellishm&quot;
 &amp; &quot;ent =&gt; \&quot;\&quot;,\n    InitialState =&gt; \&quot;\&quot;, ResizeModel =&gt; \&quot;\&quot;, \n\n    (*&quot;
 &amp; &quot; Widget Attributes *)\n    tOrientation =&gt; \&quot;Center\&quot;, tVal =&gt; \&quot;\&quot;,\n\n&quot;
 &amp; &quot;    (*- getText() returns text -*)\n    getText =&gt; meth(s) \n      form&quot;
 &amp; &quot;_getText(s.form, s.name, \&quot;\&quot;) end,\n    (*- putText(val:text) -*)\n   &quot;
 &amp; &quot; putText =&gt; meth(s, val) \n     s.tVal := val;\n      form_putText(s.fo&quot;
 &amp; &quot;rm, s.name, \&quot;\&quot;, val, false); ok end,\n    (*- appendText(val:text) -*&quot;
 &amp; &quot;)\n    appendText =&gt; meth(s, val) \n\ts.tVal := s.tVal @ val;\n      fo&quot;
 &amp; &quot;rm_putText(s.form, s.name, \&quot;\&quot;, val, true); ok end,\n    (*- putBgColo&quot;
 &amp; &quot;r(clr:text) -*)\n    putBgColor =&gt; meth(s, val) \n\ts.BgColor := val;\n&quot;
 &amp; &quot;      form_putText(s.form, s.name, \&quot;BgColor\&quot;, val, false); ok end,\n &quot;
 &amp; &quot;   (*- putFgColor(clr:text) -*)\n    putFgColor =&gt; meth(s, val) \n\ts.F&quot;
 &amp; &quot;gColor := val;\n      form_putText(s.form, s.name, \&quot;FgColor\&quot;, val, fa&quot;
 &amp; &quot;lse); ok end,\n    (*- putValue(intval:integer) -*)\n    putValue =&gt; me&quot;
 &amp; &quot;th(s, val) \n      var v = ok; \n      try v := fmt_int(val) except els&quot;
 &amp; &quot;e v := \&quot;\&quot; end;\n\ts.tVal := v;\n      form_putText(s.form, s.name, \&quot;&quot;
 &amp; &quot;\&quot;, v, false); \n      ok end,\n     (*- makeActive() -*)\n    makeActi&quot;
 &amp; &quot;ve =&gt; meth(s) \n      s.InitialState := \&quot;Active\&quot;;\t\n      form_putRe&quot;
 &amp; &quot;activity(s.form, s.name &amp; \&quot;filter\&quot;, \&quot;active\&quot;); \n      form_popUp(s&quot;
 &amp; &quot;.form, s.name &amp; \&quot;top\&quot;);\n      ok end,\n     (*- makeInvis&quot;;

CONST E3_10 =
   &quot;ible() -*)\n    makeInvisible =&gt; meth(s) \n      s.InitialState := \&quot;Va&quot;
 &amp; &quot;nish\&quot;;\n      refreshWidget( s);\n    \tok end,\t   \n    (*- -*)\n  }&quot;
 &amp; &quot;\n  end,\n\n(*= textedit =*) \n  texteditNew =&gt; meth(s,  n)\n  { \n    &quot;
 &amp; &quot;SELF =&gt; 0,\n    form =&gt; 0, \n    name =&gt; n,\n    class =&gt; \&quot;textedit\&quot;,&quot;
 &amp; &quot;\n\n   (* Generic Attributes *)\n    parent =&gt; 0,\n\n    x =&gt; 0, y =&gt; 0&quot;
 &amp; &quot;, width =&gt;0, height =&gt;0, BgColor =&gt;\&quot;\&quot;, FgColor =&gt; \&quot;\&quot;,\n    Font =&gt; &quot;
 &amp; &quot;\&quot;\&quot;, Rim =&gt; 0, Border =&gt; 0, Embellishment =&gt; \&quot;\&quot;,\n    InitialState =&quot;
 &amp; &quot;&gt; \&quot;\&quot;, ResizeModel =&gt; \&quot;\&quot;, \n\n   (* Widget Attributes *)\n    teRead&quot;
 &amp; &quot;Only =&gt; false, teClip =&gt; false, teHasScrollbar =&gt; true,\n    teContents&quot;
 &amp; &quot; =&gt; \&quot;\&quot;, teFromFile =&gt; \&quot;\&quot;, getFromFile =&gt; false,\n    \n    (*- getT&quot;
 &amp; &quot;ext() returns text -*)\n    getText =&gt; meth(s) \n      form_getText(s.f&quot;
 &amp; &quot;orm, s.name, \&quot;\&quot;) end,\n    (*- putText(t:text) -*)\n    putText =&gt; me&quot;
 &amp; &quot;th(s, val) \n      form_putText(s.form, s.name, \&quot;\&quot;, val, false); ok e&quot;
 &amp; &quot;nd,\n    (*- appendText(t:text) -*)\n    appendText =&gt; meth(s, val) \n &quot;
 &amp; &quot;     form_putText(s.form, s.name, \&quot;\&quot;, val, true); ok end,\n    (*- fl&quot;
 &amp; &quot;ush() -*)\n    flush =&gt; meth(s) \n      form_putText(s.form, s.name, \&quot;&quot;
 &amp; &quot;\&quot;, \&quot;\&quot;, false); ok end,\n      (*- makeDormant() -*)\n    makeDormant&quot;
 &amp; &quot; =&gt; meth(s) \n     s.InitialState := \&quot;Dormant\&quot;;\n      form_putReacti&quot;
 &amp; &quot;vity(s.form, s.name &amp; \&quot;filter\&quot;, \&quot;dormant\&quot;); ok end,\n    (*- makePa&quot;
 &amp; &quot;ssive() -*)\n    makePassive =&gt; meth(s) \n      s.InitialState := \&quot;Pas&quot;
 &amp; &quot;sive\&quot;;\n      form_putReactivity(s.form, s.name &amp; \&quot;filter\&quot;, \&quot;passiv&quot;
 &amp; &quot;e\&quot;); ok end,\n    \n   (*- putBgColor(clr:text) -*)\n    putBgColor =&gt;&quot;
 &amp; &quot; meth(s, val) \t\n\ts.BgColor := val;\n      form_putText(s.form, s.nam&quot;
 &amp; &quot;e, \&quot;BgColor\&quot;, val, false); ok end,\n     (*- putFgColor(clr:text) -*)&quot;
 &amp; &quot;\n     putFgColor =&gt; meth(s, val) \n     s.FgColor := val;\n      form_&quot;
 &amp; &quot;putText(s.form, s.name, \&quot;FgColor\&quot;, val, false); ok end,\n(*- makeActi&quot;
 &amp; &quot;ve() -*)\n    makeActive =&gt; meth(s) \n      s.InitialState := \&quot;Active\&quot;&quot;
 &amp; &quot;;\t\n      form_putReactivity(s.form, s.name &amp; \&quot;filter\&quot;, \&quot;active\&quot;);&quot;
 &amp; &quot; \n      form_popUp(s.form, s.name &amp; \&quot;top\&quot;);\n      ok end,\n (*- mak&quot;
 &amp; &quot;eInvisible() -*)\n    makeInvisible =&gt; meth(s) \n      s.Initial&quot;;

CONST E3_11 =
   &quot;State := \&quot;Vanish\&quot;;\n      refreshWidget( s);\n    \tok end,\n   (*- -&quot;
 &amp; &quot;*)\n  }\n  end,\n\n(*= typein =*)\n  typeinNew =&gt; meth(s,  n)\n  { \n  &quot;
 &amp; &quot;  SELF =&gt; 0,\n    form =&gt; 0, \n    name =&gt; n,\n    class =&gt; \&quot;typein\&quot;,&quot;
 &amp; &quot;\n\n    (* Generic Attributes *)\n    parent =&gt; 0,\n\n    x =&gt; 0, y =&gt; &quot;
 &amp; &quot;0, width =&gt;0, height =&gt;0, BgColor =&gt;\&quot;\&quot;, FgColor =&gt; \&quot;\&quot;,\n    Font =&gt;&quot;
 &amp; &quot; \&quot;\&quot;, Rim =&gt; 0, Border =&gt; 0, Embellishment =&gt; \&quot;\&quot;,\n    InitialState &quot;
 &amp; &quot;=&gt; \&quot;\&quot;, ResizeModel =&gt; \&quot;\&quot;, \n\n    (* Widget Attributes *)\n     tyR&quot;
 &amp; &quot;eadOnly =&gt; false, tyExpand =&gt; false, tyInit =&gt; \&quot;\&quot;,\n\n   \n    (*- pu&quot;
 &amp; &quot;tText(t:text) -*)\n    putText =&gt; meth(s, val) \n      form_putText(s.f&quot;
 &amp; &quot;orm, s.name, \&quot;\&quot;, val, false); ok end,\n    (*- appendText(t:text) -*)&quot;
 &amp; &quot;\n    appendText =&gt; meth(s, val) \n      form_putText(s.form, s.name, \&quot;&quot;
 &amp; &quot;\&quot;, val, true); ok end,\n    (*- getText() returns text -*)\n    getTex&quot;
 &amp; &quot;t =&gt; meth(s) \n      form_getText(s.form, s.name, \&quot;\&quot;) end,\n   (*- fl&quot;
 &amp; &quot;ush() -*)\n    flush =&gt; meth(s) \n      form_putText(s.form, s.name, \&quot;&quot;
 &amp; &quot;\&quot;, \&quot;\&quot;, false); ok end,\n\n(*- makeDormant() -*)\n    makeDormant =&gt; &quot;
 &amp; &quot;meth(s) \n     s.InitialState := \&quot;Dormant\&quot;;\n      form_putReactivity&quot;
 &amp; &quot;(s.form, s.name &amp; \&quot;filter\&quot;, \&quot;dormant\&quot;); ok end,\n    (*- makePassiv&quot;
 &amp; &quot;e() -*)\n    makePassive =&gt; meth(s) \n     s.InitialState := \&quot;Passive\&quot;&quot;
 &amp; &quot;;\n      form_putReactivity(s.form, s.name &amp; \&quot;filter\&quot;, \&quot;passive\&quot;); &quot;
 &amp; &quot;ok end,\n    (*- makeActive() -*)\n    makeActive =&gt; meth(s) \n      s.&quot;
 &amp; &quot;InitialState := \&quot;Active\&quot;;\t\n      form_putReactivity(s.form, s.name &quot;
 &amp; &quot;&amp; \&quot;filter\&quot;, \&quot;active\&quot;); \n      form_popUp(s.form, s.name &amp; \&quot;top\&quot;)&quot;
 &amp; &quot;;\n      ok end,\n    (*- makeInvisible() -*)\n    makeInvisible =&gt; met&quot;
 &amp; &quot;h(s) \n      s.InitialState := \&quot;Vanish\&quot;;\n      refreshWidget( s);\n &quot;
 &amp; &quot;   \tok end,\n    \n\n   (*- putBgColor(clr:text) -*)\n    putBgColor =&quot;
 &amp; &quot;&gt; meth(s, val) \t\n\ts.BgColor := val;\n      form_putText(s.form, s.na&quot;
 &amp; &quot;me, \&quot;BgColor\&quot;, val, false); ok end,\n     (*- putFgColor(clr:text) -*&quot;
 &amp; &quot;)\n     putFgColor =&gt; meth(s, val) \n     s.FgColor := val;\n      form&quot;
 &amp; &quot;_putText(s.form, s.name, \&quot;FgColor\&quot;, val, false); ok end,  \n  }\n  en&quot;
 &amp; &quot;d,\n\n(*= vscroll =*)\n  vscrollNew =&gt; meth(s,  n)\n  { \n    SELF =&gt; 0&quot;
 &amp; &quot;,&quot;;

CONST E3_12 =
   &quot;\n    form =&gt; 0, \n    name =&gt; n,\n    class =&gt; \&quot;vscroll\&quot;,\n\n   (* G&quot;
 &amp; &quot;eneric Attributes *)\n    parent =&gt; 0,\n\n    x =&gt; 0, y =&gt; 0, width =&gt;0&quot;
 &amp; &quot;, height =&gt;0, BgColor =&gt;\&quot;\&quot;, FgColor =&gt; \&quot;\&quot;,\n    Font =&gt; \&quot;\&quot;, Rim =&quot;
 &amp; &quot;&gt; 0, Border =&gt; 0, Embellishment =&gt; \&quot;\&quot;,\n    InitialState =&gt; \&quot;\&quot;, Res&quot;
 &amp; &quot;izeModel =&gt; \&quot;\&quot;, \n \n    (* Widget Attributes *)\n   Min =&gt; 0, Max =&gt;&quot;
 &amp; &quot; 0, Val =&gt; 0,\n   Thumb =&gt; 0, Step =&gt; 0,\n\n   (*- getValue() returns i&quot;
 &amp; &quot;nteger -*)\n    getValue =&gt; meth(s) \n      form_getInt(s.form, s.name &quot;
 &amp; &quot;, \&quot;\&quot;) end,\n    (*- getMin() returns integer -*)\n    getMin =&gt; meth(&quot;
 &amp; &quot;s) \n      form_getInt(s.form, s.name , \&quot;Min\&quot;) end,\n    (*- getMax()&quot;
 &amp; &quot; returns integer -*)\n    getMax =&gt; meth(s) \n      form_getInt(s.form,&quot;
 &amp; &quot; s.name , \&quot;Max\&quot;) end,\n    (*- setValue(val) -*)\n    setValue =&gt; met&quot;
 &amp; &quot;h(s, val) \n      form_putInt(s.form, s.name , \&quot;\&quot;, val); ok  end,\n  &quot;
 &amp; &quot;  (*- setMin(minval) -*)\n    setMin =&gt; meth(s, val) \n\ts.Min := val;\n&quot;
 &amp; &quot;      form_putInt(s.form, s.name , \&quot;Min\&quot;, val); ok end,\n    (*- setM&quot;
 &amp; &quot;ax(maxval)  -*)\n    setMax =&gt; meth(s, val) \n\ts.Max := val;\n      fo&quot;
 &amp; &quot;rm_putInt(s.form, s.name , \&quot;Max\&quot;, val); ok  end,\n    (*- -*)\n  } \n&quot;
 &amp; &quot;  end,\n\n(*= video =*)\n  videoNew =&gt; meth(s,  n)\n  { \n    SELF =&gt; 0&quot;
 &amp; &quot;,\n    form =&gt; 0, \n    name =&gt; n,\n    class =&gt; \&quot;video\&quot;,\n\n   (* Ge&quot;
 &amp; &quot;neric Attributes *)\n    parent =&gt; 0,\n\n    x =&gt; 0, y =&gt; 0, width =&gt;0,&quot;
 &amp; &quot; height =&gt;0, BgColor =&gt;\&quot;\&quot;, FgColor =&gt; \&quot;\&quot;,\n    Font =&gt; \&quot;\&quot;, Rim =&gt;&quot;
 &amp; &quot; 0, Border =&gt; 0, Embellishment =&gt; \&quot;\&quot;,\n    InitialState =&gt; \&quot;\&quot;, Resi&quot;
 &amp; &quot;zeModel =&gt; \&quot;\&quot;, \n\n    (* Widget Attributes *)\n     Source =&gt; \&quot;\&quot;, &quot;
 &amp; &quot;Quality =&gt; 0, Width =&gt; 0, Height =&gt; 0,\n     Colours =&gt; 0, MSecs =&gt; 0, &quot;
 &amp; &quot;Synchronous =&gt; false,\n     FixedSize =&gt; false, Paused =&gt; false,\n \n  &quot;
 &amp; &quot;  AuSource =&gt; \&quot;\&quot;, Volume =&gt; 0, Mute =&gt; false, \n    IgnoreMapping =&gt; &quot;
 &amp; &quot;false,\n\n    (*- setQuality(val:integer) returns boolean -*)\n    setQ&quot;
 &amp; &quot;uality =&gt; meth(s, val) \t\t\n     try\n      form_putInt(s.form, s.name&quot;
 &amp; &quot;, \&quot;Quality\&quot;, val); \n      true\n     except else false  end\n     en&quot;
 &amp; &quot;d,\n   (*- setWidth(wid:integer) -*)\n    setWidth =&gt; meth(s, val) \t\t&quot;
 &amp; &quot;\n      form_putInt(s.form, s.name, \&quot;Width\&quot;, val); ok end,\n  (*-&quot;;

CONST E3_13 =
   &quot; setSource(src:text) returns ok -*)\n    setSource =&gt; meth(s, src)\n\ts&quot;
 &amp; &quot;.AuSource := src;\n    \ts.Source := src; refreshWidget( s); ok  end,\n&quot;
 &amp; &quot;   (*- setHeight(ht:integer) -*)\n    setHeight =&gt; meth(s, val) \t\t\t\n&quot;
 &amp; &quot;      form_putInt(s.form, s.name, \&quot;Height\&quot;, val); ok end,\n   (*- set&quot;
 &amp; &quot;FramesPerSec(fps:integer) -*)\n    setFramesPerSec =&gt; meth(s, val) \t\t&quot;
 &amp; &quot;\t\n      form_putInt(s.form, s.name, \&quot;MSecs\&quot;, (1000 /val)); ok end,\n&quot;
 &amp; &quot;   (*- setVolume(v:integer) returns boolean -*)\n    setVolume =&gt; meth(&quot;
 &amp; &quot;s, val) \t\t\n      try\t\n      \tform_putInt(s.form, s.name &amp; \&quot;audio&quot;
 &amp; &quot;\&quot; , \&quot;Volume\&quot;, val);\n\ttrue\n      except else\n\tfalse\n      end\n&quot;
 &amp; &quot;     end, \n    (*- setMute(onoff:boolean) -*)\n     setMute =&gt; meth(s,&quot;
 &amp; &quot; val)\n\tform_putBool(s.form, s.name &amp; \&quot;audio\&quot; , \&quot;Mute\&quot;, val);\t\n &quot;
 &amp; &quot;       ok end,\n    (*- setIgnoreMapping(onoff:boolean) -*)\n      setI&quot;
 &amp; &quot;gnoreMapping =&gt; meth(s, val)\n\tform_putBool(s.form, s.name &amp; \&quot;audio\&quot;&quot;
 &amp; &quot; , \&quot;IgnoreMapping\&quot;, val);\t\n        ok end,\n     (*- setSynchronous&quot;
 &amp; &quot;(onoff:boolean)  -*)\n      setSynchronous =&gt; meth(s, val)\n\tform_putB&quot;
 &amp; &quot;ool(s.form, s.name, \&quot;Synchronous\&quot;, val);\t\n        ok end,\n     (*-&quot;
 &amp; &quot; setPaused(onoff:boolean) -*)\n      setPaused =&gt; meth(s, val)\n\tform_&quot;
 &amp; &quot;putBool(s.form, s.name, \&quot;Paused\&quot;, val);\t\n        ok end,\n     (*- &quot;
 &amp; &quot;setFixedSize(onoff:boolean) -*)\n      setFixedSize =&gt; meth(s, val)\n\t&quot;
 &amp; &quot;form_putBool(s.form, s.name, \&quot;FixedSize\&quot;, val);\t\n        ok end,\n &quot;
 &amp; &quot;     (*- makeActive() -*)\n    makeActive =&gt; meth(s) \n      s.InitialS&quot;
 &amp; &quot;tate := \&quot;Active\&quot;;\t\n      form_putReactivity(s.form, s.name &amp; \&quot;filt&quot;
 &amp; &quot;er\&quot;, \&quot;active\&quot;); \n      form_popUp(s.form, s.name &amp; \&quot;top\&quot;);\n     &quot;
 &amp; &quot; ok end,\n    (*- makeInvisible() -*)\n    makeInvisible =&gt; meth(s) \n &quot;
 &amp; &quot;     s.InitialState := \&quot;Vanish\&quot;;\n      refreshWidget( s);\n    \tok &quot;
 &amp; &quot;end,\n    \n     (*- -*)\n  } \n  end,\n\n(* placeholders for restricte&quot;
 &amp; &quot;d access procs  *)\nprocessNew =&gt; ok,\nrdOpen =&gt; ok,\nwrOpen =&gt;  ok,\nw&quot;
 &amp; &quot;rOpenAppend =&gt; ok\n};\n\n\n(* Some useful procedures that will be copie&quot;
 &amp; &quot;d into volibLocal\n    in cases where the computation needs to happen l&quot;
 &amp; &quot;ocally *)\n\n(*: Join(ssn:text, host:text) returns boolean  :*)&quot;;

CONST E3_14 =
   &quot;\nlet Join = proc(ssn, host) \n  try\n    let sessionConst = net_import&quot;
 &amp; &quot;(ssn, host);\n    (sessionConst.New)(volibLocal);\n    true\n  except e&quot;
 &amp; &quot;lse \n    false\n  end; \nend;\n\n(* normal versions of restricted acce&quot;
 &amp; &quot;ss procs  *)\n(*: processNew(nameAndArgs:[text], mergeOut:boolean) retu&quot;
 &amp; &quot;rns process :*)\nvar processNew = proc(nameAndArgs, mergeOut) \n\tproce&quot;
 &amp; &quot;ss_new(processor, nameAndArgs, mergeOut)\nend;\n\n(*: rdOpen(filename:t&quot;
 &amp; &quot;ext) returns reader :*)\nvar rdOpen = proc(fnm) \n\trd_open(fileSys, fn&quot;
 &amp; &quot;m)\nend;\n\n(*: wrOpen(filename:text) returns writer :*)\nvar wrOpen = &quot;
 &amp; &quot; proc(fnm) \n\t\twr_open(fileSys, fnm);\nend;\n\n(*: wrOpenAppend(filen&quot;
 &amp; &quot;ame:text) returns writer :*)\nvar wrOpenAppend = proc(fnm) \n\t\twr_ope&quot;
 &amp; &quot;nAppend(fileSys, fnm);\nend;\n\n\nvolibLocal.Join := Join;\n\nvolibLoca&quot;
 &amp; &quot;l.processNew := meth(s, n , mer)\n\tprocessNew(n, mer)\nend;\n\nvolibLo&quot;
 &amp; &quot;cal.rdOpen := meth(s, fnm)\n\trdOpen(fnm)\nend;\n\nvolibLocal.wrOpen :=&quot;
 &amp; &quot; meth(s, fnm)\n\twrOpen(fnm)\nend;\n\nvolibLocal.wrOpenAppend := meth(s&quot;
 &amp; &quot;, fnm)\n\twrOpenAppend(fnm)\nend;\nsys_popSilence();\n\n\n&quot;;

CONST E4 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Tue Jan &quot;
 &amp; &quot;10 11:50:00 PST 1995 by mhb     *)\n\nmodule templates;\nlet Templates &quot;
 &amp; &quot;= {\nboolean =&gt; \&quot;\n(Filter %@filter $FilterState$\n \n  (Shape %@shape&quot;
 &amp; &quot; (Width $XSpan$ + Inf - Inf) (Height $YSpan$ + Inf - Inf)\n  \n    (BgC&quot;
 &amp; &quot;olor \\\&quot;$BgColor$\\\&quot;) (Color \\\&quot;$FgColor$\\\&quot;)\n     (LabelFont \\\&quot;&quot;
 &amp; &quot;$Font$\\\&quot;)  \n     \n     (Frame $FrameStyle$  \n      (Rim %@rim (Pen&quot;
 &amp; &quot; $RimPen$) (ShadowSize 1.5)\n       (Border %@border (Pen $BorderPen$)\n&quot;
 &amp; &quot;\n         (Boolean =$initValue$ %@ $fbstyle$ \n                 ( $Boo&quot;
 &amp; &quot;leanContents$ )\n         )\n         \n        )\n           \n       &quot;
 &amp; &quot; )\n      )\n    )\n )\n  \n\n\&quot;,\nbrowser =&gt; \&quot;\n(Filter %@filter $Fil&quot;
 &amp; &quot;terState$\n \n  (Shape %@shape (Width $XSpan$ + Inf - Inf) (Height $YSp&quot;
 &amp; &quot;an$ + Inf - Inf)\n  \n    (BgColor \\\&quot;$BgColor$\\\&quot;) (Color \\\&quot;$FgCol&quot;
 &amp; &quot;or$\\\&quot;)\n     (Font \\\&quot;$Font$\\\&quot;)  \n     \n     (Frame $FrameStyle$&quot;
 &amp; &quot;  \n      (Rim %@rim (Pen $RimPen$) (ShadowSize 1.5)\n       (Border %@&quot;
 &amp; &quot;border (Pen $BorderPen$)\n      \n        ($typeOfBrowser$   %@        &quot;
 &amp; &quot;                \n            $quick$\n            (Items $Items$)\n   &quot;
 &amp; &quot;         $ValueList$ \n        )\n\n        )\n           \n        )\n&quot;
 &amp; &quot;      )\n    )\n )\n  \n\n\&quot;,\nbutton =&gt; \&quot;\n(Filter %@filter $FilterSt&quot;
 &amp; &quot;ate$\n \n  (Shape %@shape (Width $XSpan$ + Inf - Inf) (Height $YSpan$ +&quot;
 &amp; &quot; Inf - Inf)\n  \n    (BgColor \\\&quot;$BgColor$\\\&quot;) (Color \\\&quot;$FgColor$\\&quot;
 &amp; &quot;\&quot;)\n     (LabelFont \\\&quot;$Font$\\\&quot;)  \n     \n     (Frame $FrameStyle$&quot;
 &amp; &quot;  \n      (Rim %@rim (Pen $RimPen$) (ShadowSize 1.5)\n       (Border %@&quot;
 &amp; &quot;border (Pen $BorderPen$)\n        $GuardHeader$\n          ($Trill$Butt&quot;
 &amp; &quot;on %@\n          ($ButtonContents$)\n          )\n        $GuardFooter$&quot;
 &amp; &quot;\n        )\n           \n        )\n      )\n    )\n )\n  \n\n\&quot;,\ncho&quot;
 &amp; &quot;ice =&gt; \&quot;\n(Filter %@filter $FilterState$\n \n  (Shape %@shape (Width $&quot;
 &amp; &quot;XSpan$ + Inf - Inf) (Height $YSpan$ + Inf - Inf)\n  \n    (BgColor \\\&quot;&quot;
 &amp; &quot;$BgC&quot;;

CONST E4_0 =
   &quot;olor$\\\&quot;) (Color \\\&quot;$FgColor$\\\&quot;)\n     (LabelFont \\\&quot;$Font$\\\&quot;)  &quot;
 &amp; &quot;\n     \n     (Frame $FrameStyle$  \n      (Rim %@rim (Pen $RimPen$) (S&quot;
 &amp; &quot;hadowSize 1.5)\n       (Border %@border (Pen $BorderPen$)\n\n         (&quot;
 &amp; &quot;Choice =$initValue$ %@ $fbstyle$ \n                 ( $ChoiceContents$ &quot;
 &amp; &quot;)\n         )\n         \n        )\n           \n        )\n      )\n &quot;
 &amp; &quot;   )\n )\n  \n\n\&quot;,\nfilebrowser =&gt; \&quot;\n(Filter %@filter $FilterState$\n&quot;
 &amp; &quot; \n  (Shape %@shape (Width $XSpan$ + Inf - Inf) (Height $YSpan$ + Inf -&quot;
 &amp; &quot; Inf)\n  \n    (BgColor \\\&quot;$BgColor$\\\&quot;) (Color \\\&quot;$FgColor$\\\&quot;)\n &quot;
 &amp; &quot;    (LabelFont \\\&quot;$LabelFont$\\\&quot;)  (Font \\\&quot;$Font$\\\&quot;)  \n\n     (F&quot;
 &amp; &quot;rame $FrameStyle$  \n      (Rim %@rim (Pen $RimPen$) (ShadowSize 1.5)\n&quot;
 &amp; &quot;       (Border %@border (Pen $BorderPen$)\n       \n        (VBox\n    &quot;
 &amp; &quot;     (Glue 5)\n          (HBox (Glue 5)\n            (Shape\n          &quot;
 &amp; &quot;    (Width 150 + Inf - 100)\n              (Height 150 + Inf - 100)\n  &quot;
 &amp; &quot;            (VBox\n                (LabelFont \\\&quot;fixed\\\&quot;)\n         &quot;
 &amp; &quot;       (DirMenu (For $fbName1$))\n                (Glue 6)\n           &quot;
 &amp; &quot;     (Frame Lowered (BgColor \\\&quot;White\\\&quot;)\n                     (File&quot;
 &amp; &quot;Browser %@ $ReadOnly$ \n                         (Value \\\&quot;$Initial$\\&quot;
 &amp; &quot;\&quot;)\n                         (Suffixes $Suffixes$)\n                  &quot;
 &amp; &quot;   )\n                 )))\n            (Glue 5)\n            (Shape\n &quot;
 &amp; &quot;             (Width 50 + Inf)\n              (VBox\n                (Fi&quot;
 &amp; &quot;ll)\n                (Button %@action \\\&quot;$ActionLabel$\\\&quot;)\n         &quot;
 &amp; &quot;       (Glue 10)\n               ))\n            (Glue 5))\n          (&quot;
 &amp; &quot;Glue 5)\n          (HBox\n            (Glue 5)\n            (Shape (Wid&quot;
 &amp; &quot;th 30 + Inf) (Height 16) \\\&quot;File :\\\&quot;)\n            (Frame Lowered (B&quot;
 &amp; &quot;gColor \\\&quot;White\\\&quot;) (Helper %@typein (For $fbName2$) (Font \\\&quot;fixed\\&quot;
 &amp; &quot;\&quot;)))\n            (Glue 5))\n          (Glue 5))\n        )\n         &quot;
 &amp; &quot;  \n        )\n      )\n    )\n )\n  \n\&quot;,\nform =&gt; \&quot;\n(ZChild $ZChild&quot;
 &amp; &quot;State$ %@ \n  (Filter %@filter $FilterState$ \n    (Radio %@radio\n    &quot;
 &amp; &quot;  $ZSplitHeader$\n      (Shape %@shape \n        (Width $XSpan$ + $XStr&quot;
 &amp; &quot;etch$ - $XShrink$) \n        (Height $YSpan$ + $YStretch$ - $YShrink$)\n&quot;
 &amp; &quot;     &quot;;

CONST E4_1 =
   &quot;   (BgColor \\\&quot;$BgColor$\\\&quot;) \n        (Color \\\&quot;$FgColor$\\\&quot;)\n   &quot;
 &amp; &quot;     (LabelFont \\\&quot;$Font$\\\&quot;)\n        (Rim %@rim (Pen $RimPen$) \n  &quot;
 &amp; &quot;        (Border %@border (Pen $BorderPen$)\n            (VBox\n\t     (&quot;
 &amp; &quot;Macro $TitleBar$ ()\n              \'(Shape %@title (Height 20)\n      &quot;
 &amp; &quot;          (Frame $FrameStyle$ \n                  (BgColor \\\&quot;$TitleBg&quot;
 &amp; &quot;Color$\\\&quot;) \n                  (Color \\\&quot;$TitleFgColor$\\\&quot;)\n       &quot;
 &amp; &quot;           (HBox \n                    (Shape (Width 15) \n            &quot;
 &amp; &quot;          (CloseButton (ShadowSize 0) (Pixmap \\\&quot;close.pbm\\\&quot;))) \n  &quot;
 &amp; &quot;                  Chisel\n                    (Shape (Width + 1000)  \n&quot;
 &amp; &quot;                       (ZMove (ShadowSize 0) (Text %@titlestring \\\&quot;$T&quot;
 &amp; &quot;itleString$\\\&quot;)))    \n                    Chisel \n                  &quot;
 &amp; &quot;  (Shape (Width 15) \n                      (ZGrow (ShadowSize 0) (Pixm&quot;
 &amp; &quot;ap \\\&quot;grow.pbm\\\&quot;))))))\n\t      )\n\t      $IncludeTitleBar$\t\t\n  &quot;
 &amp; &quot;            $MenuStructure$\n              (Text  %@background \\\&quot;\\\&quot;&quot;
 &amp; &quot; )))))\n      $ZSplitFooter$\n)))         \n\&quot;,\nframe =&gt; \&quot;\n(Filter %&quot;
 &amp; &quot;@filter $FilterState$\n (Radio %@radio\n $ZSplitHeader$\n  (Shape %@sha&quot;
 &amp; &quot;pe (Width $XSpan$ + Inf - Inf) (Height $YSpan$ + Inf - Inf)\n  \n    (B&quot;
 &amp; &quot;gColor \\\&quot;$BgColor$\\\&quot;) (Color \\\&quot;$FgColor$\\\&quot;)\n    \n     (Frame &quot;
 &amp; &quot;$FrameStyle$  \n      (Rim %@rim (Pen $RimPen$) \n       (Border %@bord&quot;
 &amp; &quot;er (Pen $BorderPen$)\n      \n        (Texture  %@ \\\&quot;$TextureFile$\\\&quot;&quot;
 &amp; &quot; )\n           \n        )\n      )\n    )\n   )\n $ZSplitFooter$      &quot;
 &amp; &quot;  \n )\n)\n\&quot;,\nhscroll =&gt; \&quot;\n(Filter %@filter $FilterState$\n \n  (Sh&quot;
 &amp; &quot;ape %@shape (Width $XSpan$ + Inf - Inf) (Height $YSpan$ + Inf - Inf)\n &quot;
 &amp; &quot; \n    (BgColor \\\&quot;$BgColor$\\\&quot;) (Color \\\&quot;$FgColor$\\\&quot;)\n     (Lab&quot;
 &amp; &quot;elFont \\\&quot;$Font$\\\&quot;)  \n     \n     (Frame $FrameStyle$  \n      (Rim&quot;
 &amp; &quot; %@rim (Pen $RimPen$) (ShadowSize 1.5)\n       (Border %@border (Pen $B&quot;
 &amp; &quot;orderPen$)\n\n        (Scroller %@\n            (Value $Value$) (Min $M&quot;
 &amp; &quot;in$)\n            (Max $Max$) (Thumb $Thumb$)\n            (Step $Step$&quot;
 &amp; &quot;)\n        )    \n       \n         \n        )\n           \n        )&quot;
 &amp; &quot;\n      )\n    )\n )\n  \n\n\&quot;,\nmenu =&gt; \&quot;\n(Filter %@Menu\n (Macro \n&quot;
 &amp; &quot;    MenuItem\n    BOA\n&quot;;

CONST E4_2 =
   &quot;    (xFilter initState x xLabel xLabelValue)\n    `(Filter %,xFilter ,i&quot;
 &amp; &quot;nitState\n        (Menu %,x (Text %,xLabel ,xLabelValue))\n     )\n  ) &quot;
 &amp; &quot;\n  (Macro \n    PullDownMenuItem\n    BOA\n    (xFilter initState x xL&quot;
 &amp; &quot;abel xLabelValue pulldown)\n    `(Filter %,xFilter ,initState\n        &quot;
 &amp; &quot;(Menu %,x (Text %,xLabel ,xLabelValue)\n            (Border (Pen 1)\n  &quot;
 &amp; &quot;                  ,pulldown\n            )\n        )\n     )\n  ) \n\n&quot;
 &amp; &quot; (Macro\n   MenuButton\n   BOA\n   (xFilter initState x xLabel xLabelVa&quot;
 &amp; &quot;lue )\n   `(Filter %,xFilter ,initState\n       (MButton %,x\n         &quot;
 &amp; &quot;(Text %,xLabel ,xLabelValue) \n       )\n    )\n  )\n    (BgColor \\\&quot;$&quot;
 &amp; &quot;MenuBgColor$\\\&quot;) (Color \\\&quot;$MenuFgColor$\\\&quot;)\n    (LabelFont \\\&quot;$Me&quot;
 &amp; &quot;nuFont$\\\&quot;)\n    (ShadowSize 0)\n    (Border  (Pen 1)\n        (HBox \n&quot;
 &amp; &quot;           $MenuItems$\n           (Glue 1000)\n        )  \n    ) \n)\n&quot;
 &amp; &quot;\&quot;,\nnumeric =&gt; \&quot;\n(Filter %@filter $FilterState$\n \n  (Shape %@shape&quot;
 &amp; &quot; (Width $XSpan$ + Inf - Inf) (Height $YSpan$ + Inf - Inf)\n  \n    (BgC&quot;
 &amp; &quot;olor \\\&quot;$BgColor$\\\&quot;) (Color \\\&quot;$FgColor$\\\&quot;)\n     (Font \\\&quot;$Font&quot;
 &amp; &quot;$\\\&quot;)  \n     \n     (Frame $FrameStyle$  \n      (Rim %@rim (Pen $Rim&quot;
 &amp; &quot;Pen$) (ShadowSize 1.5)\n       (Border %@border (Pen $BorderPen$)\n\n  &quot;
 &amp; &quot;      (Numeric $HideButtons$ $AllowEmpty$ %@\n            (Value $Value&quot;
 &amp; &quot;$) (Min $Min$)\n            (Max $Max$) \n        )    \n       \n     &quot;
 &amp; &quot;    \n        )\n           \n        )\n      )\n    )\n )\n  \n\n\&quot;,\n&quot;
 &amp; &quot;text =&gt; \&quot;\n(Filter %@filter $FilterState$\n \n  (Shape %@shape (Width &quot;
 &amp; &quot;$XSpan$ + Inf - Inf) (Height $YSpan$ + Inf - Inf)\n  \n    (BgColor \\\&quot;&quot;
 &amp; &quot;$BgColor$\\\&quot;) (Color \\\&quot;$FgColor$\\\&quot;)\n     (LabelFont \\\&quot;$Font$\\\&quot;&quot;
 &amp; &quot;)  \n     \n     (Frame $FrameStyle$  \n      (Rim %@rim (Pen $RimPen$)&quot;
 &amp; &quot; (ShadowSize 1.5)\n       (Border %@border (Pen $BorderPen$)\n\n       &quot;
 &amp; &quot; (Text $Alignment$ %@ \\\&quot;$Initial$\\\&quot;)\n         \n        )\n       &quot;
 &amp; &quot;    \n        )\n      )\n    )\n )\n  \n\n\&quot;,\ntextedit =&gt; \&quot;\n(Filter&quot;
 &amp; &quot; %@filter $FilterState$\n \n  (Shape %@shape (Width $XSpan$ + Inf - Inf&quot;
 &amp; &quot;) (Height $YSpan$ + Inf - Inf)\n  \n    (BgColor \\\&quot;$BgColor$\\\&quot;) (Co&quot;
 &amp; &quot;lor \\\&quot;$FgColor$\\\&quot;)\n     (Font \\\&quot;$Font$\\\&quot;)  \n     \n     (Fram&quot;
 &amp; &quot;e $FrameStyle$  \n   &quot;;

CONST E4_3 =
   &quot;   (Rim %@rim (Pen $RimPen$) (ShadowSize 1.5)\n       (Border %@border &quot;
 &amp; &quot;(Pen $BorderPen$)\n\n        (TextEdit %@ $ReadOnly$ $Clip$ $NoScrollba&quot;
 &amp; &quot;r$\n            ($Initial$)\n         )\n         \n        )\n        &quot;
 &amp; &quot;   \n        )\n      )\n    )\n )\n  \n\n\&quot;,\ntypein =&gt; \&quot;\n(Filter %@&quot;
 &amp; &quot;filter $FilterState$\n \n  (Shape %@shape (Width $XSpan$ + Inf - Inf) (&quot;
 &amp; &quot;Height $YSpan$ + Inf - Inf)\n  \n    (BgColor \\\&quot;$BgColor$\\\&quot;) (Color&quot;
 &amp; &quot; \\\&quot;$FgColor$\\\&quot;)\n     (Font \\\&quot;$Font$\\\&quot;)  \n     \n     (Frame $&quot;
 &amp; &quot;FrameStyle$  \n      (Rim %@rim (Pen $RimPen$) (ShadowSize 1.5)\n      &quot;
 &amp; &quot; (Border %@border (Pen $BorderPen$)\n\n        (TypeIn %@ $ReadOnly$ $E&quot;
 &amp; &quot;xpandOnDemand$\n            (Value \\\&quot;$Initial$\\\&quot;)\n         )\n    &quot;
 &amp; &quot;     \n        )\n           \n        )\n      )\n    )\n )\n  \n\n\&quot;,&quot;
 &amp; &quot;\nvideo =&gt; \&quot;\n(Filter %@filter $FilterState$\n \n  (Shape %@shape (Wid&quot;
 &amp; &quot;th $XSpan$ + Inf - Inf) (Height $YSpan$ + Inf - Inf)\n  \n    (BgColor &quot;
 &amp; &quot;\\\&quot;$BgColor$\\\&quot;) (Color \\\&quot;$FgColor$\\\&quot;)\n     (Font \\\&quot;$Font$\\\&quot;&quot;
 &amp; &quot;)  \n     \n     (Frame $FrameStyle$  \n      (Rim %@rim (Pen $RimPen$)&quot;
 &amp; &quot; (ShadowSize 1.5)\n       (Border %@border (Pen $BorderPen$)\n     (TSp&quot;
 &amp; &quot;lit %@toggle   =$PlayVideo$\n        (Audio %@audio =\\\&quot;$AudioSource$\\&quot;
 &amp; &quot;\&quot; (Volume $Volume$)\n\t\t$Mute$ $IgnoreMapping$\n            (Video %@&quot;
 &amp; &quot; \n\t\t(Quality $Quality$)\n\t\t(Width $Width$) (Height $Height$)\n\t\t&quot;
 &amp; &quot;(Colors $Colours$) (MSecs $MSecs$)\n\t\t$Synchronous$ $FixedSize$ $Paus&quot;
 &amp; &quot;ed$\n\t\t\\\&quot;$VideoSource$\\\&quot;\n\t\t)\n         )\n\t(Text \\\&quot;\\\&quot;)\n &quot;
 &amp; &quot;     )\n         \n        )\n           \n        )\n      )\n    )\n &quot;
 &amp; &quot;)\n  \n\n\&quot;,\nvscroll =&gt; \&quot;\n(Filter %@filter $FilterState$\n \n  (Shap&quot;
 &amp; &quot;e %@shape (Width $XSpan$ + Inf - Inf) (Height $YSpan$ + Inf - Inf)\n  \n&quot;
 &amp; &quot;    (BgColor \\\&quot;$BgColor$\\\&quot;) (Color \\\&quot;$FgColor$\\\&quot;)\n     (LabelF&quot;
 &amp; &quot;ont \\\&quot;$Font$\\\&quot;)  \n     \n     (Frame $FrameStyle$  \n      (Rim %@&quot;
 &amp; &quot;rim (Pen $RimPen$) (ShadowSize 1.5)\n       (Border %@border (Pen $Bord&quot;
 &amp; &quot;erPen$)\n\n        (Scroller Vertical %@ \n            (Value $Value$) &quot;
 &amp; &quot;(Min $Min$)\n            (Max $Max$) (Thumb $Thumb$)\n            (Step&quot;
 &amp; &quot; $Step$)\n        )    \n       \n         \n        )\n           \n  &quot;
 &amp; &quot;      )\n      )\n    )\n )\n  \n\n\&quot;,\n};\n&quot;;

BEGIN
END VORunBundle.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
