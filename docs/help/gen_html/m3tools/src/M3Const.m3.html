<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: m3tools/src/M3Const.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>m3tools/src/M3Const.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright 1996-2000 Critical Mass, Inc. All rights reserved.    
 See file COPYRIGHT-CMASS for details. 

<P><PRE>MODULE <module><implements><A HREF="M3Const.i3.html">M3Const</A></implements></module>;

IMPORT <A HREF="../../libm3/src/fmtlex/Fmt.i3.html">Fmt</A>, <A HREF="#x1">M3ID</A>, <A HREF="#x2">M3AST</A>, <A HREF="M3Scope.i3.html">M3Scope</A>, <A HREF="M3Type.i3.html">M3Type</A>, <A HREF="../../m3middle/src/Target.i3.html">Target</A>, <A HREF="../../m3middle/src/TInt.i3.html">TInt</A>, <A HREF="../../m3middle/src/TFloat.i3.html">TFloat</A>, <A HREF="../../m3middle/src/TWord.i3.html">TWord</A>, <A HREF="../../m3core/src/text/Text.i3.html">Text</A>;
IMPORT <A HREF="M3SetVal.i3.html">M3SetVal</A>, <A HREF="M3RecVal.i3.html">M3RecVal</A>, <A HREF="M3ArrVal.i3.html">M3ArrVal</A>, <A HREF="M3Builtin.i3.html">M3Builtin</A>;
FROM <A HREF="#x2">M3AST</A> IMPORT NodeIndex;
</PRE><BLOCKQUOTE><EM>***
IMPORT Stdio, Wr, Thread;
***</EM></BLOCKQUOTE><PRE>

TYPE
  State = RECORD
    env     : ImportOracle;
    ast     : M3AST.T;
    max_loc : CARDINAL;
    loc     : NodeIndex;
    op      : M3AST.OP;
    info    : INTEGER;
    n_ch    : CARDINAL;
    ch      : ARRAY [0..9] OF NodeIndex;
  END;

TYPE
  EvalProc = PROCEDURE (VAR s: State;  VAR(*OUT*) val: T) RAISES {Error};

VAR
  init_done := FALSE;
  eval_procs: ARRAY M3AST.OP OF EvalProc;

PROCEDURE <A NAME="Eval"><procedure>Eval</procedure></A> (ast : M3AST.T;
                loc : NodeIndex;
                env : ImportOracle;
     VAR(*OUT*) val : T)
  RAISES {Error} =
  VAR s: State;
  BEGIN
    IF (NOT init_done) THEN Init(); END;
    IF (ast.nodes = NIL) THEN BadAST(); END;
    s.env     := env;
    s.ast     := ast;
    s.max_loc := NUMBER (ast.nodes^);
    EvalX (s, loc, val);
  END Eval;

PROCEDURE <A NAME="EvalX"><procedure>EvalX</procedure></A> (VAR s: State;  loc: NodeIndex;  VAR val: T)
  RAISES {Error} =
  BEGIN
    IF (loc &gt; s.max_loc) THEN BadAST (); END;
    WITH z = s.ast.nodes [loc] DO
      WITH desc = M3AST.OpMap [z.op] DO
        s.loc  := loc;
        s.op   := z.op;
        s.info := z.info;
        s.n_ch := M3AST.GetChildren (s.ast, loc, s.ch);
</PRE><BLOCKQUOTE><EM>***
Out (<CODE>eval </CODE>, Fmt.Int (loc), <CODE> =&gt; </CODE>, Fmt.Int (z.op)
       &amp; <CODE>  n_ch = </CODE> &amp; Fmt.Int (s.n_ch));
***</EM></BLOCKQUOTE><PRE>
        IF (s.n_ch &lt; desc.min_ch) THEN BadAST (); END;
        IF (s.n_ch &gt; desc.max_ch) AND (desc.max_ch # 255) THEN BadAST (); END;
        eval_procs [s.op] (s, val);
      END;
    END;
  END EvalX;
</PRE>********
PROCEDURE Out (a, b, c, d: TEXT := NIL) =
  &lt;*FATAL Wr.Failure, Thread.Alerted*&gt;
  VAR wr := Stdio.stdout;
  BEGIN
    IF (a # NIL) THEN Wr.PutText (wr, a); END;
    IF (b # NIL) THEN Wr.PutText (wr, b); END;
    IF (c # NIL) THEN Wr.PutText (wr, c); END;
    IF (d # NIL) THEN Wr.PutText (wr, d); END;
    Wr.PutText (wr, Wr.EOL);
    Wr.Flush (wr);
  END Out;
********

<P>------------------------------------------------------------------ types ---

<P><PRE>PROCEDURE <A NAME="EvalArray"><procedure>EvalArray</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR
    index := s.ch[0];
    elt   := s.ch[1];
    arr   := NEW (M3Type.Array);
  BEGIN
    val.class := Class.Type;
    val.type  := arr;
    arr.index := EvalType (s, index);
    arr.element := EvalType (s, elt);
  END EvalArray;

PROCEDURE <A NAME="EvalOpenArray"><procedure>EvalOpenArray</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR
    elt := s.ch[0];
    arr := NEW (M3Type.OpenArray);
  BEGIN
    val.class := Class.Type;
    val.type  := arr;
    arr.element := EvalType (s, elt);
  END EvalOpenArray;

PROCEDURE <A NAME="EvalEnum"><procedure>EvalEnum</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR
    base := s.loc + 1;
    elts := NEW (REF ARRAY OF M3ID.T, s.n_ch);
    enum := NEW (M3Type.Enum);
  BEGIN
    val.class := Class.Type;
    val.type  := enum;
    enum.elements := elts;
    FOR i := 0 TO s.n_ch - 1 DO
      WITH z = s.ast.nodes [base + i] DO
        IF z.op # M3AST.OP_EnumDefn THEN Err (&quot;bad enumerated type&quot;); END;
        elts[i] := z.info;
      END;
    END;
  END EvalEnum;

PROCEDURE <A NAME="EvalNamedType"><procedure>EvalNamedType</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR xx: T;
  BEGIN
    val.class := Class.Type;
    val.type  := M3Type.Integer;  (* to prevent disasterous cycles *)
    EvalX (s, s.ch[0], xx);
    IF (xx.class # Class.Type) THEN
      Err (&quot;bad type (class = &quot; &amp; Fmt.Int (ORD (val.class)) &amp; &quot;)&quot; );
    END;
    val.type := xx.type;
  END EvalNamedType;

PROCEDURE <A NAME="EvalPacked"><procedure>EvalPacked</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR
    bits := s.ch[0];
    tipe := s.ch[1];
    pack := NEW (M3Type.Packed);
    n_bits : T;
  BEGIN
    val.class := Class.Type;
    val.type  := pack;
    EvalX (s, bits, n_bits);
    IF (n_bits.class # Class.Integer)
      OR NOT TInt.ToInt (n_bits.int, pack.bits) THEN
      Err (&quot;bad size specified in BITS FOR&quot;);
    END;
    pack.element := EvalType (s, tipe);
  END EvalPacked;

PROCEDURE <A NAME="EvalProcType"><procedure>EvalProcType</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR
    ast       := s.ast;
    self      := s.loc;
    info      := s.info;
    n_ch      := s.n_ch;
    n_formals : CARDINAL := 0;
    n_raises  : CARDINAL := 0;
    loc, ch   : NodeIndex;
    cnt       : CARDINAL;
    proc      := NEW (M3Type.Procedure);
  BEGIN
    val.class := Class.Type;
    val.type  := proc;

    (* get the calling convention *)
    IF (info = M3ID.NoID) THEN
      proc.callingConv := Target.DefaultCall;
    ELSE
      proc.callingConv := Target.FindConvention (M3ID.ToText (info));
      IF (proc.callingConv = NIL) THEN
        Err (&quot;unrecognized calling convention: &quot; &amp; M3ID.ToText (info));
      END;
    END;

    (* count the formals *)
    FOR i := 0 TO n_ch - 3 DO
      loc := M3AST.NthChild (ast, self, i);
      cnt := M3AST.NumChildren (ast, loc);
      IF (cnt &lt;= 2) THEN BadAST (); END;
      INC (n_formals, cnt - 2);
    END;
    proc.formals := NEW (REF ARRAY OF M3Type.FormalDesc, n_formals);

    (* accumulate the formals *)
    n_formals := 0;
    FOR i := 0 TO n_ch - 3 DO
      loc := M3AST.NthChild (ast, self, i);
      AddFormals (s, loc, n_formals, proc.formals);
    END;

    (* grab the return type *)
    proc.return := EvalTypeOrEmpty (s, M3AST.NthChild (ast, self, n_ch - 2));

    (* grab the exceptions *)
    loc := M3AST.NthChild (ast, self, n_ch - 1);
    WITH z = ast.nodes [loc] DO
      IF (z.op = M3AST.OP_RaisesAny) THEN
        n_raises := 1;
        proc.raises := NEW (REF ARRAY OF M3Type.ExceptDesc, 1);
        proc.raises[0].ast  := NIL;
        proc.raises[0].decl := 0;
      ELSIF (z.op = M3AST.OP_Raises) THEN
        n_raises := M3AST.NumChildren (ast, loc);
        proc.raises := NEW (REF ARRAY OF M3Type.ExceptDesc, n_raises);
        n_raises := 0;
        FOR i := 0 TO n_raises - 1 DO
          ch := M3AST.NthChild (ast, loc, i);
          AddException (s, ch, n_raises, proc.raises);
        END;
      ELSE
        Err (&quot;bad procedure type&quot;);
      END;
    END;
  END EvalProcType;

PROCEDURE <A NAME="AddFormals"><procedure>AddFormals</procedure></A> (VAR s: State;  loc: NodeIndex;  VAR n_formals: CARDINAL;
                      formals: REF ARRAY OF M3Type.FormalDesc)
  RAISES {Error} =
  VAR
    ast     := s.ast;
    n_ids   := M3AST.NumChildren (ast, loc) - 2;
    ftype   : M3Type.T;
    default : T;
    ch      : NodeIndex;
    mode    : M3Type.Mode;
  BEGIN
    (* get the formal's mode *)
    WITH z = ast.nodes [loc] DO
      CASE z.info OF
      | 0 =&gt; mode := M3Type.Mode.Value;
      | 1 =&gt; mode := M3Type.Mode.Var;
      | 2 =&gt; mode := M3Type.Mode.Readonly;
      ELSE Err (&quot;bad formal parameter mode&quot;);
      END;
    END;

    (* get the formal type *)
    ch := M3AST.NthChild (ast, loc, n_ids);
    ftype := EvalTypeOrEmpty (s, ch);

    (* get the default value *)
    ch := M3AST.NthChild (ast, loc, n_ids + 1);
    WITH z = ast.nodes [ch] DO
      IF (z.op = M3AST.OP_Empty)
        THEN default.type := M3Type.Integer;
        ELSE EvalX (s, ch, default);
      END;
    END;

    (* fix the missing type if possible *)
    IF (ftype = NIL) THEN ftype := default.type; END;

    FOR i := 0 TO n_ids - 1 DO
      ch := M3AST.NthChild (ast, loc, i);
      WITH z = ast.nodes [ch] DO
        IF (z.op # M3AST.OP_FormalDefn) THEN Err (&quot;bad formal parameter&quot;); END;
        WITH f = formals [n_formals] DO
          f.name := z.info;
          f.type := ftype;
          f.mode := mode;
          (* f.default := ?? *)
        END;
        INC (n_formals);
      END;
    END;
  END AddFormals;

PROCEDURE <A NAME="AddException"><procedure>AddException</procedure></A> (VAR s: State;  loc: NodeIndex;  VAR n_raises: CARDINAL;
                        raises: REF ARRAY OF M3Type.ExceptDesc)
  RAISES {Error} =
  VAR val: T;
  BEGIN
    EvalX (s, loc, val);
    IF (val.class # Class.Exception) THEN
      Err (&quot;bad exception in RAISES clause&quot;);
    END;
    WITH z = raises [n_raises] DO
      z.ast  := val.ref;
      z.decl := val.info;
    END;
    INC (n_raises);
  END AddException;

PROCEDURE <A NAME="EvalObject"><procedure>EvalObject</procedure></A> (&lt;*UNUSED*&gt; VAR s: State;  VAR val: T)
  RAISES {Error} =
  BEGIN
    val.class := Class.Type;
    val.type  := NEW (M3Type.Object);
    Err (&quot;object types not implemented yet&quot;);
  END EvalObject;

PROCEDURE <A NAME="EvalRecord"><procedure>EvalRecord</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR
    ast       := s.ast;
    self      := s.loc;
    n_ch      := s.n_ch;
    n_fields  : CARDINAL := 0;
    loc       : NodeIndex;
    rec       := NEW (M3Type.Record);
  BEGIN
    val.class := Class.Type;
    val.type  := rec;

    (* count the fields *)
    FOR i := 0 TO n_ch - 1 DO
      loc := M3AST.NthChild (ast, self, i);
      INC (n_fields, M3AST.NumChildren (ast, loc) - 2);
    END;
    rec.fields := NEW (REF ARRAY OF M3Type.FieldDesc, n_fields);

    (* accumulate the fields *)
    n_fields := 0;
    FOR i := 0 TO n_ch - 1 DO
      loc := M3AST.NthChild (ast, self, i);
      AddFields (s, loc, n_fields, rec.fields);
    END;
  END EvalRecord;

PROCEDURE <A NAME="AddFields"><procedure>AddFields</procedure></A> (VAR s: State;  loc: NodeIndex;  VAR n_fields: CARDINAL;
                      fields: REF ARRAY OF M3Type.FieldDesc)
  RAISES {Error} =
  VAR
    ast     := s.ast;
    n_ch    := M3AST.NumChildren (ast, loc);
    ftype   : M3Type.T;
    default : T;
    ch      : NodeIndex;
  BEGIN
    (* get the field type *)
    ch := M3AST.NthChild (ast, loc, n_ch - 2);
    ftype := EvalTypeOrEmpty (s, ch);

    (* get the default value *)
    ch := M3AST.NthChild (ast, loc, n_ch - 1);
    WITH z = ast.nodes [ch] DO
      IF (z.op = M3AST.OP_Empty)
        THEN default.type := M3Type.Integer;
        ELSE EvalX (s, ch, default);
      END;
    END;

    (* fix the missing type if possible *)
    IF (ftype = NIL) THEN ftype := default.type; END;

    FOR i := 0 TO n_ch - 3 DO
      ch := M3AST.NthChild (ast, loc, i);
      WITH z = ast.nodes [ch] DO
        IF (z.op # M3AST.OP_FieldDefn) THEN Err (&quot;bad field name&quot;); END;
        WITH f = fields [n_fields] DO
          f.name := z.info;
          f.type := ftype;
          (* f.default := ?? *)
        END;
        INC (n_fields);
      END;
    END;
  END AddFields;

PROCEDURE <A NAME="EvalRef"><procedure>EvalRef</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR
    brand  := s.ch[0];
    target := s.ch[1];
    ref    := NEW (M3Type.Ref, traced := TRUE);
  BEGIN
    val.class := Class.Type;
    val.type  := ref;
    ref.brand  := GetBrand (s, brand);
    ref.target := EvalType (s, target);
  END EvalRef;

PROCEDURE <A NAME="EvalRoot"><procedure>EvalRoot</procedure></A> (&lt;*UNUSED*&gt; VAR s: State;  VAR val: T) =
  BEGIN
    val.class := Class.Type;
    val.type  := M3Type.Root;
  END EvalRoot;

PROCEDURE <A NAME="EvalSet"><procedure>EvalSet</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR
    dom := s.ch[0];
    set := NEW (M3Type.Set);
  BEGIN
    val.class := Class.Type;
    val.type  := set;
    set.domain := EvalType (s, dom);
  END EvalSet;

PROCEDURE <A NAME="EvalSubrange"><procedure>EvalSubrange</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR
    min, max : T;
    subrange := NEW (M3Type.Subrange);
  BEGIN
    val.class := Class.Type;
    val.type  := subrange;
    EvalPair (s, min, max);
    subrange.min   := min.int;
    subrange.max   := max.int;
    subrange.super := min.type;
  END EvalSubrange;

PROCEDURE <A NAME="EvalUntracedRef"><procedure>EvalUntracedRef</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR
    brand  := s.ch[0];
    target := s.ch[1];
    ref    := NEW (M3Type.Ref, traced := FALSE);
  BEGIN
    val.class := Class.Type;
    val.type  := ref;
    ref.brand  := GetBrand (s, brand);
    ref.target := EvalType (s, target);
  END EvalUntracedRef;

PROCEDURE <A NAME="EvalUntracedRoot"><procedure>EvalUntracedRoot</procedure></A> (&lt;*UNUSED*&gt; VAR s: State;  VAR val: T) =
  BEGIN
    val.class := Class.Type;
    val.type  := M3Type.UntracedRoot;
  END EvalUntracedRoot;

PROCEDURE <A NAME="GetBrand"><procedure>GetBrand</procedure></A> (VAR s: State;  loc: NodeIndex): TEXT
  RAISES {Error} =
  VAR op := s.ast.nodes[loc].op;  val: T;
  BEGIN
    IF (op = M3AST.OP_NoBrand) THEN
      RETURN NIL;
    ELSIF (op = M3AST.OP_DefaultBrand) THEN
      RETURN NewBrand ();
    ELSE
      EvalX (s, loc, val);
      IF (val.class # Class.Text) THEN
        Err (&quot;brand is not a TEXT constant&quot;);
      END;
      RETURN NARROW (val.ref, TEXT);
    END;
  END GetBrand;

PROCEDURE <A NAME="NewBrand"><procedure>NewBrand</procedure></A> (): TEXT =
  BEGIN
    RETURN &quot;oops&quot;;
  END NewBrand;

PROCEDURE <A NAME="EvalTypeOrEmpty"><procedure>EvalTypeOrEmpty</procedure></A> (VAR s: State;  loc: NodeIndex): M3Type.T
  RAISES {Error} =
  BEGIN
    WITH z = s.ast.nodes [loc] DO
      IF (z.op = M3AST.OP_Empty)
        THEN RETURN NIL;
        ELSE RETURN EvalType (s, loc);
      END;
    END;
  END EvalTypeOrEmpty;

PROCEDURE <A NAME="EvalType"><procedure>EvalType</procedure></A> (VAR s: State;  loc: NodeIndex): M3Type.T
  RAISES {Error} =
  VAR val: T;
  BEGIN
    EvalX (s, loc, val);
    IF (val.class # Class.Type) THEN Err (&quot;not a type&quot;); END;
    RETURN val.type;
  END EvalType;
</PRE>---------------------------------------------------- expression operators ---

<P><PRE>PROCEDURE <A NAME="EvalOr"><procedure>EvalOr</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR a, b: T;
  BEGIN
    EvalPair (s, a, b);
    IF (a.class # Class.Enum)
      OR (b.class # Class.Enum)
      OR (M3Type.Base (a.type) # M3Type.Boolean)
      OR (M3Type.Base (b.type) # M3Type.Boolean) THEN
      Err (&quot;bad operand for OR&quot;);
    END;
    val.class := Class.Enum;
    val.type  := M3Type.Boolean;
    val.info  := MAX (a.info, b.info);
  END EvalOr;

PROCEDURE <A NAME="EvalAnd"><procedure>EvalAnd</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR a, b: T;
  BEGIN
    EvalPair (s, a, b);
    IF (a.class # Class.Enum)
      OR (b.class # Class.Enum)
      OR (M3Type.Base (a.type) # M3Type.Boolean)
      OR (M3Type.Base (b.type) # M3Type.Boolean) THEN
      Err (&quot;bad operand for AND&quot;);
    END;
    val.class := Class.Enum;
    val.type  := M3Type.Boolean;
    val.info  := MIN (a.info, b.info);
  END EvalAnd;

PROCEDURE <A NAME="EvalNot"><procedure>EvalNot</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  BEGIN
    EvalX (s, s.ch[0], val);
    IF (val.class # Class.Enum)
      OR (M3Type.Base (val.type) # M3Type.Boolean) THEN
      Err (&quot;bad operand for NOT&quot;);
    END;
    val.class := Class.Enum;
    val.type  := M3Type.Boolean;
    val.info  := 1 - val.info;
  END EvalNot;

PROCEDURE <A NAME="EvalEQ"><procedure>EvalEQ</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR a, b: T;
  BEGIN
    EvalPair (s, a, b);
    val.class := Class.Enum;
    val.type  := M3Type.Boolean;
    val.info  := ORD (IsEQ (a, b));
  END EvalEQ;

PROCEDURE <A NAME="EvalNE"><procedure>EvalNE</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR a, b: T;
  BEGIN
    EvalPair (s, a, b);
    val.class := Class.Enum;
    val.type  := M3Type.Boolean;
    val.info  := ORD (NOT IsEQ (a, b));
  END EvalNE;

PROCEDURE <A NAME="IsEQ"><procedure>IsEQ</procedure></A> (READONLY a, b: T): BOOLEAN =
  VAR eq: BOOLEAN;
  BEGIN
    IF (a.class # b.class) THEN RETURN FALSE; END;
    CASE a.class OF
    | Class.Integer    =&gt; eq := TInt.EQ (a.int, b.int);
    | Class.Float      =&gt; eq := TFloat.EQ (a.float, b.float);
    | Class.Enum       =&gt; eq := (a.info = b.info)
                                AND M3Type.IsEqual (a.type, b.type);
    | Class.Text       =&gt; eq := (a.ref # NIL) AND (b.ref # NIL)
                                AND Text.Equal (a.ref, b.ref);
    | Class.Type       =&gt; eq := M3Type.IsEqual (a.type, b.type);
    | Class.Addr       =&gt; eq := (a.info = b.info);
    | Class.Set        =&gt; eq := M3SetVal.Compare (a.ref, b.ref) = 0;
    | Class.Record     =&gt; eq := M3RecVal.Compare (a.ref, b.ref) = 0;
    | Class.Array      =&gt; eq := M3ArrVal.Compare (a.ref, b.ref) = 0;
    | Class.Exception  =&gt; eq := (a.ref = b.ref) AND (a.info = b.info);
    | Class.Proc       =&gt; eq := (a.ref = b.ref) AND (a.info = b.info);
    | Class.Var        =&gt; eq := (a.ref = b.ref) AND (a.info = b.info);
    | Class.GenericArg =&gt; eq := (a.ref = b.ref) AND (a.info = b.info);
    | Class.Formal     =&gt; eq := (a.ref = b.ref) AND (a.info = b.info);
    | Class.Module     =&gt; eq := (a.ref = b.ref) AND (a.info = b.info);
    | Class.Builtin    =&gt; eq := (a.info = b.info);
    END;
    RETURN eq;
  END IsEQ;

PROCEDURE <A NAME="EvalLT"><procedure>EvalLT</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  BEGIN
    EvalCompare (s, val, -1, -1);
  END EvalLT;

PROCEDURE <A NAME="EvalLE"><procedure>EvalLE</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  BEGIN
    EvalCompare (s, val, -1, 0);
  END EvalLE;

PROCEDURE <A NAME="EvalGT"><procedure>EvalGT</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  BEGIN
    EvalCompare (s, val, +1, +1);
  END EvalGT;

PROCEDURE <A NAME="EvalGE"><procedure>EvalGE</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  BEGIN
    EvalCompare (s, val, +1, 0);
  END EvalGE;

PROCEDURE <A NAME="EvalCompare"><procedure>EvalCompare</procedure></A> (VAR s: State;  VAR val: T;  s1, s2: INTEGER)
  RAISES {Error} =
  VAR a, b: T;  sign: INTEGER;
  BEGIN
    EvalPair (s, a, b);

    IF (a.class = Class.Integer) AND (b.class = Class.Integer) THEN
      IF    TInt.LT (a.int, b.int) THEN sign := -1;
      ELSIF TInt.LT (b.int, a.int) THEN sign := +1;
      ELSE                              sign :=  0;
      END;

    ELSIF (a.class = Class.Enum) AND (b.class = Class.Enum) THEN
      IF    a.info &lt; b.info THEN sign := -1;
      ELSIF b.info &lt; a.info THEN sign := +1;
      ELSE                       sign :=  0;
      END;

    ELSIF (a.class = Class.Float) AND (b.class = Class.Float)
      AND (a.float.pre = b.float.pre) THEN
      IF    TFloat.LT (a.float, b.float) THEN sign := -1;
      ELSIF TFloat.LT (b.float, a.float) THEN sign := +1;
      ELSE                                    sign :=  0;
      END;

    ELSIF (a.class = Class.Addr) AND (b.class = Class.Addr) THEN
      IF    a.info &lt; b.info THEN sign := -1;
      ELSIF b.info &lt; a.info THEN sign := +1;
      ELSE                       sign :=  0;
      END;

    ELSIF (a.class = Class.Set) AND (b.class = Class.Set) THEN
      sign := M3SetVal.Compare (a.ref, b.ref);

    ELSE
      Err (&quot;bad operand for comparison&quot;);
    END;

    val.class := Class.Enum;
    val.type  := M3Type.Boolean;
    val.info  := ORD ((sign = s1) OR (sign = s2));
  END EvalCompare;

PROCEDURE <A NAME="EvalMember"><procedure>EvalMember</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR a, b: T;
  BEGIN
    EvalPair (s, a, b);
    IF (b.class # Class.Set) THEN
      Err (&quot;bad operand for IN&quot;);
    ELSIF (a.class = Class.Integer) AND TInt.ToInt (a.int, a.info) THEN
      (* ok *)
    ELSIF (a.class = Class.Enum) THEN
      (* ok *)
    ELSE
      Err (&quot;bad operand for IN&quot;);
    END;
    val.class := Class.Enum;
    val.type  := M3Type.Boolean;
    val.info  := ORD (M3SetVal.IsMember (b.ref, a.info));
  END EvalMember;

PROCEDURE <A NAME="EvalAdd"><procedure>EvalAdd</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR a, b: T;
  BEGIN
    EvalPair (s, a, b);

    IF (a.class = Class.Integer) AND (b.class = Class.Integer)
      AND (a.type = b.type)
      AND TInt.Add (a.int, b.int, val.int) THEN
      val.class := Class.Integer;
      val.type  := a.type;

    ELSIF (a.class = Class.Float) AND (b.class = Class.Float)
      AND (a.float.pre = b.float.pre)
      AND TFloat.Add (a.float, b.float, val.float) THEN
      val.class := Class.Float;
      val.type  := a.type;

    ELSIF (a.class = Class.Addr) AND (b.class = Class.Integer) THEN
      TWord.Add (a.int, b.int, val.int);
      val.class := Class.Addr;
      val.type  := M3Type.Address;

    ELSIF (a.class = Class.Set) AND (b.class = Class.Set) THEN
      val.class := Class.Set;
      val.ref   := M3SetVal.Union (a.ref, b.ref);
      val.type  := a.type;
    ELSE
      Err (&quot;bad operand for '+'&quot;);
    END;
  END EvalAdd;

PROCEDURE <A NAME="EvalSubtract"><procedure>EvalSubtract</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR a, b: T;
  BEGIN
    EvalPair (s, a, b);

    IF (a.class = Class.Integer) AND (b.class = Class.Integer)
      AND (a.type = b.type)
      AND TInt.Subtract (a.int, b.int, val.int) THEN
      val.class := Class.Integer;
      val.type  := a.type;

    ELSIF (a.class = Class.Float) AND (b.class = Class.Float)
      AND (a.float.pre = b.float.pre)
      AND TFloat.Subtract (a.float, b.float, val.float) THEN
      val.class := Class.Float;
      val.type  := a.type;

    ELSIF (a.class = Class.Addr) AND (b.class = Class.Integer) THEN
      TWord.Subtract (a.int, b.int, val.int);
      val.class := Class.Addr;
      val.type  := M3Type.Address;

    ELSIF (a.class = Class.Set) AND (b.class = Class.Set) THEN
      val.class := Class.Set;
      val.ref   := M3SetVal.Difference (a.ref, b.ref);
      val.type  := a.type;
    ELSE
      Err (&quot;bad operand for '-'&quot;);
    END;
  END EvalSubtract;

PROCEDURE <A NAME="EvalConcat"><procedure>EvalConcat</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR a, b: T;
  BEGIN
    EvalPair (s, a, b);
    IF (a.class = Class.Text) AND (b.class = Class.Text) THEN
      val.class := Class.Text;
      val.type  := M3Type.Txt;
      val.ref   := NARROW (a.ref, TEXT) &amp; NARROW (b.ref, TEXT);
    ELSE
      Err (&quot;bad operand for '&amp;'&quot;);
    END;
  END EvalConcat;

PROCEDURE <A NAME="EvalMultiply"><procedure>EvalMultiply</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR a, b: T;
  BEGIN
    EvalPair (s, a, b);

    IF (a.class = Class.Integer) AND (b.class = Class.Integer)
      AND (a.type = b.type)
      AND TInt.Multiply (a.int, b.int, val.int) THEN
      val.class := Class.Integer;
      val.type  := a.type;

    ELSIF (a.class = Class.Float) AND (b.class = Class.Float)
      AND (a.float.pre = b.float.pre)
      AND TFloat.Multiply (a.float, b.float, val.float) THEN
      val.class := Class.Float;
      val.type  := a.type;

    ELSIF (a.class = Class.Set) AND (b.class = Class.Set) THEN
      val.class := Class.Set;
      val.ref   := M3SetVal.Intersection (a.ref, b.ref);
      val.type  := a.type;
    ELSE
      Err (&quot;bad operand for '*'&quot;);
    END;
  END EvalMultiply;

PROCEDURE <A NAME="EvalDivide"><procedure>EvalDivide</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR a, b: T;
  BEGIN
    EvalPair (s, a, b);

    IF (a.class = Class.Float) AND (b.class = Class.Float)
      AND (a.float.pre = b.float.pre)
      AND TFloat.Divide (a.float, b.float, val.float) THEN
      val.class := Class.Float;
      val.type  := a.type;

    ELSIF (a.class = Class.Set) AND (b.class = Class.Set) THEN
      val.class := Class.Set;
      val.ref   := M3SetVal.SymDifference (a.ref, b.ref);
      val.type  := a.type;
    ELSE
      Err (&quot;bad operand for '/'&quot;);
    END;
  END EvalDivide;

PROCEDURE <A NAME="EvalDiv"><procedure>EvalDiv</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR a, b: T;
  BEGIN
    EvalPair (s, a, b);

    IF (a.class = Class.Integer) AND (b.class = Class.Integer)
      AND (a.type = b.type)
      AND TInt.Div (a.int, b.int, val.int) THEN
      val.class := Class.Integer;
      val.type  := a.type;
    ELSE
      Err (&quot;bad operand for 'DIV'&quot;);
    END;
  END EvalDiv;

PROCEDURE <A NAME="EvalMod"><procedure>EvalMod</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR a, b: T;
  BEGIN
    EvalPair (s, a, b);

    IF (a.class = Class.Integer) AND (b.class = Class.Integer)
      AND (a.type = b.type)
      AND TInt.Mod (a.int, b.int, val.int) THEN
      val.class := Class.Integer;
      val.type  := a.type;

    ELSIF (a.class = Class.Float) AND (b.class = Class.Float)
      AND (a.float.pre = b.float.pre)
      AND TFloat.Mod (a.float, b.float, val.float) THEN
      val.class := Class.Float;
      val.type  := a.type;

    ELSE
      Err (&quot;bad operand for 'MOD'&quot;);
    END;
  END EvalMod;

PROCEDURE <A NAME="EvalUnaryPlus"><procedure>EvalUnaryPlus</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  BEGIN
    EvalX (s, s.ch[0], val);
  END EvalUnaryPlus;

PROCEDURE <A NAME="EvalUnaryMinus"><procedure>EvalUnaryMinus</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR a: T;  zero: Target.Float;
  BEGIN
    EvalX (s, s.ch[0], a);

    IF (a.class = Class.Integer)
      AND TInt.Subtract (TInt.Zero, a.int, val.int) THEN
      val.class := Class.Integer;
      val.type  := a.type;

    ELSIF (a.class = Class.Float) THEN
      IF    (a.float.pre = Target.Precision.Short) THEN zero := TFloat.ZeroR;
      ELSIF (a.float.pre = Target.Precision.Long)  THEN zero := TFloat.ZeroL;
      ELSE                                              zero := TFloat.ZeroX;
      END;
      IF NOT TFloat.Subtract (zero, a.float, val.float) THEN
        Err (&quot;bad operand for unary '-'&quot;);
      END;
      val.class := Class.Float;
      val.type  := a.type;

    ELSE
      Err (&quot;bad operand for unary '-'&quot;);
    END;
  END EvalUnaryMinus;

PROCEDURE <A NAME="EvalSubscript"><procedure>EvalSubscript</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR
    a, b: T;
    min_index, max_index, offs: Target.Int;
    index: INTEGER;
  BEGIN
    EvalPair (s, a, b);
    IF (a.class # Class.Array) THEN
      Err (&quot;bad operand for subscript operation&quot;);
    ELSIF (b.class = Class.Integer) THEN
      (* ok *)
    ELSIF (b.class = Class.Enum)
      AND TInt.FromInt (b.info, Target.Integer.bytes, b.int) THEN
      (* ok *)
    ELSE
      Err (&quot;bad operand for subscript operation&quot;);
    END;

    TYPECASE a.type OF
    | M3Type.Array (x) =&gt;
        IF NOT M3Type.GetBounds (x.index, min_index, max_index) THEN
          Err (&quot;bad operand for subscript operation&quot;);
        END;
    | M3Type.OpenArray =&gt;
        min_index := TInt.Zero;
    ELSE
      Err (&quot;bad operand for subscript operation&quot;);
    END;

    IF NOT TInt.Subtract (b.int, min_index, offs)
      OR NOT TInt.ToInt (offs, index) OR (index &lt; 0)
      OR NOT M3ArrVal.Index (a.ref, index, val) THEN
      Err (&quot;bad operand for subscript operation&quot;);
    END;
  END EvalSubscript;

PROCEDURE <A NAME="EvalCallExpr"><procedure>EvalCallExpr</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR
    ast  := s.ast;
    loc  := s.loc;
    n_ch := s.n_ch;
    ch0  := s.ch[0];
    ch   : NodeIndex;
    proc : T;
    args : ARRAY [0..4] OF T;
  BEGIN
    EvalX (s, ch0, proc);
    IF (proc.class # Class.Builtin) THEN Err (&quot;not a constant&quot;) END;
    FOR i := 1 TO n_ch-1 DO
      ch := M3AST.NthChild (ast, loc, i);
      EvalX (s, ch, args[i-1]);
    END;
    M3Builtin.Eval (VAL (proc.info, M3Builtin.Proc),
                    SUBARRAY (args, 0, n_ch-1), val);
  END EvalCallExpr;

PROCEDURE <A NAME="EvalConsExpr"><procedure>EvalConsExpr</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR
    self := s.loc;
    tipe := EvalType (s, s.ch[0]);
  BEGIN
    IF (tipe = NIL) THEN
      Err (&quot;bad type on constructor&quot;);
    END;
    TYPECASE M3Type.Base (tipe) OF
    | NULL =&gt;
        Err (&quot;bad type on constructor&quot;);
    | M3Type.Array(array_type) =&gt;
        EvalArrayCons (s, array_type, self, val);
    | M3Type.OpenArray =&gt;
        EvalOpenArrayCons (s, self, val);
    | M3Type.Set(set_type) =&gt;
        EvalSetCons (s, set_type, self, val);
    | M3Type.Record(record_type) =&gt;
        EvalRecordCons (s, record_type, self, val);
    ELSE
        Err (&quot;bad type on constructor&quot;);
    END;
    val.type := tipe;
  END EvalConsExpr;

PROCEDURE <A NAME="EvalArrayCons"><procedure>EvalArrayCons</procedure></A> (VAR s: State;  tipe: M3Type.Array;
                         loc: NodeIndex;  VAR val: T)
  RAISES {Error} =
  VAR
    ast    := s.ast;
    n_ch   := M3AST.NumChildren (ast, loc);
    arr    : M3ArrVal.T;
    ch     : NodeIndex;
    elt    : T;
    n_elts : INTEGER;
    dots   : BOOLEAN;
  BEGIN
    IF NOT TInt.ToInt (M3Type.Number (tipe.index), n_elts) OR (n_elts &lt; 0) THEN
      Err (&quot;bad array constructor&quot;);
    END;
    arr := M3ArrVal.NewEmpty (n_elts);

    (* check for a trailing &quot;..&quot; element *)
    ch := M3AST.NthChild (ast, loc, n_ch-1);
    IF (ast.nodes[ch].op = M3AST.OP_Etc) THEN
      dots := TRUE;
      DEC (n_ch);
      IF (n_ch &lt; 2) THEN Err (&quot;bad array constructor&quot;); END;
      IF (n_ch &gt; n_elts+1) THEN Err (&quot;bad array constructor&quot;); END;
    ELSE
      IF (n_ch # n_elts+1) THEN Err (&quot;bad array constructor&quot;); END;
      dots := FALSE;
    END;

    (* get the explicit elements *)
    FOR i := 1 TO n_ch-1 DO
      ch := M3AST.NthChild (ast, loc, i);
      EvalX (s, ch, elt);
      IF NOT M3ArrVal.Set (arr, i-1, elt) THEN
        Err (&quot;illegal array constructor&quot;);
      END;
    END;

    (* fill in the ones implied by &quot;..&quot; *)
    FOR i := n_ch TO n_elts-1 DO
      IF NOT M3ArrVal.Set (arr, i-1, elt) THEN
        Err (&quot;illegal array constructor&quot;);
      END;
    END;

    val.class := Class.Array;
    val.ref   := arr;
  END EvalArrayCons;

PROCEDURE <A NAME="EvalOpenArrayCons"><procedure>EvalOpenArrayCons</procedure></A> (VAR s: State;  loc: NodeIndex;  VAR val: T)
  RAISES {Error} =
  VAR
    ast    := s.ast;
    n_ch   := M3AST.NumChildren (ast, loc);
    arr    : M3ArrVal.T;
    ch     : NodeIndex;
    elt    : T;
  BEGIN
    (* check for a trailing &quot;..&quot; element *)
    ch := M3AST.NthChild (ast, loc, n_ch-1);
    IF (ast.nodes[ch].op = M3AST.OP_Etc) THEN
      DEC (n_ch);
      IF (n_ch &lt; 2) THEN Err (&quot;bad open array constructor&quot;); END;
    END;

    arr := M3ArrVal.NewEmpty (n_ch-1);

    (* get the explicit elements *)
    FOR i := 1 TO n_ch-1 DO
      ch := M3AST.NthChild (ast, loc, i);
      EvalX (s, ch, elt);
      IF NOT M3ArrVal.Set (arr, i-1, elt) THEN
        Err (&quot;illegal array constructor&quot;);
      END;
    END;

    val.class := Class.Array;
    val.ref   := arr;
  END EvalOpenArrayCons;

PROCEDURE <A NAME="EvalSetCons"><procedure>EvalSetCons</procedure></A> (VAR s: State;  tipe: M3Type.Set;
                       loc: NodeIndex;  VAR val: T)
  RAISES {Error} =
  VAR
    ast    := s.ast;
    n_ch   := M3AST.NumChildren (ast, loc);
    min, max, t0, t1: Target.Int;
    n_elts : INTEGER;
    set    : M3SetVal.T;
    ch     : NodeIndex;
    v1, v2 : T;
    x1, x2 : INTEGER;
  BEGIN
    IF NOT M3Type.GetBounds (tipe.domain, min, max)
      OR NOT TInt.Subtract (max, min, t0)
      OR NOT TInt.Add (t0, TInt.One, t1)
      OR NOT TInt.ToInt (t1, n_elts) THEN
      Err (&quot;illegal set constructor&quot;);
    END;
    set := M3SetVal.NewEmpty (n_elts);

    FOR i := 2 TO n_ch - 1 DO
      ch := M3AST.NthChild (ast, loc, i);
      IF (ast.nodes[ch].op = M3AST.OP_RangeExpr) THEN
        s.n_ch := M3AST.GetChildren (s.ast, ch, s.ch);
        EvalPair (s, v1, v2);
      ELSE
        EvalX (s, ch, v1);
        v2 := v1;
      END;

      IF v1.class = Class.Integer AND TInt.ToInt (v1.int, x1) THEN (* ok *)
      ELSIF v1.class = Class.Enum THEN  x1 := v1.info;
      ELSE  Err (&quot;illegal set constructor element&quot;);
      END;

      IF v2.class = Class.Integer AND TInt.ToInt (v2.int, x2) THEN (* ok *)
      ELSIF v2.class = Class.Enum THEN  x2 := v2.info;
      ELSE  Err (&quot;illegal set constructor element&quot;);
      END;

      FOR z := x1 TO x2 DO
        set := M3SetVal.Include (set, z);
      END;
    END;

    val.class := Class.Set;
    val.ref   := set;
  END EvalSetCons;

PROCEDURE <A NAME="EvalRecordCons"><procedure>EvalRecordCons</procedure></A> (VAR s: State;  tipe: M3Type.Record;
                          loc: NodeIndex;  VAR val: T)
  RAISES {Error} =
  VAR
    ast        := s.ast;
    n_ch       := M3AST.NumChildren (ast, loc);
    rec        := M3RecVal.NewEmpty ();
    next_field := 0;
    by_name    := FALSE;
    field_name : M3ID.T;
    v1         : T;
    ch         : NodeIndex;
  BEGIN
    FOR i := 1 TO n_ch-1 DO
      ch := M3AST.NthChild (ast, loc, i);
      IF (ast.nodes[ch].op = M3AST.OP_NameBind) THEN
        s.n_ch := M3AST.GetChildren (ast, ch, s.ch);
        WITH z = ast.nodes[s.ch[0]] DO
          IF z.op # M3AST.OP_Id THEN Err (&quot;illegal record constructor&quot;); END;
          field_name := z.info;
        END;
        EvalX (s, s.ch[1], v1);
        by_name := TRUE;
      ELSIF (by_name) OR (next_field &gt;= NUMBER (tipe.fields^)) THEN
        Err (&quot;illegal record constructor&quot;);
      ELSE
        field_name := tipe.fields [next_field].name;
        EvalX (s, ch, v1);
      END;
      rec := M3RecVal.SetField (rec, field_name, v1);
    END;

    val.class := Class.Record;
    val.ref   := rec;
  END EvalRecordCons;

PROCEDURE <A NAME="EvalQualify"><procedure>EvalQualify</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR id := s.info;  ast := s.ast;
  BEGIN
    EvalX (s, s.ch[0], val);
    CASE val.class OF
    | Class.Module =&gt;
        IF ResolveID (val.ref, 0, id, s.env, val) THEN
          s.ast := ast;
          RETURN;
        ELSE
          s.ast := ast;
        END;
    | Class.Record =&gt;
        IF M3RecVal.Qualify (val.ref, id, val) THEN RETURN; END;
    | Class.Type, Class.Var, Class.GenericArg, Class.Formal =&gt;
        (* nope, not handled yet... *)
    | Class.Integer, Class.Float, Class.Enum, Class.Text,
      Class.Addr, Class.Set, Class.Array, Class.Exception,
      Class.Proc, Class.Builtin =&gt;
        (* nope, illegal *)
    END;
    Err (&quot;unknown qualification: &quot; &amp; M3ID.ToText (id));
  END EvalQualify;

PROCEDURE <A NAME="EvalPair"><procedure>EvalPair</procedure></A> (VAR s: State;  VAR v1, v2: T)
  RAISES {Error} =
  VAR ch0 := s.ch[0];  ch1 := s.ch[1];
  BEGIN
    EvalX (s, ch0, v1);
    EvalX (s, ch1, v2);
  END EvalPair;
</PRE>----------------------------------------------------------- literals ---

<P><PRE>PROCEDURE <A NAME="EvalId"><procedure>EvalId</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  VAR id := s.info;
  BEGIN
    IF FindBuiltin (id, val) THEN
</PRE><BLOCKQUOTE><EM>***
IF (val.class = Class.Builtin) THEN
Out (<CODE>  </CODE>, M3ID.ToText (id), <CODE> =&gt; builtin #</CODE>, Fmt.Int (val.info));
ELSIF (val.class = Class.Type) THEN
Out (<CODE>  </CODE>, M3ID.ToText (id), <CODE> =&gt; builtin type</CODE>);
ELSE
Out (<CODE>  </CODE>, M3ID.ToText (id), <CODE> =&gt; builtin ??? **** </CODE>);
END;
***</EM></BLOCKQUOTE><PRE>
      (* ok, we got it... *)
    ELSIF ResolveID (s.ast, s.loc, id, s.env, val) THEN
      (* ok, we got it *)
    ELSE
      Err (&quot;undefined symbol: &quot; &amp; M3ID.ToText (id));
    END;
  END EvalId;

PROCEDURE <A NAME="EvalInt"><procedure>EvalInt</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  BEGIN
    val.class := Class.Integer;
    val.type  := M3Type.Integer;
    IF NOT TInt.FromInt (s.info, Target.Integer.bytes, val.int) THEN
      Err (&quot;illegal integer value&quot;);
    END;
  END EvalInt;

PROCEDURE <A NAME="EvalLInt"><procedure>EvalLInt</procedure></A> (VAR s: State;  VAR val: T)
  RAISES {Error} =
  BEGIN
    val.class := Class.Integer;
    val.type  := M3Type.Longint;
    IF NOT TInt.FromInt (s.info, Target.Longint.bytes, val.int) THEN
      Err (&quot;illegal integer value&quot;);
    END;
  END EvalLInt;

PROCEDURE <A NAME="EvalBigInt"><procedure>EvalBigInt</procedure></A> (VAR s: State;  VAR val: T) =
  BEGIN
    val.class := Class.Integer;
    val.type  := M3Type.Integer;
    val.int   := s.ast.ints [s.info];
  END EvalBigInt;

PROCEDURE <A NAME="EvalBigLInt"><procedure>EvalBigLInt</procedure></A> (VAR s: State;  VAR val: T) =
  BEGIN
    val.class := Class.Integer;
    val.type  := M3Type.Longint;
    val.int   := s.ast.ints [s.info];
  END EvalBigLInt;

PROCEDURE <A NAME="EvalReal"><procedure>EvalReal</procedure></A> (VAR s: State;  VAR val: T) =
  BEGIN
    val.class := Class.Float;
    val.type  := M3Type.Real;
    val.float := s.ast.floats [s.info];
  END EvalReal;

PROCEDURE <A NAME="EvalLReal"><procedure>EvalLReal</procedure></A> (VAR s: State;  VAR val: T) =
  BEGIN
    val.class := Class.Float;
    val.type  := M3Type.LongReal;
    val.float := s.ast.floats [s.info];
  END EvalLReal;

PROCEDURE <A NAME="EvalEReal"><procedure>EvalEReal</procedure></A> (VAR s: State;  VAR val: T) =
  BEGIN
    val.class := Class.Float;
    val.type  := M3Type.Extended;
    val.float := s.ast.floats [s.info];
  END EvalEReal;

PROCEDURE <A NAME="EvalChar"><procedure>EvalChar</procedure></A> (VAR s: State;  VAR val: T) =
  BEGIN
    val.class := Class.Enum;
    val.type  := M3Type.Char;
    val.info  := s.info;
  END EvalChar;

PROCEDURE <A NAME="EvalText"><procedure>EvalText</procedure></A> (VAR s: State;  VAR val: T) =
  BEGIN
    val.class := Class.Text;
    val.type  := M3Type.Txt;
    val.ref   := s.ast.texts [s.info];
  END EvalText;
</PRE>------------------------------------------------- user defined identifiers ---

<P><PRE>TYPE RefConst = REF T;

PROCEDURE <A NAME="ResolveID"><procedure>ResolveID</procedure></A> (ast: M3AST.T;  loc: NodeIndex;
                     id: M3ID.T;  env: ImportOracle;
                     VAR(*OUT*) val: T): BOOLEAN
  RAISES {Error} =
  VAR
    sym  : M3Scope.Defn;
    n_ch : CARDINAL;
    ch   : ARRAY [0..1] OF NodeIndex;
    defn : RefConst;
  BEGIN
    IF FindWordBuiltin (ast, id, val) THEN
</PRE><BLOCKQUOTE><EM>***
Out (<CODE>  </CODE>, M3ID.ToText (id), <CODE> =&gt; builtin #</CODE>, Fmt.Int (val.info));
***</EM></BLOCKQUOTE><PRE>
      RETURN TRUE; END;
    IF NOT M3Scope.LookUp (ast, loc, id, sym) THEN
</PRE><BLOCKQUOTE><EM>***
Out (<CODE>*** M3Scope.LookUp failed:  </CODE>, M3ID.ToText (id), <CODE> @ </CODE>, Fmt.Int (loc));
***</EM></BLOCKQUOTE><PRE>
      RETURN FALSE; END;
</PRE><BLOCKQUOTE><EM>***
Out (<CODE>  </CODE>, M3ID.ToText (id), <CODE> =&gt; defn @ </CODE>, Fmt.Int (sym.loc));
***</EM></BLOCKQUOTE><PRE>

    (* check for a cached evaluation... *)
    TYPECASE sym.info OF
    | NULL =&gt;
        (* nothing defined yet. *)
        defn := NEW (RefConst);
        M3Scope.Define (sym, defn);
    | RefConst (r) =&gt;
        val := r^;
        RETURN TRUE;
    ELSE (* ouch, somebody else is using this slot! *)
        defn := NEW (RefConst);
    END;

    CASE sym.class OF
    | M3Scope.Class.Import =&gt;
        WITH z = sym.ast.nodes [sym.loc] DO
          IF (z.op = M3AST.OP_Import) THEN
            defn.class := Class.Module;
            defn.info  := 0;
            defn.ref   := env.find (z.info);
            IF (defn.ref = NIL) THEN RETURN FALSE; END;
          ELSIF (z.op = M3AST.OP_ImportAs) THEN
            defn.class := Class.Module;
            defn.info  := 0;
            defn.ref   := env.find (sym.ast.nodes[sym.loc+1].info);
            IF (defn.ref = NIL) THEN RETURN FALSE; END;
          ELSIF (z.op = M3AST.OP_FromImport) THEN
            ast := env.find (sym.ast.nodes[sym.loc+1].info);
            IF (ast = NIL) THEN RETURN FALSE; END;
            IF NOT ResolveID (ast, 0, z.info, env, defn^) THEN RETURN FALSE; END;
          ELSE
            RETURN FALSE;
          END;
        END;

    | M3Scope.Class.Const =&gt;
        WITH z = sym.ast.nodes [sym.loc] DO
          IF (z.op # M3AST.OP_ConstDecl) THEN RETURN FALSE; END;
          n_ch := M3AST.GetChildren (sym.ast, sym.loc, ch);
          Eval (sym.ast, ch[1], env, defn^);
        END;

    | M3Scope.Class.Type =&gt;
        n_ch := M3AST.GetChildren (sym.ast, sym.loc, ch);
        WITH z = sym.ast.nodes [sym.loc] DO
          IF (z.op = M3AST.OP_TypeDecl) THEN
            Eval (sym.ast, ch[0], env, defn^);
          ELSIF (z.op = M3AST.OP_OpaqueDecl) THEN
            Eval (sym.ast, ch[0], env, defn^);
            IF (defn.class = Class.Type) THEN
              defn.type := NEW (M3Type.Opaque, super := defn.type);
            END;
          ELSE
            RETURN FALSE;
          END;
        END;
        IF (defn.class # Class.Type) THEN
</PRE><BLOCKQUOTE><EM>***
Out (<CODE>***??? Didn't find a type for </CODE>, M3ID.ToText (id), <CODE> =&gt; class </CODE>, Fmt.Int(ORD(defn.class)));
***</EM></BLOCKQUOTE><PRE>
          RETURN FALSE; END;

    | M3Scope.Class.Var =&gt;
        defn.class := Class.Var;
        defn.info  := sym.loc;
        defn.ref   := sym.ast;
    | M3Scope.Class.GenericArg =&gt;
        defn.class := Class.GenericArg;
        defn.info  := sym.loc;
        defn.ref   := sym.ast;
    | M3Scope.Class.Formal =&gt;
        defn.class := Class.Var;
        defn.info  := sym.loc;
        defn.ref   := sym.ast;
    | M3Scope.Class.Exception =&gt;
        defn.class := Class.Exception;
        defn.info  := sym.loc;
        defn.ref   := sym.ast;
    | M3Scope.Class.Procedure =&gt;
        defn.class := Class.Proc;
        defn.info  := sym.loc;
        defn.ref   := sym.ast;
    | M3Scope.Class.Module =&gt;
        defn.class := Class.Module;
        defn.info  := sym.loc;
        defn.ref   := sym.ast;
    END;

    val := defn^;
    RETURN TRUE;
  END ResolveID;
</PRE>------------------------------------------- built-in types and procedures ---

<P><PRE>CONST
  BuiltinNames = ARRAY [0..42] OF TEXT {
    &quot;ABS&quot;, &quot;ADDRESS&quot;, &quot;ADR&quot;, &quot;ADRSIZE&quot;, &quot;BITSIZE&quot;, &quot;BOOLEAN&quot;,
    &quot;BYTESIZE&quot;, &quot;CARDINAL&quot;, &quot;CEILING&quot;, &quot;CHAR&quot;, &quot;DEC&quot;, &quot;DISPOSE&quot;,
    &quot;EXTENDED&quot;, &quot;FALSE&quot;, &quot;FIRST&quot;, &quot;FLOAT&quot;, &quot;FLOOR&quot;, &quot;INC&quot;,
    &quot;INTEGER&quot;, &quot;ISTYPE&quot;, &quot;LAST&quot;, &quot;LONGCARD&quot;, &quot;LONGINT&quot;, &quot;LONGREAL&quot;, &quot;LOOPHOLE&quot;,
    &quot;MAX&quot;, &quot;MIN&quot;, &quot;MUTEX&quot;, &quot;NARROW&quot;, &quot;NEW&quot;, &quot;NIL&quot;, &quot;NULL&quot;,
    &quot;NUMBER&quot;, &quot;ORD&quot;, &quot;REAL&quot;, &quot;REFANY&quot;, &quot;ROUND&quot;, &quot;SUBARRAY&quot;,
    &quot;TEXT&quot;, &quot;TRUE&quot;, &quot;TRUNC&quot;, &quot;TYPECODE&quot;, &quot;VAL&quot;
  };

VAR
  init_builtins := FALSE;
  BuiltinIDs : ARRAY [0..41] OF M3ID.T;

PROCEDURE <A NAME="InitBuiltins"><procedure>InitBuiltins</procedure></A> () =
  BEGIN
    FOR i := FIRST (BuiltinNames) TO LAST (BuiltinNames) DO
      BuiltinIDs[i] := M3ID.Add (BuiltinNames [i]);
    END;
    init_builtins := TRUE;
  END InitBuiltins;

PROCEDURE <A NAME="FindBuiltin"><procedure>FindBuiltin</procedure></A> (id: M3ID.T;  VAR(*OUT*) val: T): BOOLEAN =
  BEGIN
    IF (NOT init_builtins) THEN InitBuiltins () END;
    FOR i := FIRST (BuiltinIDs) TO LAST (BuiltinIDs) DO
      IF BuiltinIDs[i] = id THEN
        CASE i OF
        | 00 =&gt; (* ABS *)
                val.class := Class.Builtin;
                val.info  := ORD (M3Builtin.Proc.Abs);
                RETURN TRUE;

        | 01 =&gt; (* ADDRESS *)
                val.class := Class.Type;
                val.type := M3Type.Address;
                RETURN TRUE;

        | 02 =&gt; (* ADR *)
                val.class := Class.Builtin;
                val.info  := ORD (M3Builtin.Proc.Adr);
                RETURN TRUE;

        | 03 =&gt; (* ADRSIZE *)
                val.class := Class.Builtin;
                val.info  := ORD (M3Builtin.Proc.AdrSize);
                RETURN TRUE;

        | 04 =&gt; (* BITSIZE *)
                val.class := Class.Builtin;
                val.info  := ORD (M3Builtin.Proc.BitSize);
                RETURN TRUE;

        | 05 =&gt; (* BOOLEAN *)
                val.class := Class.Type;
                val.type := M3Type.Boolean;
                RETURN TRUE;

        | 06 =&gt; (* BYTESIZE *)
                val.class := Class.Builtin;
                val.info  := ORD (M3Builtin.Proc.ByteSize);
                RETURN TRUE;

        | 07 =&gt; (* CARDINAL *)
                val.class := Class.Type;
                val.type := M3Type.Cardinal;
                RETURN TRUE;

        | 08 =&gt; (* CEILING *)
                val.class := Class.Builtin;
                val.info  := ORD (M3Builtin.Proc.Ceiling);
                RETURN TRUE;

        | 09 =&gt; (* CHAR *)
                val.class := Class.Type;
                val.type := M3Type.Char;
                RETURN TRUE;

        | 10 =&gt; (* DEC *)
                val.class := Class.Builtin;
                val.info  := ORD (M3Builtin.Proc.Dec);
                RETURN TRUE;

        | 11 =&gt; (* DISPOSE *)
                val.class := Class.Builtin;
                val.info  := ORD (M3Builtin.Proc.Dispose);
                RETURN TRUE;

        | 12 =&gt; (* EXTENDED *)
                val.class := Class.Type;
                val.type := M3Type.Extended;
                RETURN TRUE;

        | 13 =&gt; (* FALSE *)
                val.class := Class.Enum;
                val.info  := ORD (FALSE);
                val.type := M3Type.Boolean;
                RETURN TRUE;

        | 14 =&gt; (* FIRST *)
                val.class := Class.Builtin;
                val.info  := ORD (M3Builtin.Proc.First);
                RETURN TRUE;

        | 15 =&gt; (* FLOAT *)
                val.class := Class.Builtin;
                val.info  := ORD (M3Builtin.Proc.Float);
                RETURN TRUE;

        | 16 =&gt; (* FLOOR *)
                val.class := Class.Builtin;
                val.info  := ORD (M3Builtin.Proc.Floor);
                RETURN TRUE;

        | 17 =&gt; (* INC *)
                val.class := Class.Builtin;
                val.info  := ORD (M3Builtin.Proc.Inc);
                RETURN TRUE;

        | 18 =&gt; (* INTEGER *)
                val.class := Class.Type;
                val.type := M3Type.Integer;
                RETURN TRUE;

        | 19 =&gt; (* ISTYPE *)
                val.class := Class.Builtin;
                val.info  := ORD (M3Builtin.Proc.IsType);
                RETURN TRUE;

        | 20 =&gt; (* LAST *)
                val.class := Class.Builtin;
                val.info  := ORD (M3Builtin.Proc.Last);
                RETURN TRUE;

        | 21 =&gt; (* LONGCARD *)
                val.class := Class.Type;
                val.type := M3Type.Longcard;

        | 22 =&gt; (* LONGINT *)
                val.class := Class.Type;
                val.type := M3Type.Longint;

        | 23 =&gt; (* LONGREAL *)
                val.class := Class.Type;
                val.type := M3Type.LongReal;
                RETURN TRUE;

        | 24 =&gt; (* LOOPHOLE *)
                val.class := Class.Builtin;
                val.info  := ORD (M3Builtin.Proc.Loophole);
                RETURN TRUE;

        | 25 =&gt; (* MAX *)
                val.class := Class.Builtin;
                val.info  := ORD (M3Builtin.Proc.Max);
                RETURN TRUE;

        | 26 =&gt; (* MIN *)
                val.class := Class.Builtin;
                val.info  := ORD (M3Builtin.Proc.Min);
                RETURN TRUE;

        | 27 =&gt; (* MUTEX *)
                val.class := Class.Type;
                val.type := M3Type.Mutex;
                RETURN TRUE;

        | 28 =&gt; (* NARROW *)
                val.class := Class.Builtin;
                val.info  := ORD (M3Builtin.Proc.Narrow);
                RETURN TRUE;

        | 29 =&gt; (* NEW *)
                val.class := Class.Builtin;
                val.info  := ORD (M3Builtin.Proc.New);
                RETURN TRUE;

        | 30 =&gt; (* NIL *)
                val.class := Class.Addr;
                val.info  := 0;
                val.type  := M3Type.Null;
                RETURN TRUE;

        | 31 =&gt; (* NULL *)
                val.class := Class.Type;
                val.type := M3Type.Null;
                RETURN TRUE;

        | 32 =&gt; (* NUMBER *)
                val.class := Class.Builtin;
                val.info  := ORD (M3Builtin.Proc.Number);
                RETURN TRUE;

        | 33 =&gt; (* ORD *)
                val.class := Class.Builtin;
                val.info  := ORD (M3Builtin.Proc.Ord);
                RETURN TRUE;

        | 34 =&gt; (* REAL *)
                val.class := Class.Type;
                val.type := M3Type.Real;
                RETURN TRUE;

        | 35 =&gt; (* REFANY *)
                val.class := Class.Type;
                val.type := M3Type.Refany;
                RETURN TRUE;

        | 36 =&gt; (* ROUND *)
                val.class := Class.Builtin;
                val.info  := ORD (M3Builtin.Proc.Round);
                RETURN TRUE;

        | 37 =&gt; (* SUBARRAY *)
                val.class := Class.Builtin;
                val.info  := ORD (M3Builtin.Proc.Subarray);
                RETURN TRUE;

        | 38 =&gt; (* TEXT *)
                val.class := Class.Type;
                val.type := M3Type.Txt;
                RETURN TRUE;

        | 39 =&gt; (* TRUE *)
                val.class := Class.Enum;
                val.info  := ORD (TRUE);
                val.type  := M3Type.Boolean;
                RETURN TRUE;

        | 40 =&gt; (* TRUNC *)
                val.class := Class.Builtin;
                val.info  := ORD (M3Builtin.Proc.Trunc);
                RETURN TRUE;

        | 41 =&gt; (* TYPECODE *)
                val.class := Class.Builtin;
                val.info  := ORD (M3Builtin.Proc.Typecode);
                RETURN TRUE;

        | 42 =&gt; (* VAL *)
                val.class := Class.Builtin;
                val.info  := ORD (M3Builtin.Proc.Val);
                RETURN TRUE;

        END; (*CASE*)
      END;
    END;
    RETURN FALSE;
  END FindBuiltin;

CONST
  BuiltinWordNames = ARRAY [0..20] OF TEXT {
    &quot;Plus&quot;, &quot;Times&quot;, &quot;Minus&quot;, &quot;Divide&quot;, &quot;Mod&quot;, &quot;LT&quot;,
    &quot;LE&quot;, &quot;GT&quot;, &quot;GE&quot;, &quot;And&quot;, &quot;Or&quot;, &quot;Xor&quot;, &quot;Not&quot;,
    &quot;Shift&quot;, &quot;LeftShift&quot;, &quot;RightShift&quot;, &quot;Rotate&quot;,
    &quot;LeftRotate&quot;, &quot;RightRotate&quot;, &quot;Extract&quot;, &quot;Insert&quot;
  };
  BuiltinWordProc = ARRAY [0..20] OF M3Builtin.Proc {
    M3Builtin.Proc.WordPlus, M3Builtin.Proc.WordTimes,
    M3Builtin.Proc.WordMinus, M3Builtin.Proc.WordDivide,
    M3Builtin.Proc.WordMod, M3Builtin.Proc.WordLT,
    M3Builtin.Proc.WordLE, M3Builtin.Proc.WordGT,
    M3Builtin.Proc.WordGE, M3Builtin.Proc.WordAnd,
    M3Builtin.Proc.WordOr, M3Builtin.Proc.WordXor,
    M3Builtin.Proc.WordNot, M3Builtin.Proc.WordShift,
    M3Builtin.Proc.WordLeftShift, M3Builtin.Proc.WordRightShift,
    M3Builtin.Proc.WordRotate, M3Builtin.Proc.WordLeftRotate,
    M3Builtin.Proc.WordRightRotate, M3Builtin.Proc.WordExtract,
    M3Builtin.Proc.WordInsert
  };

VAR
  init_word      := FALSE;
  WordID         : M3ID.T;
  BuiltinWordIDs : ARRAY [0..20] OF M3ID.T;

PROCEDURE <A NAME="InitWordIDs"><procedure>InitWordIDs</procedure></A> () =
  BEGIN
    WordID := M3ID.Add (&quot;Word&quot;);
    FOR i := FIRST (BuiltinWordIDs) TO LAST (BuiltinWordIDs) DO
      BuiltinWordIDs[i] := M3ID.Add (BuiltinWordNames [i]);
    END;
    init_word := TRUE;
  END InitWordIDs;

PROCEDURE <A NAME="FindWordBuiltin"><procedure>FindWordBuiltin</procedure></A> (ast: M3AST.T;  id: M3ID.T;
                           VAR(*OUT*) val: T): BOOLEAN =
  BEGIN
    IF (NOT init_word) THEN InitWordIDs (); END;

    IF (ast = NIL) OR (NOT ast.interface) THEN RETURN FALSE; END;
    IF (ast.nodes = NIL) THEN RETURN FALSE; END;
    IF (ast.nodes[0].op # M3AST.OP_Unit) THEN RETURN FALSE END;
    IF (ast.nodes[0].info # WordID) THEN RETURN FALSE; END;

    FOR i := FIRST (BuiltinWordIDs) TO LAST (BuiltinWordIDs) DO
      IF BuiltinWordIDs[i] = id THEN
        val.class := Class.Builtin;
        val.info  := ORD (BuiltinWordProc[i]);
        RETURN TRUE;
      END;
    END;
    RETURN FALSE;
  END FindWordBuiltin;
</PRE>-------------------------------------------------------------- errors ---

<P><PRE>PROCEDURE <A NAME="NotConst"><procedure>NotConst</procedure></A> (&lt;*UNUSED*&gt; VAR s: State;  &lt;*UNUSED*&gt; VAR val: T)
  RAISES {Error} =
  BEGIN
    Err (&quot;not a constant&quot;);
  END NotConst;

PROCEDURE <A NAME="BadAST"><procedure>BadAST</procedure></A> () RAISES {Error} =
  BEGIN
    Err (&quot;malformed AST&quot;);
  END BadAST;

PROCEDURE <A NAME="Err"><procedure>Err</procedure></A> (msg: TEXT) RAISES {Error} =
  BEGIN
    RAISE Error (msg);
  END Err;
</PRE>------------------------------------------------------- initialization ---

<P><PRE>PROCEDURE <A NAME="Init"><procedure>Init</procedure></A> () =
  BEGIN
    init_done := TRUE;
    FOR op := FIRST (eval_procs) TO LAST (eval_procs) DO
      eval_procs [op] := NotConst;
    END;

    eval_procs [M3AST.OP_Array]        := EvalArray;
    eval_procs [M3AST.OP_OpenArray]    := EvalOpenArray;
    eval_procs [M3AST.OP_Enum]         := EvalEnum;
    eval_procs [M3AST.OP_NamedType]    := EvalNamedType;
    eval_procs [M3AST.OP_Packed]       := EvalPacked;
    eval_procs [M3AST.OP_ProcType]     := EvalProcType;
    eval_procs [M3AST.OP_Object]       := EvalObject;
    eval_procs [M3AST.OP_Record]       := EvalRecord;
    eval_procs [M3AST.OP_Ref]          := EvalRef;
    eval_procs [M3AST.OP_Root]         := EvalRoot;
    eval_procs [M3AST.OP_Set]          := EvalSet;
    eval_procs [M3AST.OP_Subrange]     := EvalSubrange;
    eval_procs [M3AST.OP_UntracedRef]  := EvalUntracedRef;
    eval_procs [M3AST.OP_UntracedRoot] := EvalUntracedRoot;

    eval_procs [M3AST.OP_Or]           := EvalOr;
    eval_procs [M3AST.OP_And]          := EvalAnd;
    eval_procs [M3AST.OP_Not]          := EvalNot;
    eval_procs [M3AST.OP_EQ]           := EvalEQ;
    eval_procs [M3AST.OP_NE]           := EvalNE;
    eval_procs [M3AST.OP_LT]           := EvalLT;
    eval_procs [M3AST.OP_LE]           := EvalLE;
    eval_procs [M3AST.OP_GT]           := EvalGT;
    eval_procs [M3AST.OP_GE]           := EvalGE;
    eval_procs [M3AST.OP_Member]       := EvalMember;
    eval_procs [M3AST.OP_Add]          := EvalAdd;
    eval_procs [M3AST.OP_Subtract]     := EvalSubtract;
    eval_procs [M3AST.OP_Concat]       := EvalConcat;
    eval_procs [M3AST.OP_Multiply]     := EvalMultiply;
    eval_procs [M3AST.OP_Divide]       := EvalDivide;
    eval_procs [M3AST.OP_Div]          := EvalDiv;
    eval_procs [M3AST.OP_Mod]          := EvalMod;
    eval_procs [M3AST.OP_UnaryPlus]    := EvalUnaryPlus;
    eval_procs [M3AST.OP_UnaryMinus]   := EvalUnaryMinus;
    eval_procs [M3AST.OP_Subscript]    := EvalSubscript;
    eval_procs [M3AST.OP_CallExpr]     := EvalCallExpr;
    eval_procs [M3AST.OP_ConsExpr]     := EvalConsExpr;
    eval_procs [M3AST.OP_Qualify]      := EvalQualify;

    eval_procs [M3AST.OP_Id]           := EvalId;
    eval_procs [M3AST.OP_Int]          := EvalInt;
    eval_procs [M3AST.OP_LInt]         := EvalLInt;
    eval_procs [M3AST.OP_BigInt]       := EvalBigInt;
    eval_procs [M3AST.OP_BigLInt]      := EvalBigLInt;
    eval_procs [M3AST.OP_Real]         := EvalReal;
    eval_procs [M3AST.OP_LReal]        := EvalLReal;
    eval_procs [M3AST.OP_EReal]        := EvalEReal;
    eval_procs [M3AST.OP_Char]         := EvalChar;
    eval_procs [M3AST.OP_Text]         := EvalText;
  END Init;

BEGIN
END M3Const.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface M3ID is in:
</A><UL>
<LI><A HREF="../../m3middle/src/M3ID.i3.html#0TOP0">m3middle/src/M3ID.i3</A>
<LI><A HREF="../../m3scan/src/M3ID.i3.html#0TOP0">m3scan/src/M3ID.i3</A>
</UL>
<P>
<HR>
<A NAME="x2">interface M3AST is in:
</A><UL>
<LI><A HREF="../../m3tk/src/ast/M3AST.i3.html#0TOP0">m3tk/src/ast/M3AST.i3</A>
<LI><A HREF="M3AST.i3.html#0TOP0">m3tools/src/M3AST.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
