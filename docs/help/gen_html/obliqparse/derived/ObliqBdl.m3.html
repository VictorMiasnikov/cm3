<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: obliqparse/derived/ObliqBdl.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>obliqparse/derived/ObliqBdl.m3</H2></A><HR>
<inModule>
<PRE>MODULE <module><implements><A HREF="ObliqBdl.i3.html">ObliqBdl</A></implements></module>;
</PRE><BLOCKQUOTE><EM> Generated by m3bundle; see its manpage. </EM></BLOCKQUOTE><PRE>

IMPORT <A HREF="../../libm3/src/bundleintf/Bundle.i3.html">Bundle</A>, <A HREF="../../libm3/src/bundleintf/BundleRep.i3.html">BundleRep</A>, <A HREF="../../m3core/src/text/Text.i3.html">Text</A>;
IMPORT <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="../../libm3/src/rw/TextWr.i3.html">TextWr</A>;

TYPE T = Bundle.T OBJECT OVERRIDES
           get      := LookUp;
           getNames := GetNames;
         END;

TYPE Texts = REF ARRAY OF TEXT;

VAR
  bundle: T     := NIL;
  names : Texts := NIL;

PROCEDURE <A NAME="Get"><procedure>Get</procedure></A>(): Bundle.T =
  BEGIN
    IF (bundle = NIL) THEN bundle := NEW (T) END;
    RETURN bundle;
  END Get;

PROCEDURE <A NAME="GetNames"><procedure>GetNames</procedure></A> (&lt;*UNUSED*&gt; self: T): Texts =
  BEGIN
    IF names = NIL THEN
      names := NEW (Texts, NUMBER (Names));
      names^ := Names;
    END;
    RETURN names;
  END GetNames;

PROCEDURE <A NAME="LookUp"><procedure>LookUp</procedure></A> (&lt;*UNUSED*&gt; self: T;  element: TEXT): TEXT =
  BEGIN
    FOR i := 0 TO LAST (Names)-1 DO
      IF Text.Equal (Names[i], element) THEN
        IF Elements[i] = NIL THEN Elements[i] := GetElt (i) END;
        RETURN Elements[i];
      END;
    END;
    RETURN NIL;
  END LookUp;

CONST Names = ARRAY [0..1] OF TEXT {
  &quot;ObliqGram&quot;,
  NIL
};

VAR Elements := ARRAY [0..1] OF TEXT {
  NIL (* E0 .. E0_5 *),
  NIL
};

PROCEDURE <A NAME="GetElt"><procedure>GetElt</procedure></A> (n: INTEGER): TEXT =
  &lt;*FATAL Thread.Alerted, Wr.Failure *&gt;
  VAR wr := TextWr.New ();
  BEGIN
    CASE n OF
    | 0 =&gt;
        Wr.PutText (wr, E0);
        Wr.PutText (wr, E0_0);
        Wr.PutText (wr, E0_1);
        Wr.PutText (wr, E0_2);
        Wr.PutText (wr, E0_3);
        Wr.PutText (wr, E0_4);
        Wr.PutText (wr, E0_5);
    ELSE (*skip*)
    END;
    RETURN TextWr.ToText (wr);
  END GetElt;

CONST E0 =
   &quot;(* &lt;pre&gt; *)\n(* METASYNTAX  (Parsing is LL(1) recursive descent).\n    &quot;
 &amp; &quot; Non-terminals are declared by \'::=\' and must be non-left-recursive.\n&quot;
 &amp; &quot;     Terminals are in double quotes \'\&quot;\'\n     \'{ g1 .. gn }\' is a &quot;
 &amp; &quot;(sequential) choice of grammars gi.\n     \'[ g1 .. gn ]\' is a sequenc&quot;
 &amp; &quot;e of grammars gi.\n     \'(g1 * g2)\' is \'[g1 g]\' where \'g::={[g2 g]&quot;
 &amp; &quot;[]}\', but left-associative\n     \'_n\' and \'::\' are used for abstra&quot;
 &amp; &quot;ct-syntax-tree generation.\n*)\n\nphrase ::=\n  { phraseEmpty\n    phra&quot;
 &amp; &quot;seHelp\n    phraseFlag\n    phraseFrame\n    phraseType\n    phraseTerm&quot;
 &amp; &quot;\n    phraseEOF\n  }\n\nphraseEmpty ::=\n  \&quot;;\&quot; \t\t\t\t\t\t:: BuildPh&quot;
 &amp; &quot;raseEmpty\n\nphraseEOF ::=\n  EOF \t\t\t\t\t\t:: BuildPhraseEmpty\n\nph&quot;
 &amp; &quot;raseHelp ::=\n  [ \&quot;~help\&quot; \n    { name string [] }_1\n    { name stri&quot;
 &amp; &quot;ng [] }_2\n    \&quot;;\&quot;\n  ]                                             :&quot;
 &amp; &quot;: BuildPhraseHelp\n\nphraseFlag ::=\n  [ \&quot;~flag\&quot; \n    { name string &quot;
 &amp; &quot;[] }_1\n    { name string [] }_2\n    \&quot;;\&quot;\n  ]                       &quot;
 &amp; &quot;                      :: BuildPhraseFlag\n\nphraseType ::=\n  [ typDecl&quot;
 &amp; &quot; \&quot;;\&quot; ] :: BuildPhraseEmpty\n\nphraseFrame ::=\n  { phraseLoad\n    ph&quot;
 &amp; &quot;raseImport\n    phraseModule\n    phraseAddHelp\n    phraseEndModule\n &quot;
 &amp; &quot;   phraseEstablish\n    phraseDelete\n    phraseSave\n    phraseQualify&quot;
 &amp; &quot;\n    phraseQuit\n  }\n\nphraseQuit ::=\n  [ \&quot;~quit\&quot; \&quot;;\&quot; ]\t\t\t\t:&quot;
 &amp; &quot;: BuildPhraseQuit\n\nphraseLoad ::=\n  [ \&quot;load\&quot; \n    { name_1\t\t\t\t&quot;
 &amp; &quot;\t:: BuildPhraseLoadName\n      string_1 \t\t\t\t\t:: BuildPhraseLoadSt&quot;
 &amp; &quot;ring\n    }_2\n    \&quot;;\&quot; \n  ]\t\t\t\t\t\t:: Select2\n\nphraseImport ::&quot;
 &amp; &quot;=\n  [ \&quot;import\&quot; name_1 \&quot;;\&quot; ]\t\t\t:: BuildPhraseImport\n\nphraseEst&quot;
 &amp; &quot;ablish ::=\n  [ \&quot;~establish\&quot; name_1\n    { [ \&quot;for\&quot; name_2 ]\t      &quot;
 &amp; &quot;          \t:: Select2\n      []\n    }_3\n    \&quot;;\&quot; \n  ]\t\t         &quot;
 &amp; &quot;                       :: BuildPhraseEstablish\n\nphraseSave ::=\n  [ \&quot;&quot;
 &amp; &quot;~save\&quot; name_1 \&quot;;\&quot; ]\t                :: BuildPhraseSave\n\nphraseDel&quot;
 &amp; &quot;ete ::=\n  [ \&quot;~delete\&quot; name_1 \&quot;;\&quot; ]\t        \t:: BuildPhraseDelete&quot;
 &amp; &quot;\n\nphraseQualify ::=\n  [ \&quot;~qualify\&quot;  \n    { [ \&quot;exporting\&quot; import&quot;
 &amp; &quot;List_1 ]\t\t:: Select1\n      []\n    }_2 \&quot;;\&quot; ]\t\t                  &quot;
 &amp; &quot;      :: BuildPhraseQualify\n\nphraseModule ::=\n  [ \&quot;module\&quot; \n    &quot;;

CONST E0_0 =
   &quot;name_1\n    { [ \&quot;for\&quot; name_2 ]                          :: Select2\n &quot;
 &amp; &quot;     []\n    }_3\n    { [ \&quot;import\&quot; importList_4  ]               \t::&quot;
 &amp; &quot; Select4\n      []\n    }_5\n    { [ \&quot;export\&quot; exportList ] [] }\n    &quot;
 &amp; &quot;\&quot;;\&quot; \n  ]\t\t\t                \t:: BuildPhraseModule\n\nphraseAddHel&quot;
 &amp; &quot;p ::= \n  [ \&quot;addhelp\&quot; name_1 \n    { [ \&quot;sort\&quot; string_2 ]           &quot;
 &amp; &quot;            :: Select2\n      []\n    }_3\n    { [ \&quot;short\&quot; string_4 ]&quot;
 &amp; &quot;                      :: Select4\n      []\n    }_5\n    string_6 \&quot;;\&quot;&quot;
 &amp; &quot; ]      \t\t\t:: BuildPhraseAddHelp\n\nphraseEndModule ::=\n  [ \&quot;end\&quot;&quot;
 &amp; &quot; \&quot;module\&quot; \n    { [ \&quot;exporting\&quot; importList_1 ]\t\t:: Select1\n     &quot;
 &amp; &quot; []\n    }_2 \&quot;;\&quot; ]\t\t                        :: BuildPhraseEndModule&quot;
 &amp; &quot;\n\nimportList ::=\n  { [ name_1 \n\t{ [ \&quot;,\&quot; importList_2 ]\t\t\t:: B&quot;
 &amp; &quot;uildImportList\n\t  []\t\t\t\t\t:: BuildImportListSingle\n\t}_3\n    ] &quot;
 &amp; &quot;   \t\t\t\t\t:: Select3                 \n    []\t\t\t\t\t\t:: BuildImp&quot;
 &amp; &quot;ortListNil\n  }\n\nphraseTerm ::=\n  [ term_1 \n      { [ \&quot;!\&quot;\n      &quot;
 &amp; &quot;    { int_2\t\t\t\t:: BuildPhraseTermDepth\n\t    [] \t\t\t\t\t:: Build&quot;
 &amp; &quot;PhraseTermDeep\n          }_3\n\t]\t\t\t\t\t:: Select3\n\t[]\t\t\t\t\t:&quot;
 &amp; &quot;: BuildPhraseTerm\n      }_4\n    \&quot;;\&quot;\n  ]\t\t\t\t\t\t:: Select4\n\nt&quot;
 &amp; &quot;ypDecl ::=\n  [ \&quot;type\&quot; ide { typParams [] } \&quot;=\&quot; typ ]\n\ntyp ::=\n &quot;
 &amp; &quot; { [ \&quot;(\&quot; typList \&quot;)\&quot; { typRngSpec [] } ]\n    [ \&quot;Option\&quot; typField&quot;
 &amp; &quot;s \&quot;end\&quot; ]\n    [ \&quot;{\&quot; typFields \&quot;}\&quot; ]\n    [ \&quot;[\&quot; { [ int \&quot;~*\&quot; &quot;
 &amp; &quot;] [] } typ \&quot;]\&quot; ]\n    [ \&quot;All\&quot; \&quot;(\&quot; ide { typBound [] } \&quot;)\&quot; typ ]&quot;
 &amp; &quot;\n    [ \&quot;Some\&quot; \&quot;(\&quot; ide { typBound [] } \&quot;)\&quot; typ ]\n    [ \&quot;Self\&quot; &quot;
 &amp; &quot;\&quot;(\&quot; ide \&quot;)\&quot; typ ]\n    [ ide \n        { [ \&quot;_\&quot; name { typParams [&quot;
 &amp; &quot;] } ]\n          typParams\n          []\n        }\n    ]\n  }\n\ntypB&quot;
 &amp; &quot;ound ::= \n  [ \&quot;&lt;:\&quot; typ ]\n\ntypParams ::=\n  [ \&quot;(\&quot; typNameList \&quot;)&quot;
 &amp; &quot;\&quot; ]\n\ntypNameList ::=\n  { [ ide { [ \&quot;,\&quot; typList ] [] } ]\n    []\n&quot;
 &amp; &quot;  }\n\ntypList ::=\n  { [ typ { [ \&quot;,\&quot; typList ] [] } ]\n    []\n  }\n&quot;
 &amp; &quot;\ntypFields ::=\n  { [ ide \&quot;:\&quot; typ\n      { [ \&quot;,\&quot; typFields ]\n\t[]&quot;
 &amp; &quot;\n      }\n    ]\n    []\n  }\n\ntypSpec ::=\n  { [ \&quot;:\&quot; typ ] [] }\n\n&quot;
 &amp; &quot;typResSpec ::=\n  { [ \&quot;:\&quot; typ { [ \&quot;!\&quot; excList ] [] } ] \n    [ \&quot;!\&quot;&quot;
 &amp; &quot; excList ]\n  }\n\ntypRngSpec ::=\n  { [ \&quot;-&gt;\&quot; typ { [ \&quot;!\&quot; excList ]&quot;
 &amp; &quot; [] } ] \n    [ \&quot;=&gt;\&quot; typ { [ \&quot;!\&quot; excList ] [] } ] \n    [ \&quot;!\&quot;&quot;;

CONST E0_1 =
   &quot; excList ]\n  }\n\nexcList ::=\n  { [ ide { [ \&quot;_\&quot; name ] [] } excList&quot;
 &amp; &quot; ] [] }\n\nprocDecl ::=\n  {\n    [ { \&quot;All\&quot; \&quot;Some\&quot; } \&quot;(\&quot; ide { ty&quot;
 &amp; &quot;pBound [] } \&quot;)\&quot; procDecl ]\n    [ ide \n      { [ \&quot;:\&quot; typ ]\n      &quot;
 &amp; &quot;  [ \&quot;(\&quot; ideList \&quot;)\&quot; typResSpec ]\n        []\n      }\n    ]\n  }\n&quot;
 &amp; &quot;  \nexportList ::=\n  { [ typDecl { [ \&quot;,\&quot; exportList ] [] } ]\n    [ &quot;
 &amp; &quot;procDecl { [ \&quot;,\&quot; exportList ] [] } ]\n    []\n  }\n\ntermBinding ::=\n&quot;
 &amp; &quot;  { [ ide_1 typSpec \&quot;=\&quot; term_2 \n      { [ \&quot;,\&quot; termBinding_3 ] \t\t&quot;
 &amp; &quot;\t:: BuildTermBinding\n        []\t\t\t\t\t:: BuildTermBindingSingle\n &quot;
 &amp; &quot;     }_4\n    ]\t\t\t\t\t\t:: Select4\n    []\t\t\t\t\t\t:: BuildTermBi&quot;
 &amp; &quot;ndingNil\n  }\n\ntermSeq ::=\n  [ term_1\n    { [ \&quot;;\&quot; \n\t{ termSeq_2&quot;
 &amp; &quot;\t\t\t\t:: BuildTermSeq\n\t  []\t\t\t\t\t:: Select1\n\t}_3\n      ]\t\t&quot;
 &amp; &quot;\t\t\t\t:: Select3\n      []\t\t\t\t\t:: Select1\n    }_4\n  ]\t\t\t\t\t&quot;
 &amp; &quot;\t:: Select4\n\ntermSeqOpt ::=\n  { termSeq\n    []                    &quot;
 &amp; &quot;                      :: BuildTermOk\n  }\n\nterm ::=\n  ( termBase *_1&quot;
 &amp; &quot;\n    { [ \&quot;(\&quot; termList_2 \&quot;)\&quot; ]\t\t\t:: BuildTermAppl\n      [ \&quot;_\&quot;&quot;
 &amp; &quot; name_2 \n        { [ \&quot;(\&quot; termList_3 \&quot;)\&quot; ]\t\t:: BuildTermOp\n     &quot;
 &amp; &quot;     []\t\t\t\t\t:: BuildTermOpConst\n        }_4\n      ]\t\t\t\t\t\t:&quot;
 &amp; &quot;: Select4\n      [ \&quot;.\&quot; name_2 \n        { [ \&quot;:=\&quot; termOrAlias_3 ]\t\t&quot;
 &amp; &quot;:: BuildTermUpdate\n          [ \&quot;(\&quot; termList_3 \&quot;)\&quot; ]               &quot;
 &amp; &quot; :: BuildTermInvoke\n          []\t\t\t\t\t:: BuildTermSelect\n        &quot;
 &amp; &quot;}_4\n      ]\t\t\t\t\t\t:: Select4\n      [ \&quot;:=\&quot; term_2 ]            &quot;
 &amp; &quot;               :: BuildTermAssign\n      [ \&quot;[\&quot; term_2 \n        { [ \&quot;&quot;
 &amp; &quot;]\&quot;\n            { [ \&quot;:=\&quot; term_3 ]\t\t\t:: BuildTermArraySet\n       &quot;
 &amp; &quot;       []\t\t\t\t:: BuildTermArrayGet\n            }_4\n          ]\t\t&quot;
 &amp; &quot;\t\t\t:: Select4\n          [ \&quot;for\&quot; term_3 \&quot;]\&quot;\n            { [ \&quot;:&quot;
 &amp; &quot;=\&quot; term_4 ]\t\t\t:: BuildTermArrayUpd\n              []\t\t\t\t:: Buil&quot;
 &amp; &quot;dTermArraySub\n            }_5\n          ]\t\t\t\t\t:: Select5\n      &quot;
 &amp; &quot;  }_6\n      ]\t\t\t\t\t\t:: Select6\n      [ ide_2 term_3 ]\t\t\t\t:: &quot;
 &amp; &quot;BuildTermInfix\n      [ \&quot;andif\&quot; term_2 ]\t\t\t:: BuildTermAndif\n    &quot;
 &amp; &quot;  [ \&quot;orif\&quot; term_2 ]\t\t\t\t:: BuildTermOrif\n    }\n  )\n\ntermBase :&quot;
 &amp; &quot;:=\n  { \n    termMinus\n    termIde\n    termConst\n    termArray\n   &quot;
 &amp; &quot; termObj\n    termOption\n    termClone\n    termNotify\n    termPic&quot;;

CONST E0_2 =
   &quot;kler\n    termReplicate\n    termRemote\n    termSimple\n    termDelega&quot;
 &amp; &quot;te\n    termRedirect\n    termProc\n    termMeth\n    termUpdateMeth\n &quot;
 &amp; &quot;   termPar\n    termLet\n    termVar\n    termIf\n    termCase\n    ter&quot;
 &amp; &quot;mLoop\n    termExit\n    termFor\n    termForeach\n    termException\n &quot;
 &amp; &quot;   termRaise\n    termTry\n    termLock\n    termWatch\n    termAll\n  &quot;
 &amp; &quot;  termSome\n    termSelf\n  }\n\ntermIde ::=\n  ide_1 \t\t\t\t\t:: Buil&quot;
 &amp; &quot;dTermIde\n\ntermConst ::=\n  { \&quot;ok\&quot;                                  &quot;
 &amp; &quot;      :: BuildTermOk\n    \&quot;true\&quot;                                     &quot;
 &amp; &quot; :: BuildTermBoolTrue\n    \&quot;false\&quot;                                   &quot;
 &amp; &quot;  :: BuildTermBoolFalse\n    char_1                                    &quot;
 &amp; &quot;  :: BuildTermChar\n    string_1                                    :: &quot;
 &amp; &quot;BuildTermString\n    int_1                                       :: Bui&quot;
 &amp; &quot;ldTermInt\n    real_1                                      :: BuildTerm&quot;
 &amp; &quot;Real\n  }\n\ntermMinus ::=\n  [ \&quot;~-\&quot; term_1 ]                        &quot;
 &amp; &quot;       :: BuildTermMinus\n\ntermArray ::=\n  [ \&quot;[\&quot; termList_1 \&quot;]\&quot; ]&quot;
 &amp; &quot;\t\t\t:: BuildTermArray\n\ntermObj ::=\n  [ \&quot;{\&quot; termObjProtected_1 te&quot;
 &amp; &quot;rmObjSerialized_2 \n\ttermObjReplicated_3 termObjSimple_4\n    termObjF&quot;
 &amp; &quot;ields_5 \&quot;}\&quot; ]                 \t:: BuildTermObj\n\ntermObjProtected :&quot;
 &amp; &quot;:=\n {  [ \&quot;protected\&quot; { \&quot;,\&quot; [] } ] \t\t        :: BuildOptionYes\n &quot;
 &amp; &quot;   []\t\t\t\t\t\t:: BuildOptionNo\n  }\n  \ntermObjSerialized ::=\n {  &quot;
 &amp; &quot;[ \&quot;serialized\&quot; { \&quot;,\&quot; [] } ] \t        :: BuildOptionYes\n    []\t\t&quot;
 &amp; &quot;\t\t\t\t:: BuildOptionNo\n  }\n\ntermObjReplicated ::=\n {  [ \&quot;replica&quot;
 &amp; &quot;ted\&quot; { \&quot;,\&quot; [] } ] \t        :: BuildOptionYes\n    []\t\t\t\t\t\t:: &quot;
 &amp; &quot;BuildOptionNo\n  }\n\ntermObjSimple ::=\n {  [ \&quot;simple\&quot; { \&quot;,\&quot; [] } &quot;
 &amp; &quot;] \t         \t:: BuildOptionYes\n    []\t\t\t\t\t\t:: BuildOptionNo\n &quot;
 &amp; &quot; }\n\ntermOption ::=\n  [ \&quot;option\&quot; name_1 typSpec \&quot;=&gt;\&quot; termSeqOpt_2&quot;
 &amp; &quot; \&quot;end\&quot; ]\t:: BuildTermOption\n\ntermOrAlias ::=\n  { term\n    [ \&quot;al&quot;
 &amp; &quot;ias\&quot; ide_1 \&quot;of\&quot; termSeq_2 \&quot;end\&quot; ]      :: BuildTermAlias\n  }\n\nt&quot;
 &amp; &quot;ermObjFields ::=\n  { [ name_1 typSpec \&quot;=&gt;\&quot; termOrAlias_2 \n      { [&quot;
 &amp; &quot; \&quot;,\&quot; termObjFields_3 ]\t\t\t:: BuildTermObjField\n\t[]\t\t\t\t\t:: Bu&quot;
 &amp; &quot;ildTermObjFieldSingle\n      }_4\n    ]\t\t\t\t\t\t:: Selec&quot;;

CONST E0_3 =
   &quot;t4\n    []\t\t\t\t\t\t:: BuildTermObjFieldNil\n  }\n\ntermClone ::=\n  &quot;
 &amp; &quot;[ \&quot;clone\&quot; \&quot;(\&quot; termList_1 \&quot;)\&quot; ]\t\t:: BuildTermClone\n\ntermNotify&quot;
 &amp; &quot; ::=\n  [ \&quot;notify\&quot; term_1 \&quot;with\&quot; term_2 ]\t\t:: BuildTermNotify\n\n&quot;
 &amp; &quot;termPickler ::=\n  [ \&quot;setpickler\&quot; \&quot;(\&quot; term_1 \&quot;,\&quot; term_2 \&quot;,\&quot; ter&quot;
 &amp; &quot;m_3 \&quot;)\&quot; ]\t:: BuildTermPickler\n\ntermReplicate ::=\n  [ \&quot;replicate\&quot;&quot;
 &amp; &quot; \&quot;(\&quot; termList_1 \&quot;)\&quot; ]\t\t:: BuildTermReplicate\n\ntermSimple ::=\n &quot;
 &amp; &quot; [ \&quot;simple\&quot; \&quot;(\&quot; term_1 \&quot;)\&quot; ]\t\t\t:: BuildTermSimple\n\ntermRemot&quot;
 &amp; &quot;e ::=\n  [ \&quot;remote\&quot; \&quot;(\&quot; term_1 \&quot;)\&quot; ]\t\t\t:: BuildTermRemote\n\nt&quot;
 &amp; &quot;ermDelegate ::= (* OBSOLETE *)\n  [ \&quot;delegate\&quot; termSeq_1 \&quot;to\&quot; termS&quot;
 &amp; &quot;eq_2 \&quot;end\&quot; ]\t:: BuildTermRedirect\n\ntermRedirect ::=\n  [ \&quot;redirec&quot;
 &amp; &quot;t\&quot; termSeq_1 \&quot;to\&quot; termSeq_2 \&quot;end\&quot; ]\t:: BuildTermRedirect\n\ntermP&quot;
 &amp; &quot;roc ::=\n  [ \&quot;proc\&quot; \&quot;(\&quot; ideList_1 \&quot;)\&quot; { [ typResSpec \&quot;,\&quot; ] [] }&quot;
 &amp; &quot; termSeqOpt_2 \&quot;end\&quot; ]\n\t\t\t\t\t \t:: BuildTermProc\n\ntermMeth ::=\n&quot;
 &amp; &quot;  [ \&quot;meth\&quot; \&quot;(\&quot; ideList_1 \&quot;)\&quot; { [ typResSpec \&quot;,\&quot; ] [] } termSeqO&quot;
 &amp; &quot;pt_2 \&quot;end\&quot; ]\n\t\t\t\t\t\t:: BuildTermMeth\ntermUpdateMeth ::=\n  [ \&quot;&quot;
 &amp; &quot;umeth\&quot; \&quot;(\&quot; ideList_1 \&quot;)\&quot; { [ typResSpec \&quot;,\&quot; ] [] } termSeqOpt_2 &quot;
 &amp; &quot;\&quot;end\&quot; ]\n\t\t\t\t\t\t:: BuildTermUpdateMeth\ntermPar ::=\n  [ \&quot;(\&quot; t&quot;
 &amp; &quot;ermSeqOpt_1 \&quot;)\&quot; ]\t\t\t:: Select1\n\ntermLet ::=\n  [ \&quot;let\&quot;\n    { &quot;
 &amp; &quot;[ \&quot;rec\&quot; termBinding_1 ]                   :: BuildTermLetRec\n      t&quot;
 &amp; &quot;ermBinding_1                             :: BuildTermLet\n    }_2\n  ] &quot;
 &amp; &quot;                                            :: Select2                 &quot;
 &amp; &quot;   \n\ntermVar ::=\n  [ \&quot;var\&quot;\n    { [ \&quot;rec\&quot; termBinding_1 ]       &quot;
 &amp; &quot;            :: BuildTermVarRec\n      termBinding_1                    &quot;
 &amp; &quot;         :: BuildTermVar\n    }_2\n  ]                                 &quot;
 &amp; &quot;            :: Select2                    \n\ntermIf ::=\n  [ \&quot;if\&quot; te&quot;
 &amp; &quot;rmSeq_1 \&quot;then\&quot; termSeqOpt_2 termElsif_3 ]\n\t\t\t\t\t\t:: BuildTermIf&quot;
 &amp; &quot;\ntermElsif ::=\n  { [ \&quot;end\&quot; ]\t\t\t\t\t:: BuildTermIfEnd\n    [ \&quot;el&quot;
 &amp; &quot;se\&quot; termSeqOpt_1 \&quot;end\&quot; ]\t\t\t:: Select1\n    [ \&quot;elsif\&quot; termSeq_1 &quot;
 &amp; &quot;\&quot;then\&quot; termSeqOpt_2 termElsif_3 ]\n\t\t\t\t\t\t:: BuildTermIf\n  }\n\n&quot;
 &amp; &quot;termCase ::=\n  [ \&quot;case\&quot; termSeq_1 \n    \&quot;of\&quot; termCaseList_2 ]\t\t\t&quot;
 &amp; &quot;:: BuildTermCase\n\ntermLoop ::=\n  [ \&quot;loop\&quot; termSeqOpt_1 \&quot;end\&quot; ]\t&quot;
 &amp; &quot;\t\t:: BuildTermLoop\n\ntermExit ::=\n  \&quot;exit\&quot;\t\t\t&quot;;

CONST E0_4 =
   &quot;\t\t:: BuildTermExit\n\ntermFor ::=\n  [ \&quot;for\&quot; ide_1 typSpec \&quot;=\&quot; te&quot;
 &amp; &quot;rm_2 \&quot;to\&quot; term_3 \&quot;do\&quot; termSeqOpt_4 \&quot;end\&quot; ]\n\t\t\t\t\t\t:: BuildT&quot;
 &amp; &quot;ermFor\n\ntermForeach ::=\n  [ \&quot;foreach\&quot; ide_1 typSpec \&quot;in\&quot; term_2 &quot;
 &amp; &quot;\n    { [ \&quot;do\&quot; termSeqOpt_3 ]\t\t\t:: BuildTermForeachDo\n      [ \&quot;m&quot;
 &amp; &quot;ap\&quot; termSeqOpt_3 ]\t\t\t:: BuildTermForeachMap\n    }_4\n    \&quot;end\&quot; \n&quot;
 &amp; &quot;  ]\t\t\t\t\t\t:: Select4\n\t\t\t\t\t\t\ntermException ::=\n  [ \&quot;excep&quot;
 &amp; &quot;tion\&quot;\t\&quot;(\&quot; term_1 \&quot;)\&quot; ]\t\t:: BuildTermException\n\ntermRaise ::=\n&quot;
 &amp; &quot;  [ \&quot;raise\&quot; \&quot;(\&quot; term_1 \&quot;)\&quot; ]                    :: BuildTermRaise&quot;
 &amp; &quot;\n\ntermTry ::=\n  [ \&quot;try\&quot; termSeqOpt_1 \n    { [ \&quot;except\&quot; termTryL&quot;
 &amp; &quot;ist_2 \&quot;end\&quot; ] \t\t:: BuildTermTry\n      [ \&quot;else\&quot; termSeqOpt_2 \&quot;en&quot;
 &amp; &quot;d\&quot; ] \t\t:: BuildTermTryElse\n      [ \&quot;finally\&quot; termSeqOpt_2 \&quot;end\&quot;&quot;
 &amp; &quot; ]\t\t:: BuildTermTryFinally\n    }_3\n  ]\t\t\t\t\t\t:: Select3\n\nter&quot;
 &amp; &quot;mList ::=\n  { [ term_1 \n      { [ \&quot;,\&quot; termList_2 ]\t\t\t:: BuildTer&quot;
 &amp; &quot;mListCons\n\t[]\t\t\t\t\t:: BuildTermListSingle\n      }_3\n    ]\t\t\t&quot;
 &amp; &quot;\t\t\t:: Select3\n    []\t\t\t\t\t\t:: BuildTermListNil\n  }\n\ntermLoc&quot;
 &amp; &quot;k ::=\n  [ \&quot;lock\&quot; termSeq_1 \&quot;do\&quot; termSeqOpt_2 \&quot;end\&quot; ]  :: BuildTe&quot;
 &amp; &quot;rmLock\n\ntermWatch ::=\n  [ \&quot;watch\&quot; termSeq_1 \&quot;until\&quot; termSeq_2 \&quot;&quot;
 &amp; &quot;end\&quot; ] :: BuildTermWatch\n\nideList ::=\n  { [ ide_1 typSpec\n      { &quot;
 &amp; &quot;[ \&quot;,\&quot; ideList_2 ]\t\t\t:: BuildIdeListCons\n\t[]\t\t\t\t\t:: BuildIde&quot;
 &amp; &quot;ListSingle\n      }_3\n    ]\t\t\t\t\t\t:: Select3\n    []\t\t\t\t\t\t:&quot;
 &amp; &quot;: BuildIdeListNil\n  }\n\ntermCaseListEnd ::=\n  { \&quot;end\&quot;\t\t\t\t\t:: &quot;
 &amp; &quot;BuildCaseListNil\n    [ \&quot;else\&quot; termSeqOpt_1 \&quot;end\&quot; ]\t        :: Bui&quot;
 &amp; &quot;ldCaseListElse\n  }\n\ntermCaseList ::=\n  { termCaseListEnd\n    [ nam&quot;
 &amp; &quot;e_1 \n      { [ \&quot;(\&quot; ide_2 typSpec \&quot;)\&quot; \&quot;=&gt;\&quot; termSeqOpt_3\n        &quot;
 &amp; &quot;  { [ \&quot;,\&quot; termCaseList_4 ]\t\t:: BuildCaseListCons\n\t    termCaseLis&quot;
 &amp; &quot;tEnd_4         \t\t:: BuildCaseListCons\n          }_5\n        ]\t\t\t&quot;
 &amp; &quot;\t\t:: Select5\n        [ \&quot;=&gt;\&quot; termSeqOpt_3\n          { [ \&quot;,\&quot; term&quot;
 &amp; &quot;CaseList_4 ]\t\t:: BuildCaseListCons\n\t    termCaseListEnd_4         \t&quot;
 &amp; &quot;\t:: BuildCaseListCons\n          }_5\n        ]\t\t\t\t\t:: Select5\n &quot;
 &amp; &quot;     }_6\n    ]\t\t\t\t\t\t:: Select6\n  }\n\ntermTryList ::=\n  { [ \&quot;&quot;
 &amp; &quot;else\&quot; termSeqOpt_1 ]                     :: BuildTryListElse\n    [ te&quot;
 &amp; &quot;rm_1 \&quot;=&gt;\&quot; termSeqOpt_2 \n      { [ \&quot;,\&quot; termTryList_3 ]\t\t\t:: Buil&quot;
 &amp; &quot;dTryLi&quot;;

CONST E0_5 =
   &quot;stCons\n\t[ \&quot;else\&quot; termSeqOpt_3 ]\t\t\t:: BuildTryListConsElse\n\t[]\t&quot;
 &amp; &quot;\t\t\t\t:: BuildTryListSingle\n      }_4\n    ]\t\t\t\t\t\t:: Select4\n&quot;
 &amp; &quot;    []\t\t\t\t\t\t:: BuildTryListNil\n  }\n\ntermAll ::=\n    [ \&quot;All\&quot;&quot;
 &amp; &quot; \&quot;(\&quot; ide { typBound [] } \&quot;)\&quot; term_1 ]    :: Select1\n\ntermSome ::=&quot;
 &amp; &quot;\n    [ \&quot;Some\&quot; \&quot;(\&quot; ide { typBound [] } \&quot;)\&quot; term_1 ]    :: Select1&quot;
 &amp; &quot;\n\ntermSelf ::=\n    [ \&quot;Self\&quot; \&quot;(\&quot; ide \&quot;)\&quot; term_1 ]    :: Select1&quot;
 &amp; &quot;\n\n(* &lt;/pre&gt; *)\n&quot;;

BEGIN
END ObliqBdl.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
