<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: m3quake/src/QMachine.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>m3quake/src/QMachine.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright (C) 1995, Digital Equipment Corporation           
 All rights reserved.                                        
 See the file COPYRIGHT for a full description.              
                                                             
 Last modified on Tue Feb 28 15:59:51 PST 1995 by kalsow     

<P><PRE>MODULE <module><implements><A HREF="QMachine.i3.html">QMachine</A></implements></module>;

IMPORT <A HREF="../../libm3/src/types/ASCII.i3.html">ASCII</A>, <A HREF="../../libm3/src/atom/Atom.i3.html">Atom</A>, <A HREF="../../libm3/derived/AtomList.i3.html">AtomList</A>, <A HREF="../../libm3/derived/IntRefTbl.i3.html">IntRefTbl</A>, <A HREF="../../libm3/src/params/Env.i3.html">Env</A>, <A HREF="../../libm3/src/fmtlex/Fmt.i3.html">Fmt</A>, <A HREF="../../m3core/src/text/Text.i3.html">Text</A>, <A HREF="../../m3core/src/text/TextConv.i3.html">TextConv</A>, <A HREF="../../libm3/src/rw/FileWr.i3.html">FileWr</A>;
IMPORT <A HREF="../../libm3/src/os/Common/Pipe.i3.html">Pipe</A>, <A HREF="../../libm3/src/rw/Rd.i3.html">Rd</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../libm3/src/rw/Stdio.i3.html">Stdio</A>, <A HREF="../../libm3/src/os/Common/OSError.i3.html">OSError</A>, <A HREF="../../libm3/derived/TextSeq.i3.html">TextSeq</A>, <A HREF="../../m3core/src/text/TextClass.i3.html">TextClass</A>;
IMPORT <A HREF="../../libm3/src/os/Common/Pathname.i3.html">Pathname</A>, <A HREF="../../libm3/src/os/Common/Process.i3.html">Process</A>, <A HREF="../../libm3/src/os/Common/File.i3.html">File</A>, <A HREF="../../libm3/src/os/Common/FS.i3.html">FS</A>, <A HREF="../../m3core/src/runtime/common/RTParams.i3.html">RTParams</A>;
IMPORT <A HREF="../../m3middle/src/M3Buf.i3.html">M3Buf</A>, <A HREF="../../m3middle/src/M3File.i3.html">M3File</A>, <A HREF="#x1">M3ID</A>, <A HREF="../../m3middle/src/M3Process.i3.html">M3Process</A>;
IMPORT <A HREF="QIdent.i3.html">QIdent</A>, <A HREF="QValue.i3.html">QValue</A>, <A HREF="QVal.i3.html">QVal</A>, <A HREF="QCode.i3.html">QCode</A>, <A HREF="QCompiler.i3.html">QCompiler</A>, <A HREF="../derived/QVTbl.i3.html">QVTbl</A>, <A HREF="../derived/QVSeq.i3.html">QVSeq</A>, <A HREF="QScanner.i3.html">QScanner</A>;
FROM <A HREF="Quake.i3.html">Quake</A> IMPORT Error, ID, IDMap, NoID;
IMPORT <A HREF="../../m3core/src/time/Common/Date.i3.html">Date</A>, <A HREF="../../m3core/src/time/Common/Time.i3.html">Time</A>;
IMPORT <A HREF="#x2">TextUtils</A>, <A HREF="../../sysutils/src/FSUtils.i3.html">FSUtils</A>, <A HREF="../../sysutils/src/System.i3.html">System</A>, <A HREF="../../sysutils/src/DirStack.i3.html">DirStack</A>; (* sysutils *)
IMPORT <A HREF="../../m3core/derived/Compiler.i3.html">Compiler</A>;
IMPORT <A HREF="#x3">M3Path</A>;

CONST
  OnUnix = (Compiler.ThisOS = Compiler.OS.POSIX);

TYPE
  QK = QValue.Kind;
  Op = QCode.Op;

REVEAL
  <A NAME="T">T</A> = T_ BRANDED &quot;QMachine.T&quot; OBJECT
    reg       : Registers;
    scopes    : ScopeStack     := NIL;
    stack     : ValueStack     := NIL;
    loops     : LoopStack      := NIL;
    output    : OutputStack    := NIL;
    frames    : FrameStack     := NIL;
    includes  : IncludeStack   := NIL;
    globals   : IntRefTbl.T    := NIL;  (* ID -&gt; QValue.Binding *)
    tmp_files : TextSeq.T      := NIL;
    tracing   : BOOLEAN        := FALSE;
    do_echo   : BOOLEAN        := FALSE;
    last_cp   : QCode.Stream   := NIL;
    bindings  : QValue.Binding := NIL;
    buffers   : BufStack;
    default_wr: Wr.T;
    shell     : TEXT         := NIL;
    sh_option : TEXT         := NIL;
    tmp_dir   : TEXT         := NIL;
  OVERRIDES
    init      := Init;
    evaluate  := Evaluate;
    get       := Get;
    put       := Put;
    lookup    := LookUp;
    push      := Push;
    pop       := Pop;
    error     := Err;
    cleanup   := CleanUp;
    include   := Include;
    normalize := Normalize;
    start_call:= StartCall;
    call_proc := CallProc;
    cp_if     := CopyIfNew;
    make_dir  := MakeDir;
    cur_file  := CurFile;
    cur_path  := CurPath;
    cur_wr    := CurWr;
    set_wr    := SetWr;
    exec_echo := ExecEcho;
    trace     := Trace;
  END;

TYPE
  Registers = RECORD
    cp : QCode.Stream   := NIL; (* code pointer *)
    pc : INTEGER        := 0;   (* program counter *)
    xp : INTEGER        := 0;   (* scope stack pointer *)
    sp : INTEGER        := 0;   (* value stack pointer *)
    lp : INTEGER        := 0;   (* loop stack pointer *)
    op : INTEGER        := 0;   (* output stack pointer *)
    fp : INTEGER        := 0;   (* frame pointer *)
    ln : INTEGER        := 0;   (* line number *)
    ip : INTEGER        := 0;   (* include stack pointer *)
    pi : QCode.ProcInfo := NIL; (* procedure info *)
    fn : BOOLEAN        := FALSE; (* =&gt; expect return result *)
  END;

TYPE
  ScopeStack   = REF ARRAY OF QValue.Scope;
  ValueStack   = REF ARRAY OF QValue.T;
  LoopStack    = REF ARRAY OF LoopInfo;
  OutputStack  = REF ARRAY OF OutputInfo;
  FrameStack   = REF ARRAY OF FrameInfo;
  IncludeStack = REF ARRAY OF IncludeInfo;

TYPE
  LoopInfo = RECORD
    iter     : QVTbl.Iterator  := NIL;
    array    : QVSeq.T         := NIL;
    next_elt : INTEGER         := 0;
    variable : QValue.Binding  := NIL;
  END;

TYPE
  OutputInfo = RECORD
    name : TEXT := NIL;
    wr   : Wr.T := NIL;
  END;

TYPE
  FrameInfo = RECORD
    proc   : QValue.Proc := NIL;
    saved  : Registers;
    outer  : BOOLEAN;  (* TRUE =&gt; exit eval loop when the frame is popped *)
  END;

TYPE
  IncludeInfo = RECORD
    file   : QCode.Stream;
    old_cp : QCode.Stream;
    old_pc : INTEGER;
  END;

TYPE
  BufStack = RECORD
    tos  : INTEGER := 0;
    bufs : ARRAY [0..9] OF M3Buf.T;
  END;
</PRE>-------------------------------------------------------- initialization ---

<P><PRE>PROCEDURE <A NAME="Init"><procedure>Init</procedure></A> (t: T;  map: IDMap): T =
  BEGIN
    t.map        := map;
    t.scopes     := NEW (ScopeStack,  40);
    t.stack      := NEW (ValueStack,  100);
    t.loops      := NEW (LoopStack,   20);
    t.output     := NEW (OutputStack, 10);
    t.frames     := NEW (FrameStack,  40);
    t.includes   := NEW (IncludeStack, 10);
    t.globals    := NEW (IntRefTbl.Default).init ();
    t.default_wr := Stdio.stdout;

    InitOSEnv (t);
    InitBuiltins (t);

    EVAL PushScope (t);  (* so that &quot;local&quot; variables have a place to go *)
    RETURN t;
  END Init;
</PRE>------------------------------------------------------------ evaluation ---

<P><PRE>PROCEDURE <A NAME="Evaluate"><procedure>Evaluate</procedure></A> (t: T;  s: QCode.Stream)
  RAISES {Error, Thread.Alerted} =
  BEGIN
    PushInclude (t, s, t.reg);
    Eval (t);
  END Evaluate;

PROCEDURE <A NAME="Eval"><procedure>Eval</procedure></A> (t: T)
  RAISES {Error, Thread.Alerted} =
  VAR
    op   : QCode.Op;
    arg  : INTEGER;
    val  : QValue.T;
    val2 : QValue.T;
    arr  : QVSeq.T;
    tbl  : QVTbl.T;
    int  : INTEGER;
    bind : QValue.Binding;
    txt  : TEXT;
    buf  : M3Buf.T;
    done : BOOLEAN;
  BEGIN
    LOOP
      IF (t.tracing) THEN TraceInstruction (t) END;
      WITH z = t.reg.cp.instrs [t.reg.pc] DO op := z.op;  arg := z.a; END;
      INC (t.reg.pc);

      CASE op OF

      | Op.Integer =&gt;
          val.kind := QK.Integer;
          val.int  := arg;
          val.ref  := NIL;
          Push (t, val);

      | Op.String =&gt;
          val.kind := QK.String;
          val.int  := arg;
          val.ref  := NIL;
          Push (t, val);

      | Op.BuildArray =&gt;
          arr := NEW (QVSeq.T).init (arg);
          FOR i := 0 TO arg-1 DO  Pop (t, val);  arr.addlo (val);  END;
          val.kind := QK.Array;
          val.int  := 0;
          val.ref  := arr;
          Push (t, val);
          arr := NIL;
          val.ref := NIL;

      | Op.BuildTable =&gt;
          tbl := NEW (QVTbl.Default).init();
          FOR i := arg-1 TO 0 BY -2 DO
            Pop (t, val2);
            Pop (t, val);
            EVAL tbl.put (QVal.ToID (t, val), val2);
          END;
          val.kind := QK.Table;
          val.int  := 0;
          val.ref  := tbl;
          Push (t, val);
          tbl := NIL;
          val.ref := NIL;
          val2.ref := NIL;

      | Op.GetEnv =&gt;
          PushText (t, GetEnv (NIL, t.map.id2txt (arg)));

      | Op.PushProc =&gt;
          val.kind := QK.Proc;
          val.int  := 0;
          val.ref  := NEW (QValue.Proc, info := t.reg.cp.procs [arg],
                           env  := t.scopes [0]);
                         (*env  := t.scopes [t.reg.xp-1]);*)
          (* In quake all procedures are global, and we don't want
             dynamic scoping... *)
          Push (t, val);
          val.ref := NIL;

      | Op.IsMember =&gt;
          Pop (t, val);  int := QVal.ToID (t, val);
          Pop (t, val);  tbl := QVal.ToTable (t, val);
          PushBool (t, tbl.get (int, val));
          tbl := NIL;
          val.ref := NIL;

      | Op.Concat =&gt;
          Pop (t, val2);
          Pop (t, val);
          buf := GetBuf (t);
          QVal.ToBuf (t, val, buf);
          QVal.ToBuf (t, val2, buf);
          PushText (t, M3Buf.ToText (buf));
          FreeBuf (t, buf);
          buf := NIL;
          val2.ref := NIL;
          val.ref := NIL;

      | Op.And =&gt;
          Pop (t, val2);
          Pop (t, val);
          PushBool (t, QVal.ToBool (t, val) AND QVal.ToBool (t, val2));
          val2.ref := NIL;
          val.ref := NIL;

      | Op.Or =&gt;
          Pop (t, val2);
          Pop (t, val);
          PushBool (t, QVal.ToBool (t, val) OR QVal.ToBool (t, val2));
          val2.ref := NIL;
          val.ref := NIL;

      | Op.Not =&gt;
          Pop (t, val);
          PushBool (t, NOT QVal.ToBool (t, val));
          val.ref := NIL;

      | Op.IndexTable =&gt;
          Pop (t, val);  int := QVal.ToID (t, val);
          Pop (t, val);  tbl := QVal.ToTable (t, val);
          IF NOT tbl.get (int, val) THEN
            Err (t, Fmt.F (&quot;table does not contain entry for: \&quot;%s\&quot;&quot;,
                           t.map.id2txt (int)));
          END;
          Push (t, val);
          tbl := NIL;
          val.ref := NIL;

      | Op.SubscriptArray =&gt;
          Pop (t, val);  int := QVal.ToInt (t, val);
          Pop (t, val);  arr := QVal.ToArray (t, val);
          IF (int &lt; 0) OR (arr.size() &lt;= int) THEN
            Err (t, &quot;array subscript out of bounds: &quot; &amp; Fmt.Int (int));
          END;
          Push (t, arr.get(int));
          arr := NIL;
          val.ref := NIL;

      | Op.InitForeach =&gt;
          Pop (t, val);
          PushLoop (t, arg, val);
          val.ref := NIL;

      | Op.NextForeach =&gt;
          IF NOT IterateLoop (t) THEN
            PopLoop (t);
            INC (t.reg.pc, arg);
          END;

      | Op.Goto =&gt;
          INC (t.reg.pc, arg);

      | Op.IfFalse =&gt;
          Pop (t, val);
          IF NOT QVal.ToBool (t, val) THEN INC (t.reg.pc, arg); END;
          val.ref := NIL;

      | Op.Halt =&gt;
          PopInclude (t);
          (**
          IF (t.reg.ip &lt;= 0) THEN EXIT; END;
          **)
          EXIT;

      | Op.PushScope =&gt;
          EVAL PushScope (t);

      | Op.PopScope =&gt;
          PopScope (t);

      | Op.DefineG =&gt;
          bind := DefineGlobal (t, arg, readonly := FALSE);
          Pop (t, bind.value);

      | Op.DefineGR =&gt;
          bind := DefineGlobal (t, arg, readonly := TRUE);
          Pop (t, bind.value);

      | Op.DefineL =&gt;
          bind := Define (t, arg, readonly := FALSE);
          Pop (t, bind.value);

      | Op.DefineLR =&gt;
          bind := Define (t, arg, readonly := TRUE);
          Pop (t, bind.value);

      | Op.LoadVar =&gt;
          bind := LookUp (t, arg);
          IF (bind # NIL) THEN
            Push (t, bind.value);
          ELSIF strict_variables THEN
            Err (t, &quot;undefined variable: &quot; &amp; t.map.id2txt (arg));
          ELSE
            PushText (t, t.map.id2txt (arg));
          END;

      | Op.Assign =&gt;
          bind := LookUp (t, arg);
          IF (bind = NIL) THEN
            bind := DefineGlobal (t, arg, readonly := FALSE);
          ELSIF bind.readonly THEN
            Err (t, &quot;cannot assign to readonly variable: &quot; &amp; t.map.id2txt(arg));
          END;
          Pop (t, val);
          bind.value := val;

      | Op.AssignTable =&gt;
          Pop (t, val);
          Pop (t, val2);  int := QVal.ToID (t, val2);
          Pop (t, val2);  tbl := QVal.ToTable (t, val2);
          EVAL tbl.put (int, val);
          tbl := NIL;
          val.ref := NIL;
          val2.ref := NIL;

      | Op.AssignArray =&gt;
          Pop (t, val);
          Pop (t, val2);  int := QVal.ToInt (t, val2);
          Pop (t, val2);  arr := QVal.ToArray (t, val2);
          IF (int &lt; 0) OR (arr.size() &lt;= int) THEN
            Err (t, &quot;array subscript out of bounds: &quot; &amp; Fmt.Int (int));
          END;
          arr.put (int, val);
          arr := NIL;
          val.ref := NIL;
          val2.ref := NIL;

      | Op.Append =&gt;
          Pop (t, val);
          Pop (t, val2);  arr := QVal.ToArray (t, val2);
          arr.addhi (val);
          arr := NIL;
          val.ref := NIL;
          val2.ref := NIL;

      | Op.StartRedirect =&gt;
          Pop (t, val);  txt := QVal.ToText (t, val);
          PushOutput (t, txt, append := FALSE);
          txt := NIL;
          val.ref := NIL;

      | Op.StartAppendRedirect =&gt;
          Pop (t, val);  txt := QVal.ToText (t, val);
          PushOutput (t, txt, append := TRUE);
          txt := NIL;
          val.ref := NIL;

      | Op.EndRedirect =&gt;
          PopOutput (t);

      | Op.StartCall =&gt;
          PushFrame (t);

      | Op.CallProc =&gt;
          DoCall (t, arg, FALSE, FALSE);

      | Op.CallFunc =&gt;
          DoCall (t, arg, TRUE, FALSE);

      | Op.SetLine =&gt;
          t.reg.ln := arg;

      | Op.ReturnValue =&gt;
          CheckReturn (t, TRUE);
          Pop (t, val);
          done := PopFrame (t);
          Push (t, val);
          IF done THEN EXIT; END;

      | Op.Return =&gt;
          CheckReturn (t, FALSE);
          IF PopFrame (t) THEN EXIT END;

      END; (* case *)
    END; (* loop *)
  END Eval;

PROCEDURE <A NAME="TraceInstruction"><procedure>TraceInstruction</procedure></A> (t: T)
  RAISES {Thread.Alerted} =
  BEGIN
    TRY
      PrintTrace (t);
    EXCEPT Wr.Failure =&gt;
      t.tracing := FALSE;
    END;
  END TraceInstruction;

PROCEDURE <A NAME="PrintTrace"><procedure>PrintTrace</procedure></A> (t: T)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR op: QCode.Op;  arg: INTEGER;
  BEGIN
    IF (t.last_cp # t.reg.cp) THEN
      Print (&quot;****** &quot;);
      IF (t.reg.cp # NIL) THEN
        Print (t.map.id2txt (t.reg.cp.source_file));
      END;
      Print (&quot; ******&quot;, Wr.EOL);
      t.last_cp := t.reg.cp;
    END;

    WITH z = t.reg.cp.instrs [t.reg.pc] DO op := z.op;  arg := z.a; END;

    FOR i := 1 TO t.reg.xp DO  Print (&quot;.&quot;); END;
    Print (Fmt.Pad (Fmt.Int (t.reg.pc),4,' ',Fmt.Align.Left));
    Print (&quot; &quot;, QCode.OpName[op]);
    CASE QCode.OpFormat [op] OF
    | 0 =&gt; (*done*)
    | 1 =&gt; Print (&quot;  &quot;, Fmt.Int (arg));
    | 2 =&gt; Print (&quot;  (&quot;, Fmt.Int (arg), &quot;) \&quot;&quot;);
           Print (t.map.id2txt (arg), &quot;\&quot;&quot;);
    | 3 =&gt; Print (&quot;  pc+(&quot;, Fmt.Int (arg), &quot;) =&gt; &quot;,
                  Fmt.Int (t.reg.pc + 1 + arg));
    END;
    Print (Wr.EOL);
    FlushIO ();
  END PrintTrace;
</PRE>------------------------------------------------------- procedure calls ---

<P><PRE>PROCEDURE <A NAME="PushFrame"><procedure>PushFrame</procedure></A> (t: T)
  RAISES {Error} =
  VAR val: QValue.T;
  BEGIN
    Pop (t, val);  (* the procedure value *)
    StartCall (t, val);
  END PushFrame;

PROCEDURE <A NAME="StartCall"><procedure>StartCall</procedure></A> (t: T;  READONLY proc: QValue.T)
  RAISES {Error} =
  BEGIN
    IF (t.reg.fp &gt;= NUMBER (t.frames^)) THEN ExpandFrames (t); END;
    WITH f = t.frames[t.reg.fp] DO
      f.proc  := QVal.ToProc (t, proc);
      f.saved := t.reg;
    END;
    INC (t.reg.fp);
  END StartCall;

PROCEDURE <A NAME="ExpandFrames"><procedure>ExpandFrames</procedure></A> (t: T) =
  VAR n := NUMBER (t.frames^);  new := NEW (FrameStack, n+n);
  BEGIN
    SUBARRAY (new^, 0, n) := t.frames^;
    t.frames := new;
  END ExpandFrames;

PROCEDURE <A NAME="CallProc"><procedure>CallProc</procedure></A> (t: T;  n_args: INTEGER;  isFunc: BOOLEAN)
  RAISES {Error, Thread.Alerted} =
  BEGIN
    DoCall (t, n_args, isFunc, TRUE);
    Eval (t);
  END CallProc;

PROCEDURE <A NAME="DoCall"><procedure>DoCall</procedure></A> (t: T;  n_args: INTEGER;  isFunc, outer: BOOLEAN)
  RAISES {Error, Thread.Alerted} =
  VAR p: QValue.Proc;  s: QValue.Scope;  val: QValue.T;
  BEGIN
    WITH f = t.frames[t.reg.fp-1] DO
      f.outer := outer;
      p := f.proc;
      IF (p.info.n_args # n_args) AND (p.info.n_args &gt;= 0) THEN
        Err (t, Fmt.F (&quot;%s to procedure %s (expected %s, received %s)&quot;,
                       &quot;wrong number of parameters passed&quot;,
                       t.map.id2txt (p.info.name),
                       Fmt.Int (p.info.n_args), Fmt.Int (n_args)));
      END;
      IF (p.info.builtin) THEN
        (* we save and restore the registers in case a builtin
           procedure is on the stack when an error is raised *)
        f.saved.pi := t.reg.pi;
        f.saved.pc := t.reg.pc;
        f.saved.cp := t.reg.cp;
        f.saved.ln := t.reg.ln;
        f.saved.fn := t.reg.fn;
        t.reg.pi := p.info;
        t.reg.pc := 0;
        t.reg.cp := NIL;
        t.reg.ln := 0;
        t.reg.fn := isFunc;
        p.info.handler (t, n_args);
        IF (p.info.handler = DoInclude) THEN
          (* the builtin include() function pops its own frame! *)
        ELSE
          CheckReturn (t, p.info.isFunc);
          IF p.info.isFunc THEN
            Pop (t, val);
            EVAL PopFrame (t);
            Push (t, val);
          ELSE
            EVAL PopFrame (t);
          END;
        END;
      ELSE
        f.saved.pi := t.reg.pi;
        f.saved.pc := t.reg.pc;
        f.saved.cp := t.reg.cp;
        f.saved.ln := t.reg.ln;
        t.reg.pi := p.info;
        t.reg.pc := p.info.entry;
        t.reg.cp := p.info.code;
        t.reg.fn := isFunc;
        s := PushScope (t);
        s.parent := p.env;  (* use procedure's static link *)
        (* scope debugging
        VAR m := &quot;\n&quot;; BEGIN
          FOR i := 0 TO t.reg.xp -1 DO
            m := m &amp; &quot; s: &quot; &amp; Fmt.Int(t.scopes[i].id);
            IF t.scopes[i].parent = NIL THEN
              m := m &amp; &quot; p: NIL\n&quot;;
            ELSE
              m := m &amp; &quot; p: &quot; &amp; Fmt.Int(t.scopes[i].parent.id) &amp; &quot;\n&quot;;
            END;
          END;
          IO.Put(&quot;scopes (DoCall):&quot; &amp; m);
        END;
        *)
        &lt;*ASSERT s.parent # s*&gt;
      END;
    END;
  END DoCall;

PROCEDURE <A NAME="PopFrame"><procedure>PopFrame</procedure></A> (t: T): BOOLEAN
  RAISES {Error, Thread.Alerted} =
  VAR val: QValue.T;
  BEGIN
    DEC (t.reg.fp);
    WITH f = t.frames[t.reg.fp] DO
      f.proc := NIL;
      WHILE (t.reg.ip &gt; f.saved.ip) DO PopInclude (t); END;
      t.reg.pi := f.saved.pi;  f.saved.pi := NIL;
      t.reg.cp := f.saved.cp;  f.saved.cp := NIL;
      t.reg.pc := f.saved.pc;
      t.reg.ln := f.saved.ln;
      t.reg.fn := f.saved.fn;
      (* IO.Put(&quot;rsp=&quot;); IO.PutInt(t.reg.sp); *)
      (* IO.Put(&quot; ssp=&quot;); IO.PutInt(f.saved.sp); IO.Put(&quot;\n&quot;); *)
      WHILE (t.reg.sp &gt; f.saved.sp) DO Pop (t, val);   END;
      (* IO.Put(&quot;rlp=&quot;); IO.PutInt(t.reg.lp); *)
      (* IO.Put(&quot; slp=&quot;); IO.PutInt(f.saved.lp); IO.Put(&quot;\n&quot;); *)
      WHILE (t.reg.lp &gt; f.saved.lp) DO PopLoop (t);    END;
      (* IO.Put(&quot;rop=&quot;); IO.PutInt(t.reg.op); *)
      (* IO.Put(&quot; sop=&quot;); IO.PutInt(f.saved.op); IO.Put(&quot;\n&quot;); *)
      WHILE (t.reg.op &gt; f.saved.op) DO PopOutput (t);  END;
      (* IO.Put(&quot;rxp=&quot;); IO.PutInt(t.reg.xp); *)
      (* IO.Put(&quot; sxp=&quot;); IO.PutInt(f.saved.xp); IO.Put(&quot;\n&quot;); *)
      WHILE (t.reg.xp &gt; f.saved.xp) DO PopScope (t);   END;
      RETURN f.outer;
    END;
  END PopFrame;

PROCEDURE <A NAME="CheckReturn"><procedure>CheckReturn</procedure></A> (t: T;  with_value: BOOLEAN)
  RAISES {Error} =
  BEGIN
    IF (t.reg.fp &lt; 1) THEN
      Err (t, &quot;return not in a function or procedure&quot;);
    END;
    IF (t.reg.fn = with_value) THEN
      (* ok *)
    ELSIF (t.reg.fn) THEN
      Err (t, &quot;expected return value is missing&quot;);
    ELSE
      Err (t, &quot;unexpected return value&quot;);
    END;
  END CheckReturn;
</PRE>------------------------------------------------------- global bindings ---

<P><PRE>PROCEDURE <A NAME="Get"><procedure>Get</procedure></A> (t: T;  name: ID;  VAR(*OUT*) value: QValue.T): BOOLEAN =
  VAR ref: REFANY;
  BEGIN
    IF t.globals.get (name, ref) THEN
      value := NARROW (ref, QValue.Binding).value;
      RETURN TRUE;
    ELSE
      RETURN FALSE;
    END;
  END Get;

PROCEDURE <A NAME="Put"><procedure>Put</procedure></A> (t: T;  name: ID;  READONLY value: QValue.T)
  RAISES {Error} =
  VAR bind := DefineGlobal (t, name, readonly := FALSE);
  BEGIN
    bind.value := value;
  END Put;
</PRE>----------------------------------------------- scopes &amp; local bindings ---

<P><PRE>PROCEDURE <A NAME="PushScope"><procedure>PushScope</procedure></A> (t: T): QValue.Scope =
  VAR m := &quot;\n&quot;;
  BEGIN
    IF (t.reg.xp &gt;= NUMBER (t.scopes^)) THEN ExpandScopes (t); END;
    WITH s = t.scopes [t.reg.xp] DO
      IF (s = NIL) THEN
        s := NEW (QValue.Scope);
        s.id := nextScopeId;
        INC (nextScopeId);
      END;
      IF (t.reg.xp &gt; 0)
        THEN s.parent := t.scopes[t.reg.xp-1];
        ELSE s.parent := NIL;
      END;
      &lt;*ASSERT s.parent # s*&gt;
      (* scope debugging
      FOR i := 0 TO t.reg.xp DO
        m := m &amp; &quot; s: &quot; &amp; Fmt.Int(t.scopes[i].id);
        IF t.scopes[i].parent = NIL THEN
          m := m &amp; &quot; p: NIL\n&quot;;
        ELSE
          m := m &amp; &quot; p: &quot; &amp; Fmt.Int(t.scopes[i].parent.id) &amp; &quot;\n&quot;;
        END;
      END;
      IO.Put(&quot;scopes:&quot; &amp; m);
      *)
      IF s.parent # NIL THEN
        IF s.parent.parent = s THEN
          TRY
            Err (t, &quot;loop in scopes, t.reg.xp = &quot; &amp; Fmt.Int(t.reg.xp) &amp; m);
          EXCEPT
            Error(e) =&gt;
            TRY
              Wr.PutText(Stdio.stderr, e);
            EXCEPT ELSE END;
          END;
          s.parent.parent := NIL;
        END;
      END;
      INC (t.reg.xp);
      RETURN s;
    END;
  END PushScope;

VAR nextScopeId := 0;

PROCEDURE <A NAME="ExpandScopes"><procedure>ExpandScopes</procedure></A> (t: T) =
  VAR n := NUMBER (t.scopes^);  new := NEW (ScopeStack, n+n);
  BEGIN
    SUBARRAY (new^, 0, n) := t.scopes^;
    t.scopes := new;
  END ExpandScopes;

PROCEDURE <A NAME="PopScope"><procedure>PopScope</procedure></A> (t: T) =
  VAR b, last_b: QValue.Binding;
  BEGIN
    DEC (t.reg.xp);
    (* IO.Put(&quot;trxp=&quot;); IO.PutInt(t.reg.xp); IO.Put(&quot;\n&quot;); *)
    WITH s = t.scopes [t.reg.xp] DO
      b := s.bindings;
      IF (b # NIL) THEN
        (* recycle the bindings *)
        WHILE (b # NIL) DO
          b.readonly  := FALSE;
          b.name      := NoID;
          b.value.ref := NIL;
          last_b := b;
          b := b.next;
        END;
        last_b.next := t.bindings;
        t.bindings := s.bindings;
        s.bindings := NIL;
      END;
      s.parent := NIL;
    END;
  END PopScope;

PROCEDURE <A NAME="Define"><procedure>Define</procedure></A> (t: T;  id: ID;  readonly: BOOLEAN): QValue.Binding
  RAISES {Error} =
  VAR old, new: QValue.Binding;
  BEGIN
    (* IO.Put(&quot;Define(&quot; &amp; Fmt.Int(id) &amp; &quot;)\n&quot;); *)
    WITH s = t.scopes [t.reg.xp-1] DO
      old := s.bindings;
      new := NewBinding (t);
      new.next     := old;
      new.name     := id;
      new.readonly := readonly;
      WHILE (old # NIL) DO
        IF (old.name = id) THEN
          Err (t, &quot;duplicate symbol defined: &quot; &amp; t.map.id2txt (id));
        END;
        old := old.next;
      END;
      s.bindings := new;
    END;
    RETURN new;
  END Define;

PROCEDURE <A NAME="DefineGlobal"><procedure>DefineGlobal</procedure></A> (t: T;  id: ID;  readonly: BOOLEAN): QValue.Binding
  RAISES {Error} =
  VAR ref: REFANY;  bind: QValue.Binding;
  BEGIN
    IF t.globals.get (id, ref) THEN
      bind := ref;
    ELSE
      bind := NewBinding (t);
      bind.name := id;
      bind.readonly := FALSE;
      EVAL t.globals.put (id, bind);
    END;
    IF (bind.readonly) THEN
      Err (t, &quot;cannot redefine readonly global symbol: &quot; &amp; t.map.id2txt (id));
    END;
    bind.readonly := readonly;
    RETURN bind;
  END DefineGlobal;

PROCEDURE <A NAME="LookUp"><procedure>LookUp</procedure></A> (t: T;  id: ID): QValue.Binding =
  VAR s: QValue.Scope;  b: QValue.Binding;  ref: REFANY;
  BEGIN
    (* IO.Put(&quot;LookUp(&quot; &amp; Fmt.Int(id) &amp; &quot;)\n&quot;); *)
    (* try the local scopes first *)
    IF (t.reg.xp &gt; 0) THEN
      s := t.scopes [t.reg.xp-1];
      WHILE (s # NIL) DO
        b := s.bindings;
        WHILE (b # NIL) DO
          IF (b.name = id) THEN RETURN b; END;
          b := b.next;
        END;
        s := s.parent;
      END;
    END;

    (* finally try the globals *)
    IF t.globals.get (id, ref)
      THEN RETURN ref;
      ELSE RETURN NIL;
    END;
  END LookUp;

PROCEDURE <A NAME="NewBinding"><procedure>NewBinding</procedure></A> (t: T): QValue.Binding =
  VAR b := t.bindings;
  BEGIN
    IF (b # NIL) THEN
      t.bindings := b.next;
      b.next := NIL;
    ELSE
      b := NEW (QValue.Binding);
    END;
    RETURN b;
  END NewBinding;
</PRE>------------------------------------------------------------ data stack ---

<P><PRE>PROCEDURE <A NAME="Push"><procedure>Push</procedure></A> (t: T;  READONLY value: QValue.T) =
  BEGIN
    IF (t.reg.sp &gt;= NUMBER (t.stack^)) THEN ExpandStack (t); END;
    t.stack [t.reg.sp] := value;
    INC (t.reg.sp);
  END Push;

PROCEDURE <A NAME="ExpandStack"><procedure>ExpandStack</procedure></A> (t: T) =
  VAR n := NUMBER (t.stack^);  new := NEW (ValueStack, n+n);
  BEGIN
    SUBARRAY (new^, 0, n) := t.stack^;
    t.stack := new;
  END ExpandStack;

PROCEDURE <A NAME="Pop"><procedure>Pop</procedure></A> (t: T;  VAR(*OUT*) value: QValue.T) RAISES {Error} =
  BEGIN
    IF (t.reg.sp &lt;= 0) THEN Err (t, &quot;empty stack&quot;); END;
    DEC (t.reg.sp);
    WITH z = t.stack [t.reg.sp] DO
      value := z;
      z.ref := NIL;
    END;
  END Pop;

PROCEDURE <A NAME="PushText"><procedure>PushText</procedure></A> (t: T;  s: TEXT) =
  VAR v := MakeText (t, s);
  BEGIN
    Push (t, v);
  END PushText;

PROCEDURE <A NAME="MakeText"><procedure>MakeText</procedure></A> (t: T;  s: TEXT): QValue.T =
  VAR v: QValue.T; len: INTEGER;
  BEGIN
    IF (s = NIL) THEN s := &quot;&quot;; END;
    len := Text.Length (s);
    v.kind := QK.String;
    IF len &gt; 1024 THEN
      (* this would break the M3ID table! *)
      v.int  := M3ID.NoID;
      v.ref  := s;
    ELSE
      v.int  := t.map.txt2id (s);
      v.ref  := NIL;
    END;
    RETURN v;
  END MakeText;

PROCEDURE <A NAME="PushBool"><procedure>PushBool</procedure></A> (t: T;  b: BOOLEAN) =
  VAR v := MakeBool (t, b);
  BEGIN
    Push (t, v);
  END PushBool;

PROCEDURE <A NAME="MakeBool"><procedure>MakeBool</procedure></A> (t: T;  b: BOOLEAN): QValue.T =
  VAR v: QValue.T;
  BEGIN
    v.kind := QK.String;
    v.int  := t.map.boolean [b];
    v.ref  := NIL;
    RETURN v;
  END MakeBool;

PROCEDURE <A NAME="PushInt"><procedure>PushInt</procedure></A> (t: T;  i: INTEGER) =
  VAR v := MakeInt (t, i);
  BEGIN
    Push (t, v);
  END PushInt;

PROCEDURE <A NAME="MakeInt"><procedure>MakeInt</procedure></A> (&lt;*UNUSED*&gt;t: T;  i: INTEGER): QValue.T =
  VAR v: QValue.T;
  BEGIN
    v.kind := QK.Integer;
    v.int  := i;
    v.ref  := NIL;
    RETURN v;
  END MakeInt;

PROCEDURE <A NAME="PushID"><procedure>PushID</procedure></A> (t: T;  nm: ID) =
  VAR v: QValue.T;
  BEGIN
    v.kind := QK.String;
    v.int  := nm;
    v.ref  := NIL;
    Push (t, v);
  END PushID;

PROCEDURE <A NAME="PopText"><procedure>PopText</procedure></A> (t: T): TEXT  RAISES {Error} =
  VAR v: QValue.T;
  BEGIN
    Pop (t, v);
    RETURN QVal.ToText (t, v);
  END PopText;

PROCEDURE <A NAME="PopBool"><procedure>PopBool</procedure></A> (t: T): BOOLEAN  RAISES {Error} =
  VAR v: QValue.T;
  BEGIN
    Pop (t, v);
    RETURN QVal.ToBool (t, v);
  END PopBool;

PROCEDURE <A NAME="PopInt"><procedure>PopInt</procedure></A> (t: T): INTEGER  RAISES {Error} =
  VAR v: QValue.T;
  BEGIN
    Pop (t, v);
    RETURN QVal.ToInt (t, v);
  END PopInt;

PROCEDURE <A NAME="PopID"><procedure>PopID</procedure></A> (t: T): ID  RAISES {Error} =
  VAR v: QValue.T;
  BEGIN
    Pop (t, v);
    RETURN QVal.ToID (t, v);
  END PopID;
</PRE>---------------------------------------------------------- output stack ---

<P><PRE>PROCEDURE <A NAME="PushOutput"><procedure>PushOutput</procedure></A> (t: T;  nm: TEXT;  append: BOOLEAN)
  RAISES {Error} =
  BEGIN
    IF (t.reg.op &gt;= NUMBER (t.output^)) THEN ExpandOutput (t); END;
    WITH o = t.output [t.reg.op] DO
      o.name := nm;
      TRY
        IF (append)
          THEN o.wr := FileWr.OpenAppend (nm);
          ELSE o.wr := FileWr.Open (nm);
        END;
      EXCEPT OSError.E(ec) =&gt;
        Err (t, Fmt.F (&quot;unable to open \&quot;%s\&quot; for writing%s&quot;, nm, OSErr(ec)));
      END;
    END;
    INC (t.reg.op);
  END PushOutput;

PROCEDURE <A NAME="ExpandOutput"><procedure>ExpandOutput</procedure></A> (t: T) =
  VAR n := NUMBER (t.output^);  new := NEW (OutputStack, n+n);
  BEGIN
    SUBARRAY (new^, 0, n) := t.output^;
    t.output := new;
  END ExpandOutput;

PROCEDURE <A NAME="PopOutput"><procedure>PopOutput</procedure></A> (t: T)
  RAISES {Error, Thread.Alerted} =
  BEGIN
    DEC (t.reg.op);
    WITH o = t.output [t.reg.op] DO
      TRY
        Wr.Close (o.wr);
        o.wr := NIL;
        o.name := NIL;
      EXCEPT Wr.Failure(ec) =&gt;
        Err (t, Fmt.F (&quot;unable to close \&quot;%s\&quot;%s&quot;, o.name, OSErr(ec)));
      END;
    END;
  END PopOutput;

PROCEDURE <A NAME="CurWr"><procedure>CurWr</procedure></A> (t: T): Wr.T =
  BEGIN
    IF (t.reg.op &lt;= 0)
      THEN RETURN t.default_wr;
      ELSE RETURN t.output [t.reg.op-1].wr;
    END;
  END CurWr;

PROCEDURE <A NAME="SetWr"><procedure>SetWr</procedure></A> (t: T;  wr: Wr.T) =
  BEGIN
    IF (t.reg.op &lt;= 0)
      THEN t.default_wr := wr;
      ELSE t.output [t.reg.op-1].wr := wr;
    END;
  END SetWr;
</PRE>------------------------------------------------------------ loop stack ---

<P><PRE>PROCEDURE <A NAME="PushLoop"><procedure>PushLoop</procedure></A> (t: T;  nm: ID;  READONLY elts: QValue.T)
  RAISES {Error} =
  VAR tbl: QVTbl.T;  arr: QVSeq.T;
  BEGIN
    IF (t.reg.lp &gt;= NUMBER (t.loops^)) THEN ExpandLoops (t); END;
    WITH x = t.loops [t.reg.lp] DO
      IF (elts.kind = QK.Table) THEN
        tbl := elts.ref;
        x.iter := tbl.iterate ();
      ELSIF (elts.kind = QK.Array) THEN
        arr := elts.ref;
        x.array := arr;
        x.next_elt := 0;
      ELSE
        Err (t, &quot;\&quot;foreach\&quot; not applied to an array or table&quot;);
      END;
      EVAL PushScope (t);
      x.variable := Define (t, nm, readonly := TRUE);
    END;
    INC (t.reg.lp);
  END PushLoop;

PROCEDURE <A NAME="ExpandLoops"><procedure>ExpandLoops</procedure></A> (t: T) =
  VAR n := NUMBER (t.loops^);  new := NEW (LoopStack, n+n);
  BEGIN
    SUBARRAY (new^, 0, n) := t.loops^;
    t.loops := new;
  END ExpandLoops;

PROCEDURE <A NAME="IterateLoop"><procedure>IterateLoop</procedure></A> (t: T): BOOLEAN =
  VAR int: INTEGER;  val: QValue.T;
  BEGIN
    WITH x = t.loops [t.reg.lp-1] DO
      IF (x.iter # NIL) THEN (* we're iterating over a table *)
        IF NOT x.iter.next (int, val) THEN RETURN FALSE; END;
        WITH z = x.variable.value DO
          z.kind := QK.String;
          z.int  := int;
          z.ref  := NIL;
        END;
      ELSE (* we're iterating over an array *)
        IF (x.next_elt &gt;= x.array.size()) THEN RETURN FALSE; END;
        x.variable.value := x.array.get (x.next_elt);
        INC (x.next_elt);
      END;
    END;
    RETURN TRUE;
  END IterateLoop;

PROCEDURE <A NAME="PopLoop"><procedure>PopLoop</procedure></A> (t: T) =
  BEGIN
    PopScope (t);
    DEC (t.reg.lp);
    WITH x = t.loops [t.reg.lp] DO
      x.iter     := NIL;
      x.array    := NIL;
      x.variable := NIL;
    END;
  END PopLoop;
</PRE>--------------------------------------------------------- include stack ---

<P><PRE>PROCEDURE <A NAME="PushInclude"><procedure>PushInclude</procedure></A> (t: T;  s: QCode.Stream;  VAR reg: Registers) =
  BEGIN
    IF (reg.ip &gt;= NUMBER (t.includes^)) THEN ExpandIncludes (t); END;
    WITH x = t.includes [reg.ip] DO
      x.file   := s;
      x.old_cp := reg.cp;
      x.old_pc := reg.pc;
    END;
    reg.cp := s;
    reg.pc := 0;
    INC (reg.ip);
  END PushInclude;

PROCEDURE <A NAME="ExpandIncludes"><procedure>ExpandIncludes</procedure></A> (t: T) =
  VAR n := NUMBER (t.includes^);  new := NEW (IncludeStack, n+n);
  BEGIN
    SUBARRAY (new^, 0, n) := t.includes^;
    t.includes := new;
  END ExpandIncludes;

PROCEDURE <A NAME="PopInclude"><procedure>PopInclude</procedure></A> (t: T) =
  BEGIN
    DEC (t.reg.ip);
    WITH x = t.includes [t.reg.ip] DO
      t.reg.cp := x.old_cp;
      t.reg.pc := x.old_pc;
      x.file   := NIL;
      x.old_cp := NIL;
    END;
  END PopInclude;
</PRE>----------------------------------------------------- OS dependent goo! ---

<P><PRE>PROCEDURE <A NAME="InitOSEnv"><procedure>InitOSEnv</procedure></A> (t: T) =
  BEGIN
    t.shell := GetEnv(NIL, &quot;QUAKE_SHELL&quot;);
    t.sh_option := GetEnv(NIL, &quot;QUAKE_SHELL_OPTION&quot;);
    t.tmp_dir := GetEnv(NIL, &quot;QUAKE_TMPDIR&quot;);
    IF OnUnix THEN
      IF t.shell = NIL THEN t.shell := &quot;/bin/sh&quot; END;
      IF t.sh_option = NIL THEN t.sh_option := &quot;-c&quot; END;
      IF t.tmp_dir = NIL THEN
        t.tmp_dir := GetEnv (&quot;/tmp&quot;, &quot;TMPDIR&quot;, &quot;TMP&quot;, &quot;TEMP&quot;);
      END;
    ELSE
      IF t.shell = NIL THEN t.shell := GetEnv (&quot;COMMAND.COM&quot;, &quot;COMSPEC&quot;) END;
      IF t.sh_option = NIL THEN t.sh_option := &quot;/c&quot; END;
      IF t.tmp_dir = NIL THEN
        t.tmp_dir   := GetEnv (&quot;C:\\TEMP&quot;, &quot;TMPDIR&quot;, &quot;TMP&quot;, &quot;TEMP&quot;);
      END;
    END;
  END InitOSEnv;

PROCEDURE <A NAME="GetEnv"><procedure>GetEnv</procedure></A> (default, v0, v1, v2, v3, v4: TEXT := NIL): TEXT =
  VAR val := Env.Get (v0);
  BEGIN
    IF val = NIL AND v1 # NIL THEN val := Env.Get(v1) END;
    IF val = NIL AND v2 # NIL THEN val := Env.Get(v2) END;
    IF val = NIL AND v3 # NIL THEN val := Env.Get(v3) END;
    IF val = NIL AND v4 # NIL THEN val := Env.Get(v4) END;
    IF val = NIL THEN val := default; END;
    RETURN val;
  END GetEnv;
</PRE>---------------------------------------------------- builtin procedures ---

<P><PRE>TYPE
  Builtin = RECORD
    name    : TEXT;
    proc    : QCode.BuiltinProc;
    n_args  : INTEGER; (* -1 means any number of parameters *)
    is_func : BOOLEAN;
  END;

CONST
  Builtins = ARRAY OF Builtin {
    Builtin {&quot;arglist&quot;,       DoArgList,                    2, TRUE},
    Builtin {&quot;cp_if&quot;,         DoCopyIfNew,                  2, FALSE},
    Builtin {&quot;defined&quot;,       DoDefined,                    1, TRUE},
    Builtin {&quot;empty&quot;,         DoEmpty,                      1, TRUE},
    Builtin {&quot;equal&quot;,         DoEqual,                      2, TRUE},
    Builtin {&quot;error&quot;,         DoError,                      1, FALSE},
    Builtin {&quot;escape&quot;,        DoEscape,                     1, TRUE},
    Builtin {&quot;exec&quot;,          DoExec,                      -1, FALSE},
    Builtin {&quot;cm3_exec&quot;,      DoCm3Exec,                   -1, FALSE},
    Builtin {&quot;file&quot;,          DoFile,                       0, TRUE},
    Builtin {&quot;format&quot;,        DoFormat,                    -1, TRUE},
    Builtin {&quot;include&quot;,       DoInclude,                    1, FALSE},
    Builtin {&quot;make_dir&quot;,      DoMakeDir,                    1, FALSE},
    Builtin {&quot;normalize&quot;,     DoNormalize,                  2, TRUE},
    Builtin {&quot;path&quot;,          DoPath,                       0, TRUE},
    Builtin {&quot;stale&quot;,         DoStale,                      2, TRUE},
    Builtin {&quot;try_exec&quot;,      DoTryExec,                   -1, TRUE},
    Builtin {&quot;try_cm3_exec&quot;,  DoTryCm3Exec,                -1, TRUE},
    Builtin {&quot;unlink_file&quot;,   DoUnlink,                     1, TRUE},
    Builtin {&quot;write&quot;,         DoWrite,                     -1, FALSE},
    Builtin {&quot;datetime&quot;,      DoDateTime,                   0, TRUE},
    Builtin {&quot;date&quot;,          DoDate,                       0, TRUE},
    Builtin {&quot;datestamp&quot;,     DoDateStamp,                  0, TRUE},
    Builtin {&quot;TRACE_INSTR&quot;,   DoTrace,                      0, FALSE},
    (* Builtin {&quot;eval_func&quot;,  DoEvalFunc,                   1, TRUE}, *)
    Builtin {&quot;hostname&quot;,      DoHostname,                   0, TRUE},

    Builtin {&quot;pushd&quot;,         DoPushdDir,                   1, FALSE},
    Builtin {&quot;popd&quot;,          DoPopDir,                     0, FALSE},
    Builtin {&quot;cd&quot;,            DoChangeDir,                  1, FALSE},
    Builtin {&quot;getwd&quot;,         DoGetWorkingDir,              0, TRUE},

    Builtin {&quot;quake&quot;,         DoEvalProc,                   1, FALSE},

    Builtin {&quot;q_exec&quot;,        DoQExec,                      1, TRUE},
    Builtin {&quot;q_exec_put&quot;,    DoQExecPut,                   2, TRUE},
    Builtin {&quot;q_exec_get&quot;,    DoQExecGet,                   1, TRUE},

    Builtin {&quot;fs_exists&quot;,     DoFSExists,                   1, TRUE},
    Builtin {&quot;fs_readable&quot;,   DoFSReadable,                 1, TRUE},
    Builtin {&quot;fs_writable&quot;,   DoFSWritable,                 1, TRUE},
    Builtin {&quot;fs_executable&quot;, DoFSExecutable,               1, TRUE},
    Builtin {&quot;fs_isdir&quot;,      DoFSIsDir,                    1, TRUE},
    Builtin {&quot;fs_isfile&quot;,     DoFSIsFile,                   1, TRUE},
    Builtin {&quot;fs_contents&quot;,   DoFSContents,                 1, TRUE},
    Builtin {&quot;fs_putfile&quot;,    DoFSPutFile,                  2, FALSE},
    Builtin {&quot;fs_mkdir&quot;,      DoFSMkDir,                    1, FALSE},
    Builtin {&quot;fs_touch&quot;,      DoFSTouch,                    1, FALSE},
    Builtin {&quot;fs_lsdirs&quot;,     DoFSSubDirs,                  2, TRUE},
    Builtin {&quot;fs_lsfiles&quot;,    DoFSFiles,                    2, TRUE},
    Builtin {&quot;fs_rmdir&quot;,      DoFSRmDir,                    1, FALSE},
    Builtin {&quot;fs_rmfile&quot;,     DoFSRmFile,                   1, FALSE},
    Builtin {&quot;fs_rmrec&quot;,      DoFSRmRec,                    1, FALSE},
    Builtin {&quot;fs_cp&quot;,         DoFSCopy,                     2, FALSE},

    Builtin {&quot;pn_valid&quot;,      DoPnValid,                    1, TRUE},
    Builtin {&quot;pn_decompose&quot;,  DoPnDecompose,                1, TRUE},
    Builtin {&quot;pn_compose&quot;,    DoPnCompose,                  1, TRUE},
    Builtin {&quot;pn_absolute&quot;,   DoPnAbsolute,                 1, TRUE},
    Builtin {&quot;pn_prefix&quot;,     DoPnPrefix,                   1, TRUE},
    Builtin {&quot;pn_last&quot;,       DoPnLast,                     1, TRUE},
    Builtin {&quot;pn_base&quot;,       DoPnBase,                     1, TRUE},
    Builtin {&quot;pn_lastbase&quot;,   DoPnLastBase,                 1, TRUE},
    Builtin {&quot;pn_lastext&quot;,    DoPnLastExt,                  1, TRUE},
    Builtin {&quot;pn_join&quot;,       DoPnJoin,                     2, TRUE},
    Builtin {&quot;pn_join2&quot;,      DoPnJoin2,                    3, TRUE},
    Builtin {&quot;pn_replace_ext&quot;,DoPnReplaceExt,               2, TRUE},
    Builtin {&quot;pn_parent&quot;,     DoPnParent,                   0, TRUE},
    Builtin {&quot;pn_current&quot;,    DoPnCurrent,                  0, TRUE},

    Builtin {&quot;len&quot;,           DoLen,                        1, TRUE},

    Builtin {&quot;split&quot;,         DoTextTokens,                 2, TRUE},
    Builtin {&quot;sub&quot;,           DoTextSub,                    3, TRUE},
    Builtin {&quot;skipl&quot;,         DoTextSkipLeft,               1, TRUE},
    Builtin {&quot;skipr&quot;,         DoTextSkipRight,              1, TRUE},
    Builtin {&quot;squeeze&quot;,       DoTextSqueeze,                1, TRUE},
    Builtin {&quot;compress&quot;,      DoTextCompress,               1, TRUE},
    Builtin {&quot;pos&quot;,           DoTextPos,                    2, TRUE},
    Builtin {&quot;tcontains&quot;,     DoTextContains,               2, TRUE},
    Builtin {&quot;bool&quot;,          DoTextBool,                   1, TRUE},
    Builtin {&quot;encode&quot;,        DoTextEncode,                 1, TRUE},
    Builtin {&quot;decode&quot;,        DoTextDecode,                 1, TRUE},
    Builtin {&quot;subst_chars&quot;,   DoTextSubstChars,             3, TRUE},
    Builtin {&quot;del_chars&quot;,     DoTextRemoveChars,            2, TRUE},
    Builtin {&quot;subst&quot;,         DoTextSubst,                  4, TRUE},
    Builtin {&quot;subst_env&quot;,     DoTextSubstEnv,               1, TRUE},
    Builtin {&quot;add_prefix&quot;,    DoTextAddPrefix,              2, TRUE},
    Builtin {&quot;add_suffix&quot;,    DoTextAddSuffix,              2, TRUE}
  };

PROCEDURE <A NAME="InitBuiltins"><procedure>InitBuiltins</procedure></A> (t: T) =
  VAR b: QValue.Binding;
  BEGIN
    FOR i := FIRST (Builtins) TO LAST (Builtins) DO
      WITH z = Builtins [i] DO
        b := NewBuiltin (t, z.name, z.proc, z.n_args, z.is_func);
        EVAL t.globals.put (b.name, b);
      END;
    END;
    b := NewConst (t, &quot;TRUE&quot;, t.map.boolean [TRUE]);
    EVAL t.globals.put (b.name, b);
    b := NewConst (t, &quot;FALSE&quot;, t.map.boolean [FALSE]);
    EVAL t.globals.put (b.name, b);
  END InitBuiltins;

PROCEDURE <A NAME="NewBuiltin"><procedure>NewBuiltin</procedure></A> (t       : T;
                      nm      : TEXT;
                      handler : QCode.BuiltinProc;
                      n_args  : INTEGER;
                      isFunc  : BOOLEAN): QValue.Binding =
  VAR
    id   := t.map.txt2id (nm);
    info := NEW (QCode.ProcInfo, name := id, isFunc := isFunc,
                   n_args := n_args, builtin := TRUE, handler := handler);
    proc := NEW (QValue.Proc, info := info, env := NIL);
    bind := NEW (QValue.Binding, name := info.name, readonly := TRUE);
  BEGIN
    bind.value.kind := QValue.Kind.Proc;
    bind.value.int  := 0;
    bind.value.ref  := proc;
    RETURN bind;
  END NewBuiltin;

PROCEDURE <A NAME="NewConst"><procedure>NewConst</procedure></A> (t: T;  nm: TEXT;  val: ID): QValue.Binding =
  VAR
    id   := t.map.txt2id (nm);
    bind := NEW (QValue.Binding, name := id, readonly := TRUE);
  BEGIN
    bind.value.kind := QValue.Kind.String;
    bind.value.int  := val;
    bind.value.ref  := NIL;
    RETURN bind;
  END NewConst;

PROCEDURE <A NAME="DoArgList"><procedure>DoArgList</procedure></A> (t: T;  n_args: INTEGER)
  RAISES {Error, Thread.Alerted} =
  CONST
    Max_args       = 10;
    Max_arg_length = 1024;
  VAR
    prefix, args : TEXT;
    split        : TextSeq.T;
    val0, val1   : QValue.T;
    file         : TEXT;
    wr           : Wr.T;
    buf          : M3Buf.T;
  BEGIN
    &lt;*ASSERT n_args = 2 *&gt;
    buf := GetBuf (t);
    Pop (t, val1);
    QVal.ToBuf (t, val1, buf);
    args  := M3Buf.ToText (buf);
    split := SplitArgs (args);
    FreeBuf (t, buf);

    Pop (t, val0);
    prefix := QVal.ToText (t, val0);

    (* check for the easy case *)
    IF (split.size () &lt;= Max_args)
      AND (Text.Length (args) &lt;= Max_arg_length) THEN
      Push (t, val1);
      RETURN;
    END;

    TRY
      file := UniqueTempFile (t);
      wr := FileWr.Open (file);
      TRY
        FOR i := 0 TO split.size()-1  DO
          Wr.PutText (wr, split.get(i));
          Wr.PutText (wr, Wr.EOL);
        END;
      FINALLY
        Wr.Close (wr);
      END;

      PushText (t, prefix &amp; file);
    EXCEPT
    | Wr.Failure(ec) =&gt;
        Err (t, &quot;unable to write on \&quot;&quot; &amp; file &amp; &quot;\&quot;&quot; &amp; OSErr (ec));
    | OSError.E(ec) =&gt;
        Err (t, &quot;unable to write on \&quot;&quot; &amp; file &amp; &quot;\&quot;&quot; &amp; OSErr (ec));
    END;
  END DoArgList;

PROCEDURE <A NAME="DoCopyIfNew"><procedure>DoCopyIfNew</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR val: QValue.T;  src, dest: TEXT;
  BEGIN
    &lt;*ASSERT n_args = 2 *&gt;
    Pop (t, val);  dest := QVal.ToText (t, val);
    Pop (t, val);  src  := QVal.ToText (t, val);
    CopyIfNew (t, src, dest);
  END DoCopyIfNew;

PROCEDURE <A NAME="CopyIfNew"><procedure>CopyIfNew</procedure></A> (t: T;  src, dest: TEXT) RAISES {Error} =
  VAR equal := FALSE;
  BEGIN

    src := FixPath (src);
    dest := FixPath (dest);

    IF M3File.IsDirectory (dest) THEN
      dest := Pathname.Join (dest, Pathname.Last (src), NIL);
    END;

    TRY
      equal := M3File.IsEqual (src, dest);
    EXCEPT OSError.E =&gt;
    END;

    TRY
      IF NOT equal THEN M3File.Copy (src, dest); END;
    EXCEPT OSError.E(ec) =&gt;
      Err (t, Fmt.F (&quot;unable to copy \&quot;%s\&quot; to \&quot;%s\&quot;%s&quot;,
                     src, dest, OSErr (ec)));
    END;
  END CopyIfNew;

PROCEDURE <A NAME="DoDefined"><procedure>DoDefined</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR val: QValue.T;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, val);
    PushBool (t, LookUp (t, QVal.ToID (t, val)) # NIL);
  END DoDefined;

PROCEDURE <A NAME="DoEmpty"><procedure>DoEmpty</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR empty := FALSE;  val: QValue.T;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, val);
    CASE val.kind OF
    | QK.Integer =&gt; empty := FALSE;
    | QK.String  =&gt; empty := (val.int = t.map.boolean[FALSE]);
    | QK.Array   =&gt; empty := NARROW (val.ref, QVSeq.T).size() = 0;
    | QK.Table   =&gt; empty := NARROW (val.ref, QVTbl.T).size() = 0;
    ELSE
      Err (t, &quot;\&quot;empty\&quot; not applied to a string, table, or array&quot;);
    END;
    PushBool (t, empty);
  END DoEmpty;

PROCEDURE <A NAME="DoEqual"><procedure>DoEqual</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR v1, v2: QValue.T;  eq := FALSE;
  BEGIN
    &lt;*ASSERT n_args = 2 *&gt;
    Pop (t, v1);
    Pop (t, v2);
    IF (v1.kind = v2.kind) THEN
      CASE v1.kind OF
      | QK.Var     =&gt; eq := (v1.int = v2.int) AND (v1.ref = v2.ref);
      | QK.Integer =&gt; eq := (v1.int = v2.int);
      | QK.String  =&gt;
        IF v1.ref = NIL AND v2.ref = NIL THEN
          eq := (v1.int = v2.int);
        ELSIF v1.ref # NIL AND v2.ref # NIL THEN
          eq := Text.Equal (NARROW (v1.ref, TEXT), NARROW (v2.ref, TEXT));
        ELSE
          eq := FALSE;
        END;
      | QK.Table   =&gt; eq := (v1.ref = v2.ref);
      | QK.Array   =&gt; eq := (v1.ref = v2.ref);
      | QK.Proc    =&gt; eq := (v1.ref = v2.ref);
      END;
    END;
    PushBool (t, eq);
  END DoEqual;

PROCEDURE <A NAME="DoError"><procedure>DoError</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR val: QValue.T;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, val);
    Err (t, QVal.ToText (t, val));
  END DoError;

PROCEDURE <A NAME="DoEscape"><procedure>DoEscape</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    val     : QValue.T;
    txt     : TEXT;
    buf     : M3Buf.T;
    ch      : CHAR;
    len     : INTEGER;
    out_len : INTEGER;
    out_buf : ARRAY [0..199] OF CHAR;
    in_buf  : ARRAY [0..199] OF CHAR;
    new_ch  : BOOLEAN := FALSE;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, val);  txt := QVal.ToText (t, val);
    len := Text.Length (txt);
    IF (len+len &lt;= NUMBER (out_buf)) THEN
      out_len := 0;
      Text.SetChars (in_buf, txt);
      FOR i := 0 TO len-1 DO
        ch := Text.GetChar (txt, i);
        IF (ch = '\134') THEN
          out_buf[out_len] := ch; INC (out_len);
          new_ch := TRUE;
        END;
        out_buf [out_len] := ch;  INC (out_len);
      END;
      IF (new_ch)
        THEN PushText (t, Text.FromChars (SUBARRAY (out_buf, 0, out_len)));
        ELSE Push (t, val);
      END;
    ELSE
      buf := GetBuf (t);
      FOR i := 0 TO len - 1 DO
        ch := Text.GetChar (txt, i);
        IF (ch = '\134') THEN M3Buf.PutChar (buf, ch); new_ch := TRUE; END;
        M3Buf.PutChar (buf, ch);
      END;
      txt := M3Buf.ToText (buf);
      FreeBuf (t, buf);
      IF (new_ch)
        THEN PushText (t, txt);
        ELSE Push (t, val);
      END;
    END;
  END DoEscape;

PROCEDURE <A NAME="ExecEcho"><procedure>ExecEcho</procedure></A> (t: T;  b: BOOLEAN): BOOLEAN =
  VAR old := t.do_echo;
  BEGIN
    t.do_echo := b;
    RETURN old;
  END ExecEcho;

PROCEDURE <A NAME="Trace"><procedure>Trace</procedure></A> (t: T; b: BOOLEAN) =
  BEGIN
    t.tracing := b;
  END Trace;

PROCEDURE <A NAME="DoExec"><procedure>DoExec</procedure></A> (t: T;  n_args: INTEGER)
  RAISES {Error, Thread.Alerted} =
  BEGIN
    ExecCommand (t, n_args, onlyTry := FALSE);
  END DoExec;

PROCEDURE <A NAME="DoTryExec"><procedure>DoTryExec</procedure></A> (t: T;  n_args: INTEGER)
  RAISES {Error, Thread.Alerted} =
</PRE><BLOCKQUOTE><EM> uncomment this incorrect code for internal compiler errors
  VAR info := ExecCommand (t, n_args);
</EM></BLOCKQUOTE><PRE>
  BEGIN
    ExecCommand (t, n_args, onlyTry := TRUE);
  END DoTryExec;

PROCEDURE <A NAME="DoCm3Exec"><procedure>DoCm3Exec</procedure></A> (t: T;  n_args: INTEGER)
  RAISES {Error, Thread.Alerted} =
  BEGIN
    ExecCommand (t, n_args, mergeStdoutStderr := TRUE, onlyTry := FALSE);
  END DoCm3Exec;

PROCEDURE <A NAME="DoTryCm3Exec"><procedure>DoTryCm3Exec</procedure></A> (t: T;  n_args: INTEGER)
  RAISES {Error, Thread.Alerted} =
  BEGIN
    ExecCommand (t, n_args, mergeStdoutStderr := TRUE, onlyTry := TRUE);
  END DoTryCm3Exec;

PROCEDURE <A NAME="ExecCommand"><procedure>ExecCommand</procedure></A> (t: T;  n_args: INTEGER;
                       mergeStdoutStderr := FALSE;
                       onlyTry := FALSE;)
  RAISES {Error, Thread.Alerted} =
  VAR
    echo         := TRUE;
    first        := TRUE;
    n            : INTEGER;
    handle       : Process.T;
    stdin, stdout, stderr: File.T;
    args         : ARRAY [0..1] OF TEXT;
    buf          : M3Buf.T;
    n_shell_args : INTEGER;
    wr           : Wr.T := CurWr (t);
    quake_in     : Pipe.T;
    process_out  : Pipe.T;
    inbuf        : ARRAY [0..255] OF CHAR;
    command      := &quot;&quot;;
    exit_code    := 0;
    ignore_errors := FALSE;
    len          : INTEGER;
  BEGIN
    IF n_args &gt; 0 THEN

      (* pack the arguments into a single string &amp; pop the stack *)
      buf   := GetBuf (t);
      FOR i := t.reg.sp - n_args TO t.reg.sp - 1 DO
        IF (first) THEN first := FALSE;  ELSE  M3Buf.PutChar (buf, ' ');  END;
        QVal.ToBuf (t, t.stack[i], buf);
        t.stack[i].ref := NIL;
      END;
      t.reg.sp := t.reg.sp - n_args;
      command := M3Buf.ToText (buf);
      FreeBuf (t,  buf);

      (* strip the leading magic characters *)
      n := 0;
      len := Text.Length (command);
      WHILE n &lt; len DO
        CASE Text.GetChar (command, n) OF
        | '@' =&gt; echo := FALSE;
        | '-' =&gt; ignore_errors := TRUE;
        ELSE EXIT;
        END;
        INC (n);
      END;
      IF n # 0 THEN
        command := Text.Sub (command, n);
      END;

      (* echo the command &amp; flush any pending output *)
      TRY
        IF echo OR t.do_echo THEN
          Wr.PutText (wr, command);
          Wr.PutText (wr, Wr.EOL);
        END;
        FlushIO ();
      EXCEPT Wr.Failure (ec) =&gt;
        Err (t, &quot;write failed&quot; &amp; OSErr (ec));
      END;

      args [0] := t.sh_option;
      args [1] := command;
      n_shell_args := 2;

      (* finally, execute the command *)
      TRY
        IF mergeStdoutStderr THEN
          Process.GetStandardFileHandles (stdin, stdout, stderr);
          Pipe.Open (hr := quake_in, hw := process_out);
          TRY
            (* fire up the subprocess *)
            handle := Process.Create (t.shell, SUBARRAY (args, 0, n_shell_args),
                                      stdin := stdin, stdout := process_out,
                                      stderr := process_out);
            (* close our copy of the writing end of the output pipe *)
            process_out.close ();
            LOOP
              (* send anything coming through the pipe to the quake output file *)
              n := M3File.Read (quake_in, inbuf, NUMBER (inbuf));
              IF (n &lt;= 0) THEN EXIT; END;
              Wr.PutString (wr, SUBARRAY (inbuf, 0, n));
            END;
          FINALLY
            quake_in.close ();
            FlushIO ();
          END;
        ELSE
          FlushIO ();
          Process.GetStandardFileHandles (stdin, stdout, stderr);
          handle := Process.Create (t.shell, SUBARRAY (args, 0, n_shell_args),
                                    stdin := stdin, stdout := stdout,
                                    stderr := stderr);
        END;
      EXCEPT
      | Thread.Alerted =&gt;
          KillProcess (handle);
          RAISE Thread.Alerted;
      | Wr.Failure (ec) =&gt;
          KillProcess (handle);
          Err (t, &quot;write failed&quot; &amp; OSErr (ec));
      | OSError.E (ec) =&gt;
          KillProcess (handle);
          Err (t, Fmt.F (&quot;exec failed%s *** %s&quot;, OSErr (ec), command));
      END;

      (* wait for everything to shutdown... *)
      exit_code := Process.Wait (handle);
    END;

    IF onlyTry THEN
      IF ignore_errors THEN
        exit_code := 0;
      END;
      PushInt (t, exit_code);
    ELSE
      IF (exit_code # 0) AND NOT ignore_errors THEN
        Err (t, Fmt.F(&quot;exit %s: %s&quot;, Fmt.Int(exit_code), command));
      END;
    END;

  END ExecCommand;

PROCEDURE <A NAME="KillProcess"><procedure>KillProcess</procedure></A> (handle: Process.T) =
  BEGIN
    IF (handle # NIL) THEN
      TRY
        M3Process.Interrupt (handle);
      EXCEPT OSError.E =&gt;
        (* ignore *)
      END;
    END;
  END KillProcess;

PROCEDURE <A NAME="DoFile"><procedure>DoFile</procedure></A> (t: T;  n_args: INTEGER) =
  BEGIN
    &lt;*ASSERT n_args = 0 *&gt;
    PushText (t, CurFile (t));
  END DoFile;

PROCEDURE <A NAME="CurFile"><procedure>CurFile</procedure></A> (t: T): TEXT =
  BEGIN
    RETURN t.map.id2txt (t.includes[t.reg.ip-1].file.source_file);
  END CurFile;

PROCEDURE <A NAME="DoFormat"><procedure>DoFormat</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    val     : QValue.T;
    n       : INTEGER;
    format  : TEXT;
    strings := NEW (REF ARRAY OF TEXT, n_args - 1);
  BEGIN
    &lt;*ASSERT n_args &gt; 0 *&gt;
    n := 0;
    FOR i := t.reg.sp - n_args + 1 TO t.reg.sp - 1 DO
      strings [n] := QVal.ToText (t, t.stack[i]);  INC (n);
      t.stack[i].ref := NIL;
    END;
    DEC (t.reg.sp, n_args - 1);
    Pop (t, val);
    format := QVal.ToText (t, val);
    PushText (t, Fmt.FN (format, strings^));
  END DoFormat;

PROCEDURE <A NAME="DoInclude"><procedure>DoInclude</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error, Thread.Alerted} =
  VAR path: TEXT;  val: QValue.T;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, val);  path := QVal.ToText (t, val);
    IncludeFile (t, path, from_code := TRUE);
  END DoInclude;

PROCEDURE <A NAME="Include"><procedure>Include</procedure></A> (t: T;  path: TEXT) RAISES {Error, Thread.Alerted} =
  BEGIN
    IncludeFile (t, path, from_code := FALSE);
  END Include;

PROCEDURE <A NAME="IncludeFile"><procedure>IncludeFile</procedure></A> (t: T;  path: TEXT;  from_code: BOOLEAN)
  RAISES {Error, Thread.Alerted} =
  VAR old_path: TEXT;  code: QCode.Stream;
  BEGIN
    IF NOT Pathname.Absolute (path) THEN
      old_path := CurFile (t);
      path := Pathname.Join (Pathname.Prefix (old_path), path, NIL);
    END;

    TRY
      code := QCompiler.CompileFile (path, t.map);
    EXCEPT Error(msg) =&gt;
      Err (t, msg);
    END;

    (****
    WITH f = t.frames [t.reg.fp-1] DO
      PushInclude (t, code, f.saved);
      t.reg.ip := f.saved.ip;
    END;
    ****)

    IF (from_code) THEN
      EVAL PopFrame (t); (* pop the call to &quot;include()&quot; *)
    END;
    PushInclude (t, code, t.reg);
    Eval (t);
  END IncludeFile;

PROCEDURE <A NAME="DoEvalProc"><procedure>DoEvalProc</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    val: QValue.T;
    code: QCode.Stream;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, val);

    TRY
      TRY
        code := QCompiler.CompileText (&quot;eval&quot;, QVal.ToText (t, val), t.map);
      EXCEPT Error(msg) =&gt;
        Err (t, msg);
      END;

      PushInclude (t, code, t.reg);
      Eval (t);
    EXCEPT
      Thread.Alerted =&gt; Err (t, &quot;interrupted&quot;);
    END;
  END DoEvalProc;

PROCEDURE <A NAME="DoMakeDir"><procedure>DoMakeDir</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR val: QValue.T;  dir, prefix: TEXT;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, val);  dir := QVal.ToText (t, val);
    prefix := Env.Get(&quot;CM3_INSTALL_PREFIX&quot;);
    IF prefix # NIL THEN
      dir := prefix &amp; dir;
    END;
    MakeDir (t, M3Path.New (dir));
  END DoMakeDir;

PROCEDURE <A NAME="MakeDir"><procedure>MakeDir</procedure></A> (t: T;  dir: TEXT)  RAISES {Error} =
  VAR parent: TEXT;
  BEGIN
    IF dir = NIL THEN RETURN END;
    dir := FixPath (dir);
    IF M3File.IsDirectory (dir) THEN RETURN END;

    parent := Pathname.Prefix (dir);
    IF (parent # NIL) AND NOT PathEqual (parent, dir) THEN
      MakeDir (t, parent);
    END;

    TRY
      FS.CreateDirectory (dir);
    EXCEPT OSError.E (ec) =&gt;
      Err (t, Fmt.F (&quot;unable to create directory \&quot;%s\&quot;%s&quot;, dir, OSErr (ec)));
    END;
  END MakeDir;

PROCEDURE <A NAME="DoNormalize"><procedure>DoNormalize</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR val: QValue.T;  unfixed, prefix: TEXT;
  BEGIN
    &lt;*ASSERT n_args = 2 *&gt;
    Pop (t, val);  unfixed := QVal.ToText (t, val);
    Pop (t, val);  prefix  := QVal.ToText (t, val);
    PushText (t, Normalize (t, prefix, unfixed));
  END DoNormalize;

PROCEDURE <A NAME="FixPath"><procedure>FixPath</procedure></A> (path: TEXT): TEXT =
</PRE><BLOCKQUOTE><EM> Many Win32 functions allow forward slashes in place of
backward slashes. On a system with just one volume, or in
a context in which only one volume matters, c:/foo and /foo
mean the same thing. Therefore it is possibly advantageous
and simplifying to just use <CODE>/foo</CODE>. However older Win32 Modula-3
runtime does not accept forward slashes.
In order to bootstrap a newer cm3 against an older runtime, convert.
</EM></BLOCKQUOTE><PRE>
  BEGIN
    IF OnUnix THEN
      IF Text.Length(path) &gt; 2
          AND Text.GetChar(path, 1) = ':'
          AND Text.GetChar(path, 2) = '\\' THEN
        path := Text.Sub(path, 2);
      END;
      path := TextUtils.SubstChar(path, '\\', '/');
    ELSE
      path := TextUtils.SubstChar(path, '/', '\\');
    END;
    RETURN path;
  END FixPath;

PROCEDURE <A NAME="Normalize"><procedure>Normalize</procedure></A> (t: T;  prefix, unfixed: TEXT): TEXT  RAISES {Error} =
  VAR unfixedArcs, prefixArcs: Pathname.Arcs;
  BEGIN
    TRY
      unfixedArcs := Pathname.Decompose(unfixed);
    EXCEPT Pathname.Invalid =&gt;
      Err (t, Fmt.F (&quot;invalid path (\&quot;%s\&quot;) in normalize&quot;, unfixed));
    END;

    TRY
      prefixArcs := Pathname.Decompose(prefix);
    EXCEPT Pathname.Invalid =&gt;
      Err (t, Fmt.F (&quot;invalid path (\&quot;%s\&quot;) in normalize&quot;, prefix));
    END;

    TRY
      RETURN Pathname.Compose (StripPrefix (t, prefixArcs,
                                   CanonicalizePath (unfixedArcs)));
    EXCEPT Pathname.Invalid =&gt;
      Err (t, Fmt.F (&quot;invalid path in normalize(\&quot;%s\&quot;, \&quot;%s\&quot;)&quot;,
                     prefix, unfixed));
    END;
    RETURN NIL;
  END Normalize;

PROCEDURE <A NAME="DoPath"><procedure>DoPath</procedure></A> (t: T;  n_args: INTEGER) =
  BEGIN
    &lt;*ASSERT n_args = 0 *&gt;
    PushText (t, CurPath (t));
  END DoPath;

PROCEDURE <A NAME="CurPath"><procedure>CurPath</procedure></A> (t: T): TEXT =
  BEGIN
    RETURN Pathname.Prefix (CurFile (t));
  END CurPath;

PROCEDURE <A NAME="DoStale"><procedure>DoStale</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    val, val2 : QValue.T;
    arr       : QVSeq.T;
    dep       : TEXT;
    target    : TEXT;
    t_status  : File.Status;
    d_status  : File.Status;
  BEGIN
    &lt;*ASSERT n_args = 2 *&gt;
    Pop (t, val2);  (* dependencies *)
    Pop (t, val);   target := QVal.ToText (t, val);

    TRY
      t_status := FS.Status (target);
      IF (val2.kind = QK.Array) THEN
        arr := val2.ref;
        FOR i := 0 TO arr.size() - 1 DO
          dep := QVal.ToText (t, arr.get (i));
          d_status := FS.Status (dep);
          IF t_status.modificationTime &lt; d_status.modificationTime THEN
            PushBool (t, TRUE);
            RETURN;
          END;
        END;
      ELSE
        dep := QVal.ToText (t, val2);
        d_status := FS.Status (dep);
        IF t_status.modificationTime &lt; d_status.modificationTime THEN
          PushBool (t, TRUE);
          RETURN;
        END;
      END;
    EXCEPT OSError.E =&gt;
      PushBool (t, TRUE);
      RETURN;
    END;

    PushBool (t, FALSE);
  END DoStale;

PROCEDURE <A NAME="DoUnlink"><procedure>DoUnlink</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR val: QValue.T;  ok := FALSE;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, val);
    TRY
      FS.DeleteFile (QVal.ToText (t, val));
      ok := TRUE;
    EXCEPT OSError.E =&gt;
      ok := FALSE;
    END;
    PushBool (t, ok);
  END DoUnlink;

PROCEDURE <A NAME="DoWrite"><procedure>DoWrite</procedure></A> (t: T;  n_args: INTEGER)
  RAISES {Error, Thread.Alerted} =
  VAR wr := CurWr (t);  buf := GetBuf (t);  txt: TEXT;
  BEGIN
    (* write the arguments to an internal buffer &amp; pop the stack *)
    FOR i := t.reg.sp - n_args TO t.reg.sp - 1 DO
      QVal.ToBuf (t, t.stack[i], buf);
      t.stack[i].ref := NIL;
    END;
    t.reg.sp := t.reg.sp - n_args;
    txt := M3Buf.ToText (buf);
    FreeBuf (t, buf);

    TRY
      Wr.PutText (wr, txt);
      Wr.Flush (wr);
    EXCEPT Wr.Failure (ec) =&gt; Err (t, &quot;write failed&quot; &amp; OSErr (ec));
    END;
  END DoWrite;

PROCEDURE <A NAME="DoDateTime"><procedure>DoDateTime</procedure></A>(t: T;  n_args: INTEGER) =
  BEGIN
    &lt;*ASSERT n_args = 0*&gt;
    WITH date = Date.FromTime(Time.Now(), Date.UTC) DO
        PushText (
            t,
            Fmt.FN(
                &quot;%04s-%02s-%02s %02s:%02s:%02s&quot;,
                ARRAY OF TEXT{
                    Fmt.Int(date.year),
                    Fmt.Int(ORD(date.month) + 1),
                    Fmt.Int(date.day),
                    Fmt.Int(date.hour),
                    Fmt.Int(date.minute),
                    Fmt.Int(date.second)
                    }));
    END;
  END DoDateTime;

PROCEDURE <A NAME="DoDate"><procedure>DoDate</procedure></A>(t: T;  n_args: INTEGER) =
  BEGIN
    &lt;*ASSERT n_args = 0*&gt;
    WITH date = Date.FromTime(Time.Now(), Date.UTC) DO
        PushText (
            t,
            Fmt.FN(
                &quot;%04s-%02s-%02s&quot;,
                ARRAY OF TEXT{
                    Fmt.Int(date.year),
                    Fmt.Int(ORD(date.month) + 1),
                    Fmt.Int(date.day)
                    }));
    END;
  END DoDate;

PROCEDURE <A NAME="DoDateStamp"><procedure>DoDateStamp</procedure></A>(t: T;  n_args: INTEGER) =
  BEGIN
    &lt;*ASSERT n_args = 0*&gt;
    WITH date = Date.FromTime(Time.Now(), Date.UTC) DO
        PushText (
            t,
            Fmt.FN(
                &quot;%04s-%02s-%02s-%02s-%02s-%02s&quot;,
                ARRAY OF TEXT{
                    Fmt.Int(date.year),
                    Fmt.Int(ORD(date.month) + 1),
                    Fmt.Int(date.day),
                    Fmt.Int(date.hour),
                    Fmt.Int(date.minute),
                    Fmt.Int(date.second)
                    }));
    END;
  END DoDateStamp;

PROCEDURE <A NAME="DoHostname"><procedure>DoHostname</procedure></A>(t: T;  n_args: INTEGER) =
  BEGIN
    &lt;*ASSERT n_args = 0*&gt;
    PushText (t, System.Hostname());
  END DoHostname;

PROCEDURE <A NAME="DoTrace"><procedure>DoTrace</procedure></A> (t: T;  n_args: INTEGER) =
  BEGIN
    &lt;*ASSERT n_args = 0*&gt;
    t.tracing := NOT t.tracing;
  END DoTrace;
</PRE>--------------------------------------------------- dirstack extensions ---
<PRE>PROCEDURE <A NAME="DoPushdDir"><procedure>DoPushdDir</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    val: QValue.T;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, val);
    TRY
      DirStack.PushDir (QVal.ToText (t, val));
    EXCEPT
      DirStack.Error(msg) =&gt; Err (t, &quot;pushd failed: &quot; &amp; msg);
    END;
  END DoPushdDir;

PROCEDURE <A NAME="DoPopDir"><procedure>DoPopDir</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  BEGIN
    &lt;*ASSERT n_args = 0 *&gt;
    TRY
      DirStack.PopDir ();
    EXCEPT
      DirStack.Error(msg) =&gt; Err (t, &quot;popd failed: &quot; &amp; msg);
    END;
  END DoPopDir;

PROCEDURE <A NAME="DoChangeDir"><procedure>DoChangeDir</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    val: QValue.T;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, val);
    TRY
      DirStack.SetWorkingDir (QVal.ToText (t, val));
    EXCEPT
      DirStack.Error(msg) =&gt; Err (t, &quot;cd failed: &quot; &amp; msg);
    END;
  END DoChangeDir;

PROCEDURE <A NAME="DoGetWorkingDir"><procedure>DoGetWorkingDir</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    res: TEXT;
  BEGIN
    &lt;*ASSERT n_args = 0 *&gt;
    TRY
      res := DirStack.GetWorkingDir ();
    EXCEPT
      DirStack.Error(msg) =&gt; Err (t, &quot;getwd failed: &quot; &amp; msg);
    END;
    PushText (t, res);
  END DoGetWorkingDir;
</PRE>------------------------------------------------------- exec extensions ---
<PRE>PROCEDURE <A NAME="DoQExec"><procedure>DoQExec</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    val: QValue.T;
    res: INTEGER;
    cmd: TEXT;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, val);
    TRY
      cmd := QVal.ToText (t, val);
      IF t.do_echo THEN
        Wr.PutText(CurWr(t), cmd &amp; Wr.EOL);
      END;
      res := System.ExecuteList (cmd);
    EXCEPT
      System.ExecuteError(msg) =&gt; Err (t, &quot;execution failed: &quot; &amp; msg);
    | Thread.Alerted =&gt; Err (t, &quot;interrupted&quot;);
    | Wr.Failure(al) =&gt; Err (t, &quot;execution failed: &quot; &amp;
                             System.AtomListToText(al));
    END;
    PushInt (t, res);
  END DoQExec;

PROCEDURE <A NAME="DoQExecPut"><procedure>DoQExecPut</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    val1, val2: QValue.T;
    inputWr: Wr.T;
    p: Process.T;
    res: INTEGER;
    cmd: TEXT;
  BEGIN
    &lt;*ASSERT n_args = 2 *&gt;
    Pop (t, val2);
    Pop (t, val1);
    TRY
      cmd := QVal.ToText (t, val1);
      IF t.do_echo THEN
        Wr.PutText(CurWr(t), cmd &amp; Wr.EOL);
      END;
      p := System.PipeTo (cmd, inputWr);
      Wr.PutText( inputWr, (QVal.ToText (t, val2)));
      Wr.Close (inputWr);
      res := System.Wait (p);
    EXCEPT
      System.ExecuteError(msg) =&gt; Err (t, &quot;execution failed: &quot; &amp; msg);
    | System.Error(msg) =&gt; Err (t, &quot;execution failed: &quot; &amp; msg);
    | Wr.Failure(al) =&gt; Err (t, &quot;execution failed: &quot; &amp;
                             System.AtomListToText(al));
    | Thread.Alerted =&gt; Err (t, &quot;interrupted&quot;);
    END;
    PushInt (t, res);
  END DoQExecPut;

PROCEDURE <A NAME="DoQExecGet"><procedure>DoQExecGet</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    val, res: QValue.T;
    outputRd: Rd.T;
    outText: TEXT;
    p: Process.T;
    ret: INTEGER;
    arr: QVSeq.T;
    cmd: TEXT;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, val);
    TRY
      cmd := QVal.ToText (t, val);
      IF t.do_echo THEN
        Wr.PutText(CurWr(t), cmd &amp; Wr.EOL);
      END;
      p := System.RdExecute (cmd, outputRd);
      outText := Rd.GetText (outputRd, LAST(CARDINAL));
      ret := System.Wait (p);
      Rd.Close (outputRd);
    EXCEPT
      System.ExecuteError(msg) =&gt; Err (t, &quot;execution failed: &quot; &amp; msg);
    | Thread.Alerted =&gt; Err (t, &quot;interrupted&quot;);
    | System.Error(msg) =&gt; Err (t, &quot;execution failed: &quot; &amp; msg);
    | Rd.Failure(al) =&gt; Err (t, &quot;execution failed: &quot; &amp;
                             System.AtomListToText(al));
    | Wr.Failure(al) =&gt; Err (t, &quot;execution failed: &quot; &amp;
                             System.AtomListToText(al));
    END;
    arr := NEW (QVSeq.T).init();
    arr.addhi (MakeInt (t, ret));
    arr.addhi (MakeText (t, outText));
    res.kind := QK.Array;
    res.int  := 0;
    res.ref  := arr;
    Push (t, res);
  END DoQExecGet;
</PRE>--------------------------------------------------- pathname extensions ---
<PRE>PROCEDURE <A NAME="DoPnValid"><procedure>DoPnValid</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn: QValue.T;
    res: BOOLEAN;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, pn);
    res := Pathname.Valid (QVal.ToText (t, pn));
    PushBool (t, res);
  END DoPnValid;

PROCEDURE <A NAME="DoPnAbsolute"><procedure>DoPnAbsolute</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn: QValue.T;
    res: BOOLEAN;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, pn);
    res := Pathname.Absolute (QVal.ToText (t, pn));
    PushBool (t, res);
  END DoPnAbsolute;

&lt;*FATAL Pathname.Invalid*&gt;

PROCEDURE <A NAME="DoPnDecompose"><procedure>DoPnDecompose</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn: QValue.T;
    seq: TextSeq.T;
    res: QValue.T;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, pn);
    seq := Pathname.Decompose (QVal.ToText (t, pn));
    res.kind := QK.Array;
    res.int  := 0;
    res.ref  := MakeQValSeq (t, seq);
    Push (t, res);
  END DoPnDecompose;

PROCEDURE <A NAME="DoPnCompose"><procedure>DoPnCompose</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn: QValue.T;
    qseq: QVSeq.T;
    seq: TextSeq.T := NEW (TextSeq.T).init();
    res: Pathname.T;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, pn);
    qseq := QVal.ToArray (t, pn);
    FOR i := 0 TO qseq.size() - 1 DO
      VAR
        elem := qseq.get (i);
        qval := QVal.ToText (t, elem);
      BEGIN
        (* IO.Put( &quot;qval=&quot; &amp; qval &amp; &quot;\n&quot;); *)
        IF i = 0 AND Text.Empty(qval) THEN
          (* FIXME: it seems there's no real NIL representation in quake? *)
          qval := NIL;
        END;
        seq.addhi (qval);
      END;
    END;
    res := Pathname.Compose (seq);
    PushText (t, res);
  END DoPnCompose;

PROCEDURE <A NAME="DoPnPrefix"><procedure>DoPnPrefix</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn: QValue.T;
    res: Pathname.T;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, pn);
    res := Pathname.Prefix (QVal.ToText (t, pn));
    PushText (t, res);
  END DoPnPrefix;

PROCEDURE <A NAME="DoPnLast"><procedure>DoPnLast</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn: QValue.T;
    res: Pathname.T;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, pn);
    res := Pathname.Last (QVal.ToText (t, pn));
    PushText (t, res);
  END DoPnLast;

PROCEDURE <A NAME="DoPnBase"><procedure>DoPnBase</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn: QValue.T;
    res: Pathname.T;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, pn);
    res := Pathname.Base (QVal.ToText (t, pn));
    PushText (t, res);
  END DoPnBase;

PROCEDURE <A NAME="DoPnLastBase"><procedure>DoPnLastBase</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn: QValue.T;
    res: Pathname.T;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, pn);
    res := Pathname.LastBase (QVal.ToText (t, pn));
    PushText (t, res);
  END DoPnLastBase;

PROCEDURE <A NAME="DoPnLastExt"><procedure>DoPnLastExt</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn: QValue.T;
    res: Pathname.T;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, pn);
    res := Pathname.LastExt (QVal.ToText (t, pn));
    PushText (t, res);
  END DoPnLastExt;

PROCEDURE <A NAME="DoPnJoin"><procedure>DoPnJoin</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn, pn2: QValue.T;
    res: Pathname.T;
  BEGIN
    &lt;*ASSERT n_args = 2 *&gt;
    Pop (t, pn2);
    Pop (t, pn);
    res := Pathname.Join (QVal.ToText (t, pn), QVal.ToText (t, pn2));
    PushText (t, res);
  END DoPnJoin;

PROCEDURE <A NAME="DoPnJoin2"><procedure>DoPnJoin2</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn, pn2, ext: QValue.T;
    res: Pathname.T;
  BEGIN
    &lt;*ASSERT n_args = 3 *&gt;
    Pop (t, ext);
    Pop (t, pn2);
    Pop (t, pn);
    res := Pathname.Join (QVal.ToText (t, pn),
                          QVal.ToText (t, pn2),
                          QVal.ToText (t, ext));
    PushText (t, res);
  END DoPnJoin2;

PROCEDURE <A NAME="DoPnReplaceExt"><procedure>DoPnReplaceExt</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn, ext: QValue.T;
    res: Pathname.T;
  BEGIN
    &lt;*ASSERT n_args = 2 *&gt;
    Pop (t, ext);
    Pop (t, pn);
    res := Pathname.ReplaceExt (QVal.ToText (t, pn), QVal.ToText (t, ext));
    PushText (t, res);
  END DoPnReplaceExt;

PROCEDURE <A NAME="DoPnParent"><procedure>DoPnParent</procedure></A> (t: T;  n_args: INTEGER) =
  VAR
    res: Pathname.T;
  BEGIN
    &lt;*ASSERT n_args = 0 *&gt;
    res := Pathname.Parent;
    PushText (t, res);
  END DoPnParent;

PROCEDURE <A NAME="DoPnCurrent"><procedure>DoPnCurrent</procedure></A> (t: T;  n_args: INTEGER) =
  VAR
    res: Pathname.T;
  BEGIN
    &lt;*ASSERT n_args = 0 *&gt;
    res := Pathname.Current;
    PushText (t, res);
  END DoPnCurrent;
</PRE>--------------------------------------------------------- fs extensions ---
<PRE>PROCEDURE <A NAME="DoFSExists"><procedure>DoFSExists</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn: QValue.T;
    res: BOOLEAN;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, pn);
    res := FSUtils.Exists (QVal.ToText (t, pn));
    PushBool (t, res);
  END DoFSExists;

PROCEDURE <A NAME="DoFSReadable"><procedure>DoFSReadable</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn: QValue.T;
    res: BOOLEAN;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, pn);
    res := FSUtils.IsReadable (QVal.ToText (t, pn));
    PushBool (t, res);
  END DoFSReadable;

PROCEDURE <A NAME="DoFSWritable"><procedure>DoFSWritable</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn: QValue.T;
    res: BOOLEAN;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, pn);
    res := FSUtils.IsWritable (QVal.ToText (t, pn));
    PushBool (t, res);
  END DoFSWritable;

PROCEDURE <A NAME="DoFSExecutable"><procedure>DoFSExecutable</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn: QValue.T;
    res: BOOLEAN;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, pn);
    res := FSUtils.IsExecutable (QVal.ToText (t, pn));
    PushBool (t, res);
  END DoFSExecutable;

PROCEDURE <A NAME="DoFSIsDir"><procedure>DoFSIsDir</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn: QValue.T;
    res: BOOLEAN;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, pn);
    res := FSUtils.IsDir (QVal.ToText (t, pn));
    PushBool (t, res);
  END DoFSIsDir;

PROCEDURE <A NAME="DoFSIsFile"><procedure>DoFSIsFile</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn: QValue.T;
    res: BOOLEAN;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, pn);
    res := FSUtils.IsFile (QVal.ToText (t, pn));
    PushBool (t, res);
  END DoFSIsFile;

PROCEDURE <A NAME="DoFSContents"><procedure>DoFSContents</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn: QValue.T;
    fn, res: TEXT;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, pn);
    fn := QVal.ToText (t, pn);
    TRY
      res := FSUtils.FileContents (fn);
    EXCEPT
      FSUtils.E(m) =&gt; Err (t, &quot;cannot read file &quot; &amp; fn &amp; &quot;: &quot; &amp; m);
    END;
    PushText (t, res);
  END DoFSContents;

PROCEDURE <A NAME="DoFSPutFile"><procedure>DoFSPutFile</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn, data: QValue.T;
    fn: TEXT;
  BEGIN
    &lt;*ASSERT n_args = 2 *&gt;
    Pop (t, data);
    Pop (t, pn);
    fn := QVal.ToText (t, pn);
    TRY
      FSUtils.PutFile (fn, QVal.ToText (t, data));
    EXCEPT
      FSUtils.E(m) =&gt; Err (t, &quot;cannot write file &quot; &amp; fn &amp; &quot;: &quot; &amp; m);
    END;
  END DoFSPutFile;

PROCEDURE <A NAME="DoFSSubDirs"><procedure>DoFSSubDirs</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn, rel, res: QValue.T;
    fn, a2: TEXT;
    seq: TextSeq.T;
  BEGIN
    &lt;*ASSERT n_args = 2 *&gt;
    Pop (t, rel);
    Pop (t, pn);
    fn := QVal.ToText (t, pn);
    a2 := QVal.ToText (t, rel);
    TRY
      seq := FSUtils.SubDirs (fn, Text.Length (a2) &gt; 0);
    EXCEPT
      FSUtils.E(m) =&gt; Err (t, &quot;cannot list dirs &quot; &amp; fn &amp; &quot;: &quot; &amp; m);
    END;
    res.kind := QK.Array;
    res.int  := 0;
    res.ref  := MakeQValSeq (t, seq);
    Push (t, res);
  END DoFSSubDirs;

PROCEDURE <A NAME="DoFSFiles"><procedure>DoFSFiles</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn, rel, res: QValue.T;
    fn, a2: TEXT;
    seq: TextSeq.T;
  BEGIN
    &lt;*ASSERT n_args = 2 *&gt;
    Pop (t, rel);
    Pop (t, pn);
    fn := QVal.ToText (t, pn);
    a2 := QVal.ToText (t, rel);
    TRY
      seq := FSUtils.SubFiles (fn, Text.Length (a2) &gt; 0);
    EXCEPT
      FSUtils.E(m) =&gt; Err (t, &quot;cannot list files in &quot; &amp; fn &amp; &quot;: &quot; &amp; m);
    END;
    res.kind := QK.Array;
    res.int  := 0;
    res.ref  := MakeQValSeq (t, seq);
    Push (t, res);
  END DoFSFiles;

PROCEDURE <A NAME="DoFSMkDir"><procedure>DoFSMkDir</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn: QValue.T;
    fn: TEXT;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, pn);
    fn := QVal.ToText (t, pn);
    TRY
      FSUtils.Mkdir (fn);
    EXCEPT
      FSUtils.E(m) =&gt; Err (t, &quot;cannot create directories &quot; &amp; fn &amp; &quot;: &quot; &amp; m);
    END;
  END DoFSMkDir;

PROCEDURE <A NAME="DoFSTouch"><procedure>DoFSTouch</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn: QValue.T;
    fn: TEXT;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, pn);
    fn := QVal.ToText (t, pn);
    TRY
      FSUtils.Touch (fn);
    EXCEPT
      FSUtils.E(m) =&gt; Err (t, &quot;cannot touch file &quot; &amp; fn &amp; &quot;: &quot; &amp; m);
    END;
  END DoFSTouch;

PROCEDURE <A NAME="DoFSRmDir"><procedure>DoFSRmDir</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn: QValue.T;
    fn: TEXT;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, pn);
    fn := QVal.ToText (t, pn);
    TRY
      FSUtils.Rmdir (fn);
    EXCEPT
      FSUtils.E(m) =&gt; Err (t, &quot;cannot remove directory &quot; &amp; fn &amp; &quot;: &quot; &amp; m);
    END;
  END DoFSRmDir;

PROCEDURE <A NAME="DoFSRmFile"><procedure>DoFSRmFile</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn: QValue.T;
    fn: TEXT;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, pn);
    fn := QVal.ToText (t, pn);
    TRY
      FSUtils.Rm (fn);
    EXCEPT
      FSUtils.E(m) =&gt; Err (t, &quot;cannot remove file &quot; &amp; fn &amp; &quot;: &quot; &amp; m);
    END;
  END DoFSRmFile;

PROCEDURE <A NAME="DoFSRmRec"><procedure>DoFSRmRec</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn: QValue.T;
    fn: TEXT;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, pn);
    fn := QVal.ToText (t, pn);
    TRY
      FSUtils.RmRec (fn);
    EXCEPT
      FSUtils.E(m) =&gt; Err (t, &quot;cannot remove recursively &quot; &amp; fn &amp; &quot;: &quot; &amp; m);
    END;
  END DoFSRmRec;

PROCEDURE <A NAME="DoFSCopy"><procedure>DoFSCopy</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    pn, dst: QValue.T;
    fn, dest: TEXT;
  BEGIN
    &lt;*ASSERT n_args = 2 *&gt;
    Pop (t, dst);
    Pop (t, pn);
    fn := QVal.ToText (t, pn);
    dest := QVal.ToText (t, dst);
    TRY
      FSUtils.Cp (fn, dest);
    EXCEPT
      FSUtils.E(m) =&gt; Err (t, &quot;cannot cp &quot; &amp; fn &amp; &quot; to &quot; &amp; dest &amp; &quot;: &quot; &amp; m);
    END;
  END DoFSCopy;
</PRE>------------------------------------------------------- text extensions ---
<PRE>PROCEDURE <A NAME="DoLen"><procedure>DoLen</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    val: QValue.T;
    res: INTEGER;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, val);
    CASE val.kind OF
    | QK.Var     =&gt; res := Text.Length (QVal.ToTag (t, val));
    | QK.Integer =&gt; res := QVal.ToInt (t, val);
    | QK.String  =&gt; res := Text.Length (QVal.ToText (t, val));
    | QK.Table   =&gt; res := QVal.ToTable (t, val).size();
    | QK.Array   =&gt; res := QVal.ToArray (t, val).size();
    | QK.Proc    =&gt; res := -2;
    END;
    PushInt (t, res);
  END DoLen;

PROCEDURE <A NAME="DoTextTokens"><procedure>DoTextTokens</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    str, sep, res: QValue.T;
    seps: TEXT;
    set := ASCII.Set{};
    seq: TextSeq.T;
  BEGIN
    &lt;*ASSERT n_args = 2 *&gt;
    Pop (t, sep);
    Pop (t, str);
    seps := QVal.ToText (t, sep);
    FOR i := 0 TO Text.Length (seps) -1 DO
      set := set + ASCII.Set{Text.GetChar (seps, i)};
    END;
    seq := TextUtils.Tokenize (QVal.ToText (t, str), set);
    res.kind := QK.Array;
    res.int  := 0;
    res.ref  := MakeQValSeq (t, seq);
    Push (t, res);
  END DoTextTokens;

PROCEDURE <A NAME="MakeQValSeq"><procedure>MakeQValSeq</procedure></A> (t: T; s: TextSeq.T): QVSeq.T =
  VAR
    arr: QVSeq.T;
  BEGIN
    arr := NEW (QVSeq.T).init();
    FOR i := 0 TO s.size() -1 DO
      arr.addhi (MakeText (t, s.get (i)));
    END;
    RETURN arr;
  END MakeQValSeq;

PROCEDURE <A NAME="DoTextSub"><procedure>DoTextSub</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    str, off, len: QValue.T;
    res: TEXT;
  BEGIN
    &lt;*ASSERT n_args = 3 *&gt;
    Pop (t, len);
    Pop (t, off);
    Pop (t, str);
    res := Text.Sub (QVal.ToText (t, str), QVal.ToInt (t, off),
                     QVal.ToInt (t, len));
    PushText (t, res);
  END DoTextSub;

PROCEDURE <A NAME="DoTextSqueeze"><procedure>DoTextSqueeze</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    str: QValue.T;
    res: TEXT;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, str);
    res := TextUtils.Squeeze (QVal.ToText (t, str));
    PushText (t, res);
  END DoTextSqueeze;

PROCEDURE <A NAME="DoTextSkipLeft"><procedure>DoTextSkipLeft</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    val: QValue.T;
    res: TEXT;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, val);
    res := TextUtils.SkipLeft (QVal.ToText (t, val));
    PushText (t, res);
  END DoTextSkipLeft;

PROCEDURE <A NAME="DoTextSkipRight"><procedure>DoTextSkipRight</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    val: QValue.T;
    res: TEXT;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, val);
    res := TextUtils.SkipRight (QVal.ToText (t, val));
    PushText (t, res);
  END DoTextSkipRight;

PROCEDURE <A NAME="DoTextCompress"><procedure>DoTextCompress</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    val: QValue.T;
    res: TEXT;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, val);
    res := TextUtils.Compress (QVal.ToText (t, val));
    PushText (t, res);
  END DoTextCompress;

PROCEDURE <A NAME="DoTextPos"><procedure>DoTextPos</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    str, sub: QValue.T;
    res: INTEGER;
  BEGIN
    &lt;*ASSERT n_args = 2 *&gt;
    Pop (t, sub);
    Pop (t, str);
    res := TextUtils.Pos (QVal.ToText (t, str), QVal.ToText (t, sub));
    IF res = -1 THEN
      PushText (t, &quot;-1&quot;); (* quake has no integer denotation, so we cheat *)
    ELSE
      PushInt (t, res);
    END;
  END DoTextPos;

PROCEDURE <A NAME="DoTextContains"><procedure>DoTextContains</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    str, sub: QValue.T;
    res: BOOLEAN;
  BEGIN
    &lt;*ASSERT n_args = 2 *&gt;
    Pop (t, sub);
    Pop (t, str);
    res := TextUtils.Contains (QVal.ToText (t, str), QVal.ToText (t, sub));
    PushBool (t, res);
  END DoTextContains;

PROCEDURE <A NAME="DoTextBool"><procedure>DoTextBool</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    str: QValue.T;
    res: BOOLEAN;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, str);
    res := TextUtils.BoolVal (QVal.ToText (t, str));
    PushBool (t, res);
  END DoTextBool;

PROCEDURE <A NAME="DoTextEncode"><procedure>DoTextEncode</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    str: QValue.T;
    res: TEXT;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, str);
    res := TextConv.Encode (QVal.ToText (t, str));
    PushText (t, res);
  END DoTextEncode;

 PROCEDURE <A NAME="DoTextDecode"><procedure>DoTextDecode</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    str: QValue.T;
    val, res: TEXT;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, str);
    val := QVal.ToText (t, str);
    TRY
      res := TextConv.Decode (val);
    EXCEPT
      TextConv.Fail =&gt; Err (t, &quot;text decode failed for &quot; &amp; val);
    END;
    PushText (t, res);
  END DoTextDecode;

PROCEDURE <A NAME="DoTextSubstChars"><procedure>DoTextSubstChars</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    str, a, b: QValue.T;
    la, lb: INTEGER;
    sa, sb: TEXT;
    ta, tb: REF ARRAY OF CHAR;
    res: TEXT;
  BEGIN
    &lt;*ASSERT n_args = 3 *&gt;
    Pop (t, b);
    Pop (t, a);
    Pop (t, str);
    sa := QVal.ToText (t, a);
    sb := QVal.ToText (t, b);
    la := Text.Length (sa);
    lb := Text.Length (sb);
    &lt;*ASSERT la = lb *&gt;
    ta := NEW (REF ARRAY OF CHAR, la);
    tb := NEW (REF ARRAY OF CHAR, lb);
    TextClass.GetChars (sa, ta^, 0);
    TextClass.GetChars (sb, tb^, 0);
    res := TextUtils.SubstChars (QVal.ToText (t, str), ta^, tb^);
    PushText (t, res);
  END DoTextSubstChars;

PROCEDURE <A NAME="DoTextRemoveChars"><procedure>DoTextRemoveChars</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    str, a: QValue.T;
    aa: TEXT;
    set := ASCII.Set{};
    res: TEXT;
  BEGIN
    &lt;*ASSERT n_args = 2 *&gt;
    Pop (t, a);
    Pop (t, str);
    aa := QVal.ToText (t, a);
    FOR i := 0 TO Text.Length (aa) -1 DO
      set := set + ASCII.Set{Text.GetChar (aa, i)};
    END;
    res := TextUtils.RemoveChars (QVal.ToText (t, str), set);
    PushText (t, res);
  END DoTextRemoveChars;

PROCEDURE <A NAME="DoTextSubst"><procedure>DoTextSubst</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    str, a, b, n: QValue.T;
    res: TEXT;
  BEGIN
    &lt;*ASSERT n_args = 4 *&gt;
    Pop (t, n);
    Pop (t, b);
    Pop (t, a);
    Pop (t, str);
    res := TextUtils.Substitute (QVal.ToText (t, str), QVal.ToText (t, a),
                                 QVal.ToText (t, b), QVal.ToInt (t, n));
    PushText (t, res);
  END DoTextSubst;

PROCEDURE <A NAME="DoTextSubstEnv"><procedure>DoTextSubstEnv</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    str: QValue.T;
    res: TEXT;
  BEGIN
    &lt;*ASSERT n_args = 1 *&gt;
    Pop (t, str);
    res := TextUtils.SubstEnvVars (QVal.ToText (t, str));
    PushText (t, res);
  END DoTextSubstEnv;

PROCEDURE <A NAME="DoTextAddPrefix"><procedure>DoTextAddPrefix</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    arr, pre, res: QValue.T;
    qseq: QVSeq.T;
    seq: TextSeq.T := NEW (TextSeq.T).init();
  BEGIN
    &lt;*ASSERT n_args = 2 *&gt;
    Pop (t, pre);
    Pop (t, arr);
    qseq := QVal.ToArray (t, arr);
    FOR i := 0 TO qseq.size() - 1 DO
      seq.addhi (QVal.ToText (t, qseq.get (i)));
    END;
    seq := TextUtils.AddPrefix (seq, QVal.ToText (t, pre));
    res.kind := QK.Array;
    res.int  := 0;
    res.ref  := MakeQValSeq (t, seq);
    Push (t, res);
  END DoTextAddPrefix;

PROCEDURE <A NAME="DoTextAddSuffix"><procedure>DoTextAddSuffix</procedure></A> (t: T;  n_args: INTEGER) RAISES {Error} =
  VAR
    arr, pre, res: QValue.T;
    qseq: QVSeq.T;
    seq: TextSeq.T := NEW (TextSeq.T).init();
  BEGIN
    &lt;*ASSERT n_args = 2 *&gt;
    Pop (t, pre);
    Pop (t, arr);
    qseq := QVal.ToArray (t, arr);
    FOR i := 0 TO qseq.size() - 1 DO
      seq.addhi (QVal.ToText (t, qseq.get (i)));
    END;
    seq := TextUtils.AddSuffix (seq, QVal.ToText (t, pre));
    res.kind := QK.Array;
    res.int  := 0;
    res.ref  := MakeQValSeq (t, seq);
    Push (t, res);
  END DoTextAddSuffix;
</PRE>-------------------------------------------------------- memory buffers ---
 We don't use TRY/FINALLY or worry about buffers that aren't freed.
   In the rare cases when they're not returned, the collector get them. 

<P><PRE>PROCEDURE <A NAME="GetBuf"><procedure>GetBuf</procedure></A> (t: T): M3Buf.T =
  VAR buf: M3Buf.T;
  BEGIN
    IF (t.buffers.tos &gt; 0) THEN
      DEC (t.buffers.tos);
      WITH z = t.buffers.bufs [t.buffers.tos] DO  buf := z; z := NIL;  END;
    ELSE
      buf := M3Buf.New ();
    END;
    RETURN buf;
  END GetBuf;

PROCEDURE <A NAME="FreeBuf"><procedure>FreeBuf</procedure></A> (t: T;  buf: M3Buf.T) =
  BEGIN
    IF (t.buffers.tos &lt; NUMBER (t.buffers.bufs)) THEN
      t.buffers.bufs [t.buffers.tos] := buf;
      INC (t.buffers.tos);
    END;
  END FreeBuf;
</PRE>------------------------------------------------------------ temp files ---

<P><PRE>PROCEDURE <A NAME="CleanUp"><procedure>CleanUp</procedure></A> (t: T) =
  VAR n: INTEGER;  path: TEXT;
  BEGIN
    IF (t.tmp_files # NIL) THEN
      n := t.tmp_files.size ();
      WHILE (n &gt; 0) DO
        path := t.tmp_files.remlo ();
        TRY
          FS.DeleteFile (path);
        EXCEPT OSError.E =&gt;
          (* ignore *)
        END;
        DEC (n);
      END;
    END;
  END CleanUp;

PROCEDURE <A NAME="UniqueTempFile"><procedure>UniqueTempFile</procedure></A> (t: T): TEXT =
  VAR root, file: TEXT;  seq := 0;
  BEGIN
    root := Pathname.Join (t.tmp_dir, &quot;qk&quot;, NIL);
    file := root;
    LOOP
      TRY
        EVAL FS.Status (file);
      EXCEPT OSError.E =&gt;
        EXIT;
      END;
      INC (seq);
      file := root &amp; &quot;_&quot; &amp; Fmt.Int (seq);
    END;
    IF (t.tmp_files = NIL) THEN t.tmp_files := NEW (TextSeq.T).init(); END;
    t.tmp_files.addhi (file);
    RETURN file;
  END UniqueTempFile;
</PRE>------------------------------------------------------------------ misc ---

<P><PRE>PROCEDURE <A NAME="Err"><procedure>Err</procedure></A> (t: T;  msg: TEXT) RAISES {Error} =
  VAR buf := GetBuf (t);  txt: TEXT;  line: INTEGER;
  BEGIN
    IF FindErrorFile (t, txt, line) THEN
      M3Buf.PutText (buf, &quot;\&quot;&quot;);
      M3Buf.PutText (buf, txt);
      M3Buf.PutText (buf, &quot;\&quot;, line &quot;);
      M3Buf.PutInt  (buf, line);
      M3Buf.PutText (buf, &quot;: &quot;);
    END;
    M3Buf.PutText (buf, &quot;quake runtime error: &quot;);
    M3Buf.PutText (buf, msg);
    M3Buf.PutText (buf, Wr.EOL);
    M3Buf.PutText (buf, Wr.EOL);
    M3Buf.PutText (buf, &quot;--procedure--  -line-  -file---&quot;);
    M3Buf.PutText (buf, Wr.EOL);
    DumpFrame (t, buf, t.reg);
    FOR i := t.reg.fp-1 TO 0 BY -1 DO
      DumpFrame (t, buf, t.frames[i].saved);
    END;
    txt := M3Buf.ToText (buf);
    FreeBuf (t, buf);
    RAISE Error (txt);
  END Err;

PROCEDURE <A NAME="FindErrorFile"><procedure>FindErrorFile</procedure></A> (t: T;  VAR(*OUT*) file: TEXT;
                                VAR(*OUT*) line: INTEGER): BOOLEAN =
  BEGIN
    IF FindErrorFrame (t, t.reg, file, line) THEN RETURN TRUE; END;
    FOR i := t.reg.fp-1 TO 0 BY -1 DO
      IF FindErrorFrame (t, t.frames[i].saved, file, line) THEN RETURN TRUE; END;
    END;
    RETURN FALSE;
  END FindErrorFile;

PROCEDURE <A NAME="FindErrorFrame"><procedure>FindErrorFrame</procedure></A> (t    : T;
                 READONLY reg  : Registers;
               VAR(*OUT*) file : TEXT;
               VAR(*OUT*) line : INTEGER): BOOLEAN =
  BEGIN
    IF reg.cp = NIL THEN RETURN FALSE; END;
    (* else, we're executing in user-written quake code *)
    file := t.map.id2txt (reg.cp.source_file);
    line := MAX (1, reg.ln);
    RETURN TRUE;
  END FindErrorFrame;

PROCEDURE <A NAME="DumpFrame"><procedure>DumpFrame</procedure></A> (t: T;  buf: M3Buf.T;  READONLY reg: Registers) =
  BEGIN
    IF (reg.pi = NIL)
      THEN Out (buf, &quot;&quot;, 13);
      ELSE Out (buf, t.map.id2txt (reg.pi.name), 13);
    END;
    M3Buf.PutText (buf, &quot;  &quot;);
    IF (reg.ln &gt; 0)
      THEN Out (buf, Fmt.Int (reg.ln), -6);
      ELSE Out (buf, &quot;--&quot;, -6);
    END;
    M3Buf.PutText (buf, &quot;  &quot;);
    IF (reg.cp = NIL)
      THEN M3Buf.PutText (buf, &quot;&lt;builtin&gt;&quot;);
      ELSE M3Buf.PutText (buf, t.map.id2txt (reg.cp.source_file));
    END;
    M3Buf.PutText (buf, Wr.EOL);
  END DumpFrame;

PROCEDURE <A NAME="Out"><procedure>Out</procedure></A> (buf: M3Buf.T;  txt: TEXT;  width: INTEGER) =
  VAR len := Text.Length (txt);
  BEGIN
    IF (width &lt; 0) THEN
      width := -width;
      WHILE (len &lt; width) DO M3Buf.PutChar (buf, ' '); INC (len); END;
      M3Buf.PutText (buf, txt);
    ELSE
      M3Buf.PutText (buf, txt);
      WHILE (len &lt; width) DO M3Buf.PutChar (buf, ' '); INC (len); END;
    END;
  END Out;

PROCEDURE <A NAME="OSErr"><procedure>OSErr</procedure></A> (args: AtomList.T): TEXT =
  VAR msg : TEXT := NIL;
  BEGIN
    WHILE (args # NIL) DO
      IF (msg = NIL) THEN  msg := &quot;: &quot;;  ELSE  msg := msg &amp; &quot;  ***  &quot;;  END;
      msg  := msg &amp; Atom.ToText (args.head);
      args := args.tail;
    END;
    RETURN msg;
  END OSErr;

PROCEDURE <A NAME="CanonicalizePath"><procedure>CanonicalizePath</procedure></A> (path: Pathname.Arcs): Pathname.Arcs =
  (* Remove '..' and '.' components from &quot;path&quot;.
  See also cm3/M3Path.m3/PathRemoveDots. *)
  VAR found := FALSE;  arc: TEXT;  new: Pathname.Arcs;  pending: INTEGER;
  BEGIN
    FOR i := 0 TO path.size () - 1 DO
      arc := path.get (i);
      IF (arc # NIL) AND
        (PathEqual (arc, Pathname.Current)
          OR PathEqual (arc, Pathname.Parent)) THEN
        found := TRUE;
        EXIT;
      END;
    END;

    IF NOT found THEN RETURN path; END;

    new := NEW(Pathname.Arcs).init();
    pending := 0;
    FOR i := 0 TO path.size() - 1 DO
      arc := path.get(i);
      IF (arc = NIL) THEN
        new.addhi (arc);  (* leave the NIL arcs in place (?) *)
      ELSIF PathEqual(arc, Pathname.Current) THEN
        (* skip it *)
      ELSIF PathEqual(arc, Pathname.Parent) THEN
        INC(pending);
      ELSIF pending &gt; 0 THEN
        DEC(pending);
      ELSE
        new.addhi(arc);
      END;
    END;

    WHILE pending &gt; 0 DO new.addhi(Pathname.Parent); DEC(pending); END;
    RETURN new;
  END CanonicalizePath;

PROCEDURE <A NAME="StripPrefix"><procedure>StripPrefix</procedure></A> (t: T;  prefix, path: Pathname.Arcs): Pathname.Arcs
  RAISES {Error} =
  VAR
    path_sz, prefix_sz: INTEGER;
    path_txt, prefix_txt: TEXT;
    result: Pathname.Arcs;
  BEGIN
    TRY
      path_txt   := Pathname.Compose (path);
      prefix_txt := Pathname.Compose (prefix);
      path_sz    := path.size ();
      prefix_sz  := prefix.size ();

      IF PathEqual (path_txt, prefix_txt) THEN
        result := NEW (Pathname.Arcs).init (1);
        result.addhi (NIL);
        RETURN result;
      END;

      IF NOT Pathname.Absolute(path_txt)
      OR NOT Pathname.Absolute(prefix_txt) THEN
        RETURN path;
      END;
    EXCEPT Pathname.Invalid =&gt;
      Err (t, &quot;internal error: invalid pathname in StripPrefix&quot;);
    END;

    (* make sure &quot;prefix&quot; really is a prefix of &quot;path&quot; *)
    IF (prefix_sz &gt; path_sz) THEN RETURN path; END;
    FOR i := 0 TO prefix_sz - 1 DO
      IF NOT PathEqual (prefix.get(i), path.get(i)) THEN
        RETURN path;
      END;
    END;

    result := TextSeq.Sub (path, prefix_sz);
    result.addlo (NIL);  (* make it a relative path *)
    RETURN result;
  END StripPrefix;

PROCEDURE <A NAME="PathEqual"><procedure>PathEqual</procedure></A> (a, b: TEXT): BOOLEAN =
  VAR len: CARDINAL;
  BEGIN
    len := Text.Length (a);
    IF len # Text.Length (b) THEN
      RETURN FALSE;
    END;
    IF Text.Equal (a, b) THEN RETURN TRUE; END;
    IF OnUnix THEN RETURN FALSE; END;
    RETURN CIEqual (a, b, len);
  END PathEqual;

PROCEDURE <A NAME="CIEqual"><procedure>CIEqual</procedure></A> (a, b: TEXT; len: CARDINAL): BOOLEAN =
  (* on Win32, try a case-insensitive match.
  already known:
    Text.Length (a) = len
    Text.Length (b) = len
    NOT Text.Equal (a, b) *)
  VAR nxt: CARDINAL;  buf_a, buf_b: ARRAY [0..127] OF CHAR;
      cha, chb: CHAR;
  BEGIN
    len := Text.Length (a);
    IF (len # Text.Length (b)) THEN RETURN FALSE; END;
    nxt := 0;
    WHILE (nxt &lt; len) DO
      Text.SetChars (buf_a, a, nxt);
      Text.SetChars (buf_b, b, nxt);
      FOR i := 0 TO MIN (NUMBER (buf_a), len-nxt) - 1 DO
        cha := buf_a[i];
        chb := buf_b[i];
        IF (cha # chb) AND (ASCII.Lower[cha] # ASCII.Lower[chb]) THEN
          RETURN FALSE;
        END;
      END;
      INC (nxt, NUMBER (buf_a));
    END;
    RETURN TRUE;
  END CIEqual;

PROCEDURE <A NAME="SplitArgs"><procedure>SplitArgs</procedure></A> (txt: TEXT): TextSeq.T =
  VAR
    seq   := NEW (TextSeq.T).init ();
    i     := 0;
    len   := Text.Length (txt);
    start : INTEGER;
  BEGIN
    WHILE i &lt; len DO
      WHILE i &lt; len AND QScanner.WhiteSpace [Text.GetChar (txt, i)] DO INC(i); END;
      start := i;
      WHILE i &lt; len AND NOT QScanner.WhiteSpace [Text.GetChar (txt, i)] DO INC(i); END;
      IF i &gt; start THEN seq.addhi (Text.Sub (txt, start, i - start)); END;
    END;
    RETURN seq;
  END SplitArgs;

PROCEDURE <A NAME="Print"><procedure>Print</procedure></A> (a, b, c, d: TEXT := NIL)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR wr := Stdio.stdout;
  BEGIN
    IF (wr = NIL) THEN (*try...*) wr := Stdio.stderr; END;
    IF (a # NIL) THEN Wr.PutText (wr, a); END;
    IF (b # NIL) THEN Wr.PutText (wr, b); END;
    IF (c # NIL) THEN Wr.PutText (wr, c); END;
    IF (d # NIL) THEN Wr.PutText (wr, d); END;
  END Print;

PROCEDURE <A NAME="FlushIO"><procedure>FlushIO</procedure></A> ()
  RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    IF (Stdio.stdout # NIL) THEN Wr.Flush (Stdio.stdout); END;
    IF (Stdio.stderr # NIL) THEN Wr.Flush (Stdio.stderr); END;
  END FlushIO;

VAR
  strict_variables := NOT RTParams.IsPresent (&quot;oldquake&quot;);
BEGIN
END QMachine.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface M3ID is in:
</A><UL>
<LI><A HREF="../../m3middle/src/M3ID.i3.html#0TOP0">m3middle/src/M3ID.i3</A>
<LI><A HREF="../../m3scan/src/M3ID.i3.html#0TOP0">m3scan/src/M3ID.i3</A>
</UL>
<P>
<HR>
<A NAME="x2">interface TextUtils is in:
</A><UL>
<LI><A HREF="../../cit_util/src/TextUtils.i3.html#0TOP0">cit_util/src/TextUtils.i3</A>
<LI><A HREF="../../sysutils/src/TextUtils.i3.html#0TOP0">sysutils/src/TextUtils.i3</A>
</UL>
<P>
<HR>
<A NAME="x3">interface M3Path is in:
</A><UL>
<LI><A HREF="../../cm3/src/M3Path.i3.html#0TOP0">cm3/src/M3Path.i3</A>
<LI><A HREF="M3Path.i3.html#0TOP0">m3quake/src/M3Path.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
