<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: kext/derived/ExtFormBundle.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>kext/derived/ExtFormBundle.m3</H2></A><HR>
<inModule>
<PRE>MODULE <module><implements><A HREF="ExtFormBundle.i3.html">ExtFormBundle</A></implements></module>;
</PRE><BLOCKQUOTE><EM> Generated by m3bundle; see its manpage. </EM></BLOCKQUOTE><PRE>

IMPORT <A HREF="../../libm3/src/bundleintf/Bundle.i3.html">Bundle</A>, <A HREF="../../libm3/src/bundleintf/BundleRep.i3.html">BundleRep</A>, <A HREF="../../m3core/src/text/Text.i3.html">Text</A>;

TYPE T = Bundle.T OBJECT OVERRIDES
           get      := LookUp;
           getNames := GetNames;
         END;

TYPE Texts = REF ARRAY OF TEXT;

VAR
  bundle: T     := NIL;
  names : Texts := NIL;

PROCEDURE <A NAME="Get"><procedure>Get</procedure></A>(): Bundle.T =
  BEGIN
    IF (bundle = NIL) THEN bundle := NEW (T) END;
    RETURN bundle;
  END Get;

PROCEDURE <A NAME="GetNames"><procedure>GetNames</procedure></A> (&lt;*UNUSED*&gt; self: T): Texts =
  BEGIN
    IF names = NIL THEN
      names := NEW (Texts, NUMBER (Names));
      names^ := Names;
    END;
    RETURN names;
  END GetNames;

PROCEDURE <A NAME="LookUp"><procedure>LookUp</procedure></A> (&lt;*UNUSED*&gt; self: T;  element: TEXT): TEXT =
  BEGIN
    FOR i := 0 TO LAST (Names)-1 DO
      IF Text.Equal (Names[i], element) THEN
        RETURN Elements[i];
      END;
    END;
    RETURN NIL;
  END LookUp;

CONST Names = ARRAY [0..4] OF TEXT {
  &quot;extform.tokimport.i3&quot;,
  &quot;extform.t.m3&quot;,
  &quot;extform.y.m3&quot;,
  &quot;extform.l.m3&quot;,
  NIL
};

CONST Elements = ARRAY [0..4] OF TEXT {
  E0,
  E1,
  E2,
  E3,
  NIL
};

CONST E0 =
   &quot;\n  (* Make this interface as good as any token interface *)\n  Token =&quot;
 &amp; &quot; %tok.Token;\n  ConstToken = %tok.ConstToken;\n  ParseType = %tok.Parse&quot;
 &amp; &quot;Type;\n  Allocator = %tok.Allocator;\n  Lexer = %tok.Lexer;\n  RdLexer &quot;
 &amp; &quot;= %tok.RdLexer;\nCONST\n  NewPT = %tok.NewPT;\n  Purge = %tok.Purge;\n &quot;
 &amp; &quot; NewConstToken = %tok.NewConstToken;\n&quot;;

CONST E1 =
   &quot;%interface %module\n~\\\nINTERFACE %name;\n%gen\n(* extended token defi&quot;
 &amp; &quot;nition *)\n%import\\\n%interface\\\nTYPE\n%gnTypes\\\n%tkimp\\\nEND %na&quot;
 &amp; &quot;me.\n~\\\n(* procedure format *)\n~\\\nMODULE %name;\n%gen\n%module\\\n&quot;
 &amp; &quot;BEGIN\nEND %name.\n&quot;;

CONST E2 =
   &quot;%interface %module %public %private %overrides\n~\\\nINTERFACE %name;\n&quot;
 &amp; &quot;%gen\n(* extended parser definition *)\n%import\\\n%interface\\\nTYPE\n&quot;
 &amp; &quot;%gnTypes\\\n\n  T &lt;: Public;\n  Public = %meth.T OBJECT\n%public\\\n  E&quot;
 &amp; &quot;ND;\n\n  (* And now, for a hack to allow compatible methods *)\n  (* ..&quot;
 &amp; &quot;. without importing the original parser *)\n  Original_Parser = %meth.O&quot;
 &amp; &quot;riginal_Parser;\n%orig\\\n  (* ... and without importing the original t&quot;
 &amp; &quot;oken *)\n%tokOrig\\\n%tkimp\\\nEND %name.\n~\\\\\nPROCEDURE Proc_%name(&quot;
 &amp; &quot;self: T;\n VAR p0: Original_%return%oparams) =\n  VAR\n    result: %ret&quot;
 &amp; &quot;urn;\n%narrow\\\\\n  BEGIN\n    IF p0 = NIL THEN\n      p0 := NewPT(sel&quot;
 &amp; &quot;f.allocate_%return, TYPECODE(%return));\n    END;\n    result := NARROW&quot;
 &amp; &quot;(p0, %return);(*%TYPEINIT%%return%*)\n    %yaccName.T.%name(self, p0%cp&quot;
 &amp; &quot;arams);\n    result := NARROW(p0, %return);\n    BEGIN (* user code *)\n&quot;
 &amp; &quot;      %body\n    END;\n    p0 := result;\n  END Proc_%name;\n\n~\\\nMOD&quot;
 &amp; &quot;ULE %name;\n%gen\nIMPORT %meth;\n%module\\\n\nREVEAL\n  T = Public BRAN&quot;
 &amp; &quot;DED \&quot;%name\&quot; OBJECT\n%alloc\\\n%private\\\n  OVERRIDES\n    purge := P&quot;
 &amp; &quot;roc_Purge;\n%overrides\\\n%ovr\\\n  END;\n\nPROCEDURE Proc_Purge(self: &quot;
 &amp; &quot;T): INTEGER =\n  BEGIN\n    RETURN %meth.T.purge(self)%purge;\n  END Pr&quot;
 &amp; &quot;oc_Purge;\n\n(* rule procedures *)\n%gnProcs\\\nBEGIN\nEND %name.\n&quot;;

CONST E3 =
   &quot;%interface %module %public %private %overrides\n~\\\nINTERFACE %name;\n&quot;
 &amp; &quot;%gen\n(* extended lexer definition *)\n%import\\\n%interface\\\nTYPE\n%&quot;
 &amp; &quot;gnTypes\\\n\n  T &lt;: Public;\n  Public = %meth.T OBJECT\n%public\\\n  EN&quot;
 &amp; &quot;D;\n%tkimp\\\nEND %name.\n~\\\nPROCEDURE Proc_%name(self: T): Token =\n&quot;
 &amp; &quot;  BEGIN (* user code *)\n   %body\n  END Proc_%name;\n\n~\\\nMODULE %na&quot;
 &amp; &quot;me;\n%gen\nIMPORT %meth;\n%module\\\n\nREVEAL\n  T = Public BRANDED \&quot;%&quot;
 &amp; &quot;name\&quot; OBJECT\n%alloc\\\n%private\\\n  OVERRIDES\n    purge := Proc_Pur&quot;
 &amp; &quot;ge;\n%overrides\\\n%ovr\\\n  END;\n\nPROCEDURE Proc_Purge(self: T): INT&quot;
 &amp; &quot;EGER =\n  BEGIN\n    RETURN %meth.T.purge(self)%purge;\n  END Proc_Purg&quot;
 &amp; &quot;e;\n\n(* expression procedures *)\n%gnProcs\\\nBEGIN\nEND %name.\n&quot;;

BEGIN
END ExtFormBundle.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
