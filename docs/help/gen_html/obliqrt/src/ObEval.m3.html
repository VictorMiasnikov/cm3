<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: obliqrt/src/ObEval.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>obliqrt/src/ObEval.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright 1991 Digital Equipment Corporation. 
 Distributed only by permission. 

<P><PRE>MODULE <module><implements><A HREF="ObEval.i3.html">ObEval</A></implements></module>;
IMPORT <A HREF="../../m3core/src/text/Text.i3.html">Text</A>, <A HREF="../../synloc/src/SynLocation.i3.html">SynLocation</A>, <A HREF="ObTree.i3.html">ObTree</A>, <A HREF="ObValue.i3.html">ObValue</A>, <A HREF="ObLib.i3.html">ObLib</A>, <A HREF="ObBuiltIn.i3.html">ObBuiltIn</A>, <A HREF="../../netobj/src/netobjrt/NetObj.i3.html">NetObj</A>,
       <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../sharedobj/src/SharedObj.i3.html">SharedObj</A>;

PROCEDURE <A NAME="Setup"><procedure>Setup</procedure></A> () =
  BEGIN
  END Setup;

PROCEDURE <A NAME="LookupIde"><procedure>LookupIde</procedure></A> (name  : ObTree.IdeName;
                     place : ObTree.IdePlace;
                     lValue: BOOLEAN;
                     env   : ObValue.Env;
                     glob  : ObValue.GlobalEnv;
                     loc   : SynLocation.T      ): ObValue.Val
  RAISES {ObValue.Exception} =
  VAR
    i  : INTEGER;
    val: ObValue.Val;
  BEGIN
    TYPECASE place OF
    | ObTree.IdePlaceGlobal (node) =&gt; val := glob^[node.index - 1];
    | ObTree.IdePlaceLocal (node) =&gt;
        i := node.index;
        LOOP
          (* IF i&lt;0 THEN ObErr.Fault(&quot;Eval.LookupIde&quot;) END; *)
          TYPECASE env OF
            (*
            | NULL =&gt;
                ObErr.Fault(&quot;Eval.LookupIde: Unbound var: &quot;
                  &amp; ObTree.FmtIde(name, place, NIL));
            *)
          | ObValue.LocalEnv (node) =&gt;
              IF i = 1 THEN
                (*
                IF NOT ObTree.SameIdeName(name, node.name) THEN
                      ObErr.Fault(&quot;Eval.LookupIde&quot;);
                END;
                *)
                val := node.val;
                EXIT;
              ELSE
                DEC(i);
                env := node.rest;
              END;
          ELSE                   &lt;*ASSERT FALSE*&gt;
          END;
        END;
    ELSE                         &lt;*ASSERT FALSE*&gt;
    END;
    IF lValue THEN
      RETURN val;
    ELSE
      TYPECASE val OF
      | ObValue.ValVar (node) =&gt;
          TRY
            RETURN node.remote.Get();
          EXCEPT
          | NetObj.Error (atoms) =&gt;
              ObValue.RaiseNetException(&quot;on remote access to variable '&quot;
                                          &amp; name.text &amp; &quot;'&quot;, atoms, loc);
            &lt;*ASSERT FALSE*&gt;
          | Thread.Alerted =&gt;
              ObValue.RaiseException(
                ObValue.threadAlerted,
                &quot;on remote access to variable '&quot; &amp; name.text &amp; &quot;'&quot;, loc);
            &lt;*ASSERT FALSE*&gt;
          END;
      ELSE
        RETURN val;
      END;
    END;
  END LookupIde;

PROCEDURE <A NAME="TermBindingSeq"><procedure>TermBindingSeq</procedure></A> (binding     : ObTree.TermBinding;
                          var         : BOOLEAN;
                          initEnv, env: ObValue.Env;
                          glob        : ObValue.GlobalEnv;
                          mySelf      : ObValue.ValObj      ): ObValue.Env
  RAISES {ObValue.Error, ObValue.Exception} =
  VAR
    val : ObValue.Val;
    env1: ObValue.Env;
  BEGIN
    TYPECASE binding OF
    | NULL =&gt; RETURN env;
    | ObTree.TermBinding (node) =&gt;
        env1 := initEnv;
        val := Term(node.term, (*in-out*) env1, glob, mySelf);
        IF var THEN val := ObValue.NewVar(val) END;
        RETURN TermBindingSeq(node.rest, var, initEnv,
                              NEW(ObValue.LocalEnv, name := node.binder,
                                  val := val, rest := env), glob, mySelf);
    END;
  END TermBindingSeq;

PROCEDURE <A NAME="TermBindingRec"><procedure>TermBindingRec</procedure></A> (binding: ObTree.TermBinding;
                          var    : BOOLEAN;
                          env    : ObValue.LocalEnv;
                          glob   : ObValue.GlobalEnv;
                          mySelf : ObValue.ValObj      ): ObValue.Env
  RAISES {ObValue.Error, ObValue.Exception} =
  (* Executes definitions backwards, but it's ok since they are all
     functions. *)
  VAR
    val            : ObValue.Val;
    dumFun         : ObValue.ValFun;
    recEnv, recEnv1: ObValue.Env;
  BEGIN
    TYPECASE binding OF
    | NULL =&gt; RETURN env;
    | ObTree.TermBinding (node) =&gt;
        dumFun := NEW(ObValue.ValFun, fun := NIL, global := NIL);
        IF var THEN val := ObValue.NewVar(dumFun); ELSE val := dumFun; END;
        recEnv :=
          TermBindingRec(
            node.rest, var, NEW(ObValue.LocalEnv, name := node.binder,
                                val := val, rest := env), glob, mySelf);
        recEnv1 := recEnv;
        TYPECASE Term(node.term, (*in-out*) recEnv1, glob, mySelf) OF
        | ObValue.ValFun (valFun) =&gt;
            dumFun.fun := valFun.fun;
            dumFun.global := valFun.global;
        ELSE
          ObValue.RaiseError(
            &quot;Recursive definition of a non-function&quot;, binding.location);
        END;
        RETURN recEnv;
    END;
  END TermBindingRec;

PROCEDURE <A NAME="Term"><procedure>Term</procedure></A> (               term  : ObTree.Term;
                VAR (*in-out*) env   : ObValue.Env;
                               glob  : ObValue.GlobalEnv;
                               mySelf: ObValue.ValObj     ): ObValue.Val
  RAISES {ObValue.Error, ObValue.Exception} =
  TYPE Vals = REF ARRAY OF ObValue.Val;
  VAR result: ObValue.Val;
  BEGIN
    IF interrupt THEN
      interrupt := FALSE;
      ObValue.RaiseError(&quot;Interrupt&quot;, term.location);
    END;
    TYPECASE term OF
      (* | NULL =&gt; ObErr.Fault(&quot;Eval.Term NIL&quot;); *)
    | ObTree.TermIde (node) =&gt;
        result :=
          LookupIde(node.name, node.place, FALSE, env, glob, term.location);
    | ObTree.TermOk =&gt; result := ObValue.valOk;
    | ObTree.TermBool (node) =&gt;
        IF node.cache = NIL THEN
          node.cache := NEW(ObValue.ValBool, bool := node.bool);
        END;
        result := node.cache;
    | ObTree.TermChar (node) =&gt;
        IF node.cache = NIL THEN
          node.cache := NEW(ObValue.ValChar, char := node.char);
        END;
        result := node.cache;
    | ObTree.TermText (node) =&gt;
        IF node.cache = NIL THEN
          node.cache := ObValue.NewText(node.text);
        END;
        result := node.cache;
    | ObTree.TermInt (node) =&gt;
        IF node.cache = NIL THEN
          node.cache :=
            NEW(ObValue.ValInt, int := node.int, temp := FALSE);
        END;
        result := node.cache;
    | ObTree.TermReal (node) =&gt;
        IF node.cache = NIL THEN
          node.cache :=
            NEW(ObValue.ValReal, real := node.real, temp := FALSE);
        END;
        result := node.cache;
    | ObTree.TermOption (node) =&gt;
        VAR env1: ObValue.Env;
        BEGIN
          env1 := env;
          result :=
            NEW(ObValue.ValOption, tag := node.tag.text,
                val := Term(node.term, (*in-out*) env1, glob, mySelf));
        END;
    | ObTree.TermAlias (node) =&gt;
        VAR
          env1: ObValue.Env;
          val : ObValue.Val;
        BEGIN
          env1 := env;
          val := Term(node.term, (*in-out*) env1, glob, mySelf);
          TYPECASE val OF
          | ObValue.ValObj (obj) =&gt;
              result :=
                ObValue.NewAlias(obj, node.label.text, term.location);
          ELSE
            ObValue.RaiseError(
              &quot;Aliasing must operate on an object&quot;, term.location);
          END;
        END;
    | ObTree.TermArray (node) =&gt;
        VAR
          vals                 := NEW(Vals, node.elemsNo);
          argList              := node.elems;
          env1   : ObValue.Env;
        BEGIN
          FOR i := 0 TO node.elemsNo - 1 DO
            env1 := env;
            vals[i] := Term(argList.first, (*in-out*) env1, glob, mySelf);
            argList := argList.rest;
          END;
          result := ObValue.NewArrayFromVals(vals);
        END;
    | ObTree.TermOp (node) =&gt;
        VAR
          argList                    := node.args;
          opCode                     := NARROW(node.opCode, ObLib.OpCode);
          argArray: ObValue.ArgArray;
          env1    : ObValue.Env;
          msg     : TEXT;
        BEGIN
          IF (opCode.arity &gt;= -1) AND (node.argsNo # opCode.arity) THEN
            IF opCode.arity = -1 THEN
              msg := &quot;Not expecting an argument list for procedure: &quot;
                       &amp; node.pkg.text &amp; &quot;_&quot; &amp; node.op.text;
            ELSIF node.argsNo = -1 THEN
              msg := &quot;Expecting an argument list for procedure: &quot;
                       &amp; node.pkg.text &amp; &quot;_&quot; &amp; node.op.text;
            ELSE
              msg := ObValue.BadArgsNoMsg(
                       opCode.arity, node.argsNo, &quot;procedure&quot;,
                       node.pkg.text &amp; &quot;_&quot; &amp; node.op.text);
            END;
            ObValue.RaiseError(msg, term.location);
          END;
          IF node.argsNo &gt; NUMBER(argArray) THEN
            ObValue.RaiseError(&quot;Too many arguments&quot;, term.location);
          END;
          FOR i := 1 TO node.argsNo DO
            env1 := env;
            argArray[i] :=
              Term(argList.first, (*in-out*) env1, glob, mySelf);
            argList := argList.rest;
          END;
          result :=
            NARROW(node.package, ObLib.T).Eval(
              opCode, node.argsNo, argArray, node.temp, term.location);
        END;
    | ObTree.TermFun (node) =&gt;
        VAR
          newGlob := NEW(ObValue.GlobalEnv, node.globalsNo);
          globals := node.globals;
        BEGIN
          FOR i := 0 TO node.globalsNo - 1 DO
            newGlob^[i] := LookupIde(globals.name, globals.place, TRUE,
                                     env, glob, term.location);
            globals := globals.rest;
          END;
          result := NEW(ObValue.ValFun, fun := node, global := newGlob);
        END;
    | ObTree.TermMeth (node) =&gt;
        VAR
          newGlob := NEW(ObValue.GlobalEnv, node.globalsNo);
          globals := node.globals;
        BEGIN
          FOR i := 0 TO node.globalsNo - 1 DO
            newGlob^[i] := LookupIde(globals.name, globals.place, TRUE,
                                     env, glob, term.location);
            globals := globals.rest;
          END;
          result := NEW(ObValue.ValMeth, meth := node, global := newGlob);
        END;
    | ObTree.TermAppl (node) =&gt;
        VAR
          env1, newEnv: ObValue.Env;
          newGlob     : ObValue.GlobalEnv;
          binderList  : ObTree.IdeList;
          argList     : ObTree.TermList;
          val         : ObValue.Val;
        BEGIN
          env1 := env;
          TYPECASE Term(node.fun, (*in-out*) env1, glob, mySelf) OF
          | ObValue.ValFun (clos) =&gt;
              IF node.argsNo # clos.fun.bindersNo THEN
                ObValue.RaiseError(ObValue.BadArgsNoMsg(
                                     clos.fun.bindersNo, node.argsNo, &quot;&quot;,
                                     &quot;&quot;), term.location);
              END;
              newGlob := clos.global;
              newEnv := NIL;
              binderList := clos.fun.binders;
              argList := node.args;
              FOR i := 1 TO node.argsNo DO
                env1 := env;
                newEnv := NEW(ObValue.LocalEnv, name := binderList.first,
                              val := Term(argList.first, (*in-out*) env1,
                                          glob, mySelf), rest := newEnv);
                binderList := binderList.rest;
                argList := argList.rest;
              END;
              result :=
                Term(clos.fun.body, (*in-out*) newEnv, newGlob, mySelf);
          | ObValue.ValEngine (engine) =&gt;
              IF node.argsNo # 1 THEN
                ObValue.RaiseError(
                  ObValue.BadArgsNoMsg(1, node.argsNo, &quot;&quot;, &quot;&quot;),
                  term.location);
              END;
              env1 := env;
              val := Term(node.args.first, (*in-out*) env1, glob, mySelf);
              TRY
                result := engine.remote.Eval(val, mySelf);
              EXCEPT
              | ObValue.ServerError (msg) =&gt;
                  ObValue.RaiseError(msg, term.location);
              | NetObj.Error (atoms) =&gt;
                  ObValue.RaiseNetException(
                    &quot;on remote engine execution&quot;, atoms, term.location);
              | Thread.Alerted =&gt;
                  ObValue.RaiseException(
                    ObValue.threadAlerted, &quot;on remote engine execution&quot;,
                    term.location);
              END;
          ELSE
            ObValue.RaiseError(
              &quot;Application of a non-procedure&quot;, term.location);
          END;
        END;
    | ObTree.TermObj (node) =&gt;
        VAR
          sync: ObValue.Sync;
          fields    := NEW(REF ObValue.ObjFields, node.fieldsNo);
          fieldList := node.fields;
          env1: ObValue.Env;
        BEGIN
          CASE node.sync OF
          | ObTree.Sync.None =&gt; sync := NIL;
          | ObTree.Sync.Monitored =&gt;
              sync := NEW(ObValue.Sync, mutex := NEW(Thread.Mutex));
          ELSE                   &lt;*ASSERT FALSE*&gt;
          END;
          FOR i := 0 TO node.fieldsNo - 1 DO
            env1 := env;
            fields^[i].label := fieldList.label.text;
            fields^[i].field :=
              Term(fieldList.term, (*in-out*) env1, glob, mySelf);
            TYPECASE fieldList.term OF
            | ObTree.TermMeth (meth) =&gt;
              IF meth.update THEN fields^[i].update := TRUE END;
            ELSE END;
            fieldList := fieldList.rest;
          END;

          CASE node.semantics OF
          | ObTree.SharingSemantics.Remote =&gt;
            result :=
                ObValue.NewObjectFromFields(fields, &quot;&quot;, node.protected,
                                            sync);
          | ObTree.SharingSemantics.Replicated =&gt;
            IF sync # NIL THEN
              ObValue.RaiseError(
                  &quot;serialized implied by replicated&quot;, term.location);
            END;
            TRY
              result :=
                  ObValue.NewReplObjectFromFields(fields, &quot;&quot;, node.protected);
            EXCEPT
            | SharedObj.Error (atoms) =&gt;
              ObValue.RaiseSharedException(
                  &quot;on replicated object creation&quot;, atoms, term.location);
            END;
          | ObTree.SharingSemantics.Simple =&gt;
            result :=
                ObValue.NewSimpleObjectFromFields(fields, &quot;&quot;, node.protected,
                                                  sync);
          END;
        END;
    | ObTree.TermClone (node) =&gt;
        VAR
          env1   : ObValue.Env;
          objs   : ObTree.TermList;
          valObjs: REF ARRAY OF ObValue.ValObj;
        BEGIN
          TRY
            IF node.objsNo = 1 THEN
              env1 := env;
              TYPECASE Term(node.objs.first,
                            (*in-out*) env1, glob, mySelf) OF
              | ObValue.ValObj (obj) =&gt;
                result := ObValue.ObjClone1(obj, mySelf);
              ELSE
                ObValue.RaiseError(
                  &quot;Arguments of clone must be objects&quot;, term.location);
              END;
            ELSE
              objs := node.objs;
              valObjs := NEW(REF ARRAY OF ObValue.ValObj, node.objsNo);
              FOR i := 0 TO node.objsNo - 1 DO
                env1 := env;
                TYPECASE Term(objs.first, (*in-out*) env1, glob, mySelf) OF
                | ObValue.ValObj (obj) =&gt; valObjs^[i] := obj;
                ELSE
                  ObValue.RaiseError(
                    &quot;Arguments of clone must be objects&quot;, term.location);
                END;
                objs := objs.rest;
              END;
              result :=
                ObValue.ObjClone( (*readonly*)valObjs^, mySelf);
            END;
          EXCEPT
          | ObValue.ServerError (msg) =&gt;
            ObValue.RaiseError(msg, term.location);
          | SharedObj.Error (atoms) =&gt;
            ObValue.RaiseSharedException(
                &quot;on replicated object cloning&quot;, atoms, term.location);
          | NetObj.Error (atoms) =&gt;
            ObValue.RaiseNetException(
                &quot;on remote object cloning&quot;, atoms, term.location);
          | Thread.Alerted =&gt;
            ObValue.RaiseException(
                ObValue.threadAlerted, &quot;on remote object cloning&quot;,
                term.location);
          END;
        END;
    | ObTree.TermNotify (node) =&gt;
        VAR
          env1   : ObValue.Env;
          val1   : ObValue.Val;
        BEGIN
          env1 := env;
          TYPECASE Term(node.withObj, (*in-out*) env1, glob, mySelf) OF
          | ObValue.ValFun (fun) =&gt;
            env1 := env;
            val1 := Term(node.obj, (*in-out*) env1, glob, mySelf);
            TYPECASE val1 OF
            | ObValue.ValObj, ObValue.ValVar, ObValue.ValArray,
              ObValue.ValEngine, ObValue.ValFileSystem =&gt;
              ObValue.ObjNotify(val1, fun);
            ELSE
              ObValue.RaiseError(
                  &quot;First argument of notify must be a remote data object&quot;,
                  term.location);
            END;
          ELSE
            ObValue.RaiseError(
                &quot;Second argument of notify must be a procedure&quot;,
                term.location);
          END;
          result := ObValue.valOk;
        END;
    | ObTree.TermPickler (node) =&gt;
        VAR
          env1   : ObValue.Env;
        BEGIN
          env1 := env;
          TYPECASE Term(node.pklIn, (*in-out*) env1, glob, mySelf) OF
          | ObValue.ValSimpleObj (in) =&gt;
            env1 := env;
            TYPECASE Term(node.pklOut, (*in-out*) env1, glob, mySelf) OF
            | ObValue.ValSimpleObj (out) =&gt;
              env1 := env;
              TYPECASE Term(node.obj, (*in-out*) env1, glob, mySelf) OF
              | ObValue.ValObj(valobj) =&gt;
                TRY
                  ObValue.SetObjPickler(valobj, in, out, mySelf);
                EXCEPT
                | ObValue.ServerError (msg) =&gt;
                  ObValue.RaiseError(msg, term.location);
                | SharedObj.Error (atoms) =&gt;
                  ObValue.RaiseSharedException(&quot;while setting pickler&quot;, atoms,
                                               term.location);
                | NetObj.Error (atoms) =&gt;
                  ObValue.RaiseNetException(&quot;while setting pickler&quot;, atoms,
                                            term.location);
                | Thread.Alerted =&gt;
                  ObValue.RaiseException(ObValue.threadAlerted,
                                         &quot;while setting pickler&quot;,
                                         term.location);
                END;
              ELSE
                ObValue.RaiseError(
                    &quot;First argument of registerPickler must be an object&quot;,
                    term.location);
              END;
            ELSE
              ObValue.RaiseError(
                  &quot;Second argument of registerPickler must be a simple object&quot;,
                  term.location);
          END;
          ELSE
            ObValue.RaiseError(
                &quot;Third argument of registerPickler must be a simple object&quot;,
                term.location);
          END;
          result := ObValue.valOk;
        END;
    | ObTree.TermReplicate (node) =&gt;
        VAR
          env1 : ObValue.Env;
          array1: Vals;
          arr: REF ARRAY OF TEXT;
        BEGIN
          IF node.argsNo # 2 THEN
            ObValue.RaiseError(ObValue.BadArgsNoMsg(2, node.argsNo, &quot;&quot;, &quot;&quot;),
                               term.location);
          END;
          env1 := env;
          TYPECASE Term(node.args.first, (*in-out*) env1, glob, mySelf) OF
          | ObValue.ValObj (obj) =&gt;
            env1 := env;
            TYPECASE Term(node.args.rest.first,
                          (*in-out*) env1, glob, mySelf) OF
            | ObValue.ValArray (arrayObj) =&gt;
              TRY
                array1 := arrayObj.remote.Obtain();
                arr := NEW(REF ARRAY OF TEXT, NUMBER(array1^));
                FOR i := 0 TO NUMBER(array1^)-1 DO
                  TYPECASE array1^[i] OF
                  | ObValue.ValText (txt) =&gt; arr[i] := txt.text;
                  ELSE
                    ObValue.RaiseError(
                        &quot;second argument must be array of text&quot;,
                        term.location);
                  END;
                END;
                result := ObValue.ToReplObj(obj, mySelf, arr^);
              EXCEPT
              | ObValue.ServerError (msg) =&gt;
                  ObValue.RaiseError(msg, term.location);
              | SharedObj.Error (atoms) =&gt;
                  ObValue.RaiseSharedException(
                    &quot;on conversion to replicated object&quot;, atoms,
                    term.location);
              | NetObj.Error (atoms) =&gt;
                  ObValue.RaiseNetException(
                    &quot;on conversion to replicated object&quot;, atoms,
                    term.location);
              | Thread.Alerted =&gt;
                  ObValue.RaiseException(
                    ObValue.threadAlerted,
                    &quot;on conversion to replicated object&quot;,
                    term.location);
              END;
            ELSE
              ObValue.RaiseError(
                  &quot;second argument must be array of text&quot;, term.location);
            END;
          ELSE
            ObValue.RaiseError(
              &quot;Redirection must operate on an object&quot;, term.location);
          END;
        END;
    | ObTree.TermRemote (node) =&gt;
        VAR
          env1 : ObValue.Env;
        BEGIN
          env1 := env;
          TYPECASE Term(node.obj, (*in-out*) env1, glob, mySelf) OF
          | ObValue.ValObj (obj) =&gt;
            TRY
              result := ObValue.ToRemObj(obj, mySelf);
            EXCEPT
            | ObValue.ServerError (msg) =&gt;
              ObValue.RaiseError(msg, term.location);
            | SharedObj.Error (atoms) =&gt;
              ObValue.RaiseSharedException(
                  &quot;on conversion to remote object&quot;, atoms,
                  term.location);
            | NetObj.Error (atoms) =&gt;
              ObValue.RaiseNetException(
                  &quot;on conversion to remote object&quot;, atoms,
                  term.location);
            | Thread.Alerted =&gt;
              ObValue.RaiseException(
                  ObValue.threadAlerted,
                  &quot;on conversion to remote object&quot;,
                  term.location);
            END;
          ELSE
            ObValue.RaiseError(
              &quot;remote must operate on an object&quot;, term.location);
          END;
        END;
    | ObTree.TermSimple (node) =&gt;
        VAR
          env1 : ObValue.Env;
        BEGIN
          env1 := env;
          TYPECASE Term(node.obj, (*in-out*) env1, glob, mySelf) OF
          | ObValue.ValObj (obj) =&gt;
            TRY
              result := ObValue.ToSimpleObj(obj, mySelf);
            EXCEPT
            | ObValue.ServerError (msg) =&gt;
              ObValue.RaiseError(msg, term.location);
            | SharedObj.Error (atoms) =&gt;
              ObValue.RaiseSharedException(
                  &quot;on conversion to simple object&quot;, atoms,
                  term.location);
            | NetObj.Error (atoms) =&gt;
              ObValue.RaiseNetException(
                  &quot;on conversion to simple object&quot;, atoms,
                  term.location);
            | Thread.Alerted =&gt;
              ObValue.RaiseException(
                  ObValue.threadAlerted,
                  &quot;on conversion to simple object&quot;,
                  term.location);
            END;
          ELSE
            ObValue.RaiseError(
              &quot;simple must operate on an object&quot;, term.location);
          END;
        END;
    | ObTree.TermRedirect (node) =&gt;
        VAR
          env1 : ObValue.Env;
          toObj: ObValue.Val;
        BEGIN
          env1 := env;
          TYPECASE Term(node.obj, (*in-out*) env1, glob, mySelf) OF
          | ObValue.ValObj (obj) =&gt;
              env1 := env;
              toObj := Term(node.toObj, (*in-out*) env1, glob, mySelf);
              TRY
                obj.Redirect(toObj, ObValue.Is(obj, mySelf, term.location));
              EXCEPT
              | ObValue.ServerError (msg) =&gt;
                  ObValue.RaiseError(msg, term.location);
              | SharedObj.Error (atoms) =&gt;
                  ObValue.RaiseSharedException(
                    &quot;on replicated object invocation&quot;, atoms, term.location);
              | NetObj.Error (atoms) =&gt;
                  ObValue.RaiseNetException(
                    &quot;on remote object invocation&quot;, atoms, term.location);
              | Thread.Alerted =&gt;
                  ObValue.RaiseException(
                    ObValue.threadAlerted, &quot;on remote object invocation&quot;,
                    term.location);
              END;
              result := ObValue.valOk;
          ELSE
            ObValue.RaiseError(
              &quot;Redirection must operate on an object&quot;, term.location);
          END;
        END;
    | ObTree.TermSelect (node) =&gt;
        VAR
          env1    : ObValue.Env;
          argList : ObTree.TermList;
          argArray: ObValue.ArgArray;
        BEGIN
          IF node.argsNo &gt; NUMBER(argArray) THEN
            ObValue.RaiseError(&quot;Too many arguments.&quot;, term.location);
          END;
          env1 := env;
          TYPECASE Term(node.obj, (*in-out*) env1, glob, mySelf) OF
          | ObValue.ValObj (obj) =&gt;
              argList := node.args;
              FOR i := 1 TO node.argsNo DO
                env1 := env;
                argArray[i] :=
                  Term(argList.first, (*in-out*) env1, glob, mySelf);
                argList := argList.rest;
              END;
              TRY
                IF node.invoke THEN
                  FOR i := node.argsNo + 1 TO NUMBER(argArray) DO
                    argArray[i] := NIL; (* Clear for transmission *)
                  END;
                  result :=
                    obj.Invoke(node.label.text, node.argsNo,
                               argArray, ObValue.Is(obj, mySelf,
                                                    term.location),
                                      (*var*) node.labelIndexHint);
                ELSE
                  result := obj.Select(
                              node.label.text, ObValue.Is(obj, mySelf,
                                                          term.location),
                              (*var*) node.labelIndexHint);
                END;
              EXCEPT
              | ObValue.ServerError (msg) =&gt;
                  ObValue.RaiseError(msg, term.location);
              | SharedObj.Error (atoms) =&gt;
                  ObValue.RaiseSharedException(
                    &quot;on replicated object invocation&quot;, atoms, term.location);
              | NetObj.Error (atoms) =&gt;
                  ObValue.RaiseNetException(
                    &quot;on remote object invocation&quot;, atoms, term.location);
              | Thread.Alerted =&gt;
                  ObValue.RaiseException(
                    ObValue.threadAlerted, &quot;on remote object invocation&quot;,
                    term.location);
              END;
          ELSE
            ObValue.RaiseError(
              &quot;Selection must operate on an object&quot;, term.location);
          END;
        END;
    | ObTree.TermUpdate (node) =&gt;
        VAR
          env1: ObValue.Env;
          val : ObValue.Val;
        BEGIN
          env1 := env;
          TYPECASE Term(node.obj, (*in-out*) env1, glob, mySelf) OF
          | ObValue.ValObj (obj) =&gt;
              env1 := env;
              val := Term(node.term, (*in-out*) env1, glob, mySelf);
              TRY
                obj.Update(
                  node.label.text, val, ObValue.Is(obj, mySelf, term.location),
                  (*var*) node.labelIndexHint);
              EXCEPT
              | ObValue.ServerError (msg) =&gt;
                  ObValue.RaiseError(msg, term.location);
              | SharedObj.Error (atoms) =&gt;
                  ObValue.RaiseSharedException(
                    &quot;on replicated object update&quot;, atoms, term.location);
              | NetObj.Error (atoms) =&gt;
                  ObValue.RaiseNetException(
                    &quot;on remote object update&quot;, atoms, term.location);
              | Thread.Alerted =&gt;
                  ObValue.RaiseException(
                    ObValue.threadAlerted, &quot;on remote object update&quot;,
                    term.location);
              END;
              result := ObValue.valOk;
          ELSE
            ObValue.RaiseError(
              &quot;Update must operate on an object&quot;, term.location);
          END;
        END;
    | ObTree.TermSeq =&gt;
        VAR
          term1 := term;
          env1  := env;
        BEGIN
          LOOP
            TYPECASE term1 OF
            | ObTree.TermSeq (seq) =&gt;
                EVAL Term(seq.before, (*in-out*) env1, glob, mySelf);
                term1 := seq.after;
            ELSE
              result := Term(term1, (*in-out*) env1, glob, mySelf);
              EXIT;
            END;
          END;
        END;
    | ObTree.TermLet (node) =&gt;
        IF node.rec THEN
          env := TermBindingRec(node.binding, node.var, env, glob, mySelf);
        ELSE
          env :=
            TermBindingSeq(node.binding, node.var, env, env, glob, mySelf);
        END;
        result := ObValue.valOk;
    | ObTree.TermAssign (node) =&gt;
        VAR
          env1: ObValue.Env;
          val : ObValue.Val;
        BEGIN
          TYPECASE LookupIde(
                     node.name, node.place, TRUE, env, glob, term.location)
              OF
          | ObValue.ValVar (var) =&gt;
              env1 := env;
              val := Term(node.val, (*in-out*) env1, glob, mySelf);
              TRY
                var.remote.Set(val);
              EXCEPT
              | NetObj.Error (atoms) =&gt;
                  ObValue.RaiseNetException(
                    &quot;on remote assigment to variable '&quot; &amp; node.name.text
                      &amp; &quot;'&quot;, atoms, term.location);
              | Thread.Alerted =&gt;
                  ObValue.RaiseException(
                    ObValue.threadAlerted,
                    &quot;on remote assigment to variable '&quot; &amp; node.name.text
                      &amp; &quot;'&quot;, term.location);
              END;
          ELSE
            ObValue.RaiseError(
              &quot;Assigment must operate on a variable&quot;, term.location);
          END;
          result := ObValue.valOk;
        END;
    | ObTree.TermIf (node) =&gt;
        VAR env1: ObValue.Env;
        BEGIN
          env1 := env;
          TYPECASE Term(node.test, (*in-out*) env1, glob, mySelf) OF
          | ObValue.ValBool (bool) =&gt;
              IF bool.bool THEN
                env1 := env;
                result := Term(node.ifTrue, (*in-out*) env1, glob, mySelf);
              ELSIF node.ifFalse = NIL THEN
                result := ObValue.valOk;
              ELSE
                env1 := env;
                result :=
                  Term(node.ifFalse, (*in-out*) env1, glob, mySelf);
              END;
          ELSE
            ObValue.RaiseError(
              &quot;Conditional test must be a boolean&quot;, term.location);
          END;
        END;
    | ObTree.TermCase (node) =&gt;
        VAR
          env1    : ObValue.Env;
          caseList: ObTree.TermCaseList;
        BEGIN
          env1 := env;
          TYPECASE Term(node.option, (*in-out*) env1, glob, mySelf) OF
          | ObValue.ValOption (option) =&gt;
              caseList := node.caseList;
              LOOP
                IF caseList = NIL THEN
                  ObValue.RaiseError(&quot;No case branch applies to tag: &quot;
                                       &amp; option.tag, term.location);
                END;
                IF caseList.tag = NIL THEN (* &quot;else&quot; case *)
                  env1 := env;
                  result :=
                    Term(caseList.body, (*in-out*) env1, glob, mySelf);
                  EXIT;
                END;
                IF Text.Equal(option.tag, caseList.tag.text) THEN
                  IF caseList.binder = NIL THEN
                    env1 := env;
                  ELSE
                    env1 := NEW(ObValue.LocalEnv, name := caseList.binder,
                                val := option.val, rest := env);
                  END;
                  result :=
                    Term(caseList.body, (*in-out*) env1, glob, mySelf);
                  EXIT;
                END;
                caseList := caseList.rest;
              END;
          ELSE
            ObValue.RaiseError(
              &quot;Case over a non-option value&quot;, term.location);
          END;
        END;
    | ObTree.TermLoop (node) =&gt;
        VAR env1: ObValue.Env;
        BEGIN
          TRY
            LOOP
              env1 := env;
              EVAL Term(node.loop, (*in-out*) env1, glob, mySelf);
            END;
          EXCEPT
          | ObValue.Error (pkt) =&gt;
              IF NOT Text.Equal(pkt.msg, &quot;exit&quot;) THEN
                RAISE ObValue.Error(pkt);
              END;
          END;
          result := ObValue.valOk;
        END;
    | ObTree.TermExit (node) =&gt;
        RAISE ObValue.Error(NEW(ObValue.ErrorPacket, msg := &quot;exit&quot;,
                                location := node.location));
    | ObTree.TermFor (node) =&gt;
        VAR
          env1        : ObValue.Env;
          forEnv      : ObValue.LocalEnv;
          lbVal, ubVal: ObValue.Val;
          i, ub       : INTEGER;
        BEGIN
          env1 := env;
          lbVal := Term(node.lb, (*in-out*) env1, glob, mySelf);
          TYPECASE lbVal OF
          | ObValue.ValInt (node) =&gt; i := node.int;
          ELSE
            ObValue.RaiseError(
              &quot;Lower bound of 'for' must be an integer&quot;, term.location);
          END;
          env1 := env;
          ubVal := Term(node.ub, (*in-out*) env1, glob, mySelf);
          TYPECASE ubVal OF
          | ObValue.ValInt (node) =&gt; ub := node.int;
          ELSE
            ObValue.RaiseError(
              &quot;Upper bound of 'for' must be an integer&quot;, term.location);
          END;
          forEnv := NEW(ObValue.LocalEnv, name := node.binder, val := NIL,
                        rest := env);
          TRY
            LOOP
              IF i &gt; ub THEN EXIT END;
              forEnv.val := NEW(ObValue.ValInt, int := i, temp := FALSE);
              env1 := forEnv;
              EVAL Term(node.body, (*in-out*) env1, glob, mySelf);
              INC(i);
            END;
          EXCEPT
          | ObValue.Error (pkt) =&gt;
              IF NOT Text.Equal(pkt.msg, &quot;exit&quot;) THEN
                RAISE ObValue.Error(pkt);
              END;
          END;
          result := ObValue.valOk;
        END;
    | ObTree.TermForeach (node) =&gt;
        VAR
          env1                 : ObValue.Env;
          forEnv               : ObValue.LocalEnv;
          val, rangeVal        : ObValue.Val;
          vals, oldVals, array1: Vals;
          i, ub                : INTEGER;
        BEGIN
          env1 := env;
          rangeVal := Term(node.range, (*in-out*) env1, glob, mySelf);
          TYPECASE rangeVal OF
          | ObValue.ValArray (node) =&gt;
              TRY
                array1 := node.remote.Obtain();
              EXCEPT
              | NetObj.Error (atoms) =&gt;
                  ObValue.RaiseNetException(
                    &quot;on remote array access&quot;, atoms, term.location);
              | Thread.Alerted =&gt;
                  ObValue.RaiseException(
                    ObValue.threadAlerted, &quot;on remote array access&quot;,
                    term.location);
              END;
          ELSE
            ObValue.RaiseError(
              &quot;Range of 'for' must be an array&quot;, term.location);
          END;
          i := 0;
          forEnv := NEW(ObValue.LocalEnv, name := node.binder, val := NIL,
                        rest := env);
          TRY
            ub := NUMBER(array1^);
            IF node.map THEN vals := NEW(Vals, ub); END;
            LOOP
              IF i &gt;= ub THEN EXIT END;
              forEnv.val := array1^[i];
              env1 := forEnv;
              val := Term(node.body, (*in-out*) env1, glob, mySelf);
              IF node.map THEN vals^[i] := val END;
              INC(i);
            END;
          EXCEPT
          | ObValue.Error (pkt) =&gt;
              IF NOT Text.Equal(pkt.msg, &quot;exit&quot;) THEN
                RAISE ObValue.Error(pkt);
              ELSIF node.map THEN
                oldVals := vals;
                vals := NEW(Vals, i);
                vals^ := SUBARRAY(oldVals^, 0, i);
              END;
          END;
          IF node.map THEN
            result := ObValue.NewArrayFromVals(vals);
          ELSE
            result := ObValue.valOk;
          END;
        END;
    | ObTree.TermException (node) =&gt;
        VAR env1: ObValue.Env;
        BEGIN
          env1 := env;
          TYPECASE Term(node.name, (*in-out*) env1, glob, mySelf) OF
          | ObValue.ValText (str) =&gt;
              result := NEW(ObValue.ValException, name := str.text);
          ELSE
            ObValue.RaiseError(
              &quot;Argument of exception must be a text&quot;, term.location);
          END;
        END;
    | ObTree.TermRaise (node) =&gt;
        VAR env1: ObValue.Env;
        BEGIN
          env1 := env;
          TYPECASE Term(node.exception, (*in-out*) env1, glob, mySelf) OF
          | ObValue.ValException (exc) =&gt;
              ObValue.RaiseException(exc, &quot;&quot;, node.location);
          ELSE
            ObValue.RaiseError(
              &quot;Argument of raise must be an exception&quot;, term.location);
          END;
        END;
    | ObTree.TermTry (node) =&gt;
        VAR
          env1   : ObValue.Env;
          tryList: ObTree.TermTryList;
        BEGIN
          TRY
            env1 := env;
            result := Term(node.body, (*in-out*) env1, glob, mySelf);
          EXCEPT
          | ObValue.Exception (packet) =&gt;
              tryList := node.tryList;
              LOOP
                IF tryList = NIL THEN RAISE ObValue.Exception(packet) END;
                IF tryList.exception = NIL THEN (* &quot;else&quot; case *)
                  env1 := env;
                  result :=
                    Term(tryList.recover, (*in-out*) env1, glob, mySelf);
                  EXIT;
                END;
                env1 := env;
                TYPECASE
                    Term(tryList.exception, (*in-out*) env1, glob, mySelf)
                    OF
                | ObValue.ValException (exc) =&gt;
                    IF ObValue.SameException(exc, packet.exception) THEN
                      env1 := env;
                      result := Term(tryList.recover, (*in-out*) env1,
                                     glob, mySelf);
                      EXIT;
                    END;
                    tryList := tryList.rest;
                ELSE
                  ObValue.RaiseError(
                    &quot;Guard of try must be an exception&quot;, term.location);
                END;
              END;
          | ObValue.Error (packet) =&gt;
              tryList := node.tryList;
              LOOP
                IF tryList = NIL THEN RAISE ObValue.Error(packet); END;
                IF tryList.exception = NIL THEN (* &quot;else&quot; case *)
                  env1 := env;
                  result :=
                    Term(tryList.recover, (*in-out*) env1, glob, mySelf);
                  EXIT;
                END;
                tryList := tryList.rest;
              END;
          END;
        END;
    | ObTree.TermTryFinally (node) =&gt;
        VAR env1: ObValue.Env;
        BEGIN
          TRY
            env1 := env;
            result := Term(node.body, (*in-out*) env1, glob, mySelf);
          FINALLY
            env1 := env;
            result := Term(node.finally, (*in-out*) env1, glob, mySelf);
          END;
        END;
    | ObTree.TermWatch (node) =&gt;
        VAR
          env1       : ObValue.Env;
          mySync     : ObValue.Sync;
        BEGIN
          TYPECASE mySelf OF
          | ObValue.ValRemObj (remObj) =&gt;
            TYPECASE remObj.remote OF
            | ObValue.RemObjServer(remObjServer) =&gt;
              IF remObjServer = NIL THEN
                ObValue.RaiseError(
                  &quot;watch-until must be used inside a method&quot;, term.location);
              END;
              mySync := remObjServer.sync;
            ELSE
              ObValue.RaiseError(
                  &quot;watch-until does not work on remote objects&quot;,
                  term.location);
            END;
          | ObValue.ValSimpleObj(simpleObj) =&gt;
            (* Simple objs are always local! *)
            IF simpleObj = NIL THEN
              ObValue.RaiseError(
                  &quot;watch-until must be used inside a method&quot;, term.location);
            END;
            mySync := simpleObj.simple.sync;
          ELSE
            ObValue.RaiseError(
              &quot;watch-until does not work on remote or replicated objects&quot;,
              term.location);
          END;
          env1 := env;
          TYPECASE Term(node.condition, (*in-out*) env1, glob, mySelf) OF
          | ObBuiltIn.ValCondition (cond) =&gt;
            IF mySync = NIL THEN
              ObValue.RaiseError(
                  &quot;watch-until must be used inside a protected object&quot;,
                  term.location);
            ELSE
              LOOP
                env1 := env;
                TYPECASE Term(node.guard, (*in-out*) env1, glob, mySelf) OF
                | ObValue.ValBool (guard) =&gt;
                  IF guard.bool THEN
                    EXIT
                  ELSE
                    Thread.Wait(mySync.mutex, cond.condition);
                  END;
                ELSE
                  ObValue.RaiseError(
                      &quot;Argument 2 of watch-until must be a boolean&quot;,
                      term.location);
                END;
              END;
              result := ObValue.valOk;
            END;
          ELSE
            ObValue.RaiseError(
              &quot;Argument 1 of watch-until must be a condition&quot;,
              term.location);
          END;
        END;
    ELSE                         &lt;*ASSERT FALSE*&gt;
    END;
    RETURN result;
  END Term;

PROCEDURE <A NAME="Call"><procedure>Call</procedure></A> (         clos: ObValue.ValFun;
                READONLY args: ObValue.Vals;
                         loc : SynLocation.T    := NIL): ObValue.Val
  RAISES {ObValue.Error, ObValue.Exception} =
  VAR
    env    : ObValue.Env;
    binders: ObTree.IdeList;
  BEGIN
    IF clos.fun.bindersNo # NUMBER(args) THEN
      ObValue.RaiseError(ObValue.BadArgsNoMsg(
                           clos.fun.bindersNo, NUMBER(args), &quot;&quot;, &quot;&quot;), loc);
    END;
    env := NIL;
    binders := clos.fun.binders;
    FOR i := 0 TO NUMBER(args) - 1 DO
      env := NEW(ObValue.LocalEnv, name := binders.first, val := args[i],
                 rest := env);
      binders := binders.rest;
    END;
    RETURN Term(clos.fun.body, (*in-out*) env, clos.global, NIL);
  END Call;

PROCEDURE <A NAME="CallEngine"><procedure>CallEngine</procedure></A> (engine: ObValue.ValEngine;
                      arg   : ObValue.Val;
                      loc   : SynLocation.T       := NIL): ObValue.Val
  RAISES {ObValue.Error, ObValue.Exception} =
  BEGIN
    TRY
      RETURN engine.remote.Eval(arg, NIL);
    EXCEPT
    | ObValue.ServerError (msg) =&gt;
        ObValue.RaiseError(msg, loc); &lt;*ASSERT FALSE*&gt;
    | NetObj.Error (atoms) =&gt;
        ObValue.RaiseNetException(&quot;on remote engine execution&quot;, atoms, loc); &lt;*ASSERT FALSE*&gt;
    | Thread.Alerted =&gt;
        ObValue.RaiseException(
          ObValue.threadAlerted, &quot;on remote engine execution&quot;, loc); &lt;*ASSERT FALSE*&gt;
    END;
  END CallEngine;

BEGIN
END ObEval.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
