<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: obliqrt/src/ObValue.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>obliqrt/src/ObValue.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright 1991 Digital Equipment Corporation. 
 Distributed only by permission. 

<P><PRE>MODULE <module>ObValue</module> EXPORTS <A HREF="ObValue.i3.html"><implements>ObValue</A></implements>, <A HREF="ObValueRep.i3.html"><implements>ObValueRep</A></implements>;

IMPORT <A HREF="../../m3core/src/text/Text.i3.html">Text</A>, <A HREF="../../libm3/src/fmtlex/Fmt.i3.html">Fmt</A>, <A HREF="../../synloc/src/SynWr.i3.html">SynWr</A>, <A HREF="../../synloc/src/SynLocation.i3.html">SynLocation</A>, <A HREF="ObTree.i3.html">ObTree</A>, <A HREF="../../libm3/derived/AtomList.i3.html">AtomList</A>, <A HREF="../../libm3/src/atom/Atom.i3.html">Atom</A>, <A HREF="ObEval.i3.html">ObEval</A>,
       <A HREF="../../netobj/src/netobjrt/NetObj.i3.html">NetObj</A>, <A HREF="../../libm3/src/pickle/ver2/Pickle2.i3.html">Pickle2</A> AS Pickle, <A HREF="../../libm3/src/pickle/ver2/PickleStubs.i3.html">PickleStubs</A>, <A HREF="../../libm3/src/rw/Rd.i3.html">Rd</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>,
       <A HREF="../../libm3/src/os/Common/OSError.i3.html">OSError</A>, <A HREF="../../libm3/derived/TextRefTbl.i3.html">TextRefTbl</A>, <A HREF="../../libm3/src/types/Refany.i3.html">Refany</A>, <A HREF="../../libm3/src/rw/FileRd.i3.html">FileRd</A>, <A HREF="../../libm3/src/rw/FileWr.i3.html">FileWr</A>, <A HREF="OpSys.i3.html">OpSys</A>, <A HREF="../../sharedobj/src/SharedObj.i3.html">SharedObj</A>,
       <A HREF="../../netobj/src/netobjrt/NetObjNotifier.i3.html">NetObjNotifier</A>;

IMPORT <A HREF="../derived/ObValuePickle.i3.html">ObValuePickle</A>;
</PRE> IMPORT Env AS ProcEnv; 

<P><PRE>REVEAL
    <A NAME="ValRemObj">ValRemObj</A> = ValRemObjPublic BRANDED &quot;ValRemObj&quot; OBJECT OVERRIDES
      Who      := ValRemObjWho;
      Select   := ValRemObjSelect;
      Invoke   := ValRemObjInvoke;
      Update   := ValRemObjUpdate;
      Redirect := ValRemObjRedirect;
      Has      := ValRemObjHas;
      Obtain   := ValRemObjObtain;
    END;

    <A NAME="ValReplObj">ValReplObj</A> = ValReplObjPublic BRANDED &quot;ValReplObj&quot; OBJECT OVERRIDES
      Who      := ValReplObjWho;
      Select   := ValReplObjSelect;
      Invoke   := ValReplObjInvoke;
      Update   := ValReplObjUpdate;
      Redirect := ValReplObjRedirect;
      Has      := ValReplObjHas;
      Obtain   := ValReplObjObtain;
    END;

    <A NAME="ValSimpleObj">ValSimpleObj</A> = ValSimpleObjPublic BRANDED &quot;ValSimpleObj&quot; OBJECT
      OVERRIDES
        Who      := ValSimpleObjWho;
        Select   := ValSimpleObjSelect;
        Invoke   := ValSimpleObjInvoke;
        Update   := ValSimpleObjUpdate;
        Redirect := ValSimpleObjRedirect;
        Has      := ValSimpleObjHas;
        Obtain   := ValSimpleObjObtain;
      END;

  <A NAME="RemVarServer">RemVarServer</A> = RemVar BRANDED &quot;RemVarServer&quot; OBJECT
                   val: Val;
                 OVERRIDES
                   Get := VarGet;
                   Set := VarSet;
                 END;

  <A NAME="RemArrayServer">RemArrayServer</A> = RemArray BRANDED &quot;RemArrayServer&quot; OBJECT
                     array: REF Vals;
                   OVERRIDES
                     Size   := ArraySize;
                     Get    := ArrayGet;
                     Set    := ArraySet;
                     Sub    := ArraySub;
                     Upd    := ArrayUpd;
                     Obtain := ArrayObtain;
                   END;

  <A NAME="RemObjServer">RemObjServer</A> = RemObjServerPublic BRANDED &quot;RemObjServer&quot; OBJECT
                   self     : ValRemObj;
                   fields   : REF ObjFields;
                   protected: BOOLEAN;
                 OVERRIDES
                   Who      := ObjWho;
                   Select   := ObjSelect;
                   Invoke   := ObjInvoke;
                   Update   := ObjUpdate;
                   Redirect := ObjRedirect;
                   Has      := ObjHas;
                   Obtain   := ObjObtain;
                 END;

  <A NAME="SimpleObj">SimpleObj</A> = SimpleObjPublic BRANDED &quot;SimpleObj&quot; OBJECT
                self     : ValSimpleObj;
                fields   : REF ObjFields;
                protected: BOOLEAN;

                pickleIn: REF ObjFields := NIL;
                pickleOut: REF ObjFields := NIL;
              OVERRIDES
                Who      := SimpleObjWho;
                Select   := SimpleObjSelect;
                Invoke   := SimpleObjInvoke;
                Update   := SimpleObjUpdate;
                Redirect := SimpleObjRedirect;
                Has      := SimpleObjHas;
                Obtain   := SimpleObjObtain;
              END;

  <A NAME="RemFileSystemServer">RemFileSystemServer</A> = RemFileSystem BRANDED &quot;RemFileSystemServer&quot; OBJECT
                          readOnly: BOOLEAN;
                        OVERRIDES
                          OpenRead   := FileSystemOpenRead;
                          OpenWrite  := FileSystemOpenWrite;
                          OpenAppend := FileSystemOpenAppend;
                        END;

  <A NAME="NonRemObjHookServer">NonRemObjHookServer</A> = NonRemObjHook BRANDED &quot;NonRemObjHookServer&quot; OBJECT
    replObj: ValObj;
  OVERRIDES
    init := NonRemObjHookInit;
    Get := NonRemObjHookGet;
  END;

VAR sysCallTable: TextRefTbl.Default;

PROCEDURE <A NAME="ThisMachine"><procedure>ThisMachine</procedure></A> (): TEXT =
  BEGIN
    TRY
      RETURN OpSys.GetHostName();
    EXCEPT
    | OpSys.Error =&gt; RETURN &quot;&lt;unknown&gt;&quot;;
    END;
  END ThisMachine;

PROCEDURE <A NAME="Setup"><procedure>Setup</procedure></A> () =
  BEGIN
    valOk := NEW(ValOk);
    netException := NEW(ValException, name := &quot;net_failure&quot;);
    sharedException := NEW(ValException, name := &quot;shared_failure&quot;);
    sharedFatal := NEW(ValException, name := &quot;shared_fatal&quot;);
    threadAlerted := NEW(ValException, name := &quot;thread_alerted&quot;);
    machineAddress := ThisMachine();

    sysCallTable := NEW(TextRefTbl.Default).init();
    sysCallFailure := NEW(ValException, name := &quot;sys_callFailure&quot;);
    showNetObjMsgs := FALSE;

    localProcessor := NewProcessor();
    InhibitTransmission(TYPECODE(ValProcessor),
                        &quot;processors cannot be transmitted/duplicated&quot;);
  END Setup;

PROCEDURE <A NAME="RaiseError"><procedure>RaiseError</procedure></A> (msg: TEXT; location: SynLocation.T) RAISES {Error} =
  BEGIN
    RAISE Error(NEW(ErrorPacket, msg := msg, location := location));
  END RaiseError;

PROCEDURE <A NAME="RaiseServerError"><procedure>RaiseServerError</procedure></A> (msg: TEXT) RAISES {ServerError} =
  BEGIN
    RAISE ServerError(msg);
  END RaiseServerError;

PROCEDURE <A NAME="SameException"><procedure>SameException</procedure></A> (exc1, exc2: ValException): BOOLEAN =
  BEGIN
    RETURN Text.Equal(exc1.name, exc2.name);
  END SameException;

PROCEDURE <A NAME="RaiseException"><procedure>RaiseException</procedure></A> (exception: ValException;
                          msg      : TEXT;
                          loc      : SynLocation.T ) RAISES {Exception} =
  BEGIN
    RAISE Exception(NEW(ExceptionPacket, msg := msg, location := loc,
                        exception := exception, data := NIL));
  END RaiseException;

PROCEDURE <A NAME="RaiseNetException"><procedure>RaiseNetException</procedure></A> (msg  : TEXT;
                             atoms: AtomList.T;
                             loc  : SynLocation.T) RAISES {Exception} =
  BEGIN
    IF showNetObjMsgs THEN
      msg := msg &amp; &quot; (NetObj says:&quot;;
      WHILE atoms # NIL DO
        msg := msg &amp; &quot; &quot; &amp; Atom.ToText(atoms.head);
        atoms := atoms.tail;
      END;
      msg := msg &amp; &quot;)&quot;;
    END;
    RaiseException(netException, msg, loc);
  END RaiseNetException;

PROCEDURE <A NAME="RaiseSharedException"><procedure>RaiseSharedException</procedure></A> (msg  : TEXT;
                                atoms: AtomList.T;
                                loc  : SynLocation.T) RAISES {Exception} =
  BEGIN
    IF showNetObjMsgs THEN
      msg := msg &amp; &quot; (SharedObj says:&quot;;
      WHILE atoms # NIL DO
        msg := msg &amp; &quot; &quot; &amp; Atom.ToText(atoms.head);
        atoms := atoms.tail;
      END;
      msg := msg &amp; &quot;)&quot;;
    END;
    RaiseException(sharedException, msg, loc);
  END RaiseSharedException;

PROCEDURE <A NAME="ErrorMsg"><procedure>ErrorMsg</procedure></A> (swr: SynWr.T; packet: ErrorPacket) =
  BEGIN
    Msg(swr, &quot;Execution error &quot;, packet.msg, packet.location);
  END ErrorMsg;

PROCEDURE <A NAME="ExceptionMsg"><procedure>ExceptionMsg</procedure></A> (swr: SynWr.T; packet: ExceptionPacket) =
  VAR name: TEXT;
  BEGIN
    name := packet.exception.name;
    IF NOT Text.Empty(packet.msg) THEN
      name := name &amp; &quot; (&quot; &amp; packet.msg &amp; &quot;)&quot;;
    END;
    Msg(swr, &quot;Uncaught exception &quot;, name, packet.location);
  END ExceptionMsg;

PROCEDURE <A NAME="Msg"><procedure>Msg</procedure></A> (swr           : SynWr.T;
               msgKind, msg  : TEXT;
               sourceLocation: SynLocation.T) =
  BEGIN
    SynWr.Beg(swr, 2, loud := TRUE);
    SynWr.Text(swr, msgKind, loud := TRUE);
    SynLocation.PrintLocation(swr, sourceLocation);
    SynWr.End(swr, loud := TRUE);
    SynWr.NewLine(swr, loud := TRUE);

    SynWr.Text(swr, msg, loud := TRUE);
    SynWr.NewLine(swr, loud := TRUE);
    SynWr.Flush(swr, loud := TRUE);
  END Msg;

PROCEDURE <A NAME="BadOp"><procedure>BadOp</procedure></A> (pkg, op: TEXT; location: SynLocation.T) RAISES {Error} =
  BEGIN
    RaiseError(&quot;Unknown operation: &quot; &amp; pkg &amp; &quot;_&quot; &amp; op, location);
  END BadOp;

PROCEDURE <A NAME="BadArgType"><procedure>BadArgType</procedure></A> (argNo            : INTEGER;
                      expected, pkg, op: TEXT;
                      location         : SynLocation.T) RAISES {Error} =
  BEGIN
    RaiseError(&quot;Argument &quot; &amp; Fmt.Int(argNo) &amp; &quot; of &quot; &amp; pkg &amp; &quot;_&quot; &amp; op
                 &amp; &quot; must have type &quot; &amp; expected, location);
  END BadArgType;

PROCEDURE <A NAME="BadArgVal"><procedure>BadArgVal</procedure></A> (argNo            : INTEGER;
                     expected, pkg, op: TEXT;
                     location         : SynLocation.T) RAISES {Error} =
  BEGIN
    RaiseError(&quot;Argument &quot; &amp; Fmt.Int(argNo) &amp; &quot; of &quot; &amp; pkg &amp; &quot;_&quot; &amp; op
                 &amp; &quot; must be &quot; &amp; expected, location);
  END BadArgVal;

PROCEDURE <A NAME="NewEnv"><procedure>NewEnv</procedure></A> (name: ObTree.IdeName; env: Env): Env =
  BEGIN
    RETURN NEW(LocalEnv, name := name, val := NIL, rest := env);
  END NewEnv;

PROCEDURE <A NAME="ExtendEnv"><procedure>ExtendEnv</procedure></A> (binders: ObTree.IdeList; env: Env): Env =
  BEGIN
    IF binders = NIL THEN
      RETURN env;
    ELSE
      RETURN ExtendEnv(binders.rest, NewEnv(binders.first, env));
    END;
  END ExtendEnv;

PROCEDURE <A NAME="PrintWhat"><procedure>PrintWhat</procedure></A> (self: ValAnything): TEXT =
  BEGIN
    RETURN self.what;
  END PrintWhat;

PROCEDURE <A NAME="IsSelfOther"><procedure>IsSelfOther</procedure></A> (self, other: ValAnything): BOOLEAN =
  BEGIN
    RETURN self = other;
  END IsSelfOther;

PROCEDURE <A NAME="Is"><procedure>Is</procedure></A> (v1, v2: Val; &lt;*UNUSED*&gt; location: SynLocation.T): BOOLEAN =
  BEGIN
    (* handle NILs explicitely *)
    IF v1 = NIL OR v2 = NIL THEN RETURN v1 = v2 END;

    TYPECASE v1 OF
    | ValOk =&gt;
        TYPECASE v2 OF | ValOk =&gt; RETURN TRUE; ELSE RETURN FALSE; END;
    | ValBool (node1) =&gt;
        TYPECASE v2 OF
        | ValBool (node2) =&gt; RETURN node1.bool = node2.bool;
        ELSE
          RETURN FALSE;
        END;
    | ValChar (node1) =&gt;
        TYPECASE v2 OF
        | ValChar (node2) =&gt; RETURN node1.char = node2.char;
        ELSE
          RETURN FALSE;
        END;
    | ValText (node1) =&gt;
        TYPECASE v2 OF
        | ValText (node2) =&gt; RETURN Text.Equal(node1.text, node2.text);
        ELSE
          RETURN FALSE;
        END;
    | ValException (node1) =&gt;
        TYPECASE v2 OF
        | ValException (node2) =&gt;
            RETURN Text.Equal(node1.name, node2.name);
        ELSE
          RETURN FALSE;
        END;
    | ValInt (node1) =&gt;
        TYPECASE v2 OF
        | ValInt (node2) =&gt; RETURN node1.int = node2.int;
        ELSE
          RETURN FALSE;
        END;
    | ValReal (node1) =&gt;
        TYPECASE v2 OF
        | ValReal (node2) =&gt; RETURN node1.real = node2.real;
        ELSE
          RETURN FALSE;
        END;
    | ValArray (node1) =&gt;
        TYPECASE v2 OF
        | ValArray (node2) =&gt; RETURN node1.remote = node2.remote;
        ELSE
          RETURN FALSE;
        END;
    | ValAnything (node1) =&gt;
        TYPECASE v2 OF
        | ValAnything (node2) =&gt; RETURN node1.Is(node2);
        ELSE
          RETURN FALSE;
        END;
    | ValOption (node1) =&gt;
        TYPECASE v2 OF
        | ValOption (node2) =&gt; RETURN node1 = node2;
        ELSE
          RETURN FALSE;
        END;
    | ValFun (node1) =&gt;
        TYPECASE v2 OF
        | ValFun (node2) =&gt; RETURN node1 = node2;
        ELSE
          RETURN FALSE;
        END;
    | ValMeth (node1) =&gt;
        TYPECASE v2 OF
        | ValMeth (node2) =&gt; RETURN node1 = node2;
        ELSE
          RETURN FALSE;
        END;
      (* Obliq++: added handling for the 3 subtypes, and removed the
         generic ValObj supertype *)
    | ValRemObj (node1) =&gt;
        TYPECASE v2 OF
        | ValRemObj (node2) =&gt; RETURN node1.remote = node2.remote;
        ELSE
          RETURN FALSE;
        END;
    | ValReplObj (node1) =&gt;
        TYPECASE v2 OF
        | ValReplObj (node2) =&gt; RETURN node1.replica = node2.replica;
        ELSE
          RETURN FALSE;
        END;
    | ValSimpleObj (node1) =&gt;
        TYPECASE v2 OF
        | ValSimpleObj (node2) =&gt; RETURN node1.simple = node2.simple;
        ELSE
          RETURN FALSE;
        END;
    | ValAlias (node1) =&gt;
        TYPECASE v2 OF
        | ValAlias (node2) =&gt; RETURN node1 = node2;
        ELSE
          RETURN FALSE;
        END;
    | ValEngine (node1) =&gt;
        TYPECASE v2 OF
        | ValEngine (node2) =&gt; RETURN node1.remote = node2.remote;
        ELSE
          RETURN FALSE;
        END;
    ELSE                         &lt;*ASSERT FALSE*&gt;
    END;
  END Is;

PROCEDURE <A NAME="NewText"><procedure>NewText</procedure></A> (text: TEXT): Val =
  BEGIN
    IF text = NIL THEN text := &quot;&quot; END;
    RETURN NEW(ValText, text := text);
  END NewText;

PROCEDURE <A NAME="NewVar"><procedure>NewVar</procedure></A> (val: Val): ValVar =
  BEGIN
    RETURN NEW(ValVar, remote := NEW(RemVarServer, val := val));
  END NewVar;

PROCEDURE <A NAME="VarGet"><procedure>VarGet</procedure></A> (self: RemVarServer): Val RAISES {} =
  BEGIN
    RETURN self.val;
  END VarGet;

PROCEDURE <A NAME="VarSet"><procedure>VarSet</procedure></A> (self: RemVarServer; val: Val) RAISES {} =
  BEGIN
    self.val := val;
  END VarSet;

PROCEDURE <A NAME="NewArray"><procedure>NewArray</procedure></A> (READONLY vals: Vals): ValArray =
  VAR newVals: REF Vals;
  BEGIN
    newVals := NEW(REF Vals, NUMBER(vals));
    newVals^ := vals;
    RETURN NewArrayFromVals(newVals);
  END NewArray;

PROCEDURE <A NAME="NewArrayFromVals"><procedure>NewArrayFromVals</procedure></A> (vals: REF Vals): ValArray =
  BEGIN
    RETURN NEW(ValArray, remote := NEW(RemArrayServer, array := vals));
  END NewArrayFromVals;

PROCEDURE <A NAME="ArraySize"><procedure>ArraySize</procedure></A> (arr: RemArrayServer): INTEGER RAISES {} =
  BEGIN
    RETURN NUMBER(arr.array^);
  END ArraySize;

PROCEDURE <A NAME="ArrayGet"><procedure>ArrayGet</procedure></A> (self: RemArrayServer; i: INTEGER): Val
  RAISES {ServerError} =
  BEGIN
    IF (i &lt; 0) OR (i &gt;= NUMBER(self.array^)) THEN
      RaiseServerError(&quot;arg not in range&quot;)
    END;
    RETURN self.array^[i];
  END ArrayGet;

PROCEDURE <A NAME="ArraySet"><procedure>ArraySet</procedure></A> (self: RemArrayServer; i: INTEGER; val: Val)
  RAISES {ServerError} =
  BEGIN
    IF (i &lt; 0) OR (i &gt;= NUMBER(self.array^)) THEN
      RaiseServerError(&quot;arg 1 not in range&quot;);
    END;
    self.array^[i] := val;
  END ArraySet;

PROCEDURE <A NAME="ArraySub"><procedure>ArraySub</procedure></A> (self: RemArrayServer; start, size: INTEGER): ValArray
  RAISES {ServerError} =
  VAR
    len : INTEGER;
    vals: REF Vals;
  BEGIN
    len := NUMBER(self.array^);
    IF (start &lt; 0) OR (start &gt; len) THEN
      RaiseServerError(&quot;arg 2 not in range&quot;);
    END;
    IF (size &lt; 0) OR (start + size &gt; len) THEN
      RaiseServerError(&quot;arg 3 not in range&quot;);
    END;
    vals := NEW(REF Vals, size);
    FOR i := 0 TO size - 1 DO vals^[i] := self.array^[start + i]; END;
    RETURN NEW(ValArray, remote := NEW(RemArrayServer, array := vals));
  END ArraySub;

PROCEDURE <A NAME="ArrayUpd"><procedure>ArrayUpd</procedure></A> (         self       : RemArrayServer;
                             start, size: INTEGER;
                    READONLY otherArr   : REF Vals        )
  RAISES {ServerError} =
  VAR
    selfLen, otherLen: INTEGER;
    selfArr          : REF Vals;
  BEGIN
    selfArr := self.array;
    selfLen := NUMBER(selfArr^);
    IF (start &lt; 0) OR (start &gt; selfLen) THEN
      RaiseServerError(&quot;arg 2 not in range&quot;);
    END;
    IF (size &lt; 0) OR (start + size &gt; selfLen) THEN
      RaiseServerError(&quot;arg 3 not in range of arg 1&quot;);
    END;
    otherLen := NUMBER(otherArr^);
    IF size &gt; otherLen THEN
      RaiseServerError(&quot;arg 3 not in range of arg 4&quot;);
    END;
    FOR i := size - 1 TO 0 BY -1 DO
      selfArr^[start + i] := otherArr^[i];
    END;
  END ArrayUpd;

PROCEDURE <A NAME="ArrayObtain"><procedure>ArrayObtain</procedure></A> (self: RemArrayServer): REF Vals RAISES {} =
  BEGIN
    RETURN self.array;
  END ArrayObtain;

PROCEDURE <A NAME="ArrayCat"><procedure>ArrayCat</procedure></A> (vals1, vals2: REF Vals): Val RAISES {} =
  VAR
    len1, len2: INTEGER;
    vals      : REF Vals;
  BEGIN
    len1 := NUMBER(vals1^);
    len2 := NUMBER(vals2^);
    vals := NEW(REF Vals, len1 + len2);
    FOR i := 0 TO len1 - 1 DO vals^[i] := vals1^[i]; END;
    FOR i := 0 TO len2 - 1 DO vals^[len1 + i] := vals2^[i]; END;
    RETURN NEW(ValArray, remote := NEW(RemArrayServer, array := vals));
  END ArrayCat;

PROCEDURE <A NAME="NewObject"><procedure>NewObject</procedure></A> (READONLY fields   : ObjFields;
                              who      : TEXT        := &quot;&quot;;
                              protected: BOOLEAN     := FALSE;
                              sync     : Sync        := NIL    ): ValObj =
  VAR remFields: REF ObjFields;
  BEGIN
    remFields := NEW(REF ObjFields, NUMBER(fields));
    remFields^ := fields;
    RETURN NewObjectFromFields(remFields, who, protected, sync);
  END NewObject;

PROCEDURE <A NAME="NewObjectFromFields"><procedure>NewObjectFromFields</procedure></A> (fields   : REF ObjFields;
                               who      : TEXT;
                               protected: BOOLEAN;
                               sync     : Sync           ): ValObj =
  VAR remObjServ: RemObjServer;
  BEGIN
    (* Obliq++: made the new object a ValRemObj *)
    remObjServ :=
      NEW(RemObjServer, who := who, self := NEW(ValRemObj, remote := NIL),
          fields := fields, protected := protected, sync := sync);
    remObjServ.self.remote := remObjServ;
    RETURN remObjServ.self;
  END NewObjectFromFields;

PROCEDURE <A NAME="NewReplObject"><procedure>NewReplObject</procedure></A> (READONLY fields   : ObjFields;
                         who      : TEXT        := &quot;&quot;;
                         protected: BOOLEAN     := FALSE): ValObj
    RAISES {SharedObj.Error} =
  VAR replFields: REF ObjFields;
  BEGIN
    replFields := NEW(REF ObjFields, NUMBER(fields));
    replFields^ := fields;
    RETURN NewReplObjectFromFields(replFields, who, protected);
  END NewReplObject;

PROCEDURE <A NAME="NewReplObjectFromFields"><procedure>NewReplObjectFromFields</procedure></A> (fields   : REF ObjFields;
                                   who      : TEXT;
                                   protected: BOOLEAN): ValObj
    RAISES {SharedObj.Error} =
  VAR replObjServ: ReplObjStd;
  BEGIN
    replObjServ := NEW(ReplObjStd, who := who,
                      self := NEW(ValReplObj, replica := NIL),
                      protected := protected,
                      fields := fields).init();
    replObjServ.self.replica := replObjServ;
    RETURN replObjServ.self;
  END NewReplObjectFromFields;

PROCEDURE <A NAME="NewSimpleObject"><procedure>NewSimpleObject</procedure></A> (READONLY fields   : ObjFields;
                           who      : TEXT        := &quot;&quot;;
                           protected: BOOLEAN     := FALSE;
                           sync     : Sync        := NIL    ): ValObj =
  VAR simpleFields: REF ObjFields;
  BEGIN
    simpleFields := NEW(REF ObjFields, NUMBER(fields));
    simpleFields^ := fields;
    RETURN NewSimpleObjectFromFields(simpleFields, who, protected, sync);
  END NewSimpleObject;

PROCEDURE <A NAME="NewSimpleObjectFromFields"><procedure>NewSimpleObjectFromFields</procedure></A> (fields   : REF ObjFields;
                                     who      : TEXT;
                                     protected: BOOLEAN;
                                     sync     : Sync           ): ValObj =
  VAR simpleObj: SimpleObj;
  BEGIN
    simpleObj := NEW(SimpleObj, who := who,
                     self := NEW(ValSimpleObj, simple := NIL),
                     fields := fields,
                     protected := protected, sync := sync);
    simpleObj.self.simple := simpleObj;
    RETURN simpleObj.self;
  END NewSimpleObjectFromFields;
</PRE>**************************
 object conversion routines
 **************************
<PRE>PROCEDURE <A NAME="CloneObjData"><procedure>CloneObjData</procedure></A>(valObj: ValObj; mySelf: ValObj;
                       VAR resWho: TEXT;
                       VAR resFields: REF ObjFields;
                       VAR protected: BOOLEAN;
                       VAR sync: Sync)
  RAISES {ServerError, NetObj.Error, SharedObj.Error, Thread.Alerted} =
  VAR
    who: TEXT;
    fieldsOf1: REF ObjFields;
    resSize  : INTEGER;
    serialized: BOOLEAN;
  BEGIN
    who := valObj.Who( (*out*)protected, (*out*) serialized);
    IF Text.Empty(who) THEN who := &quot;someone&quot; END;
    resWho := &quot;clone of &quot; &amp; who;
    fieldsOf1 := valObj.Obtain(ObjEqual(valObj, mySelf));
    resSize := NUMBER(fieldsOf1^);
    resFields := NEW(REF ObjFields, resSize);
    resFields^ := fieldsOf1^;
    IF serialized THEN
      sync := NEW(Sync, mutex := NEW(Thread.Mutex))
    ELSE
      sync := NIL
    END;
  END CloneObjData;

PROCEDURE <A NAME="ToSimpleObj"><procedure>ToSimpleObj</procedure></A> (READONLY obj: ValObj; mySelf: ValObj): ValObj
  RAISES {ServerError, NetObj.Error, SharedObj.Error, Thread.Alerted} =
  VAR
    resWho: TEXT;
    resFields: REF ObjFields;
    protected: BOOLEAN;
    sync                 : Sync;
  BEGIN
    CloneObjData(obj, mySelf, resWho, resFields, protected, sync);
    WITH res = NEW(SimpleObj, who := resWho,
                   self := NEW(ValSimpleObj, simple := NIL),
                   fields := resFields,
                   protected := protected, sync := sync) DO
      res.self.simple := res;
      RETURN res.self;
    END;
  END ToSimpleObj;

PROCEDURE <A NAME="ToReplObj"><procedure>ToReplObj</procedure></A> (READONLY obj: ValObj; mySelf: ValObj;
                     READONLY updateMethods: ARRAY OF TEXT): ValObj
  RAISES {ServerError, NetObj.Error, SharedObj.Error, Thread.Alerted} =
  VAR
    resWho: TEXT;
    resFields: REF ObjFields;
    protected: BOOLEAN;
    sync                 : Sync;
    j  : INTEGER;
  BEGIN
    CloneObjData(obj, mySelf, resWho, resFields, protected, sync);
    (* why bother failing?  What's the big deal!?   It becomes
       serialized, that's all.
    IF sync = NIL THEN
      RaiseServerError(&quot;Replicated Objects must be serialized&quot;);
    END;
    *)

    FOR i := FIRST(resFields^) TO LAST(resFields^) DO
      resFields^[i].update := FALSE;
    END;
    FOR i := FIRST(updateMethods) TO LAST(updateMethods) DO
      j := FIRST(resFields^);
      WHILE j &lt;= LAST(resFields^) DO
        IF Text.Equal(updateMethods[i], resFields^[j].label) THEN
          TYPECASE resFields^[j].field OF
          | ValMeth =&gt; resFields^[j].update := TRUE; EXIT;
          ELSE
            RaiseServerError(&quot;field '&quot; &amp; updateMethods[i] &amp;
              &quot;' is not a method&quot;);
          END;
        END;
        INC(j);
      END;
      IF j &gt; LAST(resFields^) THEN
        RaiseServerError(&quot;update method '&quot; &amp; updateMethods[i] &amp;
          &quot;' does not exist&quot;);
      END;
    END;
    WITH res = NEW(ReplObjStd, who := resWho, protected := protected,
                   self := NEW(ValReplObj, replica := NIL),
                   fields := resFields).init() DO
      res.self.replica := res;
      RETURN res.self;
    END;
  END ToReplObj;

PROCEDURE <A NAME="ToRemObj"><procedure>ToRemObj</procedure></A> (READONLY obj: ValObj; mySelf: ValObj): ValObj
  RAISES {ServerError, NetObj.Error, SharedObj.Error, Thread.Alerted} =
  VAR
    resWho: TEXT;
    resFields: REF ObjFields;
    protected: BOOLEAN;
    sync                 : Sync;
  BEGIN
    CloneObjData(obj, mySelf, resWho, resFields, protected, sync);
    WITH res = NEW(RemObjServer, who := resWho,
                   self := NEW(ValRemObj, remote := NIL),
                   fields := resFields,
                   protected := protected, sync := sync) DO
      res.self.remote := res;
      RETURN res.self;
    END;
  END ToRemObj;
</PRE>**************************
 ValObj object wrapper functions
 **************************
<PRE>PROCEDURE <A NAME="ValRemObjWho"><procedure>ValRemObjWho</procedure></A>(self: ValRemObj;
                    VAR(*out*) protected, serialized: BOOLEAN): TEXT
          RAISES {NetObj.Error, Thread.Alerted} =
  BEGIN
    RETURN self.remote.Who(protected, serialized);
  END ValRemObjWho;

PROCEDURE <A NAME="ValRemObjSelect"><procedure>ValRemObjSelect</procedure></A>(self: ValRemObj;
                    label: TEXT; internal: BOOLEAN; VAR hint: INTEGER): Val
          RAISES {Error, Exception, ServerError, SharedObj.Error,
                  NetObj.Error, Thread.Alerted} =
  BEGIN
    RETURN self.remote.Select(label, internal, hint);
  END ValRemObjSelect;

PROCEDURE <A NAME="ValRemObjInvoke"><procedure>ValRemObjInvoke</procedure></A>(self: ValRemObj;
                    label: TEXT; argNo: INTEGER; READONLY args: Vals;
               internal: BOOLEAN; VAR hint: INTEGER): Val
          RAISES {Error, Exception, ServerError, SharedObj.Error,
                  NetObj.Error, Thread.Alerted} =
  BEGIN
    RETURN self.remote.Invoke(label, argNo, args, internal, hint);
  END ValRemObjInvoke;

PROCEDURE <A NAME="ValRemObjUpdate"><procedure>ValRemObjUpdate</procedure></A>(self: ValRemObj;
                    label: TEXT; val: Val; internal: BOOLEAN;
                       VAR hint: INTEGER)
          RAISES {ServerError, SharedObj.Error,
                  NetObj.Error, Thread.Alerted} =
  BEGIN
    self.remote.Update(label, val, internal, hint);
  END ValRemObjUpdate;

PROCEDURE <A NAME="ValRemObjRedirect"><procedure>ValRemObjRedirect</procedure></A>(self: ValRemObj;
                    val: Val; internal: BOOLEAN)
          RAISES {ServerError, SharedObj.Error,
                  NetObj.Error, Thread.Alerted} =
  BEGIN
    self.remote.Redirect(val, internal);
  END ValRemObjRedirect;

PROCEDURE <A NAME="ValRemObjHas"><procedure>ValRemObjHas</procedure></A>(self: ValRemObj;
                    label: TEXT; VAR hint: INTEGER): BOOLEAN
          RAISES {NetObj.Error, Thread.Alerted} =
  BEGIN
    RETURN self.remote.Has(label, hint);
  END ValRemObjHas;

PROCEDURE <A NAME="ValRemObjObtain"><procedure>ValRemObjObtain</procedure></A>(self: ValRemObj;
                    internal: BOOLEAN): REF ObjFields
  RAISES {ServerError, NetObj.Error, Thread.Alerted} =
  BEGIN
    RETURN self.remote.Obtain(internal);
  END ValRemObjObtain;

PROCEDURE <A NAME="ValReplObjWho"><procedure>ValReplObjWho</procedure></A>(self: ValReplObj;
                    VAR(*out*) protected, serialized: BOOLEAN): TEXT
          RAISES {SharedObj.Error} =
  BEGIN
    serialized := TRUE;
    RETURN self.replica.Who(protected);
  END ValReplObjWho;

PROCEDURE <A NAME="ValReplObjSelect"><procedure>ValReplObjSelect</procedure></A>(self: ValReplObj;
                    label: TEXT; &lt;*UNUSED*&gt;internal: BOOLEAN;
                    VAR hint: INTEGER): Val
          RAISES {Error, Exception, ServerError, SharedObj.Error} =
  BEGIN
    RETURN self.replica.Select(label, hint);
  END ValReplObjSelect;

PROCEDURE <A NAME="ValReplObjInvoke"><procedure>ValReplObjInvoke</procedure></A>(self: ValReplObj;
                    label: TEXT; argNo: INTEGER; READONLY args: Vals;
                    &lt;*UNUSED*&gt;internal: BOOLEAN; VAR hint: INTEGER): Val
          RAISES {Error, Exception, ServerError, SharedObj.Error} =
  BEGIN
    RETURN self.replica.Invoke(label, argNo, args, hint);
  END ValReplObjInvoke;

PROCEDURE <A NAME="ValReplObjUpdate"><procedure>ValReplObjUpdate</procedure></A>(self: ValReplObj;
                    label: TEXT; val: Val; internal: BOOLEAN;
                       VAR hint: INTEGER)
          RAISES {ServerError, SharedObj.Error} =
  BEGIN
    self.replica.Update(label, val, internal, hint);
  END ValReplObjUpdate;

PROCEDURE <A NAME="ValReplObjRedirect"><procedure>ValReplObjRedirect</procedure></A>(&lt;*UNUSED*&gt;self: ValReplObj;
                          &lt;*UNUSED*&gt;val: Val; &lt;*UNUSED*&gt;internal: BOOLEAN)
          RAISES {ServerError} =
  BEGIN
    RaiseServerError(&quot;Cannot Redirect Replicated Object Fields&quot;);
  END ValReplObjRedirect;

PROCEDURE <A NAME="ValReplObjHas"><procedure>ValReplObjHas</procedure></A>(self: ValReplObj;
                    label: TEXT; VAR hint: INTEGER): BOOLEAN
          RAISES {SharedObj.Error} =
  BEGIN
    RETURN self.replica.Has(label, hint);
  END ValReplObjHas;

PROCEDURE <A NAME="ValReplObjObtain"><procedure>ValReplObjObtain</procedure></A>(self: ValReplObj;
                    internal: BOOLEAN): REF ObjFields
  RAISES {ServerError, SharedObj.Error} =
  BEGIN
    RETURN self.replica.Obtain(internal);
  END ValReplObjObtain;

PROCEDURE <A NAME="ValSimpleObjWho"><procedure>ValSimpleObjWho</procedure></A>(self: ValSimpleObj;
                    VAR(*out*) protected, serialized: BOOLEAN): TEXT =
  BEGIN
    RETURN self.simple.Who(protected, serialized);
  END ValSimpleObjWho;

PROCEDURE <A NAME="ValSimpleObjSelect"><procedure>ValSimpleObjSelect</procedure></A>(self: ValSimpleObj;
                    label: TEXT; internal: BOOLEAN; VAR hint: INTEGER): Val
          RAISES {Error, Exception, ServerError, SharedObj.Error,
                  NetObj.Error, Thread.Alerted} =
  BEGIN
    RETURN self.simple.Select(label, internal, hint);
  END ValSimpleObjSelect;

PROCEDURE <A NAME="ValSimpleObjInvoke"><procedure>ValSimpleObjInvoke</procedure></A>(self: ValSimpleObj;
                    label: TEXT; argNo: INTEGER; READONLY args: Vals;
               internal: BOOLEAN; VAR hint: INTEGER): Val
          RAISES {Error, Exception, ServerError, SharedObj.Error,
                  NetObj.Error, Thread.Alerted} =
  BEGIN
    RETURN self.simple.Invoke(label, argNo, args, internal, hint);
  END ValSimpleObjInvoke;

PROCEDURE <A NAME="ValSimpleObjUpdate"><procedure>ValSimpleObjUpdate</procedure></A>(self: ValSimpleObj;
                    label: TEXT; val: Val; internal: BOOLEAN;
                       VAR hint: INTEGER)
          RAISES {ServerError, SharedObj.Error,
                  NetObj.Error, Thread.Alerted} =
  BEGIN
    self.simple.Update(label, val, internal, hint);
  END ValSimpleObjUpdate;

PROCEDURE <A NAME="ValSimpleObjRedirect"><procedure>ValSimpleObjRedirect</procedure></A>(self: ValSimpleObj;
                    val: Val; internal: BOOLEAN)
          RAISES {ServerError, SharedObj.Error,
                  NetObj.Error, Thread.Alerted} =
  BEGIN
    self.simple.Redirect(val, internal);
  END ValSimpleObjRedirect;

PROCEDURE <A NAME="ValSimpleObjHas"><procedure>ValSimpleObjHas</procedure></A>(self: ValSimpleObj;
                    label: TEXT; VAR hint: INTEGER): BOOLEAN =
  BEGIN
    RETURN self.simple.Has(label, hint);
  END ValSimpleObjHas;

PROCEDURE <A NAME="ValSimpleObjObtain"><procedure>ValSimpleObjObtain</procedure></A>(self: ValSimpleObj;
                    internal: BOOLEAN): REF ObjFields
  RAISES {ServerError} =
  BEGIN
    RETURN self.simple.Obtain(internal);
  END ValSimpleObjObtain;
</PRE>**************************
 object fields
 **************************
<PRE>PROCEDURE <A NAME="ObjWho"><procedure>ObjWho</procedure></A> (            self                 : RemObjServer;
                  VAR (*out*) protected, serialized: BOOLEAN       ): TEXT =
  BEGIN
    protected := self.protected;
    serialized := self.sync # NIL;
    RETURN self.who;
  END ObjWho;

PROCEDURE <A NAME="ReplObjWho"><procedure>ReplObjWho</procedure></A> (self: ReplObj;
                      VAR (*out*) protected: BOOLEAN ): TEXT =
  BEGIN
    protected := self.protected;
    RETURN self.who;
  END ReplObjWho;

PROCEDURE <A NAME="SimpleObjWho"><procedure>SimpleObjWho</procedure></A> (            self                 : SimpleObj;
                        VAR (*out*) protected, serialized: BOOLEAN    ): TEXT =
  BEGIN
    protected := self.protected;
    serialized := self.sync # NIL;
    RETURN self.who;
  END SimpleObjWho;

PROCEDURE <A NAME="ObjEqual"><procedure>ObjEqual</procedure></A> (v1, v2: ValObj): BOOLEAN =
  BEGIN
    IF v1 = NIL OR v2 = NIL THEN RETURN v1 = v2 END;

    TYPECASE v1 OF
    | ValRemObj (node1) =&gt;
        TYPECASE v2 OF
        | ValRemObj (node2) =&gt; RETURN node1.remote = node2.remote;
        ELSE
          RETURN FALSE;
        END;
    | ValReplObj (node1) =&gt;
        TYPECASE v2 OF
        | ValReplObj (node2) =&gt; RETURN node1.replica = node2.replica;
        ELSE
          RETURN FALSE;
        END;
    | ValSimpleObj (node1) =&gt;
        TYPECASE v2 OF
        | ValSimpleObj (node2) =&gt; RETURN node1.simple = node2.simple;
        ELSE
          RETURN FALSE;
        END;
    ELSE
      RETURN FALSE;
    END;
  END ObjEqual;

PROCEDURE <A NAME="ObjClone1"><procedure>ObjClone1</procedure></A> (valObj: ValObj; mySelf: ValObj): ValObj
  RAISES {ServerError, NetObj.Error, SharedObj.Error, Thread.Alerted} =
  VAR
    resWho, who: TEXT;
  VAR fieldsOf1: REF ObjFields;
  VAR
    resSize  : INTEGER;
    resFields: REF ObjFields;
  VAR
    protected, serialized: BOOLEAN;
    sync                 : Sync;
  BEGIN
    who := valObj.Who( (*out*)protected, (*out*) serialized);
    IF Text.Empty(who) THEN who := &quot;someone&quot; END;
    resWho := &quot;clone of &quot; &amp; who;
    fieldsOf1 := valObj.Obtain(ObjEqual(valObj, mySelf));
    resSize := NUMBER(fieldsOf1^);
    resFields := NEW(REF ObjFields, resSize);
    resFields^ := fieldsOf1^;
    IF serialized THEN
      sync := NEW(Sync, mutex := NEW(Thread.Mutex))
    ELSE
      sync := NIL
    END;
    (* Obliq++: made the new object a ValRemObj *)
    TYPECASE valObj OF
    | ValRemObj =&gt;
      WITH res = NEW(RemObjServer, who := resWho,
                     self := NEW(ValRemObj, remote := NIL),
                     fields := resFields,
                     protected := protected, sync := sync) DO
        res.self.remote := res;
        RETURN res.self;
      END;
    | ValReplObj =&gt;
      WITH res = NEW(ReplObjStd, who := resWho, protected := protected,
                     self := NEW(ValReplObj, replica := NIL),
                     fields := resFields).init() DO
        res.self.replica := res;
        RETURN res.self;
      END;
    | ValSimpleObj =&gt;
      WITH res = NEW(SimpleObj, who := resWho,
                     self := NEW(ValSimpleObj, simple := NIL),
                     fields := resFields,
                     protected := protected, sync := sync) DO
        res.self.simple := res;
        RETURN res.self;
      END;
    ELSE &lt;*ASSERT FALSE*&gt;
    END;
  END ObjClone1;

PROCEDURE <A NAME="ObjClone"><procedure>ObjClone</procedure></A> (READONLY valObjs: ARRAY OF ValObj; mySelf: ValObj):
  ValObj RAISES {ServerError, NetObj.Error, Thread.Alerted, SharedObj.Error} =
  VAR
    resWho, remWho: TEXT;
  VAR fieldsOfN: REF ARRAY OF REF ObjFields;
  VAR
    resSize, k          : INTEGER;
    ithFields, resFields: REF ObjFields;
  VAR
    protected, protected1, serialized, serialized1: BOOLEAN;
    sync                                          : Sync;
  BEGIN
    (* First, check to make sure they are all the same type *)
    TYPECASE valObjs[0] OF
    | ValRemObj =&gt;
      FOR i := 1 TO NUMBER(valObjs) - 1 DO
        TYPECASE valObjs[i] OF ValRemObj =&gt; (* ok *)
        ELSE
          RaiseServerError(&quot;Objects to be cloned must be of the same type&quot;);
        END;
      END;
    | ValReplObj =&gt;
      FOR i := 1 TO NUMBER(valObjs) - 1 DO
        TYPECASE valObjs[i] OF ValReplObj =&gt; (* ok *)
        ELSE
          RaiseServerError(&quot;Objects to be cloned must be of the same type&quot;);
        END;
      END;
    | ValSimpleObj =&gt;
      FOR i := 1 TO NUMBER(valObjs) - 1 DO
        TYPECASE valObjs[i] OF ValSimpleObj =&gt; (* ok *)
        ELSE
          RaiseServerError(&quot;Objects to be cloned must be of the same type&quot;);
        END;
      END;
    ELSE
      RaiseServerError(&quot;Arguments of clone must be objects&quot;);
    END;

    resWho := &quot;clone of&quot;;
    protected := FALSE;
    serialized := FALSE;
    fieldsOfN := NEW(REF ARRAY OF REF ObjFields, NUMBER(valObjs));
    FOR i := 0 TO NUMBER(valObjs) - 1 DO
      remWho := valObjs[i].Who( (*out*)protected1, (*out*) serialized1);
      IF i = 0 THEN
        protected := protected1;
        serialized := serialized1;
      END;
      IF Text.Empty(remWho) THEN remWho := &quot;someone&quot; END;
      resWho := resWho &amp; &quot; &quot; &amp; remWho;
      fieldsOfN^[i] := valObjs[i].Obtain(ObjEqual(valObjs[i], mySelf));
    END;
    resSize := 0;
    FOR i := 0 TO NUMBER(fieldsOfN^) - 1 DO
      ithFields := fieldsOfN^[i];
      INC(resSize, NUMBER(ithFields^));
    END;
    resFields := NEW(REF ObjFields, resSize);
    k := 0;
    FOR i := 0 TO NUMBER(fieldsOfN^) - 1 DO
      ithFields := fieldsOfN^[i];
      FOR j := 0 TO NUMBER(ithFields^) - 1 DO
        resFields^[k] := ithFields^[j];
        INC(k);
      END;
    END;
    IF NUMBER(fieldsOfN^) &gt; 1 THEN
      FOR i := 0 TO resSize - 1 DO
        FOR j := i + 1 TO resSize - 1 DO
          IF Text.Equal(resFields^[i].label, resFields^[j].label) THEN
            RaiseServerError(
              &quot;duplicated field on cloning: &quot; &amp; resFields^[i].label);
          END;
        END;
      END;
    END;
    IF serialized THEN
      sync := NEW(Sync, mutex := NEW(Thread.Mutex))
    ELSE
      sync := NIL
    END;
    TYPECASE valObjs[0] OF
    | ValRemObj =&gt;
      WITH res = NEW(RemObjServer, who := resWho,
                     self := NEW(ValRemObj, remote := NIL),
                     fields := resFields,
                     protected := protected, sync := sync) DO
        res.self.remote := res;
        RETURN res.self;
      END;
    | ValReplObj =&gt;
      WITH res = NEW(ReplObjStd, who := resWho, protected := protected,
                     self := NEW(ValReplObj, replica := NIL),
                     fields := resFields).init() DO
        res.self.replica := res;
        RETURN res.self;
      END;
    | ValSimpleObj =&gt;
      WITH res = NEW(SimpleObj, who := resWho,
                     self := NEW(ValSimpleObj, simple := NIL),
                     fields := resFields,
                     protected := protected, sync := sync) DO
        res.self.simple := res;
        RETURN res.self;
      END;
    ELSE &lt;*ASSERT FALSE*&gt;
    END;
  END ObjClone;

PROCEDURE <A NAME="SetObjPickler"><procedure>SetObjPickler</procedure></A>(obj: ValObj; picklerIn: ValSimpleObj;
                        picklerOut: ValSimpleObj; mySelf: ValObj)
  RAISES {ServerError, NetObj.Error, SharedObj.Error,
          Thread.Alerted} =
  VAR
    objFields := obj.Obtain(ObjEqual(obj, mySelf));
    pklInFields := picklerIn.Obtain(ObjEqual(obj, mySelf));
    pklOutFields := picklerOut.Obtain(ObjEqual(obj, mySelf));

    inFields := NEW(REF ObjFields, NUMBER(objFields^));
    outFields := NEW(REF ObjFields, NUMBER(objFields^));
    hint: INTEGER;
    numFields := 0;
  BEGIN
    TYPECASE obj OF
    | ValSimpleObj, ValReplObj =&gt; (*ok*)
    ELSE
      RaiseServerError(&quot;Can only set picklers for simple or &quot; &amp;
        &quot;replicated objects&quot;);
    END;

    IF NUMBER(pklInFields^) # NUMBER(pklOutFields^) THEN
      RaiseServerError(&quot;in and out pickler objects must have the same &quot; &amp;
        &quot;set of fields&quot;);
    END;
    IF NUMBER(objFields^) &lt; NUMBER(pklInFields^) THEN
      RaiseServerError(&quot;pickler objects have extra fields&quot;);
    END;

    (* want to have the inFields and outFields be in the same order as
       the objects fields, for later efficient use *)
    FOR i := 0 TO NUMBER(objFields^) - 1 DO
      TYPECASE objFields[i].field OF
      | ValMeth =&gt; (* ignore *)
        IF FieldsHave (pklInFields, objFields[i].label, hint) OR
          FieldsHave (pklOutFields, objFields[i].label, hint) THEN
          RaiseServerError(&quot;field in pickle object corresponds to &quot; &amp;
            &quot;method field in object: &quot; &amp; objFields[i].label);
        END;
        (* put some dummy values for simplicity *)
        inFields[i].label := objFields[i].label;
        inFields[i].field := valOk;
        outFields[i].label := objFields[i].label;
        outFields[i].field := valOk;
      | ValAlias =&gt; RaiseServerError(&quot;Unexpected Alias field in &quot; &amp;
        &quot;replicated object: &quot; &amp; objFields[i].label);
      ELSE
        IF NOT FieldsHave(pklInFields, objFields[i].label, hint) THEN
          RaiseServerError(&quot;pickler 'in' object missing field: &quot; &amp;
            objFields[i].label);
        END;
        inFields[i].label := objFields[i].label;
        TYPECASE pklInFields[hint].field OF
        | ValMeth(meth) =&gt;
          IF meth.meth.bindersNo # 3 THEN
            RaiseServerError(BadArgsNoMsg(3, meth.meth.bindersNo,
                                          &quot;pickle 'in' method&quot;,
                                          objFields[i].label));
          END;
          inFields[i].field := meth;
        ELSE
          RaiseServerError(&quot;pickler 'in' field must be a method: &quot; &amp;
            objFields[i].label);
        END;
        IF NOT FieldsHave(pklOutFields, objFields[i].label, hint) THEN
          RaiseServerError(&quot;pickler 'out' object missing field: &quot; &amp;
            objFields[i].label);
        END;
        outFields[i].label := objFields[i].label;
        TYPECASE pklOutFields[hint].field OF
        | ValMeth(meth) =&gt;
          IF meth.meth.bindersNo # 3 THEN
            RaiseServerError(BadArgsNoMsg(3, meth.meth.bindersNo,
                                          &quot;pickler 'out' method&quot;,
                                          objFields[i].label));
          END;
          outFields[i].field := meth;
        ELSE
          RaiseServerError(&quot;pickler 'out' field must be a method: &quot; &amp;
            objFields[i].label);
        END;
        INC(numFields);
      END;
    END;

    IF numFields # NUMBER(pklOutFields^) THEN
      RaiseServerError(&quot;extra fields in pickler objects&quot;);
    END;

    TYPECASE obj OF
    | ValSimpleObj(simple) =&gt;
      simple.simple.pickleIn := inFields;
      simple.simple.pickleOut := outFields;
    | ValReplObj(repl) =&gt;
      repl.replica.pickleIn := inFields;
      repl.replica.pickleOut := outFields;
    ELSE
      &lt;*ASSERT FALSE*&gt;
    END;
  END SetObjPickler;

PROCEDURE <A NAME="BadArgsNoMsg"><procedure>BadArgsNoMsg</procedure></A> (desired, found          : INTEGER;
                        routineKind, routineName: TEXT     ): TEXT =
  VAR msg: TEXT;
  BEGIN
    msg := &quot;Expecting &quot; &amp; Fmt.Int(desired);
    IF desired = 1 THEN
      msg := msg &amp; &quot; argument&quot;;
    ELSE
      msg := msg &amp; &quot; arguments&quot;;
    END;
    msg := msg &amp; &quot;, not &quot; &amp; Fmt.Int(found);
    IF NOT Text.Empty(routineKind) THEN
      msg := msg &amp; &quot;, for &quot; &amp; routineKind &amp; &quot;: &quot; &amp; routineName;
    END;
    RETURN msg;
  END BadArgsNoMsg;

PROCEDURE <A NAME="NonRemObjHookGet"><procedure>NonRemObjHookGet</procedure></A> (self: NonRemObjHookServer): ValObj =
  BEGIN
    RETURN self.replObj;
  END NonRemObjHookGet;

PROCEDURE <A NAME="NonRemObjHookInit"><procedure>NonRemObjHookInit</procedure></A> (self: NonRemObjHookServer;
                             replObj: ValObj): NonRemObjHook =
  BEGIN
    self.replObj := replObj;
    RETURN self;
  END NonRemObjHookInit;

&lt;*INLINE*&gt; PROCEDURE <A NAME="FindField"><procedure>FindField</procedure></A> (    label : TEXT;
                                    fields: REF ObjFields;
                                VAR hint  : INTEGER        ): Val
  RAISES {ServerError} =
  VAR fieldIndex := -1;
  BEGIN
    WITH fieldsNo = NUMBER(fields^) DO
      IF (hint &gt;= 0) AND (hint &lt; fieldsNo)
           AND Text.Equal(label, fields^[hint].label) THEN
        (* use hint as is *)
      ELSE
        FOR i := 0 TO fieldsNo - 1 DO
          IF Text.Equal(label, fields^[i].label) THEN
            fieldIndex := i;
            EXIT;
          END;
        END;
        IF fieldIndex = -1 THEN
          RaiseServerError(&quot;Field not found in object: &quot; &amp; label);
        END;
        hint := fieldIndex;
      END;
    END;
    RETURN fields^[hint].field;
  END FindField;

PROCEDURE <A NAME="ObjSelect"><procedure>ObjSelect</procedure></A> (               self    : RemObjServer;
                                    label   : TEXT;
                                    internal: BOOLEAN;
                     VAR (*in-out*) hint    : INTEGER       ): Val
  RAISES {ServerError, Error, Exception, SharedObj.Error, NetObj.Error,
          Thread.Alerted} =
  VAR
    lock    : BOOLEAN;
    fields  : REF ObjFields;
    newEnv  : Env;
    fieldVal: Val;
    objMu   : Thread.Mutex;
  BEGIN
    lock := (NOT internal) AND (self.sync # NIL);
    IF lock THEN objMu := self.sync.mutex; Thread.Acquire(objMu) END;
    TRY

      fields := self.fields;
      fieldVal := FindField(label, fields, hint);
      TYPECASE fieldVal OF
      | ValMeth (meth) =&gt;
          (* Consider a method with zero parameters as a field. *)
          IF meth.meth.bindersNo - 1 # 0 THEN
            RaiseServerError(
              BadArgsNoMsg(meth.meth.bindersNo - 1, 0, &quot;method&quot;, label));
          END;
          newEnv := NEW(LocalEnv, name := meth.meth.binders.first,
                        val := self.self, rest := NIL);
          RETURN ObEval.Term(meth.meth.body, (*in-out*) newEnv,
                             meth.global, self.self);
      | ValAlias (alias) =&gt;
        RETURN alias.obj.Select(alias.label, ObjEqual(alias.obj, self.self),
                                (*var*) alias.labelIndexHint);
      ELSE
        RETURN fieldVal;
      END;

    FINALLY
      IF lock THEN Thread.Release(objMu) END;
    END;
  END ObjSelect;

PROCEDURE <A NAME="SimpleObjSelect"><procedure>SimpleObjSelect</procedure></A> (    self    : SimpleObj;
                               label   : TEXT;
                               internal: BOOLEAN;
                           VAR hint    : INTEGER    ): Val
  RAISES {ServerError, Error, Exception, SharedObj.Error, NetObj.Error,
          Thread.Alerted} =
  VAR
    lock    : BOOLEAN;
    fields  : REF ObjFields;
    newEnv  : Env;
    fieldVal: Val;
    objMu   : Thread.Mutex;
  BEGIN
    lock := (NOT internal) AND (self.sync # NIL);
    IF lock THEN objMu := self.sync.mutex; Thread.Acquire(objMu) END;
    TRY

      fields := self.fields;
      fieldVal := FindField(label, fields, hint);
      TYPECASE fieldVal OF
      | ValMeth (meth) =&gt;
          (* Consider a method with zero parameters as a field. *)
          IF meth.meth.bindersNo - 1 # 0 THEN
            RaiseServerError(
              BadArgsNoMsg(meth.meth.bindersNo - 1, 0, &quot;method&quot;, label));
          END;
          newEnv := NEW(LocalEnv, name := meth.meth.binders.first,
                        val := self.self, rest := NIL);
          RETURN ObEval.Term(meth.meth.body, (*in-out*) newEnv,
                             meth.global, self.self);
      | ValAlias (alias) =&gt;
        RETURN alias.obj.Select(alias.label, ObjEqual(alias.obj, self.self),
                                (*var*) alias.labelIndexHint);
      ELSE
        RETURN fieldVal;
      END;

    FINALLY
      IF lock THEN Thread.Release(objMu) END;
    END;
  END SimpleObjSelect;

PROCEDURE <A NAME="ReplObjSelect"><procedure>ReplObjSelect</procedure></A> (    self    : ReplObj;
                             label   : TEXT;
                         VAR hint    : INTEGER        ): Val
  RAISES {Error, Exception, ServerError, SharedObj.Error} =
  VAR
    fields                 := self.fields;
    newEnv  : Env;
    fieldVal: Val;
  BEGIN
    fieldVal := FindField(label, fields, hint);
    TYPECASE fieldVal OF
    | ValMeth (meth) =&gt;
        (* Consider a method with zero parameters as a field. *)
        IF meth.meth.bindersNo - 1 # 0 THEN
          RaiseServerError(
            BadArgsNoMsg(meth.meth.bindersNo - 1, 0, &quot;method&quot;, label));
        END;
        (* If it is not an update method, we can execute it here.  If it is
           an update method, we must call InvokeUpdate *)
        IF fields^[hint].update THEN
          VAR args := ARRAY [0..0] OF Val{NIL};
          BEGIN
            RETURN self.InvokeUpdate(label, 0, args, hint);
          END;
        ELSE
          newEnv := NEW(LocalEnv, name := meth.meth.binders.first,
                        val := self.self, rest := NIL);
          RETURN ObEval.Term(meth.meth.body, (*in-out*) newEnv,
                             meth.global, self.self);
        END;
    | ValAlias =&gt;
      &lt;*ASSERT FALSE*&gt;(* should not be any aliases on replicated object
                         fields *)
    ELSE
      RETURN fieldVal;
    END;
  END ReplObjSelect;

PROCEDURE <A NAME="FieldsHave"><procedure>FieldsHave</procedure></A> (fields: REF ObjFields; label: TEXT; VAR hint: INTEGER):
  BOOLEAN =
  BEGIN
    FOR i := 0 TO NUMBER(fields^) - 1 DO
      IF Text.Equal(label, fields^[i].label) THEN
        hint := i;
        RETURN TRUE;
      END;
    END;
    RETURN FALSE;
  END FieldsHave;

PROCEDURE <A NAME="ObjHas"><procedure>ObjHas</procedure></A> (self: RemObjServer; label: TEXT; VAR hint: INTEGER):
  BOOLEAN =
  BEGIN
    RETURN FieldsHave(self.fields, label, hint);
  END ObjHas;

PROCEDURE <A NAME="ReplObjHas"><procedure>ReplObjHas</procedure></A> (self: ReplObj; label: TEXT; VAR hint: INTEGER):
  BOOLEAN =
  BEGIN
    RETURN FieldsHave(self.fields, label, hint);
  END ReplObjHas;

PROCEDURE <A NAME="SimpleObjHas"><procedure>SimpleObjHas</procedure></A> (self: SimpleObj; label: TEXT; VAR hint: INTEGER):
  BOOLEAN =
  BEGIN
    RETURN FieldsHave(self.fields, label, hint);
  END SimpleObjHas;

PROCEDURE <A NAME="ObjInvoke"><procedure>ObjInvoke</procedure></A> (               self    : RemObjServer;
                                    label   : TEXT;
                                    argsNo  : INTEGER;
                     READONLY       args    : Vals;
                                    internal: BOOLEAN;
                     VAR (*in-out*) hint    : INTEGER       ): Val
  RAISES {ServerError, Error, Exception, SharedObj.Error, NetObj.Error,
          Thread.Alerted} =
  VAR
    lock      : BOOLEAN;
    fields    : REF ObjFields;
    binderList: ObTree.IdeList;
    newEnv    : Env;
    fieldVal  : Val;
    objMu     : Thread.Mutex;
  BEGIN
    lock := (NOT internal) AND (self.sync # NIL);
    IF lock THEN objMu := self.sync.mutex; Thread.Acquire(objMu) END;
    TRY

      fields := self.fields;
      fieldVal := FindField(label, fields, hint);
      TYPECASE fieldVal OF
      | ValMeth (meth) =&gt;
          IF meth.meth.bindersNo - 1 # argsNo THEN
            RaiseServerError(BadArgsNoMsg(meth.meth.bindersNo - 1, argsNo,
                                          &quot;method&quot;, label));
          END;
          binderList := meth.meth.binders;
          newEnv := NEW(LocalEnv, name := binderList.first,
                        val := self.self, rest := NIL);
          binderList := binderList.rest;
          FOR i := 0 TO argsNo - 1 DO
            newEnv := NEW(LocalEnv, name := binderList.first,
                          val := args[i], rest := newEnv);
            binderList := binderList.rest;
          END;
          RETURN ObEval.Term(meth.meth.body, (*in-out*) newEnv,
                             meth.global, self.self);
      | ValAlias (alias) =&gt;
        RETURN alias.obj.Invoke(alias.label, argsNo, args,
                                ObjEqual(alias.obj, self.self),
                                (*var*) alias.labelIndexHint);
      ELSE
        RaiseServerError(&quot;Field used as a method: &quot; &amp; label);
        &lt;*ASSERT FALSE*&gt;
      END;
    FINALLY
      IF lock THEN Thread.Release(objMu) END;
    END;
  END ObjInvoke;

PROCEDURE <A NAME="SimpleObjInvoke"><procedure>SimpleObjInvoke</procedure></A> (         self    : SimpleObj;
                                    label   : TEXT;
                                    argsNo  : INTEGER;
                           READONLY args    : Vals;
                                    internal: BOOLEAN;
                           VAR      hint    : INTEGER    ): Val
  RAISES {ServerError, Error, Exception, SharedObj.Error, NetObj.Error,
          Thread.Alerted} =
  VAR
    lock      : BOOLEAN;
    fields    : REF ObjFields;
    binderList: ObTree.IdeList;
    newEnv    : Env;
    fieldVal  : Val;
    objMu     : Thread.Mutex;
  BEGIN
    lock := (NOT internal) AND (self.sync # NIL);
    IF lock THEN objMu := self.sync.mutex; Thread.Acquire(objMu) END;
    TRY

      fields := self.fields;
      fieldVal := FindField(label, fields, hint);
      TYPECASE fieldVal OF
      | ValMeth (meth) =&gt;
          IF meth.meth.bindersNo - 1 # argsNo THEN
            RaiseServerError(BadArgsNoMsg(meth.meth.bindersNo - 1, argsNo,
                                          &quot;method&quot;, label));
          END;
          binderList := meth.meth.binders;
          newEnv := NEW(LocalEnv, name := binderList.first,
                        val := self.self, rest := NIL);
          binderList := binderList.rest;
          FOR i := 0 TO argsNo - 1 DO
            newEnv := NEW(LocalEnv, name := binderList.first,
                          val := args[i], rest := newEnv);
            binderList := binderList.rest;
          END;
          RETURN ObEval.Term(meth.meth.body, (*in-out*) newEnv,
                             meth.global, self.self);
      | ValAlias (alias) =&gt;
        RETURN alias.obj.Invoke(alias.label, argsNo, args,
                                ObjEqual(alias.obj, self.self),
                                (*var*) alias.labelIndexHint);
      ELSE
        RaiseServerError(&quot;Field used as a method: &quot; &amp; label);
        &lt;*ASSERT FALSE*&gt;
      END;
    FINALLY
      IF lock THEN Thread.Release(objMu) END;
    END;
  END SimpleObjInvoke;

PROCEDURE <A NAME="ReplObjInvoke"><procedure>ReplObjInvoke</procedure></A> (         self    : ReplObj;
                                  label   : TEXT;
                                  argsNo  : INTEGER;
                         READONLY args    : Vals;
                         VAR      hint    : INTEGER        ): Val
  RAISES {Error, Exception, ServerError, SharedObj.Error} =
  VAR
    fields    : REF ObjFields;
    binderList: ObTree.IdeList;
    newEnv    : Env;
    fieldVal  : Val;
  BEGIN
    fields := self.fields;
    fieldVal := FindField(label, fields, hint);

    (* If it's an update method, do perform the update instead *)
    IF fields^[hint].update THEN
      RETURN self.InvokeUpdate(label, argsNo, args, hint);
    END;

    TYPECASE fieldVal OF
    | ValMeth (meth) =&gt;
        IF meth.meth.bindersNo - 1 # argsNo THEN
          RaiseServerError(
            BadArgsNoMsg(meth.meth.bindersNo - 1, argsNo, &quot;method&quot;, label));
        END;
        binderList := meth.meth.binders;
        newEnv := NEW(LocalEnv, name := binderList.first, val := self.self,
                      rest := NIL);
        binderList := binderList.rest;
        FOR i := 0 TO argsNo - 1 DO
          newEnv := NEW(LocalEnv, name := binderList.first, val := args[i],
                        rest := newEnv);
          binderList := binderList.rest;
        END;
        RETURN ObEval.Term(meth.meth.body, (*in-out*) newEnv,
                           meth.global, self.self);
    | ValAlias =&gt;        &lt;*ASSERT FALSE*&gt;(* should never happen *)
    ELSE
      RaiseServerError(&quot;Field used as a method: &quot; &amp; label);
      &lt;*ASSERT FALSE*&gt;
    END;
  END ReplObjInvoke;

PROCEDURE <A NAME="ReplObjInvokeUpdate"><procedure>ReplObjInvokeUpdate</procedure></A> (         self    : ReplObj;
                                        label   : TEXT;
                                        argsNo  : INTEGER;
                               READONLY args    : Vals;
                                    VAR hint    : INTEGER        ): Val
  RAISES {Error, Exception, ServerError} =
  VAR
    fields    : REF ObjFields;
    binderList: ObTree.IdeList;
    newEnv    : Env;
    fieldVal  : Val;
  BEGIN
    fields := self.fields;
    fieldVal := FindField(label, fields, hint);

    TYPECASE fieldVal OF
    | ValMeth (meth) =&gt;
        IF meth.meth.bindersNo - 1 # argsNo THEN
          RaiseServerError(
            BadArgsNoMsg(meth.meth.bindersNo - 1, argsNo, &quot;method&quot;, label));
        END;
        binderList := meth.meth.binders;
        newEnv := NEW(LocalEnv, name := binderList.first, val := self.self,
                      rest := NIL);
        binderList := binderList.rest;
        FOR i := 0 TO argsNo - 1 DO
          newEnv := NEW(LocalEnv, name := binderList.first, val := args[i],
                        rest := newEnv);
          binderList := binderList.rest;
        END;
        RETURN ObEval.Term(meth.meth.body, (*in-out*) newEnv,
                           meth.global, self.self);
    | ValAlias =&gt;        &lt;*ASSERT FALSE*&gt;(* should never happen *)
    ELSE
      RaiseServerError(&quot;Field used as a method: &quot; &amp; label);
      &lt;*ASSERT FALSE*&gt;
    END;
  END ReplObjInvokeUpdate;

PROCEDURE <A NAME="ObjUpdate"><procedure>ObjUpdate</procedure></A> (               self    : RemObjServer;
                                    label   : TEXT;
                                    val     : Val;
                                    internal: BOOLEAN;
                     VAR (*in-out*) hint    : INTEGER       )
  RAISES {ServerError, SharedObj.Error, NetObj.Error, Thread.Alerted} =
  VAR
    lock                : BOOLEAN;
    fields              : REF ObjFields;
    objMu               : Thread.Mutex;
  BEGIN
    lock := (NOT internal) AND (self.sync # NIL);
    IF lock THEN objMu := self.sync.mutex; Thread.Acquire(objMu) END;
    TRY

      IF self.protected AND (NOT internal) THEN
        RaiseServerError(&quot;Cannot update protected object&quot;);
      END;
      fields := self.fields;
      EVAL FindField(label, fields, hint);

      TYPECASE fields^[hint].field OF
      | ValAlias (alias) =&gt;
          TYPECASE val OF
          | ValAlias =&gt; fields^[hint].field := val
          ELSE
            alias.obj.Update(alias.label, val,
                             ObjEqual(alias.obj, self.self),
                             (*var*) alias.labelIndexHint);
          END;
      ELSE
        fields^[hint].field := val;
      END;

    FINALLY
      IF lock THEN Thread.Release(objMu) END;
    END;
  END ObjUpdate;

PROCEDURE <A NAME="SimpleObjUpdate"><procedure>SimpleObjUpdate</procedure></A> (    self    : SimpleObj;
                               label   : TEXT;
                               val     : Val;
                               internal: BOOLEAN;
                           VAR hint    : INTEGER    )
  RAISES {ServerError, SharedObj.Error, NetObj.Error, Thread.Alerted} =
  VAR
    lock                : BOOLEAN;
    fields              : REF ObjFields;
    objMu               : Thread.Mutex;
  BEGIN
    lock := (NOT internal) AND (self.sync # NIL);
    IF lock THEN objMu := self.sync.mutex; Thread.Acquire(objMu) END;
    TRY

      IF self.protected AND (NOT internal) THEN
        RaiseServerError(&quot;Cannot update protected object&quot;);
      END;
      fields := self.fields;
      EVAL FindField(label, fields, hint);

      TYPECASE fields^[hint].field OF
      | ValAlias (alias) =&gt;
          TYPECASE val OF
          | ValAlias =&gt; fields^[hint].field := val
          ELSE
            alias.obj.Update(alias.label, val,
                             ObjEqual(alias.obj, self.self),
                             (*var*) alias.labelIndexHint);
          END;
      ELSE
        fields^[hint].field := val;
      END;

    FINALLY
      IF lock THEN Thread.Release(objMu) END;
    END;
  END SimpleObjUpdate;

PROCEDURE <A NAME="ReplObjUpdate"><procedure>ReplObjUpdate</procedure></A> (    self    : ReplObj;
                             label   : TEXT;
                             val     : Val;
                             internal: BOOLEAN;
                         VAR hint    : INTEGER        )
  RAISES {ServerError} =
  VAR
    fields              : REF ObjFields;
  BEGIN
    IF self.protected AND (NOT internal) THEN
      RaiseServerError(&quot;Cannot update protected object&quot;);
    END;

    TYPECASE val OF
    | ValAlias =&gt;
      RaiseServerError(&quot;Cannot alias fields in a replicated object&quot;);
    ELSE
    END;

    fields := self.fields;
    EVAL FindField(label, fields, hint);

    TYPECASE fields^[hint].field OF
    | ValAlias =&gt; &lt;* ASSERT FALSE *&gt; (* should be impossible *)
    ELSE
      fields^[hint].field := val;
    END;
  END ReplObjUpdate;

PROCEDURE <A NAME="ObjRedirect"><procedure>ObjRedirect</procedure></A> (self: RemObjServer; val: Val; internal: BOOLEAN)
  RAISES {ServerError, SharedObj.Error, NetObj.Error, Thread.Alerted} =
  VAR
    lock             : BOOLEAN;
    fields, newFields: REF ObjFields;
    fieldsNo         : INTEGER;
    label            : TEXT;
    hint             : INTEGER;
    objMu            : Thread.Mutex;
    valObj           : ValObj;
  BEGIN
    TYPECASE val OF ValObj(vo) =&gt; valObj := vo ELSE
      RaiseServerError(&quot;Redirection target must be an object&quot;);
    END;

    lock := (NOT internal) AND (self.sync # NIL);
    IF lock THEN objMu := self.sync.mutex; Thread.Acquire(objMu) END;
    TRY
      IF self.protected AND (NOT internal) THEN
        RaiseServerError(&quot;Cannot redirect protected object&quot;);
      END;
      fields := self.fields;
      fieldsNo := NUMBER(fields^);
      newFields := NEW(REF ObjFields, fieldsNo);
      FOR i := 0 TO fieldsNo - 1 DO
        label := fields^[i].label;
        newFields^[i].label := label;
        IF valObj.Has(label, (*in-out*) hint) THEN
          newFields^[i].field :=
              NEW(ValAlias, label := label, labelIndexHint := hint,
                  obj := valObj);
        ELSE
          RaiseServerError(&quot;Field not found in object on redirection: &quot; &amp;
            label);
        END;
        self.fields := newFields; (* atomic swap *)
      END;

    FINALLY
      IF lock THEN Thread.Release(objMu) END;
    END;
  END ObjRedirect;

PROCEDURE <A NAME="SimpleObjRedirect"><procedure>SimpleObjRedirect</procedure></A> (self: SimpleObj; val: Val; internal: BOOLEAN)
  RAISES {ServerError, SharedObj.Error, NetObj.Error, Thread.Alerted} =
  VAR
    lock             : BOOLEAN;
    fields, newFields: REF ObjFields;
    fieldsNo         : INTEGER;
    label            : TEXT;
    hint             : INTEGER;
    objMu            : Thread.Mutex;
    valObj           : ValObj;
  BEGIN
    TYPECASE val OF ValObj(vo) =&gt; valObj := vo ELSE
      RaiseServerError(&quot;Redirection target must be an object&quot;);
    END;

    lock := (NOT internal) AND (self.sync # NIL);
    IF lock THEN objMu := self.sync.mutex; Thread.Acquire(objMu) END;
    TRY
      IF self.protected AND (NOT internal) THEN
        RaiseServerError(&quot;Cannot redirect protected object&quot;);
      END;
      fields := self.fields;
      fieldsNo := NUMBER(fields^);
      newFields := NEW(REF ObjFields, fieldsNo);
      FOR i := 0 TO fieldsNo - 1 DO
        label := fields^[i].label;
        newFields^[i].label := label;
        IF valObj.Has(label, (*in-out*) hint) THEN
          newFields^[i].field :=
              NEW(ValAlias, label := label, labelIndexHint := hint,
                  obj := valObj);
        ELSE
          RaiseServerError(
              &quot;Field not found in object on redirection: &quot; &amp; label);
        END;
        self.fields := newFields; (* atomic swap *)
      END;

    FINALLY
      IF lock THEN Thread.Release(objMu) END;
    END;
  END SimpleObjRedirect;

PROCEDURE <A NAME="ObjObtain"><procedure>ObjObtain</procedure></A> (self: RemObjServer; internal: BOOLEAN): REF ObjFields
  RAISES {ServerError} =
  VAR
    lock : BOOLEAN;
    objMu: Thread.Mutex;
  BEGIN
    lock := (NOT internal) AND (self.sync # NIL);
    IF lock THEN objMu := self.sync.mutex; Thread.Acquire(objMu) END;
    TRY
      IF self.protected AND (NOT internal) THEN
        RaiseServerError(&quot;Cannot obtain protected object&quot;);
      END;
      RETURN self.fields;

    FINALLY
      IF lock THEN Thread.Release(objMu) END;
    END;
  END ObjObtain;

PROCEDURE <A NAME="ReplObjObtain"><procedure>ReplObjObtain</procedure></A> (self: ReplObj; internal: BOOLEAN):
  REF ObjFields RAISES {ServerError} =
  BEGIN
    IF self.protected AND (NOT internal) THEN
      RaiseServerError(&quot;Cannot obtain protected object&quot;);
    END;
    RETURN self.fields;
  END ReplObjObtain;

PROCEDURE <A NAME="SimpleObjObtain"><procedure>SimpleObjObtain</procedure></A> (self: SimpleObj; internal: BOOLEAN): REF ObjFields
  RAISES {ServerError} =
  VAR
    lock : BOOLEAN;
    objMu: Thread.Mutex;
  BEGIN
    lock := (NOT internal) AND (self.sync # NIL);
    IF lock THEN objMu := self.sync.mutex; Thread.Acquire(objMu) END;
    TRY
      IF self.protected AND (NOT internal) THEN
        RaiseServerError(&quot;Cannot obtain protected object&quot;);
      END;
      RETURN self.fields;

    FINALLY
      IF lock THEN Thread.Release(objMu) END;
    END;
  END SimpleObjObtain;

PROCEDURE <A NAME="ReplObjInit"><procedure>ReplObjInit</procedure></A> (self: ReplObj): ReplObj =
  BEGIN
    RETURN self;
  END ReplObjInit;

PROCEDURE <A NAME="NewAlias"><procedure>NewAlias</procedure></A> (obj: ValObj; label: TEXT; location: SynLocation.T):
  ValAlias RAISES {Error, Exception} =
  VAR
    hint    : INTEGER;
    hasLabel          := FALSE;
  BEGIN
    TRY
      hasLabel := obj.Has(label, (*var*) hint);
      IF hasLabel THEN
        RETURN NEW(ValAlias, label := label, labelIndexHint := hint,
                   obj := obj);
      ELSE
        RaiseError(&quot;Field not found in object: &quot; &amp; label, location);
        &lt;*ASSERT FALSE*&gt;
      END;
    EXCEPT
    | NetObj.Error (atoms) =&gt;
        RaiseNetException(&quot;on remote object access&quot;, atoms, location);
      &lt;*ASSERT FALSE*&gt;
    | SharedObj.Error (atoms) =&gt;
        RaiseSharedException(
          &quot;on replicated object access&quot;, atoms, location);
      &lt;*ASSERT FALSE*&gt;
    | Thread.Alerted =&gt;
        RaiseException(threadAlerted, &quot;on remote object access&quot;, location);
      &lt;*ASSERT FALSE*&gt;
    END;
  END NewAlias;

PROCEDURE <A NAME="EngineWho"><procedure>EngineWho</procedure></A> (self: RemEngineServer): TEXT RAISES {} =
  BEGIN
    RETURN self.who;
  END EngineWho;

PROCEDURE <A NAME="EngineEval"><procedure>EngineEval</procedure></A> (self: RemEngineServer; proc: Val; mySelf: ValObj):
  Val RAISES {Error, Exception, ServerError} =
  VAR
    newEnv : Env;
    newGlob: GlobalEnv;
  BEGIN
    TYPECASE proc OF
    | ValFun (clos) =&gt;
        IF 1 # clos.fun.bindersNo THEN
          RaiseServerError(
            &quot;Engine needs a procedure of 1 argument as argument&quot;);
        END;
        newGlob := clos.global;
        newEnv := NEW(LocalEnv, name := clos.fun.binders.first,
                      val := self.arg, rest := NIL);
        RETURN ObEval.Term(clos.fun.body, (*in-out*) newEnv,
                           newGlob, mySelf);
    ELSE
      RaiseServerError(&quot;Engine needs a procedure as argument&quot;);
      &lt;*ASSERT FALSE*&gt;
    END;
  END EngineEval;

PROCEDURE <A NAME="NewFileSystem"><procedure>NewFileSystem</procedure></A> (readOnly: BOOLEAN): ValFileSystem =
  BEGIN
    RETURN NEW(ValFileSystem, picklable := FALSE,
               what := &quot;&lt;FileSystem at &quot; &amp; machineAddress &amp; &quot;&gt;&quot;,
               tag := &quot;FileSystem&quot;,
               remote := NEW(RemFileSystemServer, readOnly := readOnly));
  END NewFileSystem;

PROCEDURE <A NAME="FileSystemIs"><procedure>FileSystemIs</procedure></A> (self: ValFileSystem; other: ValAnything): BOOLEAN =
  BEGIN
    TYPECASE other OF
    | ValFileSystem (oth) =&gt; RETURN self.remote = oth.remote;
    ELSE
      RETURN FALSE;
    END;
  END FileSystemIs;

PROCEDURE <A NAME="FileSystemOpenRead"><procedure>FileSystemOpenRead</procedure></A> (&lt;*UNUSED*&gt; self    : RemFileSystemServer;
                                         fileName: TEXT                 ):
  Rd.T RAISES {ServerError} =
  BEGIN
    TRY
      RETURN FileRd.Open(fileName);
    EXCEPT
    | OSError.E =&gt; RaiseServerError(&quot;FileSystemOpenRead&quot;);
      &lt;*ASSERT FALSE*&gt;
    END;
  END FileSystemOpenRead;

PROCEDURE <A NAME="FileSystemOpenWrite"><procedure>FileSystemOpenWrite</procedure></A> (self: RemFileSystemServer; fileName: TEXT):
  Wr.T RAISES {ServerError} =
  BEGIN
    IF self.readOnly THEN RaiseServerError(&quot;FileSystemOpenWrite&quot;) END;
    TRY
      RETURN FileWr.Open(fileName);
    EXCEPT
    | OSError.E =&gt; RaiseServerError(&quot;FileSystemOpenWrite&quot;);
      &lt;*ASSERT FALSE*&gt;
    END;
  END FileSystemOpenWrite;

PROCEDURE <A NAME="FileSystemOpenAppend"><procedure>FileSystemOpenAppend</procedure></A> (self: RemFileSystemServer; fileName: TEXT):
  Wr.T RAISES {ServerError} =
  BEGIN
    IF self.readOnly THEN RaiseServerError(&quot;FileSystemOpenAppend&quot;) END;
    TRY
      RETURN FileWr.OpenAppend(fileName);
    EXCEPT
    | OSError.E =&gt; RaiseServerError(&quot;FileSystemOpenAppend&quot;);
      &lt;*ASSERT FALSE*&gt;
    END;
  END FileSystemOpenAppend;

PROCEDURE <A NAME="NewProcessor"><procedure>NewProcessor</procedure></A> (): ValProcessor =
  BEGIN
    RETURN NEW(ValProcessor, picklable := FALSE,
               tag:=&quot;Processor&quot;,
               what := &quot;&lt;Processor at &quot; &amp; machineAddress &amp; &quot;&gt;&quot;);
  END NewProcessor;

PROCEDURE <A NAME="RegisterSysCall"><procedure>RegisterSysCall</procedure></A> (name: TEXT; clos: SysCallClosure) =
  VAR v: Refany.T;
  BEGIN
    &lt;* ASSERT sysCallTable # NIL *&gt;
    IF clos = NIL THEN
      EVAL sysCallTable.delete(name, (*out*) v);
    ELSE
      EVAL sysCallTable.put(name, clos);
    END;
  END RegisterSysCall;

PROCEDURE <A NAME="FetchSysCall"><procedure>FetchSysCall</procedure></A> (name: TEXT; VAR (*out*) clos: SysCallClosure):
  BOOLEAN =
  VAR
    v    : Refany.T;
    found: BOOLEAN;
  BEGIN
    found := sysCallTable.get(name, (*out*) v);
    clos := NARROW(v, SysCallClosure);
    RETURN found;
  END FetchSysCall;
</PRE> === notification for remote object disappearance === 

<P><PRE>TYPE
  ObNotifierClosure = NetObjNotifier.NotifierClosure OBJECT
    proc : ValFun;
  OVERRIDES
    notify := ObNotifyMethod;
  END;

PROCEDURE <A NAME="ObNotifyMethod"><procedure>ObNotifyMethod</procedure></A>(self: ObNotifierClosure;
                         obj: NetObj.T; st: NetObjNotifier.OwnerState) =
  VAR args   : ARRAY [0..1] OF Val;
  BEGIN
    TYPECASE obj OF
    | RemVar(var) =&gt; args[0] := NEW(ValVar, remote := var);
    | RemArray(var) =&gt; args[0] := NEW(ValArray, remote := var);
    | RemObj(var) =&gt; args[0] := NEW(ValRemObj, remote := var);
    | RemEngine(var) =&gt; args[0] := NEW(ValEngine, remote := var);
    | RemFileSystem(var) =&gt; args[0] := NEW(ValFileSystem, remote := var);
    ELSE &lt;* ASSERT FALSE *&gt; (* Shouldn't get here! *)
    END;
    CASE st OF
    | NetObjNotifier.OwnerState.Dead =&gt;
      args[1] := NewText(&quot;Dead&quot;);
    | NetObjNotifier.OwnerState.Failed =&gt;
      args[1] := NewText(&quot;Failed&quot;);
    END;
    TRY
      EVAL ObEval.Call(self.proc, args);
    EXCEPT
    | Error (packet) =&gt; ErrorMsg(SynWr.err, packet);
    | Exception (packet) =&gt; ExceptionMsg(SynWr.err, packet);
    END;
  END ObNotifyMethod;

PROCEDURE <A NAME="ObjNotify"><procedure>ObjNotify</procedure></A>(val: Val; notifyProc: ValFun) =
  BEGIN
    WITH notifier = NEW(ObNotifierClosure, proc := notifyProc) DO
      TYPECASE val OF
      | ValVar(var) =&gt;        NetObjNotifier.AddNotifier(var.remote, notifier);
      | ValArray(var) =&gt;      NetObjNotifier.AddNotifier(var.remote, notifier);
      | ValRemObj(var) =&gt;     NetObjNotifier.AddNotifier(var.remote, notifier);
      | ValEngine(var) =&gt;     NetObjNotifier.AddNotifier(var.remote, notifier);
      | ValFileSystem(var) =&gt; NetObjNotifier.AddNotifier(var.remote, notifier);
      ELSE (* do nothing for other objects *)
      END;
    END;
  END ObjNotify;
</PRE> === GC-safe hash table of refanys :-) === 

<P><PRE>TYPE TblArr = ARRAY OF RECORD old, new: REFANY END;
REVEAL
  <A NAME="Tbl">Tbl</A> = BRANDED OBJECT
          a  : REF TblArr;
          top: INTEGER      := 0;
        METHODS
          Get (old: REFANY; VAR (*out*) new: REFANY): BOOLEAN := TblGet;
          Put (old, new: REFANY)                              := TblPut;
        END;

PROCEDURE <A NAME="NewTbl"><procedure>NewTbl</procedure></A> (): Tbl =
  BEGIN
    RETURN NEW(Tbl, a := NEW(REF TblArr, 256), top := 0);
  END NewTbl;

PROCEDURE <A NAME="TblGet"><procedure>TblGet</procedure></A> (self: Tbl; old: REFANY; VAR (*out*) new: REFANY):
  BOOLEAN =
  BEGIN
    FOR i := self.top - 1 TO 0 BY -1 DO
      IF self.a^[i].old = old THEN new := self.a^[i].new; RETURN TRUE END;
    END;
    RETURN FALSE;
  END TblGet;

PROCEDURE <A NAME="TblPut"><procedure>TblPut</procedure></A> (self: Tbl; old, new: REFANY) =
  VAR newArr: REF TblArr;
  BEGIN
    self.a^[self.top].old := old;
    self.a^[self.top].new := new;
    INC(self.top);
    IF self.top &gt;= NUMBER(self.a^) THEN
      newArr := NEW(REF TblArr, 2 * NUMBER(self.a^));
      SUBARRAY(newArr^, 0, NUMBER(self.a^)) := self.a^;
      self.a := newArr;
    END;
  END TblPut;
</PRE> === Copy === 

<P><PRE>TYPE CopyStyle = {ValToVal, ValToLocal, LocalToVal};

TYPE ValVarLocal = Val BRANDED &quot;ValVarLocal&quot; OBJECT val: Val;  END;

TYPE
  ValArrayLocal = Val BRANDED &quot;ValArrayLocal&quot; OBJECT array: REF Vals;  END;

TYPE OrigObjType = {Remote, Replicated, Simple};
TYPE
  ValObjLocal = Val BRANDED &quot;ValObjLocal&quot; OBJECT
                  who                  : TEXT;
                  fields               : REF ObjFields;
                  protected, serialized: BOOLEAN;
                  type                 : OrigObjType;
                END;

PROCEDURE <A NAME="CopyVal"><procedure>CopyVal</procedure></A> (val: Val; tbl: Tbl; loc: SynLocation.T): Val
  RAISES {Error, SharedObj.Error, NetObj.Error, Thread.Alerted} =
  BEGIN
    RETURN Copy(val, tbl, loc, CopyStyle.ValToVal);
  END CopyVal;

PROCEDURE <A NAME="CopyValToLocal"><procedure>CopyValToLocal</procedure></A> (val: Val; tbl: Tbl; loc: SynLocation.T): Val
  RAISES {Error, SharedObj.Error, NetObj.Error, Thread.Alerted} =
  BEGIN
    RETURN Copy(val, tbl, loc, CopyStyle.ValToLocal);
  END CopyValToLocal;

PROCEDURE <A NAME="CopyLocalToVal"><procedure>CopyLocalToVal</procedure></A> (val: Val; tbl: Tbl; loc: SynLocation.T): Val
  RAISES {Error, SharedObj.Error, NetObj.Error, Thread.Alerted} =
  BEGIN
    RETURN Copy(val, tbl, loc, CopyStyle.LocalToVal);
  END CopyLocalToVal;

PROCEDURE <A NAME="Copy"><procedure>Copy</procedure></A> (val: Val; tbl: Tbl; loc: SynLocation.T; style: CopyStyle):
  Val RAISES {Error, SharedObj.Error, NetObj.Error, Thread.Alerted} =
  VAR cache: REFANY;

  PROCEDURE CopyFields (fields, newFields: REF ObjFields)
    RAISES {Error, SharedObj.Error, NetObj.Error, Thread.Alerted} =
    BEGIN
      FOR i := 0 TO NUMBER(fields^) - 1 DO
        newFields^[i].label := fields^[i].label;
        newFields^[i].field := Copy(fields^[i].field, tbl, loc, style);
        newFields^[i].update := FALSE;
      END;
    END CopyFields;

  BEGIN
    TYPECASE val OF
    | ValVar (node) =&gt;
        VAR
          newVar     : ValVar;
          newVarLocal: ValVarLocal;
        BEGIN
          IF tbl.Get(node.remote, (*out*) cache) THEN RETURN cache END;
          CASE style OF
          | CopyStyle.ValToVal =&gt;
              newVar := NEW(ValVar, remote := NIL);
              tbl.Put(node.remote, newVar);
              newVar.remote :=
                NEW(RemVarServer,
                    val := Copy(node.remote.Get(), tbl, loc, style));
              RETURN newVar;
          | CopyStyle.ValToLocal =&gt;
              newVarLocal := NEW(ValVarLocal, val := NIL);
              tbl.Put(node.remote, newVarLocal);
              newVarLocal.val := Copy(node.remote.Get(), tbl, loc, style);
              RETURN newVarLocal;
          ELSE                   &lt;*ASSERT FALSE*&gt;
          END;
        END;
    | ValVarLocal (node) =&gt;
        VAR newVar: ValVar;
        BEGIN
          IF tbl.Get(node, (*out*) cache) THEN RETURN cache END;
          CASE style OF
          | CopyStyle.LocalToVal =&gt;
              newVar := NEW(ValVar, remote := NIL);
              tbl.Put(node, newVar);
              newVar.remote :=
                NEW(RemVarServer, val := Copy(node.val, tbl, loc, style));
              RETURN newVar;
          ELSE                   &lt;*ASSERT FALSE*&gt;
          END;
        END;
    | ValOk, ValBool, ValChar, ValText, ValInt, ValReal, ValException,
        ValEngine =&gt;
        RETURN val;
    | ValOption (node) =&gt;
        VAR newOpt: ValOption;
        BEGIN
          IF tbl.Get(node, (*out*) cache) THEN RETURN cache END;
          newOpt := NEW(ValOption, tag := node.tag, val := NIL);
          tbl.Put(node, newOpt);
          newOpt.val := Copy(node.val, tbl, loc, style);
          RETURN newOpt;
        END;
    | ValAlias (node) =&gt;
        VAR newAlias: ValAlias;
        BEGIN
          IF tbl.Get(node, (*out*) cache) THEN RETURN cache END;
          newAlias :=
            NEW(ValAlias, label := node.label,
                labelIndexHint := node.labelIndexHint, obj := NIL);
          tbl.Put(node, newAlias);
          newAlias.obj := Copy(node.obj, tbl, loc, style);
          RETURN newAlias;
        END;
    | ValArray (node) =&gt;
        VAR
          vals, newVals: REF Vals;
          newArr       : ValArray;
          newArrLocal  : ValArrayLocal;
        BEGIN
          IF tbl.Get(node.remote, (*out*) cache) THEN RETURN cache END;
          vals := node.remote.Obtain();
          newVals := NEW(REF Vals, NUMBER(vals^));
          CASE style OF
          | CopyStyle.ValToVal =&gt;
              newArr := NEW(ValArray, remote := NIL);
              tbl.Put(node.remote, newArr);
              FOR i := 0 TO NUMBER(vals^) - 1 DO
                newVals^[i] := Copy(vals^[i], tbl, loc, style);
              END;
              newArr.remote := NEW(RemArrayServer, array := newVals);
              RETURN newArr;
          | CopyStyle.ValToLocal =&gt;
              newArrLocal := NEW(ValArrayLocal, array := NIL);
              tbl.Put(node.remote, newArrLocal);
              FOR i := 0 TO NUMBER(vals^) - 1 DO
                newVals^[i] := Copy(vals^[i], tbl, loc, style);
              END;
              newArrLocal.array := newVals;
              RETURN newArrLocal;
          ELSE                   &lt;*ASSERT FALSE*&gt;
          END;
        END;
    | ValArrayLocal (node) =&gt;
        VAR
          vals, newVals: REF Vals;
          newArr       : ValArray;
        BEGIN
          IF tbl.Get(node, (*out*) cache) THEN RETURN cache END;
          vals := node.array;
          newVals := NEW(REF Vals, NUMBER(vals^));
          CASE style OF
          | CopyStyle.LocalToVal =&gt;
              newArr := NEW(ValArray, remote := NIL);
              tbl.Put(node, newArr);
              FOR i := 0 TO NUMBER(vals^) - 1 DO
                newVals^[i] := Copy(vals^[i], tbl, loc, style);
              END;
              newArr.remote := NEW(RemArrayServer, array := newVals);
              RETURN newArr;
          ELSE                   &lt;*ASSERT FALSE*&gt;
          END;
        END;
    | ValAnything (node) =&gt;
        CASE style OF
        | CopyStyle.ValToVal =&gt; RETURN node.Copy(tbl, loc);
        | CopyStyle.ValToLocal, CopyStyle.LocalToVal =&gt;
            IF node.picklable THEN
              RETURN node
            ELSE
              RaiseError(&quot;Cannot pickle: &quot; &amp; node.what, loc);
              &lt;*ASSERT FALSE*&gt;
            END;
        ELSE                     &lt;*ASSERT FALSE*&gt;
        END;
    | ValFun (node) =&gt;
        VAR newProc: ValFun;
        BEGIN
          IF tbl.Get(node, (*out*) cache) THEN RETURN cache END;
          newProc := NEW(ValFun, fun := node.fun,
                         global := NEW(REF Vals, NUMBER(node.global^)));
          tbl.Put(node, newProc);
          FOR i := 0 TO NUMBER(node.global^) - 1 DO
            newProc.global^[i] := Copy(node.global^[i], tbl, loc, style);
          END;
          RETURN newProc;
        END;
    | ValMeth (node) =&gt;
        VAR newMeth: ValMeth;
        BEGIN
          IF tbl.Get(node, (*out*) cache) THEN RETURN cache END;
          newMeth := NEW(ValMeth, meth := node.meth,
                         global := NEW(REF Vals, NUMBER(node.global^)));
          tbl.Put(node, newMeth);
          FOR i := 0 TO NUMBER(node.global^) - 1 DO
            newMeth.global^[i] := Copy(node.global^[i], tbl, loc, style);
          END;
          RETURN newMeth;
        END;
    | ValRemObj (node) =&gt;
        VAR
          fields, newFields    : REF ObjFields;
          who                  : TEXT;
          protected, serialized: BOOLEAN;
          sync                 : Sync;
        BEGIN
          IF tbl.Get(node.remote, (*out*) cache) THEN RETURN cache END;
          TRY
            who := node.remote.Who( (*out*)protected, (*out*) serialized);
            fields := node.remote.Obtain(FALSE);
            newFields := NEW(REF ObjFields, NUMBER(fields^));
          EXCEPT
            ServerError (msg) =&gt; RaiseError(msg, loc);
          END;
          IF serialized THEN
            sync := NEW(Sync, mutex := NEW(Thread.Mutex))
          ELSE
            sync := NIL
          END;
          CASE style OF
          | CopyStyle.ValToVal =&gt;
              WITH newObj = NEW(ValRemObj, remote := NIL) DO
                tbl.Put(node.remote, newObj);
                CopyFields(fields, newFields);
                WITH newObjServ = NEW(RemObjServer, who := who,
                                      self := newObj, fields := newFields,
                                      protected := protected, sync := sync) DO
                  newObj.remote := newObjServ;
                END;
                RETURN newObj;
              END;
          | CopyStyle.ValToLocal =&gt;
              WITH newObjLocal = NEW(ValObjLocal, who := who,
                                     fields := NIL, protected := protected,
                                     serialized := serialized,
                                     type := OrigObjType.Remote) DO
                tbl.Put(node.remote, newObjLocal);
                CopyFields(fields, newFields);
                newObjLocal.fields := newFields;
                RETURN newObjLocal;
              END;
          ELSE
            &lt;*ASSERT FALSE*&gt;
          END;
        END;
    | ValReplObj (node) =&gt;
        VAR
          fields, newFields: REF ObjFields;
          protected        : BOOLEAN;
          who              : TEXT;
        BEGIN
          IF tbl.Get(node.replica, (*out*) cache) THEN RETURN cache END;
          TRY
            who := node.replica.Who((*out*)protected);
            fields := node.replica.Obtain(FALSE);
            newFields := NEW(REF ObjFields, NUMBER(fields^));
          EXCEPT
            ServerError (msg) =&gt; RaiseError(msg, loc);
          END;
          CASE style OF
          | CopyStyle.ValToVal =&gt;
              WITH newObj = NEW(ValReplObj, replica := NIL) DO
                tbl.Put(node.replica, newObj);
                CopyFields(fields, newFields);
                WITH newObjServ = NEW(ReplObjStd, who := who,
                                      self := newObj,
                                      protected := protected,
                                      fields := newFields).init() DO
                  newObj.replica := newObjServ;
                END;
                RETURN newObj;
              END;
          | CopyStyle.ValToLocal =&gt;
              WITH newObjLocal = NEW(
                                   ValObjLocal, who := who, fields := NIL,
                                   protected := protected,
                                   serialized := FALSE,
                                   type := OrigObjType.Replicated) DO
                tbl.Put(node.replica, newObjLocal);
                CopyFields(fields, newFields);
                newObjLocal.fields := newFields;
                RETURN newObjLocal;
              END;
          ELSE
            &lt;*ASSERT FALSE*&gt;
          END;
        END;
    | ValSimpleObj (node) =&gt;
        VAR
          fields, newFields    : REF ObjFields;
          who                  : TEXT;
          protected, serialized: BOOLEAN;
          sync                 : Sync;
        BEGIN
          IF tbl.Get(node.simple, (*out*) cache) THEN RETURN cache END;
          TRY
            who := node.simple.Who( (*out*)protected, (*out*) serialized);
            fields := node.simple.Obtain(FALSE);
            newFields := NEW(REF ObjFields, NUMBER(fields^));
          EXCEPT
            ServerError (msg) =&gt; RaiseError(msg, loc);
          END;
          IF serialized THEN
            sync := NEW(Sync, mutex := NEW(Thread.Mutex))
          ELSE
            sync := NIL
          END;
          CASE style OF
          | CopyStyle.ValToVal =&gt;
              WITH newObj = NEW(ValSimpleObj, simple := NIL) DO
                tbl.Put(node.simple, newObj);
                CopyFields(fields, newFields);
                WITH newObjServ = NEW(SimpleObj, who := who, self := newObj,
                                      fields := newFields,
                                      protected := protected, sync := sync) DO
                  newObj.simple := newObjServ;
                END;
                RETURN newObj;
              END;
          | CopyStyle.ValToLocal =&gt;
              WITH newObjLocal = NEW(ValObjLocal, who := who,
                                     fields := NIL, protected := protected,
                                     serialized := serialized,
                                     type := OrigObjType.Simple) DO
                tbl.Put(node.simple, newObjLocal);
                CopyFields(fields, newFields);
                newObjLocal.fields := newFields;
                RETURN newObjLocal;
              END;
          ELSE
            &lt;*ASSERT FALSE*&gt;
          END;
        END;
    | ValObjLocal (node) =&gt;
        VAR
          fields, newFields: REF ObjFields;
          sync             : Sync;
        BEGIN
          IF tbl.Get(node, (*out*) cache) THEN RETURN cache END;
          fields := node.fields;
          newFields := NEW(REF ObjFields, NUMBER(fields^));
          IF node.serialized THEN
            sync := NEW(Sync, mutex := NEW(Thread.Mutex))
          ELSE
            sync := NIL
          END;
          CASE style OF
          | CopyStyle.LocalToVal =&gt;
              CASE node.type OF
              | OrigObjType.Remote =&gt;
                  WITH newObj = NEW(ValRemObj, remote := NIL) DO
                    tbl.Put(node, newObj);
                    CopyFields(fields, newFields);
                    WITH newObjServ = NEW(RemObjServer, who := node.who,
                                          self := NIL, fields := newFields,
                                          protected := node.protected,
                                          sync := sync) DO
                      newObj.remote := newObjServ;
                      newObjServ.self := newObj;
                    END;
                    RETURN newObj;
                  END;
              | OrigObjType.Replicated =&gt;
                  WITH newObj = NEW(ValReplObj, replica := NIL) DO
                    tbl.Put(node, newObj);
                    CopyFields(fields, newFields);
                    WITH newObjServ = NEW(
                                        ReplObjStd, who := node.who,
                                        self := NIL,
                                        protected := node.protected,
                                        fields := newFields).init() DO
                      newObj.replica := newObjServ;
                      newObjServ.self := newObj;
                      RETURN newObj;
                    END;
                  END;
              | OrigObjType.Simple =&gt;
                  WITH newObj = NEW(ValSimpleObj, simple := NIL) DO
                    tbl.Put(node, newObj);
                    CopyFields(fields, newFields);
                    WITH newObjServ = NEW(SimpleObj, who := node.who,
                                          self := NIL, fields := newFields,
                                          protected := node.protected,
                                          sync := sync) DO
                      newObj.simple := newObjServ;
                      newObjServ.self := newObj;
                      RETURN newObj;
                    END;
                  END;
              END;
          ELSE                   &lt;*ASSERT FALSE*&gt;
          END;
        END;
    ELSE                         &lt;*ASSERT FALSE*&gt;
    END;
  END Copy;

PROCEDURE <A NAME="CopyId"><procedure>CopyId</procedure></A> (           self: ValAnything;
                  &lt;*UNUSED*&gt; tbl : Tbl;
                  &lt;*UNUSED*&gt; loc : SynLocation.T): ValAnything =
  BEGIN
    RETURN self;
  END CopyId;

PROCEDURE <A NAME="CopyError"><procedure>CopyError</procedure></A> (           self: ValAnything;
                     &lt;*UNUSED*&gt; tbl : Tbl;
                                loc : SynLocation.T): ValAnything
  RAISES {Error} =
  BEGIN
    RaiseError(&quot;Cannot copy: &quot; &amp; self.what, loc); &lt;*ASSERT FALSE*&gt;
  END CopyError;
</PRE>--------------------Pickling routines-----------------------
 Need a pickle special for the simple objects, and a shared
   object special for the replicated objects 

<P><PRE>PROCEDURE <A NAME="WriteFields"><procedure>WriteFields</procedure></A> (out: Pickle.Writer; fields: REF ObjFields;
                       &lt;*UNUSED*&gt; pkl: REF ObjFields)
  RAISES {Pickle.Error, Wr.Failure, Thread.Alerted} =
  BEGIN
    PickleStubs.OutInteger(out, NUMBER(fields^));
    PickleStubs.OutRef(out, fields);
  END WriteFields;

PROCEDURE <A NAME="ReadFields"><procedure>ReadFields</procedure></A> (in: Pickle.Reader; &lt;*UNUSED*&gt; pkl: REF ObjFields): REF ObjFields
  RAISES {Pickle.Error, Rd.EndOfFile, Rd.Failure, Thread.Alerted} =
  VAR ret : REF ObjFields;
  BEGIN
    WITH num = PickleStubs.InInteger(in) DO
      ret := PickleStubs.InRef(in);
      &lt;* ASSERT num = NUMBER(ret^) *&gt;
    END;
    RETURN ret;
  END ReadFields;

TYPE
  SimpleObjSpecial = Pickle.Special OBJECT
                       OVERRIDES
                         write := Write_SimpleObj;
                         read := Read_SimpleObj;
                       END;

PROCEDURE <A NAME="Write_SimpleObj"><procedure>Write_SimpleObj</procedure></A> (&lt;*UNUSED*&gt;ts: SimpleObjSpecial;
                           ref: REFANY; out: Pickle.Writer)
  RAISES {Pickle.Error, Wr.Failure, Thread.Alerted} =
  VAR o := NARROW(ref, SimpleObj);
      tc := TYPECODE(ref);
  BEGIN
    IF tc = TYPECODE(SimpleObj) THEN
      PickleStubs.OutText(out, o.who);
      IF o.sync # NIL THEN
        PickleStubs.OutBoolean(out, TRUE);
      ELSE
        PickleStubs.OutBoolean(out, FALSE);
      END;
      PickleStubs.OutBoolean(out, o.protected);
      PickleStubs.OutRef(out, o.self);

      PickleStubs.OutRef(out, o.pickleIn);
      PickleStubs.OutRef(out, o.pickleOut);

      WriteFields(out, o.fields, o.pickleOut);
    ELSE
      RAISE Pickle.Error(&quot;Pickle.Error: cannot handle subtypes &quot; &amp;
            &quot;of ObValue.SimpleObj&quot;);
    END;
  END Write_SimpleObj;

PROCEDURE <A NAME="Read_SimpleObj"><procedure>Read_SimpleObj</procedure></A> (&lt;*UNUSED*&gt;ts: SimpleObjSpecial;
                          in: Pickle.Reader;
                          id: Pickle.RefID):REFANY
  RAISES {Pickle.Error, Rd.EndOfFile, Rd.Failure, Thread.Alerted} =
  VAR o := NEW(SimpleObj);
  BEGIN
    in.noteRef(o, id);
    o.who := PickleStubs.InText(in);
    IF PickleStubs.InBoolean(in) THEN
      o.sync := NEW(Sync, mutex := NEW(Thread.Mutex))
    END;
    o.protected := PickleStubs.InBoolean(in);
    o.self := PickleStubs.InRef(in);

    o.pickleIn := PickleStubs.InRef(in);
    o.pickleOut := PickleStubs.InRef(in);

    o.fields := ReadFields(in, o.pickleIn);
    RETURN o;
  END Read_SimpleObj;

TYPE
  ReplObjStdSpecial = ObValuePickle.ReplObjStdSpecial OBJECT
                       OVERRIDES
                         write := Write_ReplObjStd;
                         read := Read_ReplObjStd;
                       END;

PROCEDURE <A NAME="Write_ReplObjStd"><procedure>Write_ReplObjStd</procedure></A> (&lt;*UNUSED*&gt;ts: ReplObjStdSpecial;
                           ref: SharedObj.T; out: Pickle.Writer)
  RAISES {Pickle.Error, Wr.Failure, Thread.Alerted} =
  VAR obj := NARROW(ref, ReplObjStd);
  BEGIN
    PickleStubs.OutRef(out, obj.who);
    PickleStubs.OutRef(out, obj.self);
    PickleStubs.OutInteger(out, ORD(obj.protected));
    PickleStubs.OutRef(out, obj.pickleIn);
    PickleStubs.OutRef(out, obj.pickleOut);

    WriteFields(out, obj.fields, obj.pickleOut);
  END Write_ReplObjStd;

PROCEDURE <A NAME="Read_ReplObjStd"><procedure>Read_ReplObjStd</procedure></A> (&lt;*UNUSED*&gt;ts: ReplObjStdSpecial;
                          ref: SharedObj.T;
                          in: Pickle.Reader)
  RAISES {Pickle.Error, Rd.EndOfFile, Rd.Failure, Thread.Alerted} =
  VAR obj := NARROW(ref, ReplObjStd);
  BEGIN
    obj.who := PickleStubs.InRef(in, -1);
    obj.self := PickleStubs.InRef(in, TYPECODE(ValReplObj));
    obj.protected := VAL(PickleStubs.InInteger(in, 0,1), BOOLEAN);
    obj.pickleIn := PickleStubs.InRef(in, -1);
    obj.pickleOut := PickleStubs.InRef(in, -1);

    obj.fields := ReadFields(in, obj.pickleIn);
  END Read_ReplObjStd;

TYPE
  InhibitSpecial = Pickle.Special OBJECT
                     reason: TEXT;
                   OVERRIDES
                     write := WriteInhibitTransmission;
                     read  := ReadInhibitTransmission;
                   END;

PROCEDURE <A NAME="WriteInhibitTransmission"><procedure>WriteInhibitTransmission</procedure></A> (           self: InhibitSpecial;
                                    &lt;*UNUSED*&gt; ref : REFANY;
                                    &lt;*UNUSED*&gt; wr  : Pickle.Writer   )
  RAISES {Pickle.Error} =
  BEGIN
    RAISE Pickle.Error(self.reason);
  END WriteInhibitTransmission;

PROCEDURE <A NAME="ReadInhibitTransmission"><procedure>ReadInhibitTransmission</procedure></A> (           self: InhibitSpecial;
                                   &lt;*UNUSED*&gt; rd  : Pickle.Reader;
                                   &lt;*UNUSED*&gt; id  : Pickle.RefID    ):
  REFANY RAISES {Pickle.Error} =
  BEGIN
    RAISE Pickle.Error(self.reason);
  END ReadInhibitTransmission;

PROCEDURE <A NAME="InhibitTransmission"><procedure>InhibitTransmission</procedure></A> (tc: INTEGER; reason: TEXT) =
  BEGIN
    Pickle.RegisterSpecial(NEW(InhibitSpecial, sc := tc, reason := reason));
  END InhibitTransmission;

BEGIN
  Pickle.RegisterSpecial(NEW(SimpleObjSpecial, sc := TYPECODE(SimpleObj)));
  ObValuePickle.RegisterSpecial_ReplObjStd(NEW(ReplObjStdSpecial));
END ObValue.
</PRE> -- This was an attempt to convince the NetObj runtime to do the right
   thing on pickling. Has been replaced by the current obliq pickling code,
   using Copy.
<P>
   There should be a way to temporarily register specials for NetObj.T's.
   The array of specials should be a parameter to Pickle.Read/Pickle.Write.
<P>
   In Setup:
      Pickle.RegisterSpecial(NEW(ValArraySpecial, sc:=TYPECODE(ValArray)));
<P>
  TYPE
    ValArraySpecial =
      Pickle.Special OBJECT
        OVERRIDES
          write := WriteValArray;
          read := ReadValArray;
        END;
<P>
  PROCEDURE WriteValArray(self: ValArraySpecial; ref: REFANY;
    wr: Pickle.Writer) RAISES {Pickle.Error, Wr.Failure, Thread.Alerted} =
  BEGIN
    TYPECASE ref OF
    <PRE>
      ValArray(valArray) =&gt;
      </PRE>
TYPECASE valArray.remote OF
      <PRE>
      RemArrayServer(remArrayServer) =&gt;
          </PRE>
wr.write(remArrayServer.array);
      ELSE RAISE Wr.Failure(NIL);
      END;
    ELSE RAISE Wr.Failure(NIL);
    END;
  END WriteValArray;
<P>
  PROCEDURE ReadValArray(self: ValArraySpecial;
    rd: Pickle.Reader; id: Pickle.RefID): REFANY
    RAISES {Pickle.Error, Rd.EndOfFile, Rd.Failure, Thread.Alerted} =
  VAR res: ValArray;
  BEGIN
    res := NEW(ValArray, remote := NEW(RemArrayServer, array := NIL));
    rd.noteRef(res, id);
    NARROW(res.remote, RemArrayServer).array := rd.read();
    RETURN res;
  END ReadValArray;

 
<P>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
