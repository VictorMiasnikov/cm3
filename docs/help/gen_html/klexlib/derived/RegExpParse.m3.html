<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: klexlib/derived/RegExpParse.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>klexlib/derived/RegExpParse.m3</H2></A><HR>
<inModule>
<PRE>MODULE <module><implements><A HREF="RegExpParse.i3.html">RegExpParse</A></implements></module>;
</PRE><BLOCKQUOTE><EM> Generated by kyacc </EM></BLOCKQUOTE><PRE>
IMPORT <A HREF="RegExpTok.i3.html">RegExpTok</A>;
IMPORT <A HREF="../../libm3/derived/IntIntTbl.i3.html">IntIntTbl</A>, <A HREF="../../libm3/derived/IntTextTbl.i3.html">IntTextTbl</A>;
IMPORT <A HREF="../../m3core/src/runtime/common/RTType.i3.html">RTType</A>;
IMPORT <A HREF="../../libm3/src/params/Env.i3.html">Env</A>, <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="../../libm3/src/fmtlex/Fmt.i3.html">Fmt</A>, <A HREF="../../libm3/src/rw/Rd.i3.html">Rd</A>;
FROM <A HREF="../../libm3/src/rw/Stdio.i3.html">Stdio</A> IMPORT stdout;
FROM <A HREF="RegExpTok.i3.html">RegExpTok</A> IMPORT NewPT;
&lt;* FATAL Wr.Failure, Thread.Alerted *&gt;

TYPE
  TypedSymbol = RECORD
    code: INTEGER;
    value: RegExpTok.ParseType;
  END;
CONST
  EOFSymbol = TypedSymbol{code := 0, value := NIL};
  NoToken = TypedSymbol{code := -1, value := NIL};
  NotASymbol = TypedSymbol{code := -1000, value := NIL};

TYPE
  StackElem = RECORD
    state: INTEGER;
    value: TypedSymbol;
  END;
  StackElemArray = REF ARRAY OF StackElem;

  Stack = RECORD
    a: StackElemArray;
    ptr: INTEGER;
  END;

REVEAL
  <A NAME="T">T</A> = Public BRANDED &quot;RegExpParse&quot; OBJECT
    lex: RegExpTok.Lexer;
    tokenLookup: IntIntTbl.T := NIL; (* M3 type code -&gt; SymCode *)
    symbols: IntTextTbl.T;           (* SymCode -&gt; name *)
    allocate_expr: RegExpTok.Allocator;
  OVERRIDES
    setLex := SetLex;
    parse := Parse;
    purge := Purge;
    paren_expr := paren_expr;
    concat_expr := concat_expr;
    or_expr := or_expr;
    plus_expr := plus_expr;
    star_expr := star_expr;
    quest_expr := quest_expr;
    repeat_expr := repeat_expr;
    ident_expr := ident_expr;
    string_expr := string_expr;
    charRange_expr := charRange_expr;
  END;

TYPE
  SymCode = BITS 9 FOR [0..262];
  (* symbol code:  0 .. 261
     set default:  262 *)

  Action = BITS 6 FOR [0..32];
  (* error:        -1   (not stored in table)
     shift:        1 .. 10
     accept:       11
     reduce:       12 .. 21
     shift&amp;accept: 22
     shift&amp;reduce: 23 .. 32  *)

  StateRef = BITS 5 FOR [0..28];
  (* no more:      0
     next state:   1..28 *)

  S = RECORD
    key: SymCode;
    action: Action;
    next: StateRef;
  END;

  R = RECORD
    length: INTEGER;
    returnCode: INTEGER;
    name: TEXT;
  END;

  Y = RECORD
    code: INTEGER;
    name: TEXT;
  END;

CONST
  States = ARRAY [1..28] OF S {
    S{257,3,11}, S{257,8,11}, S{262,11,12}, S{257,9,11}, S{262,13,13},
    S{257,10,11}, S{262,13,14}, S{41,23,15}, S{262,14,16}, S{262,14,17},
    S{40,2,18}, S{124,6,17}, S{257,5,19}, S{257,7,19}, S{124,4,16},
    S{257,7,20}, S{257,5,20}, S{259,30,21}, S{42,27,22}, S{42,27,23},
    S{260,31,24}, S{43,26,25}, S{43,26,26}, S{261,32,0}, S{63,28,27},
    S{63,28,28}, S{258,29,0}, S{258,29,11}};

  Rules = ARRAY [12..21] OF R {
    R{3, 257, &quot;paren_expr : '(' expr ')'&quot;},
    R{2, 257, &quot;concat_expr : expr expr&quot;},
    R{3, 257, &quot;or_expr : expr '|' expr&quot;},
    R{2, 257, &quot;plus_expr : expr '+'&quot;},
    R{2, 257, &quot;star_expr : expr '*'&quot;},
    R{2, 257, &quot;quest_expr : expr '?'&quot;},
    R{2, 257, &quot;repeat_expr : expr COUNT&quot;},
    R{1, 257, &quot;ident_expr : IDENTIFIER&quot;},
    R{1, 257, &quot;string_expr : STRING&quot;},
    R{1, 257, &quot;charRange_expr : CHAR_RANGE&quot;}
};

  Symbols = ARRAY [1..18] OF Y {
    Y{0,&quot;EOF&quot;}, Y{10,&quot;'\\n'&quot;}, Y{40,&quot;'('&quot;}, Y{41,&quot;')'&quot;}, Y{42,&quot;'*'&quot;},
    Y{43,&quot;'+'&quot;}, Y{45,&quot;'-'&quot;}, Y{63,&quot;'?'&quot;}, Y{91,&quot;'['&quot;}, Y{93,&quot;']'&quot;},
    Y{94,&quot;'^'&quot;}, Y{124,&quot;'|'&quot;}, Y{256,&quot;ERROR&quot;}, Y{257,&quot;expr&quot;}, Y{258,&quot;COUNT&quot;},
    Y{259,&quot;IDENTIFIER&quot;}, Y{260,&quot;STRING&quot;}, Y{261,&quot;CHAR_RANGE&quot;}};

VAR
  Debug := Env.Get(&quot;RegExpParseDEBUG&quot;) # NIL;

PROCEDURE <A NAME="SetLex"><procedure>SetLex</procedure></A>(self: T; lex: RegExpTok.Lexer): T =
  BEGIN self.lex := lex; RETURN self; END SetLex;

PROCEDURE <A NAME="Init"><procedure>Init</procedure></A>(self: T) =
  BEGIN (* called on first parse *)
    self.tokenLookup := NEW(IntIntTbl.Default).init(18);
    IF Debug THEN
      self.symbols := NEW(IntTextTbl.Default).init(18);
      FOR i := 1 TO 18 DO
        EVAL self.symbols.put(Symbols[i].code, Symbols[i].name);
      END;
    END;
  END Init;

PROCEDURE <A NAME="NextToken"><procedure>NextToken</procedure></A>(self: T): TypedSymbol =
  VAR
    symCode, m3code: INTEGER;
    token: RegExpTok.Token;
    found := FALSE;
  BEGIN
    TRY
      token := self.lex.get();
    EXCEPT
      Rd.EndOfFile =&gt; RETURN EOFSymbol;
    END;
    m3code := TYPECODE(token);
    IF NOT self.tokenLookup.get(m3code, symCode) THEN
      REPEAT
        m3code := RTType.Supertype(m3code);
        IF m3code = RTType.NoSuchType THEN
          TYPECASE token OF
          | ConstToken =&gt; symCode := -1;
          | COUNT =&gt; symCode := 258;
          | CHAR_RANGE =&gt; symCode := 261;
          | STRING =&gt; symCode := 260;
          | IDENTIFIER =&gt; symCode := 259;
          ELSE
            &lt;* ASSERT FALSE *&gt;
          END;
          found := TRUE;
        ELSE
          found := self.tokenLookup.get(m3code, symCode);
        END;
      UNTIL found;
      EVAL self.tokenLookup.put(TYPECODE(token), symCode);
    END;
    IF symCode = -1 THEN
      symCode := NARROW(token, ConstToken).val;
    END;
    RETURN TypedSymbol{code := symCode, value := token};
  END NextToken;

PROCEDURE <A NAME="AllocStack"><procedure>AllocStack</procedure></A>(): Stack =
  VAR
    a :=NEW(StackElemArray, 16);
  BEGIN
    a[0] := StackElem{state := 1, value := EOFSymbol};
    RETURN Stack{a := a, ptr := 0};
  END AllocStack;

PROCEDURE <A NAME="Push"><procedure>Push</procedure></A>(VAR stack: Stack; elem: StackElem) =
  VAR
    new: StackElemArray;
  BEGIN
    INC(stack.ptr);
    IF stack.ptr &gt; LAST(stack.a^) THEN
      new := NEW(StackElemArray, NUMBER(stack.a^) * 2);
      SUBARRAY(new^, 0, NUMBER(stack.a^)) := stack.a^;
      stack.a := new;
    END;
    stack.a[stack.ptr] := elem;
  END Push;

PROCEDURE <A NAME="ActionLookup"><procedure>ActionLookup</procedure></A>(curState: INTEGER; symbol: TypedSymbol): INTEGER =
  VAR
    cur := curState;
    state: S;
    default := -1;
  BEGIN
    REPEAT
      state := States[cur];
      IF state.key = 262 THEN
        default := state.action;
      ELSIF state.key = symbol.code THEN
        RETURN state.action;
      END;
      cur := state.next;
    UNTIL cur = 0;
    RETURN default;
  END ActionLookup;

PROCEDURE <A NAME="Parse"><procedure>Parse</procedure></A>(self: T; exhaustInput: BOOLEAN := TRUE): StartType =
  VAR
    curState: INTEGER := 1;
    stack := AllocStack();
    action: INTEGER;
    symbol, preservedToken: TypedSymbol;
    skipTokenGets: INTEGER := 0;

  PROCEDURE DebugPrint(message: TEXT) = BEGIN
    IF Debug THEN Wr.PutText(stdout,&quot;RegExpParseDEBUG: &quot;&amp;message&amp;&quot;\n&quot;);
    END;END DebugPrint;
  PROCEDURE DebugSymbol(message: TEXT) = VAR name: TEXT; BEGIN
   IF Debug THEN EVAL self.symbols.get(symbol.code, name);
    DebugPrint(message &amp; &quot; &quot; &amp; name &amp; &quot;(&quot; &amp;
      Fmt.Int(symbol.code) &amp; &quot;)&quot;); END; END DebugSymbol;
  PROCEDURE DebugState(message: TEXT) = BEGIN IF Debug THEN
    DebugPrint(message &amp; &quot; &quot; &amp; Fmt.Int(curState));END;END DebugState;
  PROCEDURE DebugRule(message: TEXT) = BEGIN IF Debug THEN
    DebugPrint(message&amp;&quot; &quot;&amp;Rules[action].name);END;END DebugRule;

  BEGIN
    IF self.tokenLookup = NIL THEN Init(self); END;
    stack.a[0] := StackElem{state := curState, value := NotASymbol};
    DebugState(&quot;starting in state&quot;);
    LOOP
      IF skipTokenGets = 2 THEN
        skipTokenGets := 1;
        DebugSymbol(&quot;scanning reduced symbol&quot;);
      ELSIF skipTokenGets = 1 AND preservedToken # NoToken THEN
        skipTokenGets := 0;
        symbol := preservedToken;
        DebugSymbol(&quot;re-scanning input token&quot;);
      ELSE
        skipTokenGets := 0;
        symbol := NextToken(self);
        preservedToken := symbol;
        DebugSymbol(&quot;input token&quot;);
      END;
      action := ActionLookup(curState, symbol);
      IF action &gt;= 22 THEN
        DebugPrint(&quot;shifting anonymously&quot;);
        Push(stack, StackElem{state := 0, value := symbol});
        DEC(action, 11);
        IF skipTokenGets = 0 THEN
          preservedToken := NoToken;
        END;
      END;
      IF action = -1 THEN
        DebugPrint(&quot;syntax error&quot;);
        self.lex.error(&quot;RegExpParse: syntax error&quot;);RETURN NIL;
      ELSIF action &lt;= 10 THEN
        curState := action;
        DebugState(&quot;shifting to state&quot;);
        Push(stack, StackElem{state := curState, value := symbol});
      ELSIF action = 11 THEN
        DebugPrint(&quot;parsing stopped with singleton start symbol on stack&quot;);
        &lt;* ASSERT stack.ptr = 1 *&gt;
        IF exhaustInput AND preservedToken = NoToken THEN
          symbol := NextToken(self);
          DebugPrint(&quot;getting token to check that it's an EOF&quot;);
        END;
        IF symbol.code # 0 THEN
          IF exhaustInput THEN
            DebugPrint(&quot;Error: last token was not EOF&quot;);
            self.lex.error(&quot;RegExpParse: syntax error (parsing stopped before EOF)&quot;);
            RETURN NIL;
          END;
          IF preservedToken # NoToken THEN
            self.lex.unget();
            DebugPrint(&quot;ungetting last token&quot;);
          END;
        END;
        symbol := stack.a[1].value;
        DebugSymbol(&quot;returning symbol&quot;);
        RETURN symbol.value;
      ELSE
        DebugRule(&quot;reducing by rule&quot;);
        WITH p=stack.ptr, a=stack.a, v=symbol.value, l=Rules[action].length DO
          CASE action OF
          | 12 =&gt; VAR w: expr := NIL;
            p1:expr:=a[p-1].value.value;
            BEGIN self.paren_expr(w, p1); v:=w; END;
          | 13 =&gt; VAR w: expr := NIL;
            p1:expr:=a[p-1].value.value;p2:expr:=a[p].value.value;
            BEGIN self.concat_expr(w, p1, p2); v:=w; END;
          | 14 =&gt; VAR w: expr := NIL;
            p1:expr:=a[p-2].value.value;p2:expr:=a[p].value.value;
            BEGIN self.or_expr(w, p1, p2); v:=w; END;
          | 15 =&gt; VAR w: expr := NIL;
            p1:expr:=a[p-1].value.value;
            BEGIN self.plus_expr(w, p1); v:=w; END;
          | 16 =&gt; VAR w: expr := NIL;
            p1:expr:=a[p-1].value.value;
            BEGIN self.star_expr(w, p1); v:=w; END;
          | 17 =&gt; VAR w: expr := NIL;
            p1:expr:=a[p-1].value.value;
            BEGIN self.quest_expr(w, p1); v:=w; END;
          | 18 =&gt; VAR w: expr := NIL;
            p1:expr:=a[p-1].value.value;p2:COUNT:=a[p].value.value;
            BEGIN self.repeat_expr(w, p1, p2); v:=w; END;
          | 19 =&gt; VAR w: expr := NIL;
            p1:IDENTIFIER:=a[p].value.value;
            BEGIN self.ident_expr(w, p1); v:=w; END;
          | 20 =&gt; VAR w: expr := NIL;
            p1:STRING:=a[p].value.value;
            BEGIN self.string_expr(w, p1); v:=w; END;
          | 21 =&gt; VAR w: expr := NIL;
            p1:CHAR_RANGE:=a[p].value.value;
            BEGIN self.charRange_expr(w, p1); v:=w; END;
          ELSE
            &lt;* ASSERT FALSE *&gt;
          END;
          FOR i := p - l + 1 TO p DO a[i].value.value.discard(); END;
          DEC(p, l);
          curState := a[p].state;
        END;
        DebugState(&quot;popping to state&quot;);
        symbol.code := Rules[action].returnCode;
        skipTokenGets := 2;
      END;
    END;
  END Parse;

PROCEDURE <A NAME="Purge"><procedure>Purge</procedure></A>(self: T): INTEGER =
  BEGIN
    RETURN 0
      + RegExpTok.Purge(self.allocate_expr);
  END Purge;
</PRE> default methods 
<PRE>PROCEDURE <A NAME="paren_expr"><procedure>paren_expr</procedure></A>(self: T;
 VAR result: expr;&lt;*UNUSED*&gt;p1: expr) = BEGIN
 IF result=NIL THEN
   result:=NewPT(self.allocate_expr,TYPECODE(expr));
 END;END paren_expr;

PROCEDURE <A NAME="concat_expr"><procedure>concat_expr</procedure></A>(self: T;
 VAR result: expr;&lt;*UNUSED*&gt;p1: expr;&lt;*UNUSED*&gt;p2: expr) = BEGIN
 IF result=NIL THEN
   result:=NewPT(self.allocate_expr,TYPECODE(expr));
 END;END concat_expr;

PROCEDURE <A NAME="or_expr"><procedure>or_expr</procedure></A>(self: T;
 VAR result: expr;&lt;*UNUSED*&gt;p1: expr;&lt;*UNUSED*&gt;p2: expr) = BEGIN
 IF result=NIL THEN
   result:=NewPT(self.allocate_expr,TYPECODE(expr));
 END;END or_expr;

PROCEDURE <A NAME="plus_expr"><procedure>plus_expr</procedure></A>(self: T;
 VAR result: expr;&lt;*UNUSED*&gt;p1: expr) = BEGIN
 IF result=NIL THEN
   result:=NewPT(self.allocate_expr,TYPECODE(expr));
 END;END plus_expr;

PROCEDURE <A NAME="star_expr"><procedure>star_expr</procedure></A>(self: T;
 VAR result: expr;&lt;*UNUSED*&gt;p1: expr) = BEGIN
 IF result=NIL THEN
   result:=NewPT(self.allocate_expr,TYPECODE(expr));
 END;END star_expr;

PROCEDURE <A NAME="quest_expr"><procedure>quest_expr</procedure></A>(self: T;
 VAR result: expr;&lt;*UNUSED*&gt;p1: expr) = BEGIN
 IF result=NIL THEN
   result:=NewPT(self.allocate_expr,TYPECODE(expr));
 END;END quest_expr;

PROCEDURE <A NAME="repeat_expr"><procedure>repeat_expr</procedure></A>(self: T;
 VAR result: expr;&lt;*UNUSED*&gt;p1: expr;&lt;*UNUSED*&gt;p2: COUNT) = BEGIN
 IF result=NIL THEN
   result:=NewPT(self.allocate_expr,TYPECODE(expr));
 END;END repeat_expr;

PROCEDURE <A NAME="ident_expr"><procedure>ident_expr</procedure></A>(self: T;
 VAR result: expr;&lt;*UNUSED*&gt;p1: IDENTIFIER) = BEGIN
 IF result=NIL THEN
   result:=NewPT(self.allocate_expr,TYPECODE(expr));
 END;END ident_expr;

PROCEDURE <A NAME="string_expr"><procedure>string_expr</procedure></A>(self: T;
 VAR result: expr;&lt;*UNUSED*&gt;p1: STRING) = BEGIN
 IF result=NIL THEN
   result:=NewPT(self.allocate_expr,TYPECODE(expr));
 END;END string_expr;

PROCEDURE <A NAME="charRange_expr"><procedure>charRange_expr</procedure></A>(self: T;
 VAR result: expr;&lt;*UNUSED*&gt;p1: CHAR_RANGE) = BEGIN
 IF result=NIL THEN
   result:=NewPT(self.allocate_expr,TYPECODE(expr));
 END;END charRange_expr;

BEGIN
END RegExpParse.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
