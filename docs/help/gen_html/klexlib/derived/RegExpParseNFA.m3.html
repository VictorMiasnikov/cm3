<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: klexlib/derived/RegExpParseNFA.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>klexlib/derived/RegExpParseNFA.m3</H2></A><HR>
<inModule>
<PRE>MODULE <module><implements><A HREF="RegExpParseNFA.i3.html">RegExpParseNFA</A></implements></module>;
</PRE><BLOCKQUOTE><EM> generated by kext </EM></BLOCKQUOTE><PRE>
IMPORT <A HREF="RegExpParse.i3.html">RegExpParse</A>;
IMPORT <A HREF="../src/NFA.i3.html">NFA</A>;
IMPORT <A HREF="../../ktoklib/src/CharCodes.i3.html">CharCodes</A>;
IMPORT <A HREF="../../libm3/src/geometry/Interval.i3.html">Interval</A>;
IMPORT <A HREF="NFATbl.i3.html">NFATbl</A>;
IMPORT <A HREF="../../ktoklib/src/FileRdErr.i3.html">FileRdErr</A>;
IMPORT <A HREF="RegExpLexStd.i3.html">RegExpLexStd</A>;

PROCEDURE <A NAME="Init"><procedure>Init</procedure></A>(self: T): T =
  BEGIN
    self.exprMacros := NEW(NFATbl.Default).init();
    RETURN self;
  END Init;

PROCEDURE <A NAME="ParseText"><procedure>ParseText</procedure></A>(self: T; t: TEXT): NFA.T =
  BEGIN
    &lt;* ASSERT self.exprMacros # NIL *&gt;
    EVAL self.setLex(NEW(RegExpLexStd.T).fromText(t));
    RETURN NARROW(self.parse(), expr).val;
  END ParseText;

PROCEDURE <A NAME="PutMacro"><procedure>PutMacro</procedure></A>(self: T; name: TEXT; n: NFA.T) =
  BEGIN
    &lt;* ASSERT self.exprMacros # NIL *&gt;
    IF self.exprMacros.put(name, n) THEN
      FileRdErr.E(NIL, &quot;redeclared macro: &quot; &amp; name);
    END;
  END PutMacro;

PROCEDURE <A NAME="Lookup"><procedure>Lookup</procedure></A>(self: T; name: TEXT): NFA.T =
  VAR
    n: NFA.T;
  BEGIN
    IF NOT self.exprMacros.get(CharCodes.StripDelims(name), n) THEN
      FileRdErr.E(NIL, &quot;undeclared macro: &quot; &amp; name);
    END;
    RETURN NFA.Copy(n);
  END Lookup;

REVEAL
  <A NAME="T">T</A> = Public BRANDED &quot;RegExpParseNFA&quot; OBJECT
    allocate_expr: Allocator := NIL;
exprMacros : NFATbl.T := NIL;  OVERRIDES
    purge := Proc_Purge;
    parseText := ParseText;
    putMacro := PutMacro;
    init := Init;
    repeat_expr := Proc_repeat_expr;
    ident_expr := Proc_ident_expr;
    or_expr := Proc_or_expr;
    plus_expr := Proc_plus_expr;
    paren_expr := Proc_paren_expr;
    quest_expr := Proc_quest_expr;
    string_expr := Proc_string_expr;
    concat_expr := Proc_concat_expr;
    star_expr := Proc_star_expr;
    charRange_expr := Proc_charRange_expr;
  END;

PROCEDURE <A NAME="Proc_Purge"><procedure>Proc_Purge</procedure></A>(self: T): INTEGER =
  BEGIN
    RETURN RegExpParse.T.purge(self)
      + Purge(self.allocate_expr);
  END Proc_Purge;
</PRE> rule procedures 
<PRE>PROCEDURE <A NAME="Proc_paren_expr"><procedure>Proc_paren_expr</procedure></A>(self: T;
 VAR p0: Original_expr; p1: Original_expr) =
  VAR
    result: expr;
    n1 := NARROW(p1, expr);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_expr, TYPECODE(expr));
    END;
    RegExpParse.T.paren_expr(self, p0, p1);
    result := NARROW(p0, expr);
    BEGIN (* user code *)
      result.val := n1.val
    END;
    p0 := result;
  END Proc_paren_expr;

PROCEDURE <A NAME="Proc_concat_expr"><procedure>Proc_concat_expr</procedure></A>(self: T;
 VAR p0: Original_expr; p1: Original_expr; p2: Original_expr) =
  VAR
    result: expr;
    n1 := NARROW(p1, expr);
    n2 := NARROW(p2, expr);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_expr, TYPECODE(expr));
    END;
    RegExpParse.T.concat_expr(self, p0, p1, p2);
    result := NARROW(p0, expr);
    BEGIN (* user code *)
      result.val := NFA.Concat(n1.val, n2.val)
    END;
    p0 := result;
  END Proc_concat_expr;

PROCEDURE <A NAME="Proc_or_expr"><procedure>Proc_or_expr</procedure></A>(self: T;
 VAR p0: Original_expr; p1: Original_expr; p2: Original_expr) =
  VAR
    result: expr;
    n1 := NARROW(p1, expr);
    n2 := NARROW(p2, expr);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_expr, TYPECODE(expr));
    END;
    RegExpParse.T.or_expr(self, p0, p1, p2);
    result := NARROW(p0, expr);
    BEGIN (* user code *)
      result.val := NFA.Or(n1.val, n2.val)
    END;
    p0 := result;
  END Proc_or_expr;

PROCEDURE <A NAME="Proc_plus_expr"><procedure>Proc_plus_expr</procedure></A>(self: T;
 VAR p0: Original_expr; p1: Original_expr) =
  VAR
    result: expr;
    n1 := NARROW(p1, expr);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_expr, TYPECODE(expr));
    END;
    RegExpParse.T.plus_expr(self, p0, p1);
    result := NARROW(p0, expr);
    BEGIN (* user code *)
      result.val := NFA.Rept(n1.val, Interval.T{1, NFA.OrMore})
    END;
    p0 := result;
  END Proc_plus_expr;

PROCEDURE <A NAME="Proc_star_expr"><procedure>Proc_star_expr</procedure></A>(self: T;
 VAR p0: Original_expr; p1: Original_expr) =
  VAR
    result: expr;
    n1 := NARROW(p1, expr);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_expr, TYPECODE(expr));
    END;
    RegExpParse.T.star_expr(self, p0, p1);
    result := NARROW(p0, expr);
    BEGIN (* user code *)
      result.val := NFA.Rept(n1.val, Interval.T{0, NFA.OrMore})
    END;
    p0 := result;
  END Proc_star_expr;

PROCEDURE <A NAME="Proc_quest_expr"><procedure>Proc_quest_expr</procedure></A>(self: T;
 VAR p0: Original_expr; p1: Original_expr) =
  VAR
    result: expr;
    n1 := NARROW(p1, expr);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_expr, TYPECODE(expr));
    END;
    RegExpParse.T.quest_expr(self, p0, p1);
    result := NARROW(p0, expr);
    BEGIN (* user code *)
      result.val := NFA.Rept(n1.val, Interval.T{0, 1})
    END;
    p0 := result;
  END Proc_quest_expr;

PROCEDURE <A NAME="Proc_repeat_expr"><procedure>Proc_repeat_expr</procedure></A>(self: T;
 VAR p0: Original_expr; p1: Original_expr; p2: Original_COUNT) =
  VAR
    result: expr;
    n1 := NARROW(p1, expr);
    n2 := NARROW(p2, COUNT);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_expr, TYPECODE(expr));
    END;
    RegExpParse.T.repeat_expr(self, p0, p1, p2);
    result := NARROW(p0, expr);
    BEGIN (* user code *)
      result.val := NFA.Rept(n1.val, n2.val)
    END;
    p0 := result;
  END Proc_repeat_expr;

PROCEDURE <A NAME="Proc_ident_expr"><procedure>Proc_ident_expr</procedure></A>(self: T;
 VAR p0: Original_expr; p1: Original_IDENTIFIER) =
  VAR
    result: expr;
    n1 := NARROW(p1, IDENTIFIER);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_expr, TYPECODE(expr));
    END;
    RegExpParse.T.ident_expr(self, p0, p1);
    result := NARROW(p0, expr);
    BEGIN (* user code *)
      result.val := Lookup(self, n1.val)
    END;
    p0 := result;
  END Proc_ident_expr;

PROCEDURE <A NAME="Proc_string_expr"><procedure>Proc_string_expr</procedure></A>(self: T;
 VAR p0: Original_expr; p1: Original_STRING) =
  VAR
    result: expr;
    n1 := NARROW(p1, STRING);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_expr, TYPECODE(expr));
    END;
    RegExpParse.T.string_expr(self, p0, p1);
    result := NARROW(p0, expr);
    BEGIN (* user code *)
      result.val := NFA.FromString(n1.val)
    END;
    p0 := result;
  END Proc_string_expr;

PROCEDURE <A NAME="Proc_charRange_expr"><procedure>Proc_charRange_expr</procedure></A>(self: T;
 VAR p0: Original_expr; p1: Original_CHAR_RANGE) =
  VAR
    result: expr;
    n1 := NARROW(p1, CHAR_RANGE);
  BEGIN
    IF p0 = NIL THEN
      p0 := NewPT(self.allocate_expr, TYPECODE(expr));
    END;
    RegExpParse.T.charRange_expr(self, p0, p1);
    result := NARROW(p0, expr);
    BEGIN (* user code *)
      result.val := NFA.FromRange(n1.val)
    END;
    p0 := result;
  END Proc_charRange_expr;

BEGIN
END RegExpParseNFA.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
