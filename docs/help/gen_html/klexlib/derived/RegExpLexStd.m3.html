<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: klexlib/derived/RegExpLexStd.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>klexlib/derived/RegExpLexStd.m3</H2></A><HR>
<inModule>
<PRE>MODULE <module><implements><A HREF="RegExpLexStd.i3.html">RegExpLexStd</A></implements></module>;
</PRE><BLOCKQUOTE><EM> generated by kext </EM></BLOCKQUOTE><PRE>
IMPORT <A HREF="RegExpLex.i3.html">RegExpLex</A>;
IMPORT <A HREF="../../libm3/src/rw/Rd.i3.html">Rd</A>;
IMPORT <A HREF="../../libm3/src/geometry/Interval.i3.html">Interval</A>;
IMPORT <A HREF="../src/NFA.i3.html">NFA</A>;
IMPORT <A HREF="../../libm3/src/fmtlex/Scan.i3.html">Scan</A>;
IMPORT <A HREF="../../m3core/src/text/Text.i3.html">Text</A>;
IMPORT <A HREF="../../ktoklib/src/CharRange.i3.html">CharRange</A>;
IMPORT <A HREF="../../ktoklib/src/CharCodes.i3.html">CharCodes</A>;
IMPORT <A HREF="../../m3core/src/float/IEEE-default/FloatMode.i3.html">FloatMode</A>, <A HREF="../../libm3/src/fmtlex/Lex.i3.html">Lex</A>;
&lt;* FATAL FloatMode.Trap, Lex.Error *&gt;

PROCEDURE <A NAME="ParseInterval"><procedure>ParseInterval</procedure></A>(t: TEXT): Interval.T =
  VAR
    inter: TEXT := CharCodes.StripDelims(t);
    pos := Text.FindChar(inter, ',');
    loStr,hiStr: TEXT;
  PROCEDURE GetInt(str: TEXT; default: INTEGER): INTEGER =
    BEGIN
      IF Text.Length(str) = 0 THEN
        RETURN default;
      ELSE
        RETURN Scan.Int(str);
      END;
    END GetInt;
  BEGIN
    IF pos = -1 THEN
      loStr := inter;
      hiStr := inter;
    ELSE
      loStr := Text.Sub(inter, 0, pos);
      hiStr := Text.Sub(inter, pos+1, LAST(INTEGER));
    END;
</PRE><BLOCKQUOTE><EM>    Term.WrLn(<CODE>lo = </CODE> &amp; loStr &amp; <CODE>, hi = </CODE> &amp; hiStr); </EM></BLOCKQUOTE><PRE>
    RETURN Interval.T{GetInt(loStr,0), GetInt(hiStr,NFA.OrMore)};
  END ParseInterval;

REVEAL
  <A NAME="T">T</A> = Public BRANDED &quot;RegExpLexStd&quot; OBJECT
    allocate_CHAR_RANGE: Allocator := NIL;
    allocate_COUNT: Allocator := NIL;
    allocate_STRING: Allocator := NIL;
    allocate_IDENTIFIER: Allocator := NIL;
  OVERRIDES
    init := Init;
    purge := Proc_Purge;
    COUNT := Proc_COUNT;
    STRING := Proc_STRING;
    brac_CHAR_RANGE := Proc_brac_CHAR_RANGE;
    dot_CHAR_RANGE := Proc_dot_CHAR_RANGE;
    IDENTIFIER := Proc_IDENTIFIER;
  END;

PROCEDURE <A NAME="Init"><procedure>Init</procedure></A>(self: T; rd: Rd.T): RdLexer =
  BEGIN
    EVAL RegExpLex.T.init(self, rd);
    RETURN self;
  END Init;

PROCEDURE <A NAME="Proc_Purge"><procedure>Proc_Purge</procedure></A>(self: T): INTEGER =
  BEGIN
    RETURN RegExpLex.T.purge(self)
      + Purge(self.allocate_CHAR_RANGE)
      + Purge(self.allocate_COUNT)
      + Purge(self.allocate_STRING)
      + Purge(self.allocate_IDENTIFIER);
  END Proc_Purge;
</PRE> expression procedures 
<PRE>PROCEDURE <A NAME="Proc_COUNT"><procedure>Proc_COUNT</procedure></A>(self: T): Token =
  BEGIN (* user code *)
   VAR result:COUNT:=NewPT(self.allocate_COUNT,TYPECODE(COUNT));BEGIN BEGIN
    result.val := ParseInterval(self.getText())
   END;RETURN result;END
  END Proc_COUNT;

PROCEDURE <A NAME="Proc_IDENTIFIER"><procedure>Proc_IDENTIFIER</procedure></A>(self: T): Token =
  BEGIN (* user code *)
   VAR result:IDENTIFIER:=NewPT(self.allocate_IDENTIFIER,TYPECODE(IDENTIFIER));BEGIN BEGIN
    result.val := self.getText()
   END;RETURN result;END
  END Proc_IDENTIFIER;

PROCEDURE <A NAME="Proc_brac_CHAR_RANGE"><procedure>Proc_brac_CHAR_RANGE</procedure></A>(self: T): Token =
  BEGIN (* user code *)
   VAR result:CHAR_RANGE:=NewPT(self.allocate_CHAR_RANGE,TYPECODE(CHAR_RANGE));BEGIN BEGIN
    result.val := CharRange.FromText(self.getText())
   END;RETURN result;END
  END Proc_brac_CHAR_RANGE;

PROCEDURE <A NAME="Proc_dot_CHAR_RANGE"><procedure>Proc_dot_CHAR_RANGE</procedure></A>(self: T): Token =
  BEGIN (* user code *)
   VAR result:CHAR_RANGE:=NewPT(self.allocate_CHAR_RANGE,TYPECODE(CHAR_RANGE));BEGIN BEGIN
    result.val := CharRange.AllExceptNewline
   END;RETURN result;END
  END Proc_dot_CHAR_RANGE;

PROCEDURE <A NAME="Proc_STRING"><procedure>Proc_STRING</procedure></A>(self: T): Token =
  BEGIN (* user code *)
   VAR result:STRING:=NewPT(self.allocate_STRING,TYPECODE(STRING));BEGIN BEGIN
    result.val := CharCodes.ParseString(self.getText())
   END;RETURN result;END
  END Proc_STRING;

BEGIN
END RegExpLexStd.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
