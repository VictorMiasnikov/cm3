<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: klexlib/derived/RegExpParseNFA.i3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>klexlib/derived/RegExpParseNFA.i3</H2></A><HR>
<inInterface>
<PRE>INTERFACE <interface><A HREF="RegExpParseNFA.m3.html">RegExpParseNFA</A></interface>;
</PRE><BLOCKQUOTE><EM> generated by kext </EM></BLOCKQUOTE><PRE>
</PRE> extended parser definition 
<PRE>IMPORT <A HREF="RegExpParse.i3.html">RegExpParse</A>;
IMPORT <A HREF="RegExpLexStd.i3.html">RegExpLexStd</A>;
IMPORT <A HREF="../src/NFA.i3.html">NFA</A>;
TYPE
  expr = RegExpParse.expr BRANDED &quot;RegExpParseNFA.expr&quot; OBJECT
    val: NFA.T
  END;
  COUNT = RegExpLexStd.COUNT;
  CHAR_RANGE = RegExpLexStd.CHAR_RANGE;
  STRING = RegExpLexStd.STRING;
  IDENTIFIER = RegExpLexStd.IDENTIFIER;

  <A HREF="RegExpParseNFA.m3.html#T">T</A> &lt;: Public;
  Public = RegExpParse.T OBJECT
  METHODS
    init(): T;
    parseText(t: TEXT): NFA.T;
    putMacro(name: TEXT; n: NFA.T);
  END;

  (* And now, for a hack to allow compatible methods *)
  (* ... without importing the original parser *)
  Original_Parser = RegExpParse.Original_Parser;
  Original_expr = RegExpParse.Original_expr;
  (* ... and without importing the original token *)
  Original_COUNT = RegExpParse.Original_COUNT;
  Original_IDENTIFIER = RegExpParse.Original_IDENTIFIER;
  Original_CHAR_RANGE = RegExpParse.Original_CHAR_RANGE;
  Original_STRING = RegExpParse.Original_STRING;

  (* Make this interface as good as any token interface *)
  Token = RegExpLexStd.Token;
  ConstToken = RegExpLexStd.ConstToken;
  ParseType = RegExpLexStd.ParseType;
  Allocator = RegExpLexStd.Allocator;
  Lexer = RegExpLexStd.Lexer;
  RdLexer = RegExpLexStd.RdLexer;
CONST
  NewPT = RegExpLexStd.NewPT;
  Purge = RegExpLexStd.Purge;
  NewConstToken = RegExpLexStd.NewConstToken;
END RegExpParseNFA.
</PRE>
</inInterface>
<PRE>























</PRE>
</BODY>
</HTML>
