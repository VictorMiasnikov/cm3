<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: obliqlibemb/derived/ObEmbBundle.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>obliqlibemb/derived/ObEmbBundle.m3</H2></A><HR>
<inModule>
<PRE>MODULE <module><implements><A HREF="ObEmbBundle.i3.html">ObEmbBundle</A></implements></module>;
</PRE><BLOCKQUOTE><EM> Generated by m3bundle; see its manpage. </EM></BLOCKQUOTE><PRE>

IMPORT <A HREF="../../libm3/src/bundleintf/Bundle.i3.html">Bundle</A>, <A HREF="../../libm3/src/bundleintf/BundleRep.i3.html">BundleRep</A>, <A HREF="../../m3core/src/text/Text.i3.html">Text</A>;

TYPE T = Bundle.T OBJECT OVERRIDES
           get      := LookUp;
           getNames := GetNames;
         END;

TYPE Texts = REF ARRAY OF TEXT;

VAR
  bundle: T     := NIL;
  names : Texts := NIL;

PROCEDURE <A NAME="Get"><procedure>Get</procedure></A>(): Bundle.T =
  BEGIN
    IF (bundle = NIL) THEN bundle := NEW (T) END;
    RETURN bundle;
  END Get;

PROCEDURE <A NAME="GetNames"><procedure>GetNames</procedure></A> (&lt;*UNUSED*&gt; self: T): Texts =
  BEGIN
    IF names = NIL THEN
      names := NEW (Texts, NUMBER (Names));
      names^ := Names;
    END;
    RETURN names;
  END GetNames;

PROCEDURE <A NAME="LookUp"><procedure>LookUp</procedure></A> (&lt;*UNUSED*&gt; self: T;  element: TEXT): TEXT =
  BEGIN
    FOR i := 0 TO LAST (Names)-1 DO
      IF Text.Equal (Names[i], element) THEN
        RETURN Elements[i];
      END;
    END;
    RETURN NIL;
  END LookUp;

CONST Names = ARRAY [0..4] OF TEXT {
  &quot;EmbProxiedObj.obl&quot;,
  &quot;SharedObj.obl&quot;,
  &quot;EmbProxiedObj.hlp&quot;,
  &quot;SharedObj.hlp&quot;,
  NIL
};

CONST Elements = ARRAY [0..4] OF TEXT {
  E0,
  E1,
  E2,
  E3,
  NIL
};

CONST E0 =
   &quot;(* Copyright (C) 1994, Digital Equipment Corporation                   &quot;
 &amp; &quot;      *)\n(* Digital Internal Use Only                                 &quot;
 &amp; &quot;                *)\n(* All rights reserved.                            &quot;
 &amp; &quot;                          *)\n(*                                       &quot;
 &amp; &quot;                                    *)\n(* Last modified on Wed Jul 20 &quot;
 &amp; &quot;17:43:23 PDT 1994 by najork                   *)\n(*       Created on W&quot;
 &amp; &quot;ed Jul 20 09:39:54 PDT 1994 by najork                   *)\n\n\nmodule &quot;
 &amp; &quot;EmbProxiedObjWrap for EmbProxiedObj;\n\n(* extend is used to create sub&quot;
 &amp; &quot;types, and should only be used by \n   machine generated protos.  As lo&quot;
 &amp; &quot;ng as raw is \&quot;ok\&quot;, it can be used.  When \n   raw is actually assigne&quot;
 &amp; &quot;d to, it just returns self. *)\n\nlet TProto = {\n  protected, \n  raw &quot;
 &amp; &quot;   =&gt; ok,\n  extend =&gt; meth (self, o, r) \n\tvar new = ok;\n\tif self.r&quot;
 &amp; &quot;aw is ok then \n\t\tself.raw := r;\n\t\tif o is ok then \n\t\t\tnew := &quot;
 &amp; &quot;clone(self);\n\t\telse\n\t\t\tnew := clone(self, o);\n\t\tend;\n\t\tsel&quot;
 &amp; &quot;f.raw := ok;\n\telse\n\t\traise(EmbProxiedObj_Error);\n\tend;\n\tnew\n\t&quot;
 &amp; &quot;end,\n};\n\nend module;\n&quot;;

CONST E1 =
   &quot;module SharedObjWrap for SharedObj;\n\n(* location is can be used to fi&quot;
 &amp; &quot;nd the name of the host the shared object is \n   on.  Could use it to &quot;
 &amp; &quot;decide whether or not to Pull and object, or just\n   for testing and d&quot;
 &amp; &quot;ebugging. *)\nlet TProto = EmbProxiedObj_TProto.extend({\n  location =&gt;&quot;
 &amp; &quot; meth(self) sys_getEnvVar(\&quot;HOSTNAME\&quot;) end\n}, ok);\n\nend module;\n&quot;;

CONST E2 =
   &quot;  EmbProxiedObj_Error: Exception       \nWHERE\n  EmbProxiedObj &lt;: { ex&quot;
 &amp; &quot;tend: Self(X) All(Y&lt;:{}) (Y) =&gt; X &amp; Y }\n       Objects of this type al&quot;
 &amp; &quot;so contain a field \&quot;raw\&quot;, \n       which is for internal use.  \n&quot;;

CONST E3 =
   &quot;  SharedObj_AcquireGlobalLock(obj: T): Ok ! SharedObj_Error Thread_aler&quot;
 &amp; &quot;ted\n  SharedObj_ReleaseGlobalLock(obj: T): Ok ! SharedObj_Error Thread&quot;
 &amp; &quot;_alerted\n  SharedObj_Own(obj: T, t: Timeliness): Ok ! SharedObj_Error &quot;
 &amp; &quot;Thread_alerted\n  SharedObj_Disown(obj: T): Ok ! SharedObj_Error Thread&quot;
 &amp; &quot;_alerted\n  SharedObj_SetTimeliness(obj: T, t: Timeliness): Ok \n\t\t\t&quot;
 &amp; &quot;\t! SharedObj_Error Thread_alerted  \n  SharedObj_SetNodeName(name: Tex&quot;
 &amp; &quot;t): Text ! SharedObj_Error Thread_alerted  \n  SharedObj_SetDefaultSequ&quot;
 &amp; &quot;encer(host: Text, name: Text): Ok \n\t\t\t\t! SharedObj_Error Thread_al&quot;
 &amp; &quot;erted  \n  SharedObj_SetDebugLevel(level: Int): Ok\n  SharedObj_PullObj&quot;
 &amp; &quot;ect(obj: T): T;\n  SharedObj_Error: Exception       \n  SharedObj_Fatal&quot;
 &amp; &quot;: Exception        \nWHERE\n  T &lt;: EmbProxiedObj              \n  Timel&quot;
 &amp; &quot;iness = -8...7\n&quot;;

BEGIN
END ObEmbBundle.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
