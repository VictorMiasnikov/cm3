<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: visualobliq/src/Dialog.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>visualobliq/src/Dialog.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright (C) 1993, Digital Equipment Corporation 
 All rights reserved. 
 See the file COPYRIGHT for a full description. 
 

<P>
<P><PRE>MODULE <module>Dialog</module> EXPORTS <A HREF="../../m3core/src/main/Main.i3.html"><implements>Main</A></implements>, <A HREF="Dialog.i3.html"><implements>Dialog</A></implements>;

IMPORT <A HREF="Attributes.i3.html">Attributes</A>, <A HREF="../../libm3/src/geometry/Axis.i3.html">Axis</A>,  <A HREF="../derived/DialogBundle.i3.html">DialogBundle</A>, <A HREF="../../vbtkit/src/lego/FileBrowserVBT.i3.html">FileBrowserVBT</A>, <A HREF="../../libm3/src/rw/FileRd.i3.html">FileRd</A>,
       <A HREF="../../libm3/src/rw/FileWr.i3.html">FileWr</A>, <A HREF="../../libm3/src/fmtlex/Fmt.i3.html">Fmt</A>, <A HREF="../../formsvbt/src/FormsVBT.i3.html">FormsVBT</A>, <A HREF="../../formsvbt/src/FVTypes.i3.html">FVTypes</A>, <A HREF="GenerateObliq.i3.html">GenerateObliq</A>, <A HREF="NodeVBT.i3.html">NodeVBT</A>,
       <A HREF="ObliqRuntime.i3.html">ObliqRuntime</A>, <A HREF="../../libm3/src/os/Common/Pathname.i3.html">Pathname</A>, <A HREF="../../libm3/src/geometry/Point.i3.html">Point</A>, <A HREF="../../vbtkit/src/vbtkitutils/Pts.i3.html">Pts</A>, <A HREF="RW.i3.html">RW</A>, <A HREF="../../libm3/src/rw/Rd.i3.html">Rd</A>, <A HREF="../../libm3/src/geometry/Rect.i3.html">Rect</A>, <A HREF="../../vbtkit/src/vbtkitutils/Rsrc.i3.html">Rsrc</A>, <A HREF="../../ui/src/split/Split.i3.html">Split</A>,
       <A HREF="../../m3core/src/text/Text.i3.html">Text</A>, <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../ui/src/vbt/Trestle.i3.html">Trestle</A>, <A HREF="../../ui/src/vbt/TrestleComm.i3.html">TrestleComm</A>, <A HREF="../../ui/src/split/TSplit.i3.html">TSplit</A>, <A HREF="../../ui/src/vbt/VBT.i3.html">VBT</A>,
       <A HREF="../../ui/src/vbt/VBTClass.i3.html">VBTClass</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="ZHandleVBT.i3.html">ZHandleVBT</A>, <A HREF="../../ui/src/split/ZSplit.i3.html">ZSplit</A>,

       (* Import interfaces of extensions *)

       <A HREF="Browser.i3.html">Browser</A>, <A HREF="Clickable.i3.html">Clickable</A>, <A HREF="DialogMenu.i3.html">DialogMenu</A>, <A HREF="Textual.i3.html">Textual</A>, <A HREF="Setting.i3.html">Setting</A>, <A HREF="VideoWidget.i3.html">VideoWidget</A>;

&lt;* FATAL FormsVBT.Error, FormsVBT.Unimplemented *&gt;
&lt;* FATAL Rd.Failure, Rsrc.NotFound, Thread.Alerted, TrestleComm.Failure *&gt;
&lt;* FATAL Wr.Failure *&gt;
&lt;* FATAL NodeVBT.InstanceListFull, NodeVBT.InvalidObjectName, Split.NotAChild *&gt;

REVEAL
  <A NAME="T">T</A> = Public BRANDED &quot;VO-Dialog&quot; OBJECT
      METHODS
        initSelection () := InitSelection;
      OVERRIDES
        realize := Realize;
      END;

TYPE

  Blocker = FVTypes.FVFilter OBJECT
            OVERRIDES
              mouse    := BlockMouse;
              position := BlockPosition;
            END;

CodeType = { None, Global, ServerSide, SessionConstructor };

CONST myVerNum = 30; (* 3.0 *)

VAR
  filename              := &quot;&lt;unnamed&gt;&quot;;
  delta                 := 0;    (* global insertion offset *)
  testModeCtr      : INTEGER;
  testModeList     : ARRAY [1 .. 100] OF VBT.T;
  progname := &quot;&quot;;
  cutnode : NodeVBT.T := NIL; (* result of last cut operation *)
  loadingVerNum := 0;
  SaveCodeIn : CodeType;

PROCEDURE <A NAME="InitSelection"><procedure>InitSelection</procedure></A> (fv: T) =
  BEGIN
    fv.selection := NEW(ZHandleVBT.Selection);
    fv.selection.init(50, TRUE, fv);
  END InitSelection;

PROCEDURE <A NAME="NewDialog"><procedure>NewDialog</procedure></A> (): T =
  VAR
    fv      := NEW(T).initFromRsrc(&quot;dialog.fv&quot;, rsrcPath);
    ccl     := NEW(FormsVBT.Closure, apply := CreateProc);
    modecl  := NEW(FormsVBT.Closure, apply := ModesProc);
    alncl    := NEW(FormsVBT.Closure, apply := AlignProc);
    shcl := NEW(FormsVBT.Closure, apply := ShapeProc);
    discl := NEW(FormsVBT.Closure, apply := DistributeProc);
    sxcl    := NEW(FormsVBT.Closure, apply := SXProc);
    sccl    := NEW(FormsVBT.Closure, apply := SCProc);
    svcl :=  NEW(FormsVBT.Closure, apply := SVRProc);
    gccl    := NEW(FormsVBT.Closure, apply := GCProc);
    buildcl := NEW(FormsVBT.Closure, apply := buildProc);
    cutcl   := NEW(FormsVBT.Closure, apply := CutProc);
    pastecl := NEW(FormsVBT.Closure, apply := PasteProc);
  BEGIN
    InitSelection(fv);

    FormsVBT.AttachProc (fv, &quot;invite1&quot;, InviteProc);
    FormsVBT.AttachProc (fv, &quot;invite2&quot;, InviteProc);
    FormsVBT.AttachProc (fv, &quot;run&quot;, RunProc);
    FormsVBT.AttachProc (fv, &quot;viewmethods&quot;, MethodsProc);
    FormsVBT.AttachProc (fv, &quot;codeapply&quot;, ApplyCodeProc);

    FormsVBT.Attach(fv, &quot;form&quot;, ccl);
    FormsVBT.Attach(fv, &quot;frame&quot;, ccl);
    FormsVBT.Attach(fv, &quot;button&quot;, ccl);
    FormsVBT.Attach(fv, &quot;choice&quot;, ccl);
    FormsVBT.Attach(fv, &quot;hscroll&quot;, ccl);
    FormsVBT.Attach(fv, &quot;vscroll&quot;, ccl);
    FormsVBT.Attach(fv, &quot;boolean&quot;, ccl);
    FormsVBT.Attach(fv, &quot;numeric&quot;, ccl);
    FormsVBT.Attach(fv, &quot;text&quot;, ccl);
    FormsVBT.Attach(fv, &quot;textedit&quot;, ccl);
    FormsVBT.Attach(fv, &quot;typein&quot;, ccl);
    FormsVBT.Attach(fv, &quot;browser&quot;, ccl);
    FormsVBT.Attach(fv, &quot;filebrowser&quot;, ccl);
    FormsVBT.Attach(fv, &quot;video&quot;, ccl);

    FormsVBT.Attach(fv, &quot;AlignNorth&quot;, alncl);
    FormsVBT.Attach(fv, &quot;AlignSouth&quot;, alncl);
    FormsVBT.Attach(fv, &quot;AlignEast&quot;, alncl);
    FormsVBT.Attach(fv, &quot;AlignWest&quot;, alncl);
    FormsVBT.Attach(fv, &quot;AlignHoriz&quot;, alncl);
    FormsVBT.Attach(fv, &quot;AlignVert&quot;, alncl);
    FormsVBT.Attach(fv, &quot;AlignHoriz&quot;, alncl);
    FormsVBT.Attach(fv, &quot;AlignCenVert&quot;, alncl);
    FormsVBT.Attach(fv, &quot;AlignCenHoriz&quot;, alncl);

    FormsVBT.Attach(fv, &quot;EqualWidth&quot;, shcl);
    FormsVBT.Attach(fv, &quot;EqualHt&quot;, shcl);
    FormsVBT.Attach(fv, &quot;EqualDim&quot;, shcl);

    FormsVBT.Attach(fv, &quot;DistHoriz&quot;, discl);
    FormsVBT.Attach(fv, &quot;DistVert&quot;, discl);
    FormsVBT.Attach(fv, &quot;DistBoth&quot;, discl);

    FormsVBT.Attach(fv, &quot;gensx&quot;, sxcl);
    FormsVBT.Attach(fv, &quot;sxtypein&quot;, sxcl);
    FormsVBT.Attach(fv, &quot;sxbutton&quot;, sxcl);

    FormsVBT.Attach(fv, &quot;editsc&quot;, sccl);
    FormsVBT.Attach(fv, &quot;editgc&quot;, gccl);
    FormsVBT.Attach(fv, &quot;editsvr&quot;, svcl);

    FormsVBT.Attach(fv, &quot;buildbtn&quot;, buildcl);
    FormsVBT.Attach(fv, &quot;build&quot;, buildcl);

    (* editing actions *)
    FormsVBT.Attach(fv, &quot;cut&quot;, cutcl);
    FormsVBT.Attach(fv, &quot;delete&quot;, cutcl);
    FormsVBT.Attach(fv, &quot;paste&quot;, pastecl);

    (* local settings *)
    FormsVBT.Attach(fv, &quot;testbild&quot;, modecl);

    (* global settings *)
    FormsVBT.AttachProc (fv, &quot;showsettings&quot;, PopSettingsProc);
    FormsVBT.AttachProc (fv, &quot;oksettings&quot;, OKSettingsProc);

    FormsVBT.AttachProc (fv, &quot;open&quot;, OpenProc);
    FormsVBT.AttachProc (fv, &quot;openbtn&quot;, OpenProc);
    FormsVBT.AttachProc (fv, &quot;openSuffixes&quot;, ChangeSuffixesProc);

    FormsVBT.AttachProc (fv, &quot;saveas&quot;, SaveAsProc);
    FormsVBT.AttachProc (fv, &quot;saveasbtn&quot;, SaveAsProc);

    FormsVBT.AttachProc (fv, &quot;clearworkspace&quot;, ClearWorkspaceProc);
    FormsVBT.AttachProc (fv, &quot;addscreen&quot;, AddScreenProc);
    FormsVBT.AttachProc (fv, &quot;quit&quot;, QuitProc);

    RETURN fv;
  END NewDialog;
</PRE> now the rigmarole to make the widgets in the menu inactive 
<PRE>PROCEDURE <A NAME="Realize"><procedure>Realize</procedure></A> (fv: T; type: TEXT; name: TEXT): VBT.T
  RAISES {FormsVBT.Error} =
  BEGIN
    IF Text.Equal(type, &quot;Filter&quot;) THEN
      RETURN NEW(Blocker)
    ELSE
      RETURN FormsVBT.T.realize(fv, type, name);
    END;
  END Realize;

PROCEDURE <A NAME="BlockMouse"><procedure>BlockMouse</procedure></A> (&lt;* UNUSED *&gt;          v : Blocker;
                      &lt;* UNUSED *&gt; READONLY cd: VBT.MouseRec) =
  BEGIN
  END BlockMouse;

PROCEDURE <A NAME="BlockPosition"><procedure>BlockPosition</procedure></A> (&lt;* UNUSED *&gt;          v : Blocker;
                         &lt;* UNUSED *&gt; READONLY cd: VBT.PositionRec) =
  BEGIN
  END BlockPosition;

PROCEDURE <A NAME="message"><procedure>message</procedure></A> (fv: FormsVBT.T; txt: TEXT) =
  BEGIN
    FormsVBT.PutText(fv, &quot;msg&quot;, txt, FALSE);
    WITH msgbox = FormsVBT.GetVBT(fv, &quot;msgbox&quot;) DO
      ZSplit.Map(msgbox);
      ZSplit.Lift(msgbox)
    END
  END message;

PROCEDURE <A NAME="QuitProc"><procedure>QuitProc</procedure></A> (&lt;* UNUSED *&gt; fv  : FormsVBT.T;
                    &lt;* UNUSED *&gt; name: TEXT;
                    &lt;* UNUSED *&gt; data: REFANY;
                    &lt;* UNUSED *&gt; time: VBT.TimeStamp) =
  BEGIN
    FOR i := 1 TO screens DO
      IF screen[i] # NIL THEN
        Trestle.Delete(screen[i]);
        screen[i] := NIL;
      END
    END
  END QuitProc;

PROCEDURE <A NAME="PasteProc"><procedure>PasteProc</procedure></A>(&lt;* UNUSED *&gt; cl  : FormsVBT.Closure;
                    fv  : FormsVBT.T;
                    &lt;* UNUSED *&gt; name: TEXT;
                    &lt;* UNUSED *&gt; time: VBT.TimeStamp) =
VAR
  dialog := NARROW(fv, T);
  n      := dialog.selection.getSelectionSize();
  zsplit  : VBT.T;
  BEGIN

    IF cutnode = NIL THEN RETURN; END;

    PixelsPerPtHor := Pts.ToPixels(fv, 1.0, Axis.T.Hor);
    PixelsPerPtVer := Pts.ToPixels(fv, 1.0, Axis.T.Ver);

    IF ISTYPE(cutnode, NodeVBT.FormNode) THEN
      WITH f = NARROW(cutnode, NodeVBT.FormNode) DO
        f.Screen := dialog.screenindex;
        f.ParentForm := NIL;
        zsplit := FormsVBT.GetVBT(fv, &quot;topZSplit&quot;);
        ZSplit.InsertAt(NARROW(zsplit, ZSplit.T), cutnode,
                        Point.Add(Rect.NorthWest(VBT.Domain(zsplit)),
                                  Point.T{30, 30}));
        WITH
          width  = ROUND(PixelsPerPtHor * FLOAT(cutnode.width)),
          height = ROUND(PixelsPerPtVer * FLOAT(cutnode.height)) DO
          ZSplit.Move(cutnode,
            Rect.FromCorners(Point.Add(Rect.NorthWest(VBT.Domain(zsplit)),
                                                 Point.T{30,30}),
                               Point.Add(Rect.NorthWest(VBT.Domain(zsplit)),
                                         Point.T{30+width,30+height})));
        END;
      END;
    ELSIF n &lt; 1 THEN
      message(fv, &quot;You need to select an object first&quot;); RETURN;
    ELSIF n &gt; 1 THEN
      message(fv, &quot;You need to select a single object, a form or a frame&quot;);
      RETURN;
    ELSE
      WITH cso = dialog.selection.getSelection(1) DO
        IF NOT ISTYPE(cso, NodeVBT.SplitNode) THEN
          message(fv, &quot;You can only insert in a form or a frame&quot;); RETURN;
        END;
        WITH csn = NARROW(cso, NodeVBT.SplitNode) DO
          INC(csn.nc);
          csn.children[csn.nc] := cutnode;
          ZSplit.InsertAt(
              csn, cutnode, Point.Add(Rect.NorthWest(VBT.Domain(csn)),
                                   Point.T{10,10}));
          WITH
            width  = ROUND(PixelsPerPtHor * FLOAT(cutnode.width)),
            height = ROUND(PixelsPerPtVer * FLOAT(cutnode.height)) DO
            ZSplit.Move(cutnode,
              Rect.FromCorners(Point.Add(Rect.NorthWest(VBT.Domain(csn)),
                                         Point.T{10,10}),
                               Point.Add(Rect.NorthWest(VBT.Domain(csn)),
                                         Point.T{10+width,10+height})));
          END;
          cutnode.parent := csn;

        END
      END;
    END;
    NodeVBT.RecursivelyInsertInTables(cutnode, dialog.selection);
    cutnode := NIL; (* only once *)
  END PasteProc;

PROCEDURE <A NAME="CutProc"><procedure>CutProc</procedure></A> (&lt;* UNUSED *&gt; cl  : FormsVBT.Closure;
                                fv  : FormsVBT.T;
                                name: TEXT;
                   &lt;* UNUSED *&gt; time: VBT.TimeStamp     ) =
  VAR
    moveback := FALSE;
    current  : NodeVBT.T;
  BEGIN
    WITH dialog = NARROW(fv, T),
         n      = dialog.selection.getSelectionSize() DO
      IF n &lt; 1 THEN
        message(fv, &quot;You need to select an object first&quot;)
      ELSIF n &gt; 1 THEN
        message(fv, &quot;You may only &quot; &amp; name &amp; &quot; single objects, not groups&quot;)
      ELSE

        WITH cso = dialog.selection.getSelection(1),
             csn = NARROW(cso, NodeVBT.T),
             par = csn.parent  DO
          IF Text.Equal(name, &quot;cut&quot;) THEN
            cutnode := csn;
            NodeVBT.ComputeDimensions(csn);
          END;
          IF ISTYPE(csn, NodeVBT.FormNode) THEN
            (* disconnect all anchored forms *)
            WITH formclass = NodeVBT.NameToIndex(&quot;form&quot;),
                 n         = NodeVBT.NoOfObjects(formclass) DO
              FOR i := 0 TO n - 1 DO
                IF i = 0 THEN
                  current := NodeVBT.GetFirst(formclass);
                ELSE
                  current := NodeVBT.GetNext(formclass);
                END;
                WITH cur = NARROW(current, NodeVBT.FormNode) DO
                  IF cur.ParentForm = csn THEN cur.ParentForm := NIL; END
                END
              END;
              WITH zsplit = FormsVBT.GetVBT(fv, &quot;topZSplit&quot;),
                   s      = NARROW(zsplit, Split.T)           DO
                Split.Delete(s, csn);
              END
            END;
          ELSE
            (* assert : csn is a member of the parent's children array *)
            WITH p = NARROW(par, NodeVBT.SplitNode) DO
              FOR i := 1 TO p.nc DO
                IF moveback THEN
                  p.children[i - 1] := p.children[i]
                ELSE
                  moveback := (p.children[i] = csn);
                END
              END;
              (* assert : moveback has to be true *)
              DEC(p.nc);
              Split.Delete(p, csn);
            END
          END;
          NodeVBT.RecursivelyDeleteFromTables(csn);
        END
      END;
    END
  END CutProc;

PROCEDURE <A NAME="ClearWorkspaceProc"><procedure>ClearWorkspaceProc</procedure></A> (&lt;* UNUSED *&gt; fv  : FormsVBT.T;
                              &lt;* UNUSED *&gt; name: TEXT;
                              &lt;* UNUSED *&gt; data: REFANY;
                              &lt;* UNUSED *&gt; time: VBT.TimeStamp) =
  VAR last := screen[1];         (* because of AwaitDelete *)
  BEGIN

    (* Get PixelsPerPt info *)

    PixelsPerPtHor := Pts.ToPixels(last, 1.0, Axis.T.Hor);
    PixelsPerPtVer := Pts.ToPixels(last, 1.0, Axis.T.Ver);

    FOR i := 2 TO screens DO
      IF screen[i] # NIL THEN
        Trestle.Delete(screen[i]);
        screen[i] := NIL;
      END
    END;
    screens := 1;
    filename := &quot;&lt;unnamed&gt;&quot;;
    WITH z = NewDialog() DO
      Trestle.Install(z, applName := &quot;VisualObliq&quot;,
                      inst := Fmt.Int(1),
                      windowTitle :=
                        &quot;Visual Obliq Editor(&quot; &amp; Fmt.Int(1)
                          &amp; &quot;) - &quot; &amp; filename);
      screen[1] := z;
      z.screenindex := 1;
    END;
    IF last # NIL THEN Trestle.Delete(last); END;
    NodeVBT.ResetTables();
    NodeVBT.ReloadSExpressions();
    GenerateObliq.sessionConstructor := &quot;CreateEachFormOnce(LOCAL);\n&quot;;
    GenerateObliq.globalCode  := &quot;&quot;;
    GenerateObliq.serverSideCode  := &quot;&quot;;
  END ClearWorkspaceProc;

PROCEDURE <A NAME="OpenProc"><procedure>OpenProc</procedure></A> (             fv  : FormsVBT.T;
                    &lt;* UNUSED *&gt; name: TEXT;
                    &lt;* UNUSED *&gt; data: REFANY;
                    &lt;* UNUSED *&gt; time: VBT.TimeStamp) =
  VAR
    s       : Rd.T;
    f, title: TEXT;
    last    : T;
  BEGIN
    f := FormsVBT.GetText(fv, &quot;open&quot;);
    TRY
      s := FileRd.Open(f)
    EXCEPT
    ELSE
      message(fv, &quot;Couldn't open &quot; &amp; f);
      RETURN;
    END;
    filename := Pathname.Last(f);
    RW.rtext(s, title);

    IF Text.Equal(title, &quot;Visual Obliq File&quot;) THEN
      loadingVerNum := 25; (* version 2.5 *)
    ELSIF Text.Equal(title, &quot;Visual Obliq File, Version =&quot;) THEN
       RW.rint(s, loadingVerNum);         (* no of screens *)
       IF loadingVerNum &gt; myVerNum THEN
         message(fv, &quot;File has newer format than supported!&quot;);
         RETURN;
       END
    ELSE
      message(fv, &quot;Illegal File Format : &quot; &amp; f);
      RETURN;
    END;

    last := screen[1];           (* because of AwaitDelete *)

    (* Get PixelsPerPt info *)

    PixelsPerPtHor := Pts.ToPixels(last, 1.0, Axis.T.Hor);
    PixelsPerPtVer := Pts.ToPixels(last, 1.0, Axis.T.Ver);

    FOR i := 2 TO screens DO
      IF screen[i] # NIL THEN
        Trestle.Delete(screen[i]);
        screen[i] := NIL;
      END
    END;

    RW.rint(s, screens);         (* no of screens *)

    IF screens &lt; 1 THEN screens := 1 END;
    (* at all costs must have at least one screen !  0 screens =&gt;
       error in file *)

    FOR i := 1 TO screens DO     (* make sure all the screens are
                                    present *)
      WITH z = NewDialog() DO
        Trestle.Install(
          z, applName := &quot;VisualObliq&quot;, inst := Fmt.Int(i),
          windowTitle := &quot;Visual Obliq Editor(&quot; &amp; Fmt.Int(i)
                           &amp; &quot;) - &quot; &amp; filename);
        screen[i] := z;
        z.screenindex := i;
      END
    END;

    IF last # NIL THEN Trestle.Delete(last); END;

    NodeVBT.LoadFromFile(screen[1], s);

    IF loadingVerNum &gt;= 30 THEN (* only for backward compatibility *)
      (* load the session constructor code - version 3.0 and above *)
      RW.rtext(s, GenerateObliq.sessionConstructor);
      (* load the global code - version 3.0 and above *)
      RW.rtext(s, GenerateObliq.globalCode);
      (* load the server side code - version 3.0 and above *)
      RW.rtext(s, GenerateObliq.serverSideCode);
    END;

    FormsVBT.PopDown (fv, &quot;open&quot;);
  END OpenProc;

PROCEDURE <A NAME="SaveAsProc"><procedure>SaveAsProc</procedure></A> (             fv  : FormsVBT.T;
                      &lt;* UNUSED *&gt; name: TEXT;
                      &lt;* UNUSED *&gt; data: REFANY;
                      &lt;* UNUSED *&gt; time: VBT.TimeStamp) =
  VAR
    f: TEXT;
    s: Wr.T;
  BEGIN
    f := FormsVBT.GetText(fv, &quot;saveas&quot;);
    TRY
      s := FileWr.Open(f)
    EXCEPT
    ELSE
      message(fv, &quot;Couldn't open &quot; &amp; f);
      RETURN;
    END;
    filename := Pathname.Last(f);
    RW.wtext(s,  &quot;Visual Obliq File, Version =&quot;);
    RW.wint(s, myVerNum);
    RW.wint(s, screens);         (* no of screens *)
    NodeVBT.SaveToFile(fv, s);

    (* save the session constructor code - version 3.0 and above *)
    RW.wtext(s, GenerateObliq.sessionConstructor);
    (* save the global code - version 3.0 and above *)
    RW.wtext(s, GenerateObliq.globalCode);
    (* save the server side code - version 3.0 and above *)
    RW.wtext(s, GenerateObliq.serverSideCode);

    Wr.Close(s);
    FormsVBT.PopDown (fv, &quot;saveas&quot;);
  END SaveAsProc;

PROCEDURE <A NAME="ChangeSuffixesProc"><procedure>ChangeSuffixesProc</procedure></A> (             fv  : FormsVBT.T;
                              &lt;* UNUSED *&gt; name: TEXT;
                              &lt;* UNUSED *&gt; data: REFANY;
                              &lt;* UNUSED *&gt; time: VBT.TimeStamp) =
  VAR fb: FileBrowserVBT.T;
  BEGIN
    TRY
      fb := FormsVBT.GetVBT(fv, &quot;open&quot;);
      IF FormsVBT.GetBoolean(fv, &quot;openSuffixes&quot;) THEN
        FileBrowserVBT.SetSuffixes(fb, &quot;vo&quot;)
      ELSE
        FileBrowserVBT.SetSuffixes(fb, &quot;&quot;)
      END
    EXCEPT
    | FormsVBT.Error =&gt; message(fv, &quot;Couldn't change suffixes&quot;);
    END
  END ChangeSuffixesProc;

PROCEDURE <A NAME="RunProc"><procedure>RunProc</procedure></A> (             fv  : FormsVBT.T;
                   &lt;* UNUSED *&gt; name: TEXT;
                   &lt;* UNUSED *&gt; data: REFANY;
                   &lt;* UNUSED *&gt; time: VBT.TimeStamp) =
  BEGIN

    ObliqRuntime.Do( GenerateObliq.GenerateCode(fv));

  END RunProc;

PROCEDURE <A NAME="ApplyCodeProc"><procedure>ApplyCodeProc</procedure></A> (             fv  : FormsVBT.T;
                   &lt;* UNUSED *&gt; name: TEXT;
                   &lt;* UNUSED *&gt; data: REFANY;
                   &lt;* UNUSED *&gt; time: VBT.TimeStamp) =
  BEGIN
    IF SaveCodeIn = CodeType.Global THEN
      GenerateObliq.globalCode := FormsVBT.GetText(fv, &quot;codeview&quot;);
    ELSIF SaveCodeIn = CodeType.ServerSide THEN
      GenerateObliq.serverSideCode := FormsVBT.GetText(fv, &quot;codeview&quot;);
    ELSIF SaveCodeIn = CodeType.SessionConstructor THEN
      GenerateObliq.sessionConstructor := FormsVBT.GetText(fv, &quot;codeview&quot;);
    END (* IF *)
  END ApplyCodeProc;

PROCEDURE <A NAME="MethodsProc"><procedure>MethodsProc</procedure></A> (             fv  : FormsVBT.T;
                   &lt;* UNUSED *&gt; name: TEXT;
                   &lt;* UNUSED *&gt; data: REFANY;
                   &lt;* UNUSED *&gt; time: VBT.TimeStamp) =
VAR
  parentage:= &quot;&quot;;
  curparent : NodeVBT.T;
  par : NodeVBT.FormNode;

  BEGIN

    WITH dialog = NARROW(fv, T),
         n      = dialog.selection.getSelectionSize() DO
      IF n &lt; 1 THEN
        message(fv, &quot;You need to select an object first&quot;)
      ELSIF n &gt; 1 THEN
        message( fv,  &quot;Methods can be displayed only  for single objects, not for groups&quot;)
      ELSE
        WITH cso = dialog.selection.getSelection(1),
             csn = NARROW(cso, NodeVBT.T),
             classname  = NodeVBT.IndexToName(csn.classIndex),
             inforef = NodeVBT.GetInfo(classname)
         DO

          (* Change the title of the code viewer appropriately *)
          FormsVBT.PutText(fv, &quot;cvtitle&quot;, csn.name &amp;&quot; - Interface&quot;);

          FormsVBT.PutText(fv, &quot;codeTitle&quot;, &quot;&quot;);
          SaveCodeIn := CodeType.None;

          (* get help on topic *)
          IF inforef = NIL THEN
            message( fv,  &quot;Could not access method definition&quot;)
          ELSE

            (* Ascertain parentage of this widget *)
            IF ISTYPE(csn, NodeVBT.FormNode) THEN
              parentage := parentage &amp; &quot;The form-widget, &quot; &amp; csn.name &amp; &quot;, is also part of a form&quot; &amp;
                               &quot; by the same name&quot;;
              curparent := csn;
            ELSE
              curparent := csn.parent;
              WHILE NOT ISTYPE(curparent, NodeVBT.FormNode) DO
                 curparent := curparent.parent;
              END;
              parentage := parentage &amp;  csn.name &amp; &quot; is part of the form, &quot; &amp;
                               curparent.name;
            END;

            (* If curparent is not the top then we list the anchorage *)
            par :=  NARROW(curparent, NodeVBT.FormNode).ParentForm;
            WHILE par # NIL DO
              curparent := par;
              parentage := parentage &amp; &quot;, which is anchored to &quot; &amp; par.name;
              par := par.ParentForm;
            END;
            parentage := parentage &amp; &quot;. Within an instance of &quot; &amp; curparent.name &amp;
                             &quot; you may refer to the &quot; &amp; csn.name &amp; &quot; widget within it as SELF.&quot; &amp;
                             csn.name &amp; &quot;. In other cases you would refer to this widget as &quot; &amp;
                             curparent.name &amp; &quot;[&lt;index&gt;].&quot; &amp; csn.name &amp; &quot; instead. Here &quot; &amp;
                             &quot;&lt;index&gt; refers to the instance of &quot; &amp; curparent.name &amp;
                             &quot; containing the widget.\n\n&quot;;

            FormsVBT.PutText(fv, &quot;cvinstns&quot;, &quot;The selected object, &quot; &amp; csn.name &amp;
              &quot;, is an object of class, &quot; &amp; classname &amp; &quot;, and can be manipulated using &quot; &amp;
              &quot;the methods shown below.\n\n&quot; &amp;
              &quot;Usage\n-----\n&quot; &amp; parentage &amp;
              &quot;Also shown below are the methods in the Visual Obliq library. These may be refered to &quot; &amp;
              &quot;in general as volibLocal.&lt;method-name&gt;. However callbacks may at times get executed &quot; &amp;
              &quot;remotely. Hence, if you are within a callback it may be better to use  &quot; &amp;
              &quot;LOCAL.&lt;method-name&gt; instead.\n&quot;);
            FormsVBT.PutText(fv, &quot;codeview&quot;, inforef.info  &amp; NodeVBT.GetInfo(&quot;Local&quot;).info);
          END
        END
      END

    END

  END MethodsProc;

PROCEDURE <A NAME="InviteProc"><procedure>InviteProc</procedure></A> (             fv  : FormsVBT.T;
                       &lt;* UNUSED *&gt; name: TEXT;
                       &lt;* UNUSED *&gt; data: REFANY;
                       &lt;* UNUSED *&gt; time: VBT.TimeStamp) =
  VAR where := FormsVBT.GetText(fv, &quot;invite2&quot;);
  BEGIN
    FormsVBT.PutText(fv, &quot;invite2&quot;, &quot;&quot;);
    ObliqRuntime.Do(&quot;installAt (\&quot;&quot; &amp; where &amp; &quot;\&quot;);&quot;);
  END InviteProc;

PROCEDURE <A NAME="buildProc"><procedure>buildProc</procedure></A> (&lt;* UNUSED *&gt; cl  : FormsVBT.Closure;
                                  fv  : FormsVBT.T;
                     &lt;* UNUSED *&gt; name: TEXT;
                     &lt;* UNUSED *&gt; time: VBT.TimeStamp     ) =
  BEGIN

    progname := FormsVBT.GetText(fv, &quot;build&quot;);
    EVAL GenerateObliq.GenerateCode(fv, progname,FormsVBT.GetBoolean(fv, &quot;singleFile&quot;));
    FormsVBT.PopDown (fv, &quot;buildDialog&quot;);
  END buildProc;

PROCEDURE <A NAME="ShapeProc"><procedure>ShapeProc</procedure></A> (&lt;* UNUSED *&gt; cl  : FormsVBT.Closure;
  fv  : FormsVBT.T;
  name: TEXT;
  &lt;* UNUSED *&gt; time: VBT.TimeStamp     ) =
  VAR
  modeOfAlignment := FormsVBT.GetChoice(fv, &quot;shapeMode&quot;);
  BEGIN
    (* get hold of the selection *)
    WITH dfv = NARROW(fv, T) DO
      IF Text.Equal(name, &quot;EqualDim&quot;) THEN
        dfv.selection.shapeSelectedObjects(&quot;EqualWidth&quot;, modeOfAlignment);
        dfv.selection.shapeSelectedObjects(&quot;EqualHt&quot;, modeOfAlignment);
      ELSE
        dfv.selection.shapeSelectedObjects(name, modeOfAlignment);
      END
    END (* WITH *)
  END ShapeProc;

PROCEDURE <A NAME="DistributeProc"><procedure>DistributeProc</procedure></A> (&lt;* UNUSED *&gt; cl  : FormsVBT.Closure;
  fv  : FormsVBT.T;
  name: TEXT;
  &lt;* UNUSED *&gt; time: VBT.TimeStamp     ) =
  BEGIN
    (* get hold of the selection *)
    WITH dfv = NARROW(fv, T) DO
      IF Text.Equal(name, &quot;DistBoth&quot;) THEN
        dfv.selection.distributeSelectedObjects(&quot;DistHoriz&quot;);
        dfv.selection.distributeSelectedObjects(&quot;DistVert&quot;);
      ELSE
        dfv.selection.distributeSelectedObjects(name);
      END
    END (* WITH *)
  END DistributeProc;

PROCEDURE <A NAME="AlignProc"><procedure>AlignProc</procedure></A> (&lt;* UNUSED *&gt; cl  : FormsVBT.Closure;
  fv  : FormsVBT.T;
  name: TEXT;
  &lt;* UNUSED *&gt; time: VBT.TimeStamp     ) =
VAR
  modeOfAlignment := FormsVBT.GetChoice(fv, &quot;alignMode&quot;);
  stretchAlign := FormsVBT.GetBoolean(fv, &quot;stretchAlign&quot;);
  BEGIN
    (* get hold of the selection *)
    WITH dfv = NARROW(fv, T) DO
      IF Text.Equal(name, &quot;AlignHoriz&quot;) THEN
        dfv.selection.alignSelectedObjects(&quot;AlignNorth&quot;, modeOfAlignment);
        dfv.selection.alignSelectedObjects(&quot;AlignSouth&quot;, modeOfAlignment);
          (* The next command may seem redundant but it is not
             since the previous command moved the south
             edges there may be some alignments that are
            now legal - so we do the north again*)
        dfv.selection.alignSelectedObjects(&quot;AlignNorth&quot;, modeOfAlignment);
      ELSIF Text.Equal(name, &quot;AlignVert&quot;) THEN

        dfv.selection.alignSelectedObjects(&quot;AlignEast&quot;, modeOfAlignment);
        dfv.selection.alignSelectedObjects(&quot;AlignWest&quot;, modeOfAlignment);

        (* The next command may seem redundant but it is not
            since the previous command moved the west
            edges there may be some alignments that are
            now legal - so we do the east again *)
        dfv.selection.alignSelectedObjects(&quot;AlignEast&quot;, modeOfAlignment);
      ELSE
      dfv.selection.alignSelectedObjects(name, modeOfAlignment, NOT stretchAlign);
      END
    END (* WITH *)
  END AlignProc;

PROCEDURE <A NAME="SXProc"><procedure>SXProc</procedure></A> (&lt;* UNUSED *&gt; cl  : FormsVBT.Closure;
                               fv  : FormsVBT.T;
                               name: TEXT;
                  &lt;* UNUSED *&gt; time: VBT.TimeStamp     ) =
  VAR
    filename          := FormsVBT.GetText(fv, &quot;sxtypein&quot;);
    writer  : Wr.T;
  BEGIN
    IF Text.Equal(name, &quot;gensx&quot;) THEN
      WITH dialog = NARROW(fv, T),
           n      = dialog.selection.getSelectionSize() DO
        IF n &lt; 1 THEN
          message(fv, &quot;You need to select an object first&quot;)
        ELSIF n &gt; 1 THEN
          message( fv,   &quot;You can generate the SX only for single objects, not for groups&quot;)
        ELSE
          WITH cso = dialog.selection.getSelection(1),
               csn = NARROW(cso, NodeVBT.T)            DO
            TRY
              NodeVBT.ComputeDimensions(csn);
              csn.DialogSX := csn.SXTemplate();
              FormsVBT.PutText(fv, &quot;sxview&quot;, csn.computeSX(TRUE));
              FormsVBT.PopUp(fv, &quot;sxviewer&quot;);
            EXCEPT
            ELSE
              message(fv, &quot;Unable to generate SX for &quot; &amp; csn.name);
            END;
          END
        END
      END;
      RETURN;
    END;

    TRY
      writer := FileWr.Open(filename);
      Wr.PutText(writer, FormsVBT.GetText(fv, &quot;sxview&quot;));
      Wr.Close(writer);
    EXCEPT
    ELSE
      message(fv, &quot;Unable to save to &quot; &amp; filename);
    END
  END SXProc;

PROCEDURE <A NAME="SCProc"><procedure>SCProc</procedure></A> (&lt;* UNUSED *&gt; cl  : FormsVBT.Closure;
                               fv  : FormsVBT.T;
                   &lt;* UNUSED *&gt;            name: TEXT;
                  &lt;* UNUSED *&gt; time: VBT.TimeStamp     ) =

  BEGIN
    FormsVBT.PutText(fv, &quot;cvtitle&quot;, &quot;Edit Session Constructor&quot;);

    WITH t = Rsrc.Open(&quot;sessionConstructor.help&quot;, rsrcPath),
         contents = Rd.GetText(t, LAST(CARDINAL)) DO
      FormsVBT.PutText(fv, &quot;cvinstns&quot;, contents &amp; NodeVBT.GetInfo(&quot;Local&quot;).info);
      Rd.Close(t)
    END;

    FormsVBT.PutText(fv, &quot;codeview&quot;,  GenerateObliq.sessionConstructor);
    SaveCodeIn := CodeType.SessionConstructor;
    FormsVBT.PutText(fv, &quot;codeTitle&quot;, &quot;Save Session Constructor&quot;);

  END SCProc;

PROCEDURE <A NAME="GCProc"><procedure>GCProc</procedure></A> (&lt;* UNUSED *&gt; cl  : FormsVBT.Closure;
                               fv  : FormsVBT.T;
                     &lt;* UNUSED *&gt;          name: TEXT;
                  &lt;* UNUSED *&gt; time: VBT.TimeStamp     ) =

  BEGIN
    FormsVBT.PutText(fv, &quot;cvtitle&quot;, &quot;Edit Global Code&quot;);

    FormsVBT.PutText(fv, &quot;cvinstns&quot;,
        &quot;\t\tGlobal Code \n&quot;
    &amp;   &quot;\t\t***********\n\n&quot;
    &amp; &quot;The code and data  you put in here will be shared by all members of the session. &quot;
    &amp; &quot;Any code that is placed here will get executed at the server site  before the session &quot;
    &amp; &quot;starts up. volibLocal will refer to the Visual Obliq library at the server. If you would &quot;
    &amp; &quot;like the procedures and methods you define here to use the local instance of the &quot;
    &amp; &quot;Visual Obliq library, you need to pass it in as a parameter.\n\n&quot;
    &amp; &quot;This is a convenient place to keep synchronization variables, and status information that &quot;
    &amp; &quot;new forms will need to bring shared widgets up to speed.\n\n&quot;
    &amp; NodeVBT.GetInfo(&quot;Local&quot;).info
      );
    FormsVBT.PutText(fv, &quot;codeview&quot;,  GenerateObliq.globalCode);
    SaveCodeIn := CodeType.Global;
   FormsVBT.PutText(fv, &quot;codeTitle&quot;, &quot;Save Global Code&quot;);
  END GCProc;

PROCEDURE <A NAME="SVRProc"><procedure>SVRProc</procedure></A> (&lt;* UNUSED *&gt; cl  : FormsVBT.Closure;
                               fv  : FormsVBT.T;
                  &lt;* UNUSED *&gt;           name: TEXT;
                  &lt;* UNUSED *&gt; time: VBT.TimeStamp     ) =

  BEGIN
    FormsVBT.PutText(fv, &quot;cvtitle&quot;, &quot;Edit Server Side Code&quot;);

    FormsVBT.PutText(fv, &quot;cvinstns&quot;,
        &quot;\t\tServer Side Code \n&quot;
    &amp;   &quot;\t\t****************\n\n&quot;
    &amp; &quot;The code you place here will get executed at the server after the session comes up. &quot;
    &amp; &quot;It will not be accessible to other hosts\n\n&quot;
    &amp; NodeVBT.GetInfo(&quot;Local&quot;).info
    );
    FormsVBT.PutText(fv, &quot;codeview&quot;,  GenerateObliq.serverSideCode);
    SaveCodeIn :=  CodeType.ServerSide;
    FormsVBT.PutText(fv, &quot;codeTitle&quot;, &quot;Save Server Side Code&quot;);
  END SVRProc;

PROCEDURE <A NAME="ModesProc"><procedure>ModesProc</procedure></A> (&lt;* UNUSED *&gt; cl  : FormsVBT.Closure;
                                  fv  : FormsVBT.T;
                     &lt;* UNUSED *&gt; name: TEXT;
                     &lt;* UNUSED *&gt; time: VBT.TimeStamp     ) =
  VAR
    dialog               := NARROW(fv, T);
    formclass            := NodeVBT.NameToIndex(&quot;form&quot;);
    n                    := NodeVBT.NoOfObjects(formclass);
    current  : NodeVBT.T;
    offset := Rect.NorthWest(VBT.Domain(FormsVBT.GetVBT(fv, &quot;topZSplit&quot;)));
  BEGIN
    TRY
      IF Text.Equal(FormsVBT.GetChoice(fv, &quot;testbild&quot;), &quot;testmode&quot;) THEN
        (* create a ZChassis for all root forms and introduce them into the
           testZSplit *)
        dialog.TestMode := TRUE;
        testModeCtr := 0;
        NodeVBT.ComputeAnchoredFormTree();

        PixelsPerPtHor := Pts.ToPixels(fv, 1.0, Axis.T.Hor);
        PixelsPerPtVer := Pts.ToPixels(fv, 1.0, Axis.T.Ver);

        (* pass 1 - compute all the s-expressions and dimensions of root
           forms *)
        FOR i := 0 TO n - 1 DO
          IF i = 0 THEN
            current := NodeVBT.GetFirst(formclass);
          ELSE
            current := NodeVBT.GetNext(formclass);
          END;
          IF NARROW(current, NodeVBT.FormNode).ParentForm = NIL THEN
            (* root form *)
            NodeVBT.ComputeDimensions(current);
            current.DialogSX := current.SXTemplate();
            EVAL current.computeSX(TRUE);
          END
        END;

        (* now switch screens *)
        WITH tsplit = FormsVBT.GetVBT(fv, &quot;testAndbild&quot;),
             testbd = FormsVBT.GetVBT(fv, &quot;testZSplit&quot;)   DO
          TSplit.SetCurrent(tsplit, testbd);
          VBTClass.Redisplay(tsplit);
        END;

        (* pass 2 - insert root forms into the zsplit *)
        FOR i := 0 TO n - 1 DO
          IF i = 0 THEN
            current := NodeVBT.GetFirst(formclass);
          ELSE
            current := NodeVBT.GetNext(formclass);
          END;
          IF NARROW(current, NodeVBT.FormNode).ParentForm = NIL THEN
            (* root form *)
            WITH newfv  = NEW(FormsVBT.T).init( &quot;(ZChassis Open NoClose (Title \&quot;\&quot;) &quot; &amp;
                 current.DialogSX &amp; &quot;)&quot;),
                (*  c = Filter.Replace(newfv, NIL), *)
                 zsplit = FormsVBT.GetVBT(fv, &quot;testZSplit&quot;),
                 z      = NARROW(zsplit, FVTypes.FVZSplit),
                 x      = ROUND(PixelsPerPtHor * FLOAT(current.x)),
                 y      = ROUND(PixelsPerPtVer * FLOAT(current.y)),
                 width  = ROUND(PixelsPerPtHor * FLOAT(current.width)),
                 height = ROUND(PixelsPerPtVer * FLOAT(current.height)),
                 nw     = Point.Add(offset, Point.T{x, y})               DO
              NodeVBT.print(
                &quot;Inserting &quot; &amp; current.name &amp; &quot; at &quot; &amp; Fmt.Int(nw.h) &amp; &quot;,&quot;
                  &amp; Fmt.Int(nw.v) &amp; &quot;:&quot; &amp; Fmt.Int(width) &amp; &quot;,&quot;
                  &amp; Fmt.Int(height) &amp; &quot;\n&quot;);

              ZSplit.InsertAt(z, newfv, nw);
              (* ZSplit.InsertAt(z, c, nw);
                 ZChildVBT.Inserted(c); *)
              INC(testModeCtr);
              testModeList[testModeCtr] := newfv
            END
          END
        END
      ELSE
        dialog.TestMode := FALSE;
        FOR i := 1 TO testModeCtr DO
          WITH zsplit = FormsVBT.GetVBT(fv, &quot;testZSplit&quot;),
               s      = NARROW(zsplit, Split.T)            DO
            Split.Delete(s, testModeList[i]);
            testModeList[i] := NIL;
          END
        END;
        testModeCtr := 0;
        (* now switch screens *)
        WITH tsplit    = FormsVBT.GetVBT(fv, &quot;testAndbild&quot;),
             topzsplit = FormsVBT.GetVBT(fv, &quot;topZSplit&quot;)    DO
          TSplit.SetCurrent(tsplit, topzsplit);
        END;

      END
    EXCEPT
    ELSE
      message(fv, &quot;Trouble Switching Modes&quot;);
    END
  END ModesProc;

PROCEDURE <A NAME="AddScreenProc"><procedure>AddScreenProc</procedure></A> (&lt;* UNUSED *&gt; fv  : FormsVBT.T;
                         &lt;* UNUSED *&gt; name: TEXT;
                         &lt;* UNUSED *&gt; data: REFANY;
                         &lt;* UNUSED *&gt; time: VBT.TimeStamp) =
  BEGIN
    WITH z = NewDialog() DO
      INC(screens);
      Trestle.Install(
        z, applName := &quot;VisualObliq&quot;, inst := Fmt.Int(screens),
        windowTitle := &quot;Visual Obliq Editor(&quot; &amp; Fmt.Int(screens)
                         &amp; &quot;) - &quot; &amp; filename);
      screen[screens] := z;
      z.screenindex := screens;
    END
  END AddScreenProc;

&lt;* UNUSED *&gt;
PROCEDURE <A NAME="AttributesProc"><procedure>AttributesProc</procedure></A> (&lt;* UNUSED *&gt; cl  : FormsVBT.Closure;
                                       fv  : FormsVBT.T;
                          &lt;* UNUSED *&gt; name: TEXT;
                          &lt;* UNUSED *&gt; data: REFANY;
                          &lt;* UNUSED *&gt; time: VBT.TimeStamp     ) =
  BEGIN
    WITH dialog = NARROW(fv, T),
         n      = dialog.selection.getSelectionSize() DO
      IF n &lt; 1 THEN
        message(fv, &quot;You need to select an object first&quot;)
      ELSIF n &gt; 1 THEN
        message(
          fv,
          &quot;Attributes may be set only for single objects, not for groups&quot;)
      ELSE
        WITH cso = dialog.selection.getSelection(1),
             csn = NARROW(cso, NodeVBT.T)            DO
          Attributes.Invoke(attributes, csn)
        END
      END

    END
  END AttributesProc;
</PRE> Settings are global - and apply to all screens 
 the widgets are explicitly synchronized 
<PRE>PROCEDURE <A NAME="OKSettingsProc"><procedure>OKSettingsProc</procedure></A> (             fv  : FormsVBT.T;
                          &lt;* UNUSED *&gt; name: TEXT;
                          &lt;* UNUSED *&gt; data: REFANY;
                          &lt;* UNUSED *&gt; time: VBT.TimeStamp) =
  BEGIN
    WITH dialog = NARROW(fv, T) DO
      dialog.grid := FormsVBT.GetInteger(fv, &quot;grid&quot;)
    END;

    SetGlobalBg(FormsVBT.GetText(fv, &quot;bgcolor&quot;));
    SetGlobalFg(FormsVBT.GetText(fv, &quot;fgcolor&quot;));
    SetGlobalFont(FormsVBT.GetText(fv, &quot;font&quot;));
    SetDefaultName(FormsVBT.GetText(fv, &quot;defname&quot;));

    SetEditingFont(FormsVBT.GetBoolean(fv, &quot;blowFont&quot;));

  END OKSettingsProc;

PROCEDURE <A NAME="PopSettingsProc"><procedure>PopSettingsProc</procedure></A> (             fv  : FormsVBT.T;
                           &lt;* UNUSED *&gt; name: TEXT;
                           &lt;* UNUSED *&gt; data: REFANY;
                           &lt;* UNUSED *&gt; time: VBT.TimeStamp) =
  BEGIN
    WITH dialog = NARROW(fv, T) DO
      FormsVBT.PutInteger(fv, &quot;grid&quot;, dialog.grid)
    END;
    FormsVBT.PutText(
      fv, &quot;bgcolor&quot;, NodeVBT.defaultBgColor, FALSE);
    FormsVBT.PutText(fv, &quot;font&quot;, NodeVBT.defaultFont, FALSE);
    FormsVBT.PutText(
      fv, &quot;fgcolor&quot;, NodeVBT.defaultFgColor, FALSE);
    FormsVBT.PutBoolean(
      fv, &quot;blowFont&quot;, NodeVBT.blowEditingFont);
  END PopSettingsProc;

PROCEDURE <A NAME="SetEditingFont"><procedure>SetEditingFont</procedure></A> (blowit: BOOLEAN) =
  VAR font := &quot;-*-courier-bold-*R-*120-*&quot;;
  BEGIN
    (* Do all the editors in the attr sheet *)
    IF blowit THEN
      font := &quot;-*-helvetica-bold-*R-*180-*&quot;;
    END;

    WITH afv = Attributes.afv DO
      FormsVBT.PutTextProperty(afv, &quot;supportCodeEditor&quot;, &quot;Font&quot;,
                               font);
      FormsVBT.PutTextProperty(afv, &quot;CallbackEditor&quot;, &quot;Font&quot;,
                               font);
     (* FormsVBT.PutTextProperty(afv, &quot;menubrowser&quot;, &quot;Font&quot;,
                         font);*)
      FormsVBT.PutTextProperty(afv, &quot;menucallback&quot;, &quot;Font&quot;,
                          font);
    END;

    TRY
      FOR i := 1 TO screens DO
        WITH fv = screen[i] DO
          FormsVBT.PutBoolean(fv, &quot;blowFont&quot;, blowit)
        END
      END
    EXCEPT
    ELSE
    END;
    NodeVBT.blowEditingFont := blowit;
  END SetEditingFont;

PROCEDURE <A NAME="SetGlobalBg"><procedure>SetGlobalBg</procedure></A> (n: TEXT) =
  BEGIN
    TRY
      FOR i := 1 TO screens DO
        WITH fv = screen[i] DO
          FormsVBT.PutText(fv, &quot;bgcolor&quot;, n, FALSE)
        END
      END
    EXCEPT
    ELSE
    END;
    NodeVBT.defaultBgColor := n;
  END SetGlobalBg;

PROCEDURE <A NAME="SetGlobalFg"><procedure>SetGlobalFg</procedure></A> (n: TEXT) =
  BEGIN
    TRY
      FOR i := 1 TO screens DO
        WITH fv = screen[i] DO
          FormsVBT.PutText(fv, &quot;fgcolor&quot;, n, FALSE)
        END
      END;
    EXCEPT
    ELSE
    END;
    NodeVBT.defaultFgColor := n;
  END SetGlobalFg;

PROCEDURE <A NAME="SetGlobalFont"><procedure>SetGlobalFont</procedure></A> (n: TEXT) =
  BEGIN
    TRY
      FOR i := 1 TO screens DO
        WITH fv = screen[i] DO FormsVBT.PutText(fv, &quot;font&quot;, n, FALSE) END
      END
    EXCEPT
    ELSE
    END;
    NodeVBT.defaultFont := n;
  END SetGlobalFont;

PROCEDURE <A NAME="SetDefaultName"><procedure>SetDefaultName</procedure></A> (n: TEXT) =
  BEGIN
    TRY
      FOR i := 1 TO screens DO
        WITH fv = screen[i] DO
          FormsVBT.PutText(fv, &quot;defname&quot;, n, FALSE)
        END
      END
    EXCEPT
    ELSE
    END;
    NodeVBT.defaultName := n;
  END SetDefaultName;

PROCEDURE <A NAME="CreateProc"><procedure>CreateProc</procedure></A> (&lt;* UNUSED *&gt; cl  : FormsVBT.Closure;
                                   fv  : FormsVBT.T;
                                   name: TEXT;
                      &lt;* UNUSED *&gt; time: VBT.TimeStamp     ) =
  VAR

    zsplit             : VBT.T;
    dialog                            := NARROW(fv, T);
    selsize            : CARDINAL;
    pardom             : Rect.T;
    parent             : ZHandleVBT.T;
    newnode            : NodeVBT.T;
    newform            : FormsVBT.T;
    minParWid, minParHt: INTEGER;
  BEGIN
    IF dialog.TestMode THEN RETURN; END;

    (* If this is a valid insertion ... *)
    (* i.e if it is a form elsif a single parent has been selected (a form
       or a frame) and there is enough space to insert the object { When
       you register a new widget you may specify how big the parent should
       be.  Pick a size at least 50 points larger than the default size of
       the widget, in each dimension.  Default min-size of parent = 100X100
       }

       *)
    selsize := dialog.selection.getSelectionSize();
    IF NOT Text.Equal(name, &quot;form&quot;) THEN
      IF selsize &lt; 1 THEN
        message(
          fv,
          &quot;You need to select a form or a frame before inserting this object&quot;);
        RETURN;
      ELSIF selsize &gt; 1 THEN
        message(
          fv,
          &quot;At most one object may be selected before inserting such objects&quot;);
        RETURN;
      ELSE
        parent := dialog.selection.getSelection(1);
        IF parent = NIL THEN
          message(fv, &quot;Selection Error&quot;);
          RETURN;
        ELSE
          WHILE NOT ISTYPE(parent, NodeVBT.SplitNode) DO
            parent := parent.parent;
          END;
        END;

        pardom := parent.getDomain();
        TRY
          NodeVBT.GetMinParentDimensions(name, minParWid, minParHt);
        EXCEPT
        | NodeVBT.InvalidObjectName (foo) =&gt;
            message(fv, foo &amp; &quot;has not been implemented&quot;);
        END;
        IF Rect.HorSize(pardom) &lt; minParWid
          OR Rect.VerSize(pardom) &lt; minParHt THEN
          message(
              fv,
              &quot;There isn't enough space to insert this object. Resize parent.&quot;);
          RETURN;
        END
      END
      END;

    (* all checks have been completed *)

    (* NodeVBT.NewObject is used to create a new instance *)
    (* which is then inserted into the hierarchy *)
    (* Only insertion related issues are addressed here *)
    (* insertion of forms is at 100+delta, 100+delta insertion of other
       objects is at 30+delta, 30+delta delta varies from 0 to 10 in steps
       of 2 *)

    IF Text.Equal(name, &quot;form&quot;) THEN
      newnode := NodeVBT.NewObject(dialog, &quot;form&quot;, NIL);
      NARROW(newnode, NodeVBT.FormNode).Screen := dialog.screenindex;
    ELSE
      newnode := NodeVBT.NewObject(dialog, name, NARROW(parent, NodeVBT.T))
    END;
    IF newnode = NIL THEN RETURN; END;
    TRY
      newform := NEW(FormsVBT.T).init(newnode.DialogSX)
    EXCEPT
    ELSE
      message(fv, &quot;Error in Default S-Expression - Please Check &quot;
                    &amp; name &amp; &quot;TEMPLATE.fv&quot;);
      RETURN;
    END;
    EVAL ZHandleVBT.T.init(newnode, newform, dialog.selection);

    IF (Text.Equal(name, &quot;form&quot;)) THEN
      zsplit := FormsVBT.GetVBT(fv, &quot;topZSplit&quot;);
      ZSplit.InsertAt(NARROW(zsplit, ZSplit.T), newnode,
                      Point.Add(Rect.NorthWest(VBT.Domain(zsplit)),
                                Point.T{50 + delta, 50 + delta}))
    ELSE
      (* parent and pardom would already be set *)
      (* parent is a zsplit *)
      WITH dad = NARROW(parent, NodeVBT.SplitNode) DO
        INC(dad.nc);
        dad.children[dad.nc] := newnode;
      END;
      ZSplit.InsertAt(
        parent, newnode, Point.Add(Rect.NorthWest(VBT.Domain(parent)),
                                   Point.T{30 + delta, 30 + delta}))
    END;
    delta := (delta + 2) MOD 12;

  END CreateProc;

BEGIN
</PRE><BLOCKQUOTE><EM>  Thread.IncDefaultStackSize(16*1024); </EM></BLOCKQUOTE><PRE>

  rsrcPath := Rsrc.BuildPath (&quot;$DIALOGPATH&quot;, DialogBundle.Get());
  ObliqRuntime.Setup();

  attributes := NEW(Attributes.T).init();

  (* Initialize all the modules *)
  NodeVBT.Initialize();

  (* Initialize Extension Modules *)

  Browser.Initialize();
  Clickable.Initialize();
  Setting.Initialize();
  Textual.Initialize();
  VideoWidget.Initialize();

  WITH z = NewDialog() DO
    INC(screens);
    z.screenindex := screens;
    Trestle.Install(
      z, applName := &quot;VisualObliq&quot;,
      inst := &quot;VO Editor (&quot; &amp; Fmt.Int(screens) &amp; &quot;)&quot;,
      windowTitle :=
        &quot;Visual Obliq Editor(&quot; &amp; Fmt.Int(screens) &amp; &quot;) - &quot; &amp; filename);
    screen[screens] := z;

    DialogMenu.Initialize();
    GenerateObliq.Initialize();
  END;
  WHILE screen[1] # NIL DO Trestle.AwaitDelete(screen[1]) END;
END Dialog.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
