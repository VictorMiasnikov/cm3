<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: visualobliq/src/NodeVBT.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>visualobliq/src/NodeVBT.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright (C) 1993, Digital Equipment Corporation 
 All rights reserved. 
 See the file COPYRIGHT for a full description. 
 
 Last modified on Wed Feb  1 09:44:24 PST 1995 by kalsow 
      modified on Sat Sep 10 14:24:12 PDT 1994 by bharat 
      modified on Wed Nov 17 16:09:19 PST 1993 by mhb    
<PRE>&lt;* PRAGMA LL *&gt;

MODULE <module>NodeVBT</module> EXPORTS <A HREF="NodeVBT.i3.html"><implements>NodeVBT</A></implements>;

IMPORT <A HREF="../../libm3/src/types/ASCII.i3.html">ASCII</A>, <A HREF="Attributes.i3.html">Attributes</A>, <A HREF="../../libm3/src/geometry/Axis.i3.html">Axis</A>, <A HREF="Dialog.i3.html">Dialog</A>, <A HREF="DialogMenu.i3.html">DialogMenu</A>, <A HREF="../../libm3/src/fmtlex/Fmt.i3.html">Fmt</A>,
       <A HREF="../../formsvbt/src/FormsVBT.i3.html">FormsVBT</A>, <A HREF="GenerateObliq.i3.html">GenerateObliq</A>, <A HREF="../../libm3/src/fmtlex/Lex.i3.html">Lex</A>, <A HREF="../../vbtkit/src/lego/ListVBT.i3.html">ListVBT</A>,
       <A HREF="../../libm3/src/geometry/Point.i3.html">Point</A>, <A HREF="../../vbtkit/src/vbtkitutils/Pts.i3.html">Pts</A>, <A HREF="RW.i3.html">RW</A>, <A HREF="../../libm3/src/geometry/Rect.i3.html">Rect</A>, <A HREF="../../libm3/src/rw/Rd.i3.html">Rd</A>, <A HREF="../../vbtkit/src/vbtkitutils/Rsrc.i3.html">Rsrc</A>, <A HREF="../../ui/src/split/Split.i3.html">Split</A>, <A HREF="../../libm3/src/rw/Stdio.i3.html">Stdio</A>, <A HREF="../../m3core/src/text/Text.i3.html">Text</A>, <A HREF="../../libm3/src/rw/TextRd.i3.html">TextRd</A>, <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>,
       <A HREF="../../ui/src/split/TSplit.i3.html">TSplit</A>, <A HREF="../../ui/src/vbt/VBT.i3.html">VBT</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="ZHandleVBT.i3.html">ZHandleVBT</A>, <A HREF="../../ui/src/split/ZSplit.i3.html">ZSplit</A>;

&lt;* FATAL FormsVBT.Error, FormsVBT.Unimplemented, InvalidObjectName,
         Rd.Failure, Split.NotAChild, Thread.Alerted *&gt;

REVEAL
  <A NAME="T">T</A> = Public BRANDED &quot;VO-NodeVBT&quot; OBJECT
      OVERRIDES
        loadAttributes             := LoadAttributes;
        checkAttributes            := CheckAttributes;
        applyAttributes            := ApplyAttributes;
        computeSX                  := ComputeSX;
        generateObjectDefs         := GenerateObjectDefs;
        generateCallbacks          := GenerateCallbacks;
        generateAttachments        := GenerateAttachments;
        generateInitializationCode := GenerateInitializationCode;
        SXTemplate                 := SX;
        save                       := Save;
        load                       := Load;
        initObliqAttrs       := InitObliqAttrs;
      END;

  <A NAME="Widget">Widget</A> = PublicWidget BRANDED &quot;VO-Widget&quot; OBJECT END;

  <A NAME="SplitNode">SplitNode</A> =
    PublicSplit BRANDED &quot;VO-SplitNode&quot; OBJECT
      Texture := &quot;blank.pbm&quot;;
    OVERRIDES
      loadAttributes := SplitLoadAttributes;
      (* checkAttributes := SplitCheckAttributes;*)
      applyAttributes            := SplitApplyAttributes;
      computeSX                  := SplitComputeSX;
      generateObjectDefs         := SplitGenerateObjectDefs;
      generateCallbacks          := SplitGenerateCallbacks;
      generateAttachments        := SplitGenerateAttachments;
      generateInitializationCode := SplitGenerateInitializationCode;
      save                       := SplitSave;
      load                       := SplitLoad;
      initObliqAttrs       := SplitObAttrs;
    END;

  <A NAME="FormNode">FormNode</A> =
    PublicForm BRANDED &quot;VO-PublicForm&quot; OBJECT

      Tag: BOOLEAN;
      (* used to eliminate nodes in the subtree rooted at a given node from
         the list of possible parent-nodes *)

      TitleBgColor: TEXT     := &quot;VerySlightlyBluishGrey85&quot;;
      TitleFgColor: TEXT     := &quot;Black&quot;;
      TitleString : TEXT     := &quot;Title&quot;;
      StretchX    : CARDINAL := 1000;
      StretchY    : CARDINAL := 1000;
      ShrinkX     : CARDINAL := 0;
      ShrinkY     : CARDINAL := 0;

    OVERRIDES
      getDomain                  := GetDomain;
      loadAttributes             := FormLoadAttributes;
      applyAttributes            := FormApplyAttributes;
      computeSX                  := FormComputeSX;
      generateObjectDefs         := FormGenerateObjectDefs;
      generateCallbacks          := FormGenerateCallbacks;
      generateAttachments        := FormGenerateAttachments;
      generateInitializationCode := FormGenerateInitializationCode;

      save := FormSave;
      load := FormLoad;
      initObliqAttrs       := FormObAttrs;
    END;

  <A NAME="FrameNode">FrameNode</A> = PublicFrame BRANDED &quot;VO-FrameNode&quot; OBJECT END;
</PRE>***************************************************************************
 Variables for object management 
<PRE>TYPE
  ObjList = ARRAY [0 .. 100] OF T;
  ObjClass = RECORD
               name      : TEXT;  (* name of the class *)
               instances          := 0; (* number of instances *)
               count              := 0;
               SXTemplate: TEXT;

               instanceList: ObjList;

               (*-- the following dont need to be saved *)
               createProc                     : Proc;
               last                           : CARDINAL  := 0;
               minParentWidth, minParentHeight: INTEGER;
               attrsheetName: TEXT;  (* this is generally name &amp; &quot;att&quot; but
                                        in some cases multiple widgets may
                                        share the same attr sheet - e.g
                                        hscroll/vscroll share the attr
                                        sheet scrolleratt *)

             END;
</PRE> This is the createproc used by the Manager to create new object
   instances 
 They are registered by widgets using the register method 

<P>
<P><PRE>VAR
  ObjectClasses: REF ARRAY [0 .. 100] OF ObjClass;
  ClassCounter : CARDINAL                         := 0;
  (* number of classes installed *)
  inited        : BOOLEAN   := FALSE;

  infoList :  ARRAY [0..100] OF REF InfoDefn;
  createdInfoList : BOOLEAN := FALSE;
  infoCtr := 0;

PROCEDURE <A NAME="SX"><procedure>SX</procedure></A> (nv: T): TEXT =
  BEGIN
    RETURN ObjectClasses[nv.classIndex].SXTemplate;
  END SX;

PROCEDURE <A NAME="LoadAttributes"><procedure>LoadAttributes</procedure></A> (nv: T; as: FormsVBT.T) =
  BEGIN
    (* load generic attributes *)
    (* Name *)
    FormsVBT.PutText(as, &quot;name&quot;, nv.name, FALSE);
    (* Type *)
    FormsVBT.PutText(as, &quot;type&quot;, GetNodeTypeName(nv), FALSE);
    (* FgColor *)
    FormsVBT.PutText(as, &quot;fgctypein&quot;, nv.FgColor, FALSE);
    (* BgColor *)
    FormsVBT.PutText(as, &quot;bgctypein&quot;, nv.BgColor, FALSE);
    (* Rim size *)
    FormsVBT.PutInteger(as, &quot;rimsize&quot;, nv.Rim);
    (* Border size *)
    FormsVBT.PutInteger(as, &quot;bordersize&quot;, nv.Border);
    (* Font *)
    FormsVBT.PutText(as, &quot;fonttypein&quot;, nv.Font, FALSE);
    (* Embellishment *)
    FormsVBT.PutChoice(as, &quot;Embellishment&quot;, nv.Embellishment);
    (* Reactivity *)
    FormsVBT.PutChoice(as, &quot;InitialState&quot;, nv.InitialState);
    (* Reshape *)
    FormsVBT.PutChoice(as, &quot;Reshape&quot;, nv.ResizeModel);
    (* Foreground / Background *)
    IF nv.Foreground THEN
      FormsVBT.PutChoice(as, &quot;exechow&quot;, &quot;Foreground&quot;)
    ELSE
      FormsVBT.PutChoice(as, &quot;exechow&quot;, &quot;Background&quot;)
    END;
    IF nv.Local THEN
      FormsVBT.PutChoice(as, &quot;execwhere&quot;, &quot;Local&quot;)
    ELSE
      FormsVBT.PutChoice(as, &quot;execwhere&quot;, &quot;Remote&quot;);
      FormsVBT.MakeActive(as, &quot;remFilter&quot;);
    END;

    FormsVBT.PutText(as, &quot;Location&quot;, nv.Location, FALSE);
    FormsVBT.PutText(as, &quot;CallbackEditor&quot;, nv.Code, FALSE);
    Attributes.currentNode := nv;
  END LoadAttributes;

PROCEDURE <A NAME="IntAttr"><procedure>IntAttr</procedure></A>(name:TEXT; arg : INTEGER): TEXT =
  BEGIN
    RETURN  &quot;\ttemp.&quot; &amp; name &amp; &quot; := &quot; &amp; Fmt.Int(arg) &amp; &quot;;\n&quot;;
  END IntAttr;

PROCEDURE <A NAME="TextAttr"><procedure>TextAttr</procedure></A>(name:TEXT; arg :TEXT) : TEXT =
  BEGIN
    RETURN  &quot;\ttemp.&quot; &amp; name &amp; &quot; := \&quot;&quot; &amp;  GenerateObliq.SlashQuotes(
                                               GenerateObliq.SlashSlashes(arg)) &amp; &quot;\&quot;;\n&quot;;
  END TextAttr;

PROCEDURE <A NAME="BoolAttr"><procedure>BoolAttr</procedure></A>(name:TEXT; arg :BOOLEAN) : TEXT =
  BEGIN
    IF arg THEN
      RETURN  &quot;\ttemp.&quot; &amp; name &amp; &quot; := true;\n&quot;;
    ELSE
      RETURN  &quot;\ttemp.&quot; &amp; name &amp; &quot; := false;\n&quot;;
    END;
  END BoolAttr;

PROCEDURE <A NAME="InitObliqAttrs"><procedure>InitObliqAttrs</procedure></A>(v:T) : TEXT =
  VAR ret := &quot;temp.SELF := meth(s) VOInstance end;\n&quot;;
  BEGIN
    IF (v.parent # NIL) THEN
      ret := ret &amp;  &quot;\ttemp.parent := meth(s) VOInstance.&quot;
      &amp; v.parent.name &amp; &quot;  end;\n&quot;;
    END;

     ret := ret &amp; IntAttr(&quot;x&quot;, v.x) &amp;
                IntAttr(&quot;y&quot;, v.y) &amp;
                IntAttr(&quot;width&quot;, v.width) &amp;
                IntAttr(&quot;height&quot;, v.height);

     ret := ret &amp; TextAttr(&quot;BgColor&quot;, v.BgColor) &amp;
                TextAttr(&quot;FgColor&quot;, v.FgColor) &amp;
                TextAttr(&quot;Font&quot;, v.Font) &amp;
                IntAttr(&quot;Rim&quot;, v.Rim) &amp;
                IntAttr(&quot;Border&quot;, v.Border) &amp;
                TextAttr(&quot;Embellishment&quot;, v.Embellishment) &amp;
                TextAttr(&quot;InitialState&quot;, v.InitialState) &amp;
                TextAttr(&quot;ResizeModel&quot;, v.ResizeModel);
     RETURN ret;

   END InitObliqAttrs;

PROCEDURE <A NAME="CheckAttributes"><procedure>CheckAttributes</procedure></A> (v: T; as: FormsVBT.T; VAR error: TEXT):
  BOOLEAN =
  BEGIN
    (* check the validity of generic attributes *)
    WITH nom   = FormsVBT.GetText(as, &quot;name&quot;),
         other = GetNodeNamed(nom)             DO (* search all lists *)
      IF other # NIL AND other # v THEN
        error := &quot;There is already an object called &quot; &amp; nom;
        RETURN FALSE;
      END
    END;
    RETURN TRUE;
  END CheckAttributes;

PROCEDURE <A NAME="ComputeSX"><procedure>ComputeSX</procedure></A> (v: T; Final: BOOLEAN := FALSE): TEXT =
  VAR start, found: INTEGER;
  BEGIN
    (* this is called last after all overrides have finished with the
       s-expression*)
    v.DialogSX := FindAndReplace(v.DialogSX, &quot;XSpan&quot;, Fmt.Int(v.width));
    v.DialogSX := FindAndReplace(v.DialogSX, &quot;YSpan&quot;, Fmt.Int(v.height));
    v.DialogSX := FindAndReplace(v.DialogSX, &quot;RimPen&quot;, Fmt.Int(v.Rim));
    v.DialogSX :=
      FindAndReplace(v.DialogSX, &quot;BorderPen&quot;, Fmt.Int(v.Border));
    v.DialogSX := FindAndReplace(v.DialogSX, &quot;BgColor&quot;, v.BgColor);
    v.DialogSX := FindAndReplace(v.DialogSX, &quot;FgColor&quot;, v.FgColor);
    v.DialogSX := FindAndReplace(v.DialogSX, &quot;Font&quot;, v.Font);

    IF Final THEN
      v.DialogSX :=
        FindAndReplace(v.DialogSX, &quot;FilterState&quot;, v.InitialState)
    ELSE
      v.DialogSX := FindAndReplace(v.DialogSX, &quot;FilterState&quot;, &quot;Active&quot;)
    END;

    IF Text.Equal(v.Embellishment, &quot;None&quot;) THEN
      v.DialogSX :=
        FindAndReplace(v.DialogSX, &quot;FrameStyle&quot;, &quot;(ShadowSize 0)&quot;);
      (* Remember to set it to 1.5 in the next level if a shadow is needed
         within *)
    ELSE
      v.DialogSX :=
        FindAndReplace(v.DialogSX, &quot;FrameStyle&quot;, v.Embellishment);
    END;

    (* now replace all %@ occurences with %v.name *)
    start := 0;
    found := Text.FindChar(v.DialogSX, '%', start);
    WHILE found # -1 AND found + 2 &lt; Text.Length(v.DialogSX) DO
      IF Text.GetChar(v.DialogSX, found + 1) = '@' THEN
        v.DialogSX := Text.Sub(v.DialogSX, 0, found + 1) &amp; v.name
                        &amp; Text.Sub(v.DialogSX, found + 2)
      END;
      start := found + 2;
      found := Text.FindChar(v.DialogSX, '%', start);
    END;
    (* print(&quot;After ComputeSX :\n&quot; &amp; v.DialogSX &amp; &quot;\n&quot;); *)
    TRY
      FOR i := 1 TO Dialog.screens DO
        WITH fv = Dialog.screen[i] DO
          FormsVBT.PutText(fv, &quot;sxview&quot;, v.DialogSX, FALSE)
        END
      END
    EXCEPT
    ELSE
    END;
    RETURN v.DialogSX;
  END ComputeSX;

PROCEDURE <A NAME="ApplyAttributes"><procedure>ApplyAttributes</procedure></A> (v: T; as: FormsVBT.T) =
  BEGIN
    (* Apply generic attributes - this is overriden in all cases.  All
       widgets call this before applying their own attributes Split nodes
       do not call this method - forms and frames call the split node
       method *)
    v.name := FormsVBT.GetText(as, &quot;name&quot;);
    v.FgColor := FormsVBT.GetText(as, &quot;fgctypein&quot;);
    v.BgColor := FormsVBT.GetText(as, &quot;bgctypein&quot;);
    v.Rim := FormsVBT.GetInteger(as, &quot;rimsize&quot;);
    v.Border := FormsVBT.GetInteger(as, &quot;bordersize&quot;);
    v.Font := FormsVBT.GetText(as, &quot;fonttypein&quot;);
    v.Embellishment := FormsVBT.GetChoice(as, &quot;Embellishment&quot;);
    v.ResizeModel := FormsVBT.GetChoice(as, &quot;Reshape&quot;);
    v.InitialState := FormsVBT.GetChoice(as, &quot;InitialState&quot;);
    v.Foreground :=
      Text.Equal(FormsVBT.GetChoice(as, &quot;exechow&quot;), &quot;Foreground&quot;);
    v.Local := Text.Equal(FormsVBT.GetChoice(as, &quot;execwhere&quot;), &quot;Local&quot;);
    v.Location := FormsVBT.GetText(as, &quot;Location&quot;);
    v.Code := FormsVBT.GetText(as, &quot;CallbackEditor&quot;);

    (* Inheritance *)
    IF Text.Equal(v.FgColor, &quot;Inherit&quot;) THEN
      IF ISTYPE(v, FormNode) THEN (* get global value *)
        v.FgColor := defaultFgColor;
      ELSE
        v.FgColor := v.parent.FgColor;
      END;
      FormsVBT.PutText(as, &quot;fgctypein&quot;, v.FgColor, FALSE);
    END;
    IF Text.Equal(v.BgColor, &quot;Inherit&quot;) THEN
      IF ISTYPE(v, FormNode) THEN (* get global value *)
        v.BgColor := defaultBgColor;
      ELSE
        v.BgColor := v.parent.BgColor;
      END;
      FormsVBT.PutText(as, &quot;bgctypein&quot;, v.BgColor, FALSE);
    END;
    IF Text.Equal(v.Font, &quot;Inherit&quot;) THEN
      IF ISTYPE(v, FormNode) THEN (* get global value *)
        v.Font := defaultFont;
      ELSE
        v.Font := v.parent.Font;
      END;
      FormsVBT.PutText(as, &quot;fonttypein&quot;, v.Font, FALSE);
    END;

    ComputeDimensions(v);

  END ApplyAttributes;

PROCEDURE <A NAME="GenerateObjectDefs"><procedure>GenerateObjectDefs</procedure></A> (nv: T): TEXT =
  VAR code := nv.name &amp; &quot; =&gt; ( let temp = LOCAL.&quot;;
  BEGIN
   code := code &amp; GetNodeTypeName(nv) &amp; &quot;New(\&quot;&quot;
             &amp; nv.name &amp; &quot;\&quot;);\n&quot;;
   code := code &amp; &quot;\ttemp.form := meth(s) SELF.FORM end;\n&quot;;
   code := code &amp; nv.initObliqAttrs();

   code := code &amp; &quot;temp),\n&quot;;

    RETURN code;
  END GenerateObjectDefs;

PROCEDURE <A NAME="GenerateCallbacks"><procedure>GenerateCallbacks</procedure></A> (nv: T): TEXT =
  VAR ncb: TEXT;
  BEGIN
    IF AllWhitespace(nv.Code) THEN RETURN &quot;&quot;; END;

    ncb :=
      FindAndReplace(GenerateObliq.callbackTemplate, &quot;objname&quot;, nv.name);
    IF nv.Foreground THEN
      ncb := FindAndReplace(ncb, &quot;bgHeader&quot;, &quot;&quot;);
      ncb := FindAndReplace(ncb, &quot;bgFooter&quot;, &quot;&quot;)
    ELSE
      ncb := FindAndReplace(ncb, &quot;bgHeader&quot;, &quot;thread_fork(proc()\n&quot;);
      ncb := FindAndReplace(ncb, &quot;bgFooter&quot;, &quot;\nend, 10000)\n&quot;)
    END;

    IF nv.Local THEN
      ncb := FindAndReplace(ncb, &quot;remoteHeader&quot;, &quot;&quot;);
      ncb := FindAndReplace(ncb, &quot;remoteFooter&quot;, &quot;&quot;)
    ELSE
      ncb :=
        FindAndReplace(
          ncb, &quot;remoteHeader&quot;,
          &quot;let VODest = \n(*----------------------------------------*)\n&quot;
            &amp; nv.Location &amp; &quot;;\n&quot;
            &amp; &quot;(*----------------------------------------*)\n&quot;
            &amp; &quot;VODest.VOCompute( proc(REMOTE) \n&quot;);
      ncb := FindAndReplace(ncb, &quot;remoteFooter&quot;, &quot;\n ok; \n end )\n&quot;);
    END;

    RETURN FindAndReplace(ncb, &quot;usercode&quot;,
                          &quot;(* Callback for &quot; &amp; nv.name &amp; &quot;*)\n&quot; &amp; nv.Code)
             &amp; &quot;\n&quot;;
  END GenerateCallbacks;

PROCEDURE <A NAME="GenerateAttachments"><procedure>GenerateAttachments</procedure></A> (nv: T): TEXT =
  BEGIN
    (* this is not a split node *)
    IF AllWhitespace(nv.Code) THEN RETURN &quot;&quot;; END;
    RETURN &quot;form_attach(SELF.FORM,  SELF.&quot; &amp; nv.name &amp; &quot;.name, SELF.&quot; &amp; nv.name
             &amp; &quot;Proc);\n&quot;;
  END GenerateAttachments;

PROCEDURE <A NAME="GenerateInitializationCode"><procedure>GenerateInitializationCode</procedure></A> (nv: T): TEXT =
  BEGIN
    RETURN (&quot;(* Initialization Code &quot; &amp; nv.name &amp; &quot; *)\n&quot;);
  END GenerateInitializationCode;

PROCEDURE <A NAME="ComputeDimensions"><procedure>ComputeDimensions</procedure></A> (nv: T) =
  VAR pardomain: Rect.T;
  BEGIN

    WITH v      = nv.getchild(),
         dom    = VBT.Domain(v),
         nw     = Rect.NorthWest(dom),
         width  = Rect.HorSize(dom),
         height = Rect.VerSize(dom)    DO
      (* convert from Pixels to Points *)

      nv.width := ROUND(FLOAT(width) / Pts.ToPixels(v, 1.0, Axis.T.Hor));
      nv.height := ROUND(FLOAT(height) / Pts.ToPixels(v, 1.0, Axis.T.Ver));

      IF NOT ISTYPE(nv, FormNode) THEN
        pardomain := VBT.Domain(nv.parent)
      ELSE
        WITH fn     = NARROW(nv, FormNode),
             dialog = Dialog.screen[fn.Screen],
             zsplit = FormsVBT.GetVBT(dialog, &quot;topZSplit&quot;) DO
          pardomain := VBT.Domain(zsplit)
        END
      END;
      WITH parnw = Rect.NorthWest(pardomain) DO
        nv.x :=
          ROUND(FLOAT(nw.h - parnw.h) / Pts.ToPixels(v, 1.0, Axis.T.Hor));
        nv.y :=
          ROUND(FLOAT(nw.v - parnw.v) / Pts.ToPixels(v, 1.0, Axis.T.Ver));
      END

      (*
        nv.x := ROUND(FLOAT(nw.h) / Pts.ToPixels(v, 1.0, Axis.T.Hor));
        nv.y := ROUND(FLOAT(nw.v) / Pts.ToPixels(v, 1.0, Axis.T.Ver));
      *)
    END;
    print(&quot;ComputeDimensions of  &quot; &amp; nv.name &amp; &quot; ::=  &quot; &amp; Fmt.Int(nv.x)
            &amp; &quot;,&quot; &amp; Fmt.Int(nv.y) &amp; &quot;:&quot; &amp; Fmt.Int(nv.width) &amp; &quot;,&quot;
            &amp; Fmt.Int(nv.height) &amp; &quot;\n&quot;);
  END ComputeDimensions;

PROCEDURE <A NAME="LRProc"><procedure>LRProc</procedure></A> (&lt;* UNUSED *&gt; cl  : FormsVBT.Closure;
                               afv : FormsVBT.T;
                               name: TEXT;
                  &lt;* UNUSED *&gt; time: VBT.TimeStamp     ) =
  BEGIN
    IF Text.Equal(name, &quot;Local&quot;) THEN
      FormsVBT.MakeDormant(afv, &quot;remFilter&quot;)
    ELSE
      FormsVBT.MakeActive(afv, &quot;remFilter&quot;)
    END
  END LRProc;
</PRE>*********************Split  Attribute Management ******************
<PRE>PROCEDURE <A NAME="SplitLoadAttributes"><procedure>SplitLoadAttributes</procedure></A> (nv: SplitNode; as: FormsVBT.T) =
  BEGIN
    (* load texture attributes *)
    (* Name *)
    IF ISTYPE(nv, FormNode) THEN
      FormsVBT.PutText(as, &quot;formtexture&quot;, nv.Texture, FALSE);
    ELSE
      FormsVBT.PutText(as, &quot;frametexture&quot;, nv.Texture, FALSE);
    END;
    LoadAttributes(nv, as);      (* common attributes *)
  END SplitLoadAttributes;
</PRE><P>
PROCEDURE SplitCheckAttributes (    nv   : SplitNode;
                                    as   : FormsVBT.T;
                                    VAR error: TEXT        ): BOOLEAN =
  VAR texture: TEXT;
  BEGIN
    (* check the texture filename attributes 
    <PRE>IF ISTYPE(nv, FormNode) THEN
      texture := FormsVBT.GetText(as, &quot;formtexture&quot;)
    ELSE
      texture := FormsVBT.GetText(as, &quot;frametexture&quot;)
    END;
    IF Text.Equal(texture, &quot;Blank&quot;) THEN texture := &quot;blank.pbm&quot; END;
    TRY
      cachedRawImage := GetRawImage(texture)
    EXCEPT
      Error (msg) =&gt; error := &quot;Error in Texture.&quot; &amp; msg; RETURN FALSE
    ELSE
      error := &quot;Invalid Texture Specification&quot;;
      RETURN FALSE
    END;
    RETURN CheckAttributes(nv, as, error);
  END SplitCheckAttributes;
*)
PROCEDURE <A NAME="SplitApplyAttributes"><procedure>SplitApplyAttributes</procedure></A> (nv: SplitNode; as: FormsVBT.T) =
  BEGIN
    ApplyAttributes(nv, as);
    IF ISTYPE(nv, FormNode) THEN
      nv.Texture := FormsVBT.GetText(as, &quot;formtexture&quot;)
    ELSE
      nv.Texture := FormsVBT.GetText(as, &quot;frametexture&quot;)
    END
  END SplitApplyAttributes;

PROCEDURE <A NAME="SplitObAttrs"><procedure>SplitObAttrs</procedure></A>(nv: SplitNode) : TEXT =
  VAR ret :=  TextAttr(&quot;Texture&quot;, nv.Texture);
  BEGIN
    (* do all the kids of the split *)
    ret := ret &amp; &quot;\ttemp.children := meth(s)  [&quot;;
    (* iterate over children and put in a VOInstance.&lt;child.name&gt; for each child *)
    FOR i := 1 TO nv.nc DO
      WITH child = nv.children[i] DO
        ret := ret &amp; &quot;VOInstance.&quot; &amp; child.name &amp; &quot;, &quot;;
      END (* WITH *)
    END;
    ret := ret &amp; &quot;]; end;\n&quot;;
   RETURN InitObliqAttrs(nv) &amp; ret;
  END SplitObAttrs;

PROCEDURE <A NAME="ResizeString"><procedure>ResizeString</procedure></A>(ch : T) : TEXT =
VAR
  model := ch.ResizeModel;
  retval := &quot; Scaled&quot;; (* default *)
  BEGIN
    IF Text.Equal(model, &quot;CenterPin&quot;) THEN
      retval := &quot; FixedHV &quot;
    ELSIF Text.Equal(model, &quot;HScaled&quot;) THEN
      retval := &quot; FixedV &quot;
    ELSIF Text.Equal(model, &quot;VScaled&quot;) THEN
      retval := &quot; FixedH &quot;
    END;
    RETURN retval;
  END ResizeString;

PROCEDURE <A NAME="SplitComputeSX"><procedure>SplitComputeSX</procedure></A> (nv: SplitNode; Final: BOOLEAN := FALSE)
  : TEXT =
  VAR footer := &quot;)\n&quot;;
      child_offset_redn := 0;
      include_title_bar := TRUE;
  BEGIN
    IF NOT Final THEN
      nv.DialogSX := FindAndReplace(nv.DialogSX, &quot;ZSplitHeader&quot;, &quot;&quot;);
      nv.DialogSX := FindAndReplace(nv.DialogSX, &quot;ZSplitFooter&quot;, &quot;&quot;);
    ELSE
      nv.DialogSX :=
        FindAndReplace(nv.DialogSX, &quot;ZSplitHeader&quot;,
                       &quot;(ZSplit %@zsplit\n (ZBackground %@zback\n  &quot;);

      IF ISTYPE(nv, FormNode)  THEN
            WITH  fn =  NARROW(nv, FormNode) DO
              IF fn.ParentForm = NIL THEN (* its a top level form .. *)
                child_offset_redn := GetTitleHt(fn);
                nv.DialogSX := FindAndReplace(nv.DialogSX, &quot;YSpan&quot;, Fmt.Int(nv.height- child_offset_redn) );
                include_title_bar := FALSE;
              END (* IF *)
            END (* WITH *)
          END;

      FOR i := 1 TO nv.nc DO
        WITH child = nv.children[i] DO
          ComputeDimensions(child);
          child.DialogSX := child.SXTemplate();
          EVAL child.computeSX(TRUE);

          (* Attach child to the split .
             Top-level forms are a special case because the title bar has to be removed
             which means reducing the vert offset of all children and reducing the height
             of the form by the title-ht*)

          footer := footer &amp; &quot;(ZChild (At &quot; &amp; Fmt.Int(child.x) &amp; &quot;  &quot;
                      &amp; Fmt.Int(child.y - child_offset_redn) &amp; &quot;  NW Absolute) Open\n  &quot; &amp;
                      ResizeString(child) &amp;
                      child.DialogSX &amp; &quot;\n    )\n&quot;;

        END
      END;

      IF ISTYPE(nv, FormNode) THEN

        WITH fn = NARROW(nv, FormNode) DO (* do all the anchored children *)
          FOR j := 0 TO fn.NoOfChildren - 1 DO
            fn.ChildForms[j].DialogSX := fn.ChildForms[j].SXTemplate();
            ComputeDimensions(fn.ChildForms[j]);
            EVAL fn.ChildForms[j].computeSX(TRUE);
            footer := footer &amp; fn.ChildForms[j].DialogSX;
          END;
        END (* WITH *);

      END (* IF *);

      footer := footer &amp; &quot;)\n&quot;;
      nv.DialogSX := FindAndReplace(nv.DialogSX, &quot;ZSplitFooter&quot;, footer);
    END (* IF *);

    nv.DialogSX := FindAndReplace(nv.DialogSX, &quot;TextureFile&quot;, nv.Texture);
    (* print(&quot;After SplitComputeSX :\n&quot; &amp; nv.DialogSX &amp; &quot;\n&quot;); *)

    IF ISTYPE(nv, FormNode) THEN
      IF include_title_bar THEN (* do title bar *)
        nv.DialogSX := FindAndReplace(nv.DialogSX, &quot;IncludeTitleBar&quot;, &quot;($TitleBar$)&quot;);
      ELSE
        nv.DialogSX := FindAndReplace(nv.DialogSX, &quot;IncludeTitleBar&quot;, &quot;&quot;);
      END;
      (* either way replace all occurences of $TitleBar$ with name &amp; TitleBar *)
      nv.DialogSX := FAndRAll(nv.DialogSX, &quot;TitleBar&quot;, nv.name &amp; &quot;TitleBar&quot;);
    END (* IF *);

    RETURN ComputeSX(nv, Final);
  END SplitComputeSX;

PROCEDURE <A NAME="SplitGenerateObjectDefs"><procedure>SplitGenerateObjectDefs</procedure></A> (nv: SplitNode): TEXT =
  VAR objdefs := &quot;&quot;;
  BEGIN
    (* compute obj defs for all children *)
    FOR i := 1 TO nv.nc DO
      objdefs := objdefs &amp; nv.children[i].generateObjectDefs();
    END;

    (* append obj def for this node *)
    RETURN objdefs &amp; GenerateObjectDefs(nv);

  END SplitGenerateObjectDefs;

PROCEDURE <A NAME="SplitGenerateCallbacks"><procedure>SplitGenerateCallbacks</procedure></A> (nv: SplitNode): TEXT =
  VAR cbdefs := &quot;&quot;;
  BEGIN
    (* compute callbacks for all children *)
    FOR i := 1 TO nv.nc DO
      cbdefs := cbdefs &amp; nv.children[i].generateCallbacks();
    END;

    (* Split Nodes have no callbacks *)
    RETURN cbdefs;
  END SplitGenerateCallbacks;

PROCEDURE <A NAME="SplitGenerateAttachments"><procedure>SplitGenerateAttachments</procedure></A> (nv: SplitNode): TEXT =
  VAR adefs := &quot;&quot;;
  BEGIN
    (* compute attachments for all children *)
    FOR i := 1 TO nv.nc DO
      adefs := adefs &amp; nv.children[i].generateAttachments();
    END;

    (* Split Nodes have no attachments *)
    RETURN adefs;
  END SplitGenerateAttachments;

PROCEDURE <A NAME="SplitGenerateInitializationCode"><procedure>SplitGenerateInitializationCode</procedure></A> (nv: SplitNode): TEXT =
  VAR prefix := &quot;&quot;;
  BEGIN
    (* compute init code for all children *)
    FOR i := 1 TO nv.nc DO
      IF ISTYPE(nv.children[i], SplitNode) THEN
        prefix := prefix &amp; nv.children[i].generateInitializationCode();
      END
    END;
    (* SplitNodes have no callbacks - the Code field has init code *)
    RETURN prefix &amp; nv.Code;
  END SplitGenerateInitializationCode;

PROCEDURE <A NAME="print"><procedure>print</procedure></A> (c: TEXT) =
  BEGIN
    TRY
      Wr.PutText(Stdio.stdout, c);
      Wr.Flush(Stdio.stdout);
    EXCEPT
    ELSE
    END
  END print;
</PRE>************ Form Attribute Management *******************

<P><PRE>PROCEDURE <A NAME="ComputeAnchoredFormTree"><procedure>ComputeAnchoredFormTree</procedure></A> () =
  (* This computes the tree of anchored forms from the parent field of all
     the active FormNodes *)
  VAR
    formclass    := NameToIndex(&quot;form&quot;);
    n            := NoOfObjects(formclass);
    current  : T;
  BEGIN

    IF n &gt; 0 THEN
      FOR i := 0 TO NoOfObjects(formclass) - 1 DO
        (* pass 1 - set counters to 0 *)
        IF i = 0 THEN
          current := GetFirst(formclass);

        ELSE
          current := GetNext(formclass);

        END;
        WITH z = NARROW(current, FormNode) DO

          z.NoOfChildren := 0;
          z.Tag := TRUE;         (* side effect *)
        END
      END;                       (* end of pass 1 *)

      FOR i := 0 TO NoOfObjects(formclass) - 1 DO
        IF i = 0 THEN
          current := GetFirst(formclass)
        ELSE
          current := GetNext(formclass)
        END;

        WITH z = NARROW(current, FormNode),
             p = z.ParentForm               DO
          IF p # NIL THEN

            p.ChildForms[p.NoOfChildren] := z;
            INC(p.NoOfChildren)
          END
        END
      END
    END                          (* end of pass 2 *)
  END ComputeAnchoredFormTree;

PROCEDURE <A NAME="ComputeViableParentsFor"><procedure>ComputeViableParentsFor</procedure></A> (nv: FormNode) =
  (* this calls ComputeAnchoredFormTree and tags nodes in the tree rooted
     at nv with Tag = FALSE *)

  PROCEDURE SetTagsOnTree (v: FormNode) =
    BEGIN
      v.Tag := FALSE;
      FOR i := 0 TO v.NoOfChildren - 1 DO
        SetTagsOnTree(v.ChildForms[i])
      END
    END SetTagsOnTree;

  BEGIN
    ComputeAnchoredFormTree();
    SetTagsOnTree(nv);
  END ComputeViableParentsFor;

PROCEDURE <A NAME="LoadParentNames"><procedure>LoadParentNames</procedure></A> (nv: FormNode; as: FormsVBT.T) =
  VAR
    formclass    := NameToIndex(&quot;form&quot;);
    n            := NoOfObjects(formclass);
    current  : T;
    list         := &quot;&quot;;
  BEGIN

    ComputeViableParentsFor(nv);
    FOR i := 0 TO n - 1 DO
      IF i = 0 THEN
        current := GetFirst(formclass)
      ELSE
        current := GetNext(formclass)
      END;
      WITH z = NARROW(current, FormNode) DO

        IF z.Tag THEN list := list &amp; z.name &amp; &quot;\n&quot; END
      END
    END;
    WITH x       = FormsVBT.GetVBT(as, &quot;parentlist&quot;),
         parlist = NARROW(x, ListVBT.T)               DO
      Attributes.LVFlush(parlist);
      Attributes.LVAppendText(parlist, list);
    END;
  END LoadParentNames;

PROCEDURE <A NAME="AnchorProc"><procedure>AnchorProc</procedure></A> (&lt;* UNUSED *&gt; cl  : FormsVBT.Closure;
                                   afv : FormsVBT.T;
                      &lt;* UNUSED *&gt; name: TEXT;
                      &lt;* UNUSED *&gt; time: VBT.TimeStamp     ) =
  BEGIN
    IF FormsVBT.GetBoolean(afv, &quot;anchored&quot;) THEN
      LoadParentNames(NARROW(Attributes.currentNode, FormNode), afv);
      FormsVBT.PutText(afv, &quot;parent&quot;, &quot;&quot;, FALSE);
      FormsVBT.MakeActive(afv, &quot;anchorfilter&quot;);
    ELSE
      FormsVBT.PutText(afv, &quot;parent&quot;, &quot;&quot;, FALSE);
      FormsVBT.MakeDormant(afv, &quot;anchorfilter&quot;);
    END
  END AnchorProc;

PROCEDURE <A NAME="ParentProc"><procedure>ParentProc</procedure></A> (&lt;* UNUSED *&gt; cl  : FormsVBT.Closure;
                                   afv : FormsVBT.T;
                      &lt;* UNUSED *&gt; name: TEXT;
                      &lt;* UNUSED *&gt; time: VBT.TimeStamp     ) =
  BEGIN
    WITH nom = FormsVBT.GetTextProperty(afv, &quot;parentlist&quot;, &quot;Select&quot;) DO
      FormsVBT.PutText(afv, &quot;parent&quot;, nom, FALSE);
    END;
    ZSplit.Unmap(FormsVBT.GetVBT(afv, &quot;combo&quot;));
    TSplit.SetCurrent(NARROW(FormsVBT.GetVBT(afv, &quot;com&quot;), TSplit.T),
                      FormsVBT.GetVBT(afv, &quot;opencombo&quot;));
  END ParentProc;

PROCEDURE <A NAME="MenuProc"><procedure>MenuProc</procedure></A> (&lt;* UNUSED *&gt; cl  : FormsVBT.Closure;
                                 afv : FormsVBT.T;
                                 name: TEXT;
                    &lt;* UNUSED *&gt; time: VBT.TimeStamp     ) =
  BEGIN
    IF Text.Equal(name, &quot;menuBoolean&quot;) THEN
      IF FormsVBT.GetBoolean(afv, &quot;menuBoolean&quot;) THEN
        FormsVBT.MakeActive(afv, &quot;tomenuFilter&quot;)
      ELSE
        FormsVBT.MakeDormant(afv, &quot;tomenuFilter&quot;)
      END
    END
  END MenuProc;

PROCEDURE <A NAME="FormLoadAttributes"><procedure>FormLoadAttributes</procedure></A> (nv: FormNode; as: FormsVBT.T) =
  BEGIN

    (* Anchored *)
    (* If this is an anchored form set Anchored to true and enable the
       parent menu.  load the parent menu with possible parents i.e.  All
       Forms - Forms in the Anchor-Tree rooted at this node *)
    IF (nv.ParentForm # NIL) THEN
      FormsVBT.MakeActive(as, &quot;anchorfilter&quot;);
      FormsVBT.PutText(as, &quot;parent&quot;, nv.ParentForm.name, FALSE);
      FormsVBT.PutBoolean(as, &quot;anchored&quot;, TRUE);
      LoadParentNames(nv, as);
    ELSE
      FormsVBT.PutBoolean(as, &quot;anchored&quot;, FALSE);
      FormsVBT.PutText(as, &quot;parent&quot;, &quot;&quot;, FALSE);
      FormsVBT.MakeDormant(as, &quot;anchorfilter&quot;);
    END;
    FormsVBT.PutBoolean(as, &quot;menuBoolean&quot;, nv.HasMenu);
    IF nv.HasMenu THEN
      FormsVBT.MakeActive(as, &quot;tomenuFilter&quot;)
    ELSE
      FormsVBT.MakeDormant(as, &quot;tomenuFilter&quot;)
    END;
    FormsVBT.PutInteger(as, &quot;vstretch&quot;, nv.StretchY);
    FormsVBT.PutInteger(as, &quot;vshrink&quot;, nv.ShrinkY);
    FormsVBT.PutInteger(as, &quot;hstretch&quot;, nv.StretchX);
    FormsVBT.PutInteger(as, &quot;hshrink&quot;, nv.ShrinkX);
    FormsVBT.PutText(as, &quot;tfgctypein&quot;, nv.TitleFgColor, FALSE);
    FormsVBT.PutText(as, &quot;tbgctypein&quot;, nv.TitleBgColor, FALSE);
    FormsVBT.PutText(as, &quot;ttyp&quot;, nv.TitleString, FALSE);
    FormsVBT.PutText(as, &quot;supportCodeEditor&quot;, nv.SupportCode, FALSE);
    SplitLoadAttributes(nv, as); (* call split attributes *)
    DialogMenu.LoadAttributes(nv);
  END FormLoadAttributes;

PROCEDURE <A NAME="FormApplyAttributes"><procedure>FormApplyAttributes</procedure></A> (nv: FormNode; as: FormsVBT.T) =
  BEGIN
    SplitApplyAttributes(nv, as);
    IF FormsVBT.GetBoolean(as, &quot;anchored&quot;) THEN
      WITH name       = FormsVBT.GetText(as, &quot;parent&quot;),
           classindex = NameToIndex(&quot;form&quot;)             DO
        nv.ParentForm := GetNodeNamed(name, classindex);
      END
    ELSE
      nv.ParentForm := NIL;
    END;
    nv.StretchY := FormsVBT.GetInteger(as, &quot;vstretch&quot;);
    nv.ShrinkY := FormsVBT.GetInteger(as, &quot;vshrink&quot;);
    nv.StretchX := FormsVBT.GetInteger(as, &quot;hstretch&quot;);
    nv.ShrinkX := FormsVBT.GetInteger(as, &quot;hshrink&quot;);
    nv.SupportCode := FormsVBT.GetText(as, &quot;supportCodeEditor&quot;);
    nv.TitleFgColor := FormsVBT.GetText(as, &quot;tfgctypein&quot;);
    IF Text.Equal(nv.TitleFgColor, &quot;Inherit&quot;) THEN
      nv.TitleFgColor := nv.FgColor;
      FormsVBT.PutText(as, &quot;tfgctypein&quot;, nv.TitleFgColor, FALSE);
    END;

    nv.TitleBgColor := FormsVBT.GetText(as, &quot;tbgctypein&quot;);
    IF Text.Equal(nv.TitleBgColor, &quot;Inherit&quot;) THEN
      nv.TitleBgColor := nv.BgColor;
      FormsVBT.PutText(as, &quot;tbgctypein&quot;, nv.TitleBgColor, FALSE);
    END;

    nv.TitleString := FormsVBT.GetText(as, &quot;ttyp&quot;);
    nv.HasMenu := FormsVBT.GetBoolean(as, &quot;menuBoolean&quot;);

  END FormApplyAttributes;

PROCEDURE <A NAME="FormComputeSX"><procedure>FormComputeSX</procedure></A> (nv: FormNode; Final: BOOLEAN := FALSE): TEXT =
  BEGIN
    IF NOT Text.Equal(nv.InitialState, &quot;Vanish&quot;) THEN
      nv.DialogSX := FindAndReplace(nv.DialogSX, &quot;ZChildState&quot;, &quot;Open&quot;);
    ELSE
      nv.DialogSX := FindAndReplace(nv.DialogSX, &quot;ZChildState&quot;, &quot;&quot;);
    END;
    nv.DialogSX :=
      FindAndReplace(nv.DialogSX, &quot;XStretch&quot;, Fmt.Int(nv.StretchX));
    nv.DialogSX :=
      FindAndReplace(nv.DialogSX, &quot;YStretch&quot;, Fmt.Int(nv.StretchY));
    nv.DialogSX :=
      FindAndReplace(nv.DialogSX, &quot;XShrink&quot;, Fmt.Int(nv.ShrinkX));
    nv.DialogSX :=
      FindAndReplace(nv.DialogSX, &quot;YShrink&quot;, Fmt.Int(nv.ShrinkY));
    IF nv.HasMenu THEN
      nv.DialogSX := FindAndReplace(nv.DialogSX, &quot;MenuStructure&quot;,
                                    DialogMenu.ComputeMenuSX(nv));
    ELSE
      nv.DialogSX := FindAndReplace(nv.DialogSX, &quot;MenuStructure&quot;, &quot;&quot;);
    END;
    nv.DialogSX :=
      FindAndReplace(nv.DialogSX, &quot;TitleBgColor&quot;, nv.TitleBgColor);
    nv.DialogSX :=
      FindAndReplace(nv.DialogSX, &quot;TitleFgColor&quot;, nv.TitleFgColor);
    nv.DialogSX :=
      FindAndReplace(nv.DialogSX, &quot;TitleString&quot;, nv.TitleString);
    (* print(&quot;After FormComputeSX :\n&quot; &amp; nv.DialogSX &amp; &quot;\n&quot;); *)
    RETURN SplitComputeSX(nv, Final);
    (* after which there should be no unresolved symbols *)
  END FormComputeSX;

PROCEDURE <A NAME="FormGenerateObjectDefs"><procedure>FormGenerateObjectDefs</procedure></A> (nv: FormNode): TEXT =
  VAR objdefs := &quot;&quot;;
  BEGIN
    (* for all anchored forms &amp; menu items within, generate obj defs *)

    (* anchored forms *)
    FOR j := 0 TO nv.NoOfChildren - 1 DO
      objdefs := objdefs &amp; nv.ChildForms[j].generateObjectDefs()
    END;

    (* for all menu items generate menu item objdefs *)
    IF nv.HasMenu THEN
      objdefs := objdefs &amp; DialogMenu.ComputeMenuObjDefs(nv);
    END;

    RETURN objdefs &amp; SplitGenerateObjectDefs(nv);
  END FormGenerateObjectDefs;

PROCEDURE <A NAME="FormGenerateCallbacks"><procedure>FormGenerateCallbacks</procedure></A> (nv: FormNode): TEXT =
  VAR cbdefs := &quot;&quot;;
  BEGIN

    (* for all anchored forms &amp; menu items within, generate callbacks *)

    (* anchored forms *)
    FOR j := 0 TO nv.NoOfChildren - 1 DO
      cbdefs := cbdefs &amp; nv.ChildForms[j].generateCallbacks()
    END;

    (* For all menu items generate menu item callbacks *)
    IF nv.HasMenu THEN
      cbdefs := cbdefs &amp; DialogMenu.ComputeMenuCallbacks(nv);
    END;

    RETURN cbdefs &amp; SplitGenerateCallbacks(nv);

  END FormGenerateCallbacks;

PROCEDURE <A NAME="FormGenerateAttachments"><procedure>FormGenerateAttachments</procedure></A> (nv: FormNode): TEXT =
  VAR adefs := &quot;&quot;;
  BEGIN
    (* forms and frames have no attachments but their components may *)

    (* for all anchored forms &amp; menu items within, generate attachments *)
    (* anchored forms *)
    FOR j := 0 TO nv.NoOfChildren - 1 DO
      adefs := adefs &amp; nv.ChildForms[j].generateAttachments()
    END;

    (* For all menu items generate menu item attachments *)
    IF nv.HasMenu THEN
      adefs := adefs &amp; DialogMenu.ComputeMenuAttachments(nv)
    END;

    RETURN adefs &amp; SplitGenerateAttachments(nv);

  END FormGenerateAttachments;

PROCEDURE <A NAME="FormGenerateInitializationCode"><procedure>FormGenerateInitializationCode</procedure></A> (nv: FormNode): TEXT =
  VAR prefix := &quot;&quot;;
  BEGIN
    (* for all anchored forms &amp; menu items within, gen init code *)
    (* anchored forms *)
    FOR j := 0 TO nv.NoOfChildren - 1 DO
      prefix := prefix &amp; nv.ChildForms[j].generateInitializationCode()
    END;

    RETURN prefix &amp; SplitGenerateInitializationCode(nv);
  END FormGenerateInitializationCode;
</PRE>************ Frame Attribute Management ******************

<P>
<P>
<P>***********  Support Code *********************************

<P>
<P><PRE>PROCEDURE <A NAME="FindAndReplace"><procedure>FindAndReplace</procedure></A> (string, quarry, replacement: TEXT;
                          delimiter                  : CHAR   := '$'):
  TEXT =
  VAR
    first: INTEGER := Text.FindChar(string, delimiter);
    next : INTEGER;
  BEGIN
    IF first = -1 THEN RETURN string; END;
    next := Text.FindChar(string, delimiter, first + 1);
    WHILE next # -1 DO
      IF Text.Equal(Text.Sub(string, first + 1, next - first - 1), quarry) THEN
        RETURN Text.Sub(string, 0, first) &amp; replacement
                 &amp; Text.Sub(string, next + 1);
      END;
      first := next;
      next := Text.FindChar(string, delimiter, first + 1);
    END;
    RETURN string;
  END FindAndReplace;

PROCEDURE <A NAME="FAndRAll"><procedure>FAndRAll</procedure></A> (string, quarry, replacement: TEXT;
                    delimiter                  : CHAR   := '$'): TEXT =
  VAR
    first: INTEGER := Text.FindChar(string, delimiter);
    next : INTEGER;
  BEGIN
    IF first = -1 THEN RETURN string; END;
    next := Text.FindChar(string, delimiter, first + 1);
    WHILE next # -1 DO
      IF Text.Equal(Text.Sub(string, first + 1, next - first - 1), quarry) THEN
        RETURN Text.Sub(string, 0, first)
                 &amp; FAndRAll(replacement &amp; Text.Sub(string, next + 1),
                            quarry, replacement, delimiter);
      END;
      first := next;
      next := Text.FindChar(string, delimiter, first + 1);
    END;
    RETURN string;
  END FAndRAll;

PROCEDURE <A NAME="GetDomain"><procedure>GetDomain</procedure></A> (v: FormNode): Rect.T =
  VAR
    fv          := v.getchild();
    back: VBT.T;
    rect        := VBT.Domain(v);
  BEGIN

    IF ISTYPE(fv, FormsVBT.T) THEN
      (* which should always be the case *)
      back :=
        FormsVBT.GetVBT(NARROW(fv, FormsVBT.T), v.name &amp; &quot;background&quot;);
      rect := VBT.Domain(back);
    END;
    (* move  the e,w,s boundaries by 4 inward *)
    rect.east := rect.east-4;
    rect.west := rect.west+4;
    rect.south := rect.south-4;
    RETURN rect;
  END GetDomain;

PROCEDURE <A NAME="GetTitleHt"><procedure>GetTitleHt</procedure></A>( &lt;* UNUSED *&gt;f : FormNode) : INTEGER =
  BEGIN
    RETURN 20; (* This is currently a constant *)
  END GetTitleHt;
</PRE>*****************  CLASS MANAGEMENT ****************************************
<PRE>PROCEDURE <A NAME="Register"><procedure>Register</procedure></A> (className      : TEXT;
                    createProc     : Proc;
                    minParentWidth : INTEGER := 100;
                    minParentHeight: INTEGER := 100;
                    attrsheetName  : TEXT    := &quot;Default&quot;): CARDINAL
  =
  VAR classnumber := ClassCounter;
  BEGIN
    IF NOT inited THEN
      ObjectClasses := NEW(REF ARRAY [0 .. 100] OF ObjClass);
      inited := TRUE;
    END;
    (* assumes that this class has not been registered before *)
    WITH cl = ObjectClasses[ClassCounter] DO
      cl.name := className;
      cl.createProc := createProc;
      cl.minParentWidth := minParentWidth;
      cl.minParentHeight := minParentHeight;
      IF Text.Equal(attrsheetName, &quot;Default&quot;) THEN
        cl.attrsheetName := className &amp; &quot;att&quot;
      ELSE
        cl.attrsheetName := attrsheetName
      END;
      INC(ClassCounter);
      TRY
        WITH rd = Rsrc.Open(className &amp; &quot;TEMPLATE.fv&quot;, Dialog.rsrcPath) DO
          cl.SXTemplate := Rd.GetText(rd, LAST(CARDINAL));
          Rd.Close(rd)
        END
      EXCEPT
      | Rsrc.NotFound =&gt;
            print(&quot;Not Found: &quot; &amp; className &amp; &quot;TEMPLATE.fv&quot;);
      END (* TRY *);
    END;
    RETURN classnumber;
  END Register;

PROCEDURE <A NAME="ReloadSExpressions"><procedure>ReloadSExpressions</procedure></A>() =
  BEGIN
    FOR i := 0 TO ClassCounter - 1 DO
      TRY
        WITH rd = Rsrc.Open( ObjectClasses[i].name &amp; &quot;TEMPLATE.fv&quot;, Dialog.rsrcPath) DO
          ObjectClasses[i].SXTemplate := Rd.GetText(rd, LAST(CARDINAL));
          Rd.Close(rd)
        END
      EXCEPT
      | Rsrc.NotFound =&gt;
            print(&quot;Not Found: &quot; &amp; ObjectClasses[i].name &amp; &quot;TEMPLATE.fv&quot;);
      END (* TRY *);
    END;
  END ReloadSExpressions;

PROCEDURE <A NAME="NameToIndex"><procedure>NameToIndex</procedure></A> (className: TEXT): CARDINAL
  RAISES {InvalidObjectName} =
  BEGIN
    FOR i := 0 TO ClassCounter - 1 DO
      IF Text.Equal(className, ObjectClasses[i].name) THEN RETURN i END
    END;
    RAISE InvalidObjectName(className)
  END NameToIndex;

PROCEDURE <A NAME="NewObject"><procedure>NewObject</procedure></A> (dialogFV : FormsVBT.T;
                     className: TEXT;
                     parent   : T          := NIL): T
  RAISES {InstanceListFull} =
  VAR
    instanceName: TEXT;
    instance    : T;
    found                  := FALSE;
    n           : CARDINAL;
  BEGIN

    TRY
      n := NameToIndex(className);
    EXCEPT
    | InvalidObjectName (foo) =&gt;
        Dialog.message(
          dialogFV, &quot;The class &quot; &amp; foo &amp; &quot; has not yet been implemented&quot;);
        RETURN NIL;
    END;

    WITH cl = ObjectClasses[n] DO
      INC(cl.instances);
      INC(cl.count);
      instanceName := cl.name &amp; Fmt.Int(cl.count);
      (* Default names are of the form : foo1, foo2 .. *)
      FOR i := 0 TO 100 DO
        IF cl.instanceList[i] = NIL AND NOT found THEN (* found a free
                                                          entry*)
          found := TRUE;
          instance := cl.createProc();
          instance.parent := parent;
          instance.name := instanceName;
          instance.classIndex := n;

          instance.DialogSX := instance.SXTemplate();
          EVAL instance.computeSX();

          cl.instanceList[i] := instance;

          RETURN instance
        END
      END;
      RAISE InstanceListFull(className)
    END
  END NewObject;

PROCEDURE <A NAME="InsertObject"><procedure>InsertObject</procedure></A> (nv : T)
    RAISES {InstanceListFull} =
  VAR
    classname := GetNodeTypeName(nv);
    classindex := NameToIndex(classname);
    found                  := FALSE;
  BEGIN
    WITH cl = ObjectClasses[classindex] DO
      INC(cl.instances);
      FOR i := 0 TO 100 DO
        IF cl.instanceList[i] = NIL AND NOT found THEN (* found a free
                                                          entry*)
          found := TRUE;
          cl.instanceList[i] := nv;
          RETURN;
        END
      END;
      RAISE InstanceListFull(classname)
    END
  END InsertObject;

PROCEDURE <A NAME="GetMinParentDimensions"><procedure>GetMinParentDimensions</procedure></A> (    className      : TEXT;
                                  VAR minParentWidth : INTEGER;
                                  VAR minParentHeight: INTEGER  )
  RAISES {InvalidObjectName} =
  BEGIN
    WITH n  = NameToIndex(className),
         cl = ObjectClasses[n]        DO
      minParentWidth := cl.minParentWidth;
      minParentHeight := cl.minParentHeight;
    END
  END GetMinParentDimensions;

PROCEDURE <A NAME="GetNodeIndex"><procedure>GetNodeIndex</procedure></A> (v: T): CARDINAL RAISES {InvalidNode} =
  BEGIN
    WITH ci    = v.classIndex,
         ilist = ObjectClasses[ci].instanceList DO
      FOR i := 0 TO 100 DO IF ilist[i] = v THEN RETURN i END END
    END;
    RAISE InvalidNode;
  END GetNodeIndex;

PROCEDURE <A NAME="NoOfClasses"><procedure>NoOfClasses</procedure></A> (): CARDINAL =
  BEGIN
    RETURN ClassCounter
  END NoOfClasses;

PROCEDURE <A NAME="GetNodeTypeName"><procedure>GetNodeTypeName</procedure></A> (v: T): TEXT =
  BEGIN
    RETURN ObjectClasses[v.classIndex].name;
  END GetNodeTypeName;

PROCEDURE <A NAME="GetAttributeSheetName"><procedure>GetAttributeSheetName</procedure></A> (v: T): TEXT =
  BEGIN
    RETURN ObjectClasses[v.classIndex].attrsheetName;
  END GetAttributeSheetName;

PROCEDURE <A NAME="DeleteObject"><procedure>DeleteObject</procedure></A> (obj: T) =
  BEGIN
    WITH n     = obj.classIndex,
         ilist = ObjectClasses[n].instanceList DO
      DEC(ObjectClasses[n].instances);
      FOR i := 0 TO 100 DO IF ilist[i] = obj THEN ilist[i] := NIL END END
    END
  END DeleteObject;

PROCEDURE <A NAME="IndexToName"><procedure>IndexToName</procedure></A> (classIndex: CARDINAL): TEXT =
  BEGIN
    RETURN ObjectClasses[classIndex].name;
  END IndexToName;

PROCEDURE <A NAME="NoOfObjects"><procedure>NoOfObjects</procedure></A> (index: CARDINAL): CARDINAL =
  BEGIN
    RETURN ObjectClasses[index].instances;
  END NoOfObjects;

PROCEDURE <A NAME="GetFirst"><procedure>GetFirst</procedure></A> (classIndex: CARDINAL): T =
  BEGIN
    WITH ilist = ObjectClasses[classIndex].instanceList DO
      FOR i := 0 TO 100 DO
        IF ilist[i] # NIL THEN
          ObjectClasses[classIndex].last := i;
          RETURN ilist[i]
        END
      END
    END;
    RETURN NIL
  END GetFirst;

PROCEDURE <A NAME="GetNext"><procedure>GetNext</procedure></A> (classIndex: CARDINAL): T =
  BEGIN
    WITH oc    = ObjectClasses[classIndex],
         ilist = oc.instanceList            DO
      FOR i := oc.last + 1 TO 100 DO
        IF ilist[i] # NIL THEN oc.last := i; RETURN ilist[i] END
      END
    END;
    RETURN NIL
  END GetNext;

PROCEDURE <A NAME="GetNodeNamed"><procedure>GetNodeNamed</procedure></A> (name: TEXT; classIndex: INTEGER := -1): T =
  VAR start, end: CARDINAL;
  BEGIN
    IF classIndex = -1 THEN
      start := 0;
      end := ClassCounter - 1;
    ELSE
      start := classIndex;
      end := classIndex
    END;
    FOR i := start TO end DO
      WITH oc = ObjectClasses[i] DO
        FOR j := 0 TO 100 DO
          IF oc.instanceList[j] # NIL THEN
            IF Text.Equal(oc.instanceList[j].name, name) THEN
              RETURN oc.instanceList[j]
            END
          END
        END
      END
    END;
    RETURN NIL
  END GetNodeNamed;

PROCEDURE <A NAME="FormConstructor"><procedure>FormConstructor</procedure></A> (): T =
  BEGIN
    RETURN NEW(FormNode, BgColor := &quot;Grey75&quot;, FgColor := &quot;Black&quot;, Rim := 0,
               Border := 1, Font := &quot;-*-helvetica-bold-*R-*120-*&quot;,
               width := 100, height := 100, Embellishment := &quot;Raised&quot;);
  END FormConstructor;

PROCEDURE <A NAME="FrameConstructor"><procedure>FrameConstructor</procedure></A> (): T =
  BEGIN
    RETURN NEW(FrameNode, BgColor := &quot;Grey75&quot;, FgColor := &quot;Black&quot;,
               Rim := 0, Border := 0, Embellishment := &quot;Raised&quot;);
  END FrameConstructor;

PROCEDURE <A NAME="AllWhitespace"><procedure>AllWhitespace</procedure></A> (t: TEXT): BOOLEAN =
  VAR reader: Rd.T;
  BEGIN
    IF Text.Empty(t) THEN RETURN TRUE; END;
    reader := TextRd.New(t);
    Lex.Skip(reader);
    RETURN Rd.EOF(reader);
  END AllWhitespace;
</PRE> save and load procs 

<P><PRE>PROCEDURE <A NAME="SaveToFile"><procedure>SaveToFile</procedure></A> (fv: FormsVBT.T; s: Wr.T) =
  VAR current: T;
  BEGIN
    RW.wint(s, ClassCounter);    (* no of classes that follow *)
    FOR i := 0 TO ClassCounter - 1 DO
      (* write class description to file *)
      RW.wtext(s, ObjectClasses[i].name);
      RW.wint(s, ObjectClasses[i].instances);
      RW.wint(s, ObjectClasses[i].count);
      RW.wtext(s, ObjectClasses[i].SXTemplate);
      FOR j := 1 TO ObjectClasses[i].instances DO
        IF j = 1 THEN
          current := GetFirst(i);
        ELSE
          current := GetNext(i)
        END;
        current.save(fv, s);
      END;
    END;

  END SaveToFile;

PROCEDURE <A NAME="ResetTables"><procedure>ResetTables</procedure></A> () =
  BEGIN
    FOR i := 0 TO ClassCounter - 1 DO
      FOR j := 0 TO 100 DO ObjectClasses[i].instanceList[j] := NIL; END;
      ObjectClasses[i].instances := 0;
      ObjectClasses[i].count := 0;
    END;
  END ResetTables;

PROCEDURE <A NAME="LoadFromFile"><procedure>LoadFromFile</procedure></A> (fv: FormsVBT.T; s: Rd.T) =
  VAR
    classCount, cx: INTEGER;
    cname         : TEXT;

  BEGIN
    (* clean up *)
    GenerateObliq.sessionConstructor := &quot;CreateEachFormOnce(LOCAL);\n&quot;;
    GenerateObliq.globalCode  := &quot;&quot;;
    GenerateObliq.serverSideCode  := &quot;&quot;;

    (* all screens have been deleted &amp; fresh screens have been created *)

    (* We want to keep the ObjectClasses as they are but their
       instanceLists need to be freed *)
    print(&quot;Cleaning up \n&quot;);

    FOR i := 0 TO ClassCounter - 1 DO
      FOR j := 0 TO 100 DO ObjectClasses[i].instanceList[j] := NIL; END
    END;

    RW.rint(s, classCount);      (* no of classes that follow *)

    FOR i := 1 TO classCount DO
      (* read class description from file *)
      RW.rtext(s, cname);

      TRY
        cx := NameToIndex(cname)
      EXCEPT
      ELSE
        Dialog.message(
          Dialog.screen[1], &quot;Unknown class specification - Load Aborted &quot;)
      END;
      RW.rint(s, ObjectClasses[cx].instances);
      RW.rint(s, ObjectClasses[cx].count);
      RW.rtext(s, ObjectClasses[cx].SXTemplate);

      FOR j := 0 TO ObjectClasses[cx].instances - 1 DO
        WITH instance = ObjectClasses[cx].createProc() DO
          ObjectClasses[cx].instanceList[j] := instance;
          instance.load(fv, s);
          instance.classIndex := cx;
        END
      END;
    END;
    IF  NOT  FormsVBT.GetBoolean(fv, &quot;useSSX&quot;) THEN
      ReloadSExpressions();
    END;
    print(&quot;Done\n&quot;);
    (* Resolve References - T.partuple, SplitNode.childtuples and
       FormNode.Partuple *)

    FOR i := 0 TO ClassCounter - 1 DO
      FOR j := 0 TO ObjectClasses[i].instances - 1 DO
        WITH current = ObjectClasses[i].instanceList[j] DO
          print(&quot;Computing sx for &quot; &amp; current.name &amp; &quot;\n&quot;);
          (* compute the sx while we're about it *)
          current.DialogSX := current.SXTemplate();
          EVAL current.computeSX();

          current.parent := RW.ttop(current.partuple);
          IF ISTYPE(current, SplitNode) THEN
            WITH sn = NARROW(current, SplitNode) DO
              FOR k := 1 TO sn.nc DO
                sn.children[k] := RW.ttop(sn.childtuples[k]);
              END
            END;
            IF ISTYPE(current, FormNode) THEN
              WITH fn = NARROW(current, FormNode) DO
                fn.ParentForm := NARROW(RW.ttop(fn.Partuple), FormNode);
              END
            END
          END
        END
      END
    END;

    (* insert FormNodes into appropriate screens *)
    WITH fx = NameToIndex(&quot;form&quot;) DO
      FOR j := 0 TO ObjectClasses[fx].instances - 1 DO
        WITH cur     = ObjectClasses[fx].instanceList[j],
             fn      = NARROW(cur, FormNode),
             dialog  = Dialog.screen[fn.Screen],
             zsplit  = FormsVBT.GetVBT(dialog, &quot;topZSplit&quot;),
             newform = NEW(FormsVBT.T).init(cur.DialogSX),
             x       = ROUND(Dialog.PixelsPerPtHor * FLOAT(cur.x)),
             y       = ROUND(Dialog.PixelsPerPtVer * FLOAT(cur.y)),
             width   = ROUND(Dialog.PixelsPerPtHor * FLOAT(cur.width)),
             height  = ROUND(Dialog.PixelsPerPtVer * FLOAT(cur.height)) DO
          EVAL ZHandleVBT.T.init(cur, newform, dialog.selection);
          ZSplit.InsertAt(NARROW(zsplit, ZSplit.T), cur,
                          (* Point.Add(Rect.NorthWest(VBT.Domain(zsplit)),
                             Point.T{50 + j, 50 + j}) *)
                          Point.T{x, y});
          ZSplit.Move(
            cur,
            Rect.FromCorners(Point.T{x, y}, Point.T{x + width, y + height}));
          RecursivelyInsertChildren(fn, dialog);
        END
      END
    END

  END LoadFromFile;
</PRE> x = ROUND(Pts.ToPixels(nv, FLOAT(cur.x), Axis.T.Hor)), y =
   ROUND(Pts.ToPixels(nv, FLOAT(cur.y), Axis.T.Ver)), wid =
   ROUND(Pts.ToPixels(nv, FLOAT(cur.width), Axis.T.Hor)), ht =
   ROUND(Pts.ToPixels(nv, FLOAT(cur.height), Axis.T.Ver)) 

<P><PRE>PROCEDURE <A NAME="RecursivelyDeleteFromTables"><procedure>RecursivelyDeleteFromTables</procedure></A> (csn: T) =
  BEGIN
    IF ISTYPE(csn, SplitNode) THEN
      WITH s = NARROW(csn, SplitNode) DO
        FOR i := 1 TO s.nc DO RecursivelyDeleteFromTables(s.children[i]) END
      END
    END;
    DeleteObject(csn);
  END RecursivelyDeleteFromTables;
</PRE> x = ROUND(Pts.ToPixels(nv, FLOAT(cur.x), Axis.T.Hor)), y =
   ROUND(Pts.ToPixels(nv, FLOAT(cur.y), Axis.T.Ver)), wid =
   ROUND(Pts.ToPixels(nv, FLOAT(cur.width), Axis.T.Hor)), ht =
   ROUND(Pts.ToPixels(nv, FLOAT(cur.height), Axis.T.Ver)) 

<P><PRE>PROCEDURE <A NAME="RecursivelyInsertInTables"><procedure>RecursivelyInsertInTables</procedure></A> (csn: T; se: ZHandleVBT.Selection) =
  &lt;* FATAL InstanceListFull *&gt;
  BEGIN
    IF ISTYPE(csn, SplitNode) THEN
      WITH s = NARROW(csn, SplitNode) DO
        FOR i := 1 TO s.nc DO RecursivelyInsertInTables(s.children[i], se) END
      END
    END;
    InsertObject(csn);
    ZHandleVBT.NewSelection(csn, se);
  END RecursivelyInsertInTables;

PROCEDURE <A NAME="RecursivelyInsertChildren"><procedure>RecursivelyInsertChildren</procedure></A> (nv: SplitNode; dialog: Dialog.T) =
  BEGIN
    (* assert : nv has already been inserted *)
    FOR i := 1 TO nv.nc DO
      WITH cur     = nv.children[i],
           newform = NEW(FormsVBT.T).init(cur.DialogSX),
           x       = ROUND(Dialog.PixelsPerPtHor * FLOAT(cur.x)),
           y       = ROUND(Dialog.PixelsPerPtVer * FLOAT(cur.y)),
           width   = ROUND(Dialog.PixelsPerPtHor * FLOAT(cur.width)),
           height  = ROUND(Dialog.PixelsPerPtVer * FLOAT(cur.height)) DO
        EVAL ZHandleVBT.T.init(cur, newform, dialog.selection);
        ZSplit.InsertAt(nv, cur, Point.T{x, y});
        print(&quot;Inserting &quot; &amp; cur.name &amp; &quot; at &quot; &amp; Fmt.Int(x) &amp; &quot;,&quot;
                &amp; Fmt.Int(y) &amp; &quot;\n&quot;);

        ZSplit.Move(cur, Rect.FromCorners(
                           Point.T{x, y}, Point.T{x + width, y + height}));

        WITH dom = ZSplit.GetDomain(cur) DO
          print(&quot;Final Dimensions of &quot; &amp; cur.name &amp; &quot; = &quot;
                  &amp; Fmt.Int(Rect.HorSize(dom)) &amp; &quot; X &quot;
                  &amp; Fmt.Int(Rect.VerSize(dom)) &amp; &quot;\n&quot;);
        END;
        IF ISTYPE(cur, SplitNode) THEN
          RecursivelyInsertChildren(cur, dialog);
        END
      END
    END
  END RecursivelyInsertChildren;

PROCEDURE <A NAME="Save"><procedure>Save</procedure></A> (nv: T; &lt;* UNUSED *&gt; fv: FormsVBT.T; s: Wr.T) =
  BEGIN
    ComputeDimensions(nv);
    nv.partuple := RW.ptot(nv.parent);
    RW.wtuple(s, nv.partuple);
    RW.wtext(s, nv.name);
    RW.wint(s, nv.x);
    RW.wint(s, nv.y);
    RW.wint(s, nv.width);
    RW.wint(s, nv.height);
    print(&quot;Saving dimensions of &quot; &amp; nv.name &amp; &quot;: &quot; &amp; Fmt.Int(nv.x) &amp; &quot;,&quot;
            &amp; Fmt.Int(nv.y) &amp; &quot;,&quot; &amp; Fmt.Int(nv.width) &amp; &quot;,&quot;
            &amp; Fmt.Int(nv.height) &amp; &quot;\n&quot;);
    RW.wtext(s, nv.BgColor);
    RW.wtext(s, nv.FgColor);
    RW.wtext(s, nv.Font);
    RW.wcard(s, nv.Rim);
    RW.wcard(s, nv.Border);
    RW.wtext(s, nv.Embellishment);
    RW.wtext(s, nv.InitialState);
    RW.wbool(s, nv.Foreground);
    RW.wbool(s, nv.Local);
    RW.wtext(s, nv.Location);
    RW.wtext(s, nv.Code);
    RW.wtext(s, nv.ResizeModel);
    (* classIndex may change *)
  END Save;

PROCEDURE <A NAME="Load"><procedure>Load</procedure></A> (nv: T; &lt;*UNUSED*&gt;fv: FormsVBT.T; s: Rd.T) =
  BEGIN
    RW.rtuple(s, nv.partuple);
    RW.rtext(s, nv.name);
    RW.rint(s, nv.x);
    RW.rint(s, nv.y);
    RW.rint(s, nv.width);
    RW.rint(s, nv.height);
    print(&quot;Loading dimensions of &quot; &amp; nv.name &amp; &quot;: &quot; &amp; Fmt.Int(nv.x) &amp; &quot;,&quot;
            &amp; Fmt.Int(nv.y) &amp; &quot;,&quot; &amp; Fmt.Int(nv.width) &amp; &quot;,&quot;
            &amp; Fmt.Int(nv.height) &amp; &quot;\n&quot;);
    RW.rtext(s, nv.BgColor);
    RW.rtext(s, nv.FgColor);
    RW.rtext(s, nv.Font);
    RW.rcard(s, nv.Rim);
    RW.rcard(s, nv.Border);
    RW.rtext(s, nv.Embellishment);
    RW.rtext(s, nv.InitialState);
    RW.rbool(s, nv.Foreground);
    RW.rbool(s, nv.Local);
    RW.rtext(s, nv.Location);
    RW.rtext(s, nv.Code);
    RW.rtext(s, nv.ResizeModel);
    (* classIndex is set in LoadFromFile *)
    (* note parent hasn't been set yet - it is derived from nv.partuple *)
  END Load;

PROCEDURE <A NAME="SplitSave"><procedure>SplitSave</procedure></A> (nv: SplitNode; fv: FormsVBT.T; s: Wr.T) =
  BEGIN
    Save(nv, fv, s);
    RW.wcard(s, nv.nc);
    FOR i := 1 TO nv.nc DO RW.wtuple(s, RW.ptot(nv.children[i])) END;
  END SplitSave;

PROCEDURE <A NAME="SplitLoad"><procedure>SplitLoad</procedure></A> (nv: SplitNode; fv: FormsVBT.T; s: Rd.T) =
  BEGIN
    Load(nv, fv, s);
    RW.rcard(s, nv.nc);
    FOR i := 1 TO nv.nc DO RW.rtuple(s, nv.childtuples[i]) END;
  END SplitLoad;

PROCEDURE <A NAME="FormSave"><procedure>FormSave</procedure></A> (nv: FormNode; fv: FormsVBT.T; s: Wr.T) =
  BEGIN
    SplitSave(nv, fv, s);

    IF nv.HasMenu AND nv.Menu # NIL THEN
      RW.wbool(s, TRUE);
      RW.wtext(s, nv.MenuBgColor);
      RW.wtext(s, nv.MenuFgColor);
      RW.wtext(s, nv.MenuFont);
      RW.wcard(s, NUMBER(nv.Menu^));
      FOR i := FIRST(nv.Menu^) TO LAST(nv.Menu^) DO
        RW.wcard(s, nv.Menu[i].Level);
        RW.wtext(s, nv.Menu[i].Label);
        RW.wtext(s, nv.Menu[i].Name);
        RW.wbool(s, nv.Menu[i].inForeGround);
        RW.wbool(s, nv.Menu[i].isLocal);
        RW.wtext(s, nv.Menu[i].executeAt);
        RW.wtext(s, nv.Menu[i].initialState);
        RW.wtext(s, nv.Menu[i].callback);
      END;
    ELSE
      RW.wbool(s, FALSE)
    END;

    RW.wtuple(s, RW.ptot(nv.ParentForm));
    RW.wtext(s, nv.SupportCode);
    RW.wcard(s, nv.Screen);
    RW.wtext(s, nv.TitleBgColor);
    RW.wtext(s, nv.TitleFgColor);
    RW.wtext(s, nv.TitleString);
    RW.wcard(s, nv.StretchX);
    RW.wcard(s, nv.StretchY);
    RW.wcard(s, nv.ShrinkX);
    RW.wcard(s, nv.ShrinkY);
  END FormSave;

PROCEDURE <A NAME="FormLoad"><procedure>FormLoad</procedure></A> (nv: FormNode; fv: FormsVBT.T; s: Rd.T) =
  VAR menusize: CARDINAL;
  BEGIN
    SplitLoad(nv, fv, s);
    RW.rbool(s, nv.HasMenu);
    IF nv.HasMenu THEN
      RW.rtext(s, nv.MenuBgColor);
      RW.rtext(s, nv.MenuFgColor);
      RW.rtext(s, nv.MenuFont);
      RW.rcard(s, menusize);
      nv.Menu := NEW(REF ARRAY OF DialogMenu.T, menusize);
      FOR i := FIRST(nv.Menu^) TO LAST(nv.Menu^) DO
        RW.rcard(s, nv.Menu[i].Level);
        RW.rtext(s, nv.Menu[i].Label);
        RW.rtext(s, nv.Menu[i].Name);
        RW.rbool(s, nv.Menu[i].inForeGround);
        RW.rbool(s, nv.Menu[i].isLocal);
        RW.rtext(s, nv.Menu[i].executeAt);
        RW.rtext(s, nv.Menu[i].initialState);
        RW.rtext(s, nv.Menu[i].callback);
      END
    END;

    RW.rtuple(s, nv.Partuple);
    RW.rtext(s, nv.SupportCode);
    RW.rcard(s, nv.Screen);
    RW.rtext(s, nv.TitleBgColor);
    RW.rtext(s, nv.TitleFgColor);
    RW.rtext(s, nv.TitleString);
    RW.rcard(s, nv.StretchX);
    RW.rcard(s, nv.StretchY);
    RW.rcard(s, nv.ShrinkX);
    RW.rcard(s, nv.ShrinkY);
  END FormLoad;

PROCEDURE <A NAME="FormObAttrs"><procedure>FormObAttrs</procedure></A>(nv: FormNode) : TEXT =
  VAR ret := &quot;&quot;;
  BEGIN
    (* need to put in support for form-anchoring *)
    (* not clear where.. *)

    IF nv.ParentForm # NIL THEN
      ret := ret &amp; &quot;\ttemp.ParentForm := meth(s) VOInstance.&quot; &amp; nv.ParentForm.name &amp;
                 &quot; end;\n&quot;;
    END;

    IF nv.NoOfChildren &gt; 0 THEN
      ret := ret &amp; &quot;\ttemp.ChildForms := meth(s)  [&quot;;
      FOR i := 0 TO nv.NoOfChildren-1 DO
        ret := ret &amp; &quot; VOInstance.&quot; &amp; nv.ChildForms[i].name  &amp; &quot;,&quot;;
      END;
      ret := ret &amp; &quot;] end;\n&quot;;
    END;

   IF nv.HasMenu AND nv.Menu # NIL THEN
      ret := ret &amp; BoolAttr(&quot;HasMenu&quot;, TRUE) &amp;
      TextAttr(&quot;MenuBgColor&quot;, nv.MenuBgColor) &amp;
      TextAttr(&quot;MenuFgColor&quot;,  nv.MenuFgColor) &amp;
      TextAttr(&quot;MenuFont&quot;, nv.MenuFont);

      ret := ret &amp; &quot;\ttemp.Menu := meth(s)  [&quot;;
      FOR i := FIRST(nv.Menu^) TO LAST(nv.Menu^) DO
        IF nv.Menu[i].Level &gt; 0 OR NOT (Text.Equal(nv.Menu[i].Name, &quot;RIDGE&quot;)) THEN
          ret := ret &amp; &quot; VOInstance.&quot; &amp; nv.Menu[i].Name  &amp; &quot;,&quot;;
        END;
      END;
      ret := ret &amp; &quot;] end;\n&quot;;

    ELSE
      ret := ret &amp; BoolAttr(&quot;HasMenu&quot;, FALSE)
    END;

   ret := ret &amp; TextAttr(&quot;TitleBgColor&quot;, nv.TitleBgColor) &amp;
              TextAttr(&quot;TitleFgColor&quot;, nv.TitleFgColor) &amp;
              TextAttr(&quot;TitleString&quot;, nv.TitleString) &amp;
              IntAttr(&quot;StretchX&quot;, nv.StretchX) &amp;
              IntAttr(&quot;StretchY&quot;, nv.StretchY) &amp;
              IntAttr(&quot;ShrinkX&quot;, nv.ShrinkX) &amp;
              IntAttr(&quot;ShrinkY&quot;, nv.ShrinkY);

    RETURN SplitObAttrs(nv) &amp; ret;
  END FormObAttrs;

PROCEDURE <A NAME="GetInfo"><procedure>GetInfo</procedure></A>(topic:TEXT) : REF InfoDefn =
VAR
  volib : Rd.T;
  delimiterFound : CHAR;
  s, e : CARDINAL;
  signature : TEXT;
</PRE><BLOCKQUOTE><EM> Procedure that reads progressively down a file and finds
   comments of the form (* ... </EM></BLOCKQUOTE><PRE>. It then looks to see if there
   is delimiter from signset immediately  inside th comment.
   If so the contents minus any preceding/trailing blanks is
   returned and delimiterFound is set appropriately *)

PROCEDURE Find(c: CHAR) : BOOLEAN
RAISES {Rd.EndOfFile, Rd.Failure, Thread.Alerted} =
  BEGIN
    WITH got = Rd.GetChar(volib) DO
      IF got = c THEN
        RETURN TRUE;
      ELSE
        Rd.UnGetChar(volib);
        RETURN FALSE;
      END (* IF *)
    END (* WITH *)
  END Find;

PROCEDURE ParseCommentStart()
  RAISES {Rd.EndOfFile, Rd.Failure, Thread.Alerted} =
  BEGIN
    LOOP
      REPEAT
      UNTIL  Rd.GetChar(volib) = '(';
      IF Find('*') THEN RETURN;
      END (* IF *)
    END (* LOOP *)
  END ParseCommentStart;

PROCEDURE GetBodyOfComment():TEXT
  RAISES {Rd.EndOfFile, Rd.Failure, Thread.Alerted} =
  VAR
    current : CHAR;
    retval := &quot;&quot;;
  BEGIN
    LOOP
      current := Rd.GetChar(volib);
      WHILE  current # '*' DO
        retval := retval &amp; Text.FromChar(current);
        current := Rd.GetChar(volib);
      END;
      IF Find(')') THEN
        RETURN retval;
      ELSE
        retval := retval &amp; &quot;*&quot;;
      END (* IF *)
    END (* LOOP *)
  END GetBodyOfComment;

PROCEDURE GetNextSignature(signset : SET OF CHAR): TEXT =
  VAR comment: TEXT;
      ret_val : TEXT;
  BEGIN
    TRY

      LOOP
        ParseCommentStart();
        comment := GetBodyOfComment();

        (* is this a valid comment ? *)
        WITH
          f = Text.GetChar(comment, 0),
          l = Text.GetChar(comment, Text.Length(comment) -1)
         DO
          IF f IN signset AND f=l THEN

            delimiterFound := f;
            ret_val :=  Text.Sub(comment, 1,  Text.Length(comment) -2);
            EXIT;
          END (* IF *)
        END (* WITH *)
      END (* LOOP *);

      EXCEPT
      ELSE

        RETURN NIL;
      END (* TRY *);

    RETURN ret_val;

  END GetNextSignature;

BEGIN
   print(&quot;Getting Info on &quot; &amp; topic &amp; &quot;\n&quot;);
    IF NOT createdInfoList THEN
      (* index = 0 is for volib methods*)
      infoList[infoCtr] := NEW(REF InfoDefn, topic:=&quot;Local&quot;,
                              info:= &quot;\t\tMethods in the Visual Obliq Library\n&quot;
                                   &amp; &quot;\t\t***********************************\n\n&quot;);
      INC(infoCtr);

      (* open internal volib.obl *)
      TRY
        volib := Rsrc.Open(&quot;volib.obl&quot;, Dialog.rsrcPath);

      LOOP
        WITH sig = GetNextSignature(SET OF CHAR{'=',':','-'}) DO

          IF sig = NIL THEN
            EXIT;
          ELSE

            (* strip initial and final blanks *)
            s:= 0;    e := Text.Length(sig)-1;
            WHILE s&lt;= e DO
              IF NOT Text.GetChar(sig, s) IN  ASCII.Spaces THEN
                EXIT;
              ELSE
                INC(s);
              END;
            END;

            WHILE e &gt; s DO
              IF NOT Text.GetChar(sig, e) IN  ASCII.Spaces THEN
                EXIT;
              ELSE
                DEC(e);
              END;
            END;
            (* s and e delimit the actual string *)
            signature := Text.Sub(sig, s, e-s+1);

            CASE delimiterFound OF
              | '=' =&gt;
                  infoList[infoCtr] := NEW(REF InfoDefn, topic:= signature,
                  info:=&quot;\t\tMethods for &quot; &amp; signature &amp;  &quot;\n\n&quot;);
                    INC(infoCtr);

              | '-' =&gt;
                  infoList[infoCtr-1].info := infoList[infoCtr-1].info &amp; signature &amp; &quot;\n&quot;;

              | ':' =&gt;
                  infoList[0].info := infoList[0].info &amp; signature &amp; &quot;\n&quot;;
              ELSE
              END (* CASE *)
          END (* IF *)
        END (* WITH *)
      END (* LOOP *);
      Rd.Close(volib);
      createdInfoList := TRUE;

      EXCEPT ELSE
      END;
    END (* IF *);

    (* Lookup topic and return a reference to the  information record  *)
    FOR i:=0 TO infoCtr-1 DO
      IF Text.Equal(infoList[i].topic, topic) THEN
        RETURN infoList[i];
      END (* IF *)
    END (* FOR *);

    RETURN NIL;
END GetInfo;

PROCEDURE <A NAME="Initialize"><procedure>Initialize</procedure></A> () =
  BEGIN
    EVAL Register(&quot;form&quot;, FormConstructor);
    EVAL Register(&quot;frame&quot;, FrameConstructor);

    WITH menuclosure = NEW(FormsVBT.Closure, apply := MenuProc) DO
      (* attach menu design button and menu boolean *)
      FormsVBT.Attach(Attributes.afv, &quot;menuBoolean&quot;, menuclosure);
      FormsVBT.Attach(Attributes.afv, &quot;tomenu&quot;, menuclosure);
    END;

    WITH lrclosure = NEW(FormsVBT.Closure, apply := LRProc) DO
      (* attach local and remote choices *)
      FormsVBT.Attach(Attributes.afv, &quot;Local&quot;, lrclosure);
      FormsVBT.Attach(Attributes.afv, &quot;Remote&quot;, lrclosure);
    END;

    WITH colorclosure = NEW(
                          FormsVBT.Closure, apply := Attributes.ColorProc),
         anchorclosure = NEW(FormsVBT.Closure, apply := AnchorProc),
         parclosure    = NEW(FormsVBT.Closure, apply := ParentProc)  DO
      (* attach form-attribute sheet color-popup-helper-buttons *)
      FormsVBT.Attach(Attributes.afv, &quot;tbgc&quot;, colorclosure);
      FormsVBT.Attach(Attributes.afv, &quot;tfgc&quot;, colorclosure);

      (* attach anchor enable boolean *)
      FormsVBT.Attach(Attributes.afv, &quot;anchored&quot;, anchorclosure);
      (* attach browser selection *)
      FormsVBT.Attach(Attributes.afv, &quot;parentlist&quot;, parclosure);

    END;
  END Initialize;

BEGIN
END NodeVBT.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
