<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: m3core/src/thread/PTHREAD/ThreadPThread.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>m3core/src/thread/PTHREAD/ThreadPThread.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright (C) 2005, Purdue Research Foundation                  
 All rights reserved.                                            
 See the file COPYRIGHT-PURDUE for a full description.           

<P><PRE>UNSAFE MODULE <module>ThreadPThread</module> EXPORTS <A HREF="../Common/Thread.i3.html"><implements>Thread</A></implements>, <A HREF="#x1"><implements>ThreadF</A></implements>, <A HREF="#x2"><implements>RTThread</A></implements>,
<A HREF="../Common/Scheduler.i3.html"><implements>Scheduler</A></implements>, <A HREF="../Common/SchedulerPosix.i3.html"><implements>SchedulerPosix</A></implements>, <A HREF="../../runtime/common/RTOS.i3.html"><implements>RTOS</A></implements>, <A HREF="../../runtime/common/RTHooks.i3.html"><implements>RTHooks</A></implements>, <A HREF="ThreadPThread.i3.html"><implements>ThreadPThread</A></implements>;

IMPORT <A HREF="../../C/Common/Cerrno.i3.html">Cerrno</A>, <A HREF="../../float/IEEE-default/FloatMode.i3.html">FloatMode</A>, <A HREF="../Common/MutexRep.i3.html">MutexRep</A>,
       <A HREF="../../runtime/common/RTCollectorSRC.i3.html">RTCollectorSRC</A>, <A HREF="../../runtime/common/RTError.i3.html">RTError</A>, <A HREF="../../runtime/common/RTHeapRep.i3.html">RTHeapRep</A>, <A HREF="../../runtime/common/RTIO.i3.html">RTIO</A>, <A HREF="../../runtime/common/RTParams.i3.html">RTParams</A>,
       <A HREF="../../runtime/POSIX/RTPerfTool.i3.html">RTPerfTool</A>, <A HREF="../../runtime/common/RTProcess.i3.html">RTProcess</A>, <A HREF="../Common/Thread.i3.html">Thread</A>, <A HREF="../Common/ThreadEvent.i3.html">ThreadEvent</A>, <A HREF="../../time/Common/Time.i3.html">Time</A>,
       <A HREF="#x3">Unix</A>, <A HREF="#x4">Utime</A>, <A HREF="../../word/Word.i3.html">Word</A>, <A HREF="#x5">Usched</A>,
       <A HREF="#x6">Uerror</A>, <A HREF="#x7">Uexec</A>;
FROM <A HREF="../../../derived/Compiler.i3.html">Compiler</A> IMPORT ThisFile, ThisLine;
FROM <A HREF="../../C/Common/Ctypes.i3.html">Ctypes</A> IMPORT int;
IMPORT <A HREF="../../runtime/common/RuntimeError.i3.html">RuntimeError</A> AS RTE;
</PRE>----------------------------------------------------- types and globals ---

<P><PRE>CONST
  WAIT_UNIT = 1000000; (* one million nanoseconds, one thousandth of a second *)
  RETRY_INTERVAL = 10000000; (* 10 million nanoseconds, one hundredth of a second *)

REVEAL
  <A NAME="Mutex">Mutex</A> = MutexRep.Public BRANDED &quot;Mutex Pthread-1.0&quot; OBJECT
    mutex: pthread_mutex_t := NIL;
  OVERRIDES
    acquire := LockMutex;
    release := UnlockMutex;
  END;

  <A NAME="Condition">Condition</A> = BRANDED &quot;Thread.Condition Pthread-1.0&quot; OBJECT
    mutex: pthread_mutex_t := NIL;
    waiters: Activation := NIL;     (* LL = mutex *)
  END;

  <A NAME="T">T</A> = BRANDED &quot;Thread.T Pthread-1.6&quot; OBJECT
    act: Activation := NIL;         (* live untraced thread data *)
    closure: Closure := NIL;        (* our work and its result *)
    result: REFANY := NIL;          (* our work and its result *)
    join: Condition;                (* wait here to join; NIL when done *)
    joined: BOOLEAN := FALSE;       (* Is anyone waiting yet? *)
  END;

TYPE
  ActState = { Starting, Started, Stopping, Stopped };
  REVEAL <A NAME="Activation">Activation</A> = UNTRACED BRANDED REF RECORD
    frame: ADDRESS := NIL;              (* exception handling support *)
    mutex: pthread_mutex_t := NIL;      (* write-once in CreateT *)
    cond: pthread_cond_t := NIL;        (* write-once in CreateT; a place to park while waiting *)
    alerted : BOOLEAN := FALSE;         (* LL = mutex; the alert flag *)
    waitingOn: pthread_mutex_t := NIL;  (* LL = mutex; The CV's mutex *)
    nextWaiter: Activation := NIL;      (* LL = mutex; waiting thread queue *)
    next, prev: Activation := NIL;      (* LL = activeMu; global doubly-linked, circular list of all active threads *)
    handle: pthread_t := NIL;           (* LL = activeMu; thread handle *)
    stackbase: ADDRESS := NIL;          (* LL = activeMu; stack base for GC *)
    context: ADDRESS := NIL;            (* LL = activeMu *)
    state := ActState.Started;          (* LL = activeMu *)
    slot: INTEGER;                      (* LL = slotMu; index in slots *)
    floatState : FloatMode.ThreadState; (* per-thread floating point state *)
    heapState : RTHeapRep.ThreadState;  (* per-thread heap state *)
  END;

PROCEDURE <A NAME="SetState"><procedure>SetState</procedure></A> (act: Activation;  state: ActState) =
  CONST text = ARRAY ActState OF TEXT
    { &quot;Starting&quot;, &quot;Started&quot;, &quot;Stopping&quot;, &quot;Stopped&quot; };
  BEGIN
    act.state := state;
    IF DEBUG THEN
      RTIO.PutText(text[state]);
      RTIO.PutText(&quot; act=&quot;);
      RTIO.PutAddr(act);
      RTIO.PutText(&quot;\n&quot;);
      RTIO.Flush();
    END;
  END SetState;
</PRE>----------------------------------------------------------------- Mutex ---
         
<P><PRE>PROCEDURE <A NAME="Acquire"><procedure>Acquire</procedure></A> (m: Mutex) =
  BEGIN
    m.acquire ();
  END Acquire;

PROCEDURE <A NAME="Release"><procedure>Release</procedure></A> (m: Mutex) =
  BEGIN
    m.release ();
  END Release;

PROCEDURE <A NAME="CleanMutex"><procedure>CleanMutex</procedure></A> (r: REFANY) =
  VAR m := NARROW(r, Mutex);
  BEGIN
    pthread_mutex_delete(m.mutex);
    m.mutex := NIL;
  END CleanMutex;

PROCEDURE <A NAME="InitMutex"><procedure>InitMutex</procedure></A> (VAR m: pthread_mutex_t; root: REFANY;
                     Clean: PROCEDURE(root: REFANY)) =
  VAR mutex := pthread_mutex_new();
  BEGIN
    WITH r = pthread_mutex_lock(initMu) DO &lt;*ASSERT r=0*&gt; END;
    IF m = NIL THEN (* We won the race. *)
      IF mutex = NIL THEN (* But we failed. *)
        WITH r = pthread_mutex_unlock(initMu) DO &lt;*ASSERT r=0*&gt; END;
        RTE.Raise (RTE.T.OutOfMemory);
      ELSE (* We won the race and succeeded. *)
        m := mutex;
        WITH r = pthread_mutex_unlock(initMu) DO &lt;*ASSERT r=0*&gt; END;
        RTHeapRep.RegisterFinalCleanup (root, Clean);
      END;
    ELSE (* another thread beat us in the race, ok *)
      WITH r = pthread_mutex_unlock(initMu) DO &lt;*ASSERT r=0*&gt; END;
      pthread_mutex_delete(mutex);
    END;
  END InitMutex;

PROCEDURE <A NAME="LockMutex"><procedure>LockMutex</procedure></A> (m: Mutex) =
  BEGIN
    IF m.mutex = NIL THEN InitMutex(m.mutex, m, CleanMutex) END;
    IF perfOn THEN PerfChanged(State.locking) END;
    WITH r = pthread_mutex_lock(m.mutex) DO
      IF r # 0 THEN DieI(ThisLine(), r) END;
    END;
    IF perfOn THEN PerfRunning() END;
  END LockMutex;

PROCEDURE <A NAME="UnlockMutex"><procedure>UnlockMutex</procedure></A> (m: Mutex) =
  (* LL = m *)
  BEGIN
    IF m.mutex = NIL THEN InitMutex(m.mutex, m, CleanMutex) END;
    WITH r = pthread_mutex_unlock(m.mutex) DO
      IF r # 0 THEN DieI(ThisLine(), r) END;
    END;
  END UnlockMutex;
</PRE>---------------------------------------- Condition variables and Alerts ---

<P><PRE>PROCEDURE <A NAME="CleanCondition"><procedure>CleanCondition</procedure></A> (r: REFANY) =
  VAR c := NARROW(r, Condition);
  BEGIN
    pthread_mutex_delete(c.mutex);
    c.mutex := NIL;
  END CleanCondition;

PROCEDURE <A NAME="XWait"><procedure>XWait</procedure></A> (self: Activation; m: Mutex; c: Condition; alertable: BOOLEAN)
  RAISES {Alerted} =
  (* LL = m *)
  VAR next, prev: Activation;
  BEGIN
    IF c.mutex = NIL THEN InitMutex(c.mutex, c, CleanCondition) END;
    WITH r = pthread_mutex_lock(self.mutex) DO &lt;*ASSERT r=0*&gt; END;
    &lt;*ASSERT self.waitingOn = NIL*&gt;
    &lt;*ASSERT self.nextWaiter = NIL*&gt;

    WITH r = pthread_mutex_lock(c.mutex) DO &lt;*ASSERT r=0*&gt; END;
    self.waitingOn := c.mutex;
    self.nextWaiter := c.waiters;
    c.waiters := self;
    WITH r = pthread_mutex_unlock(c.mutex) DO &lt;*ASSERT r=0*&gt; END;

    m.release();
    IF perfOn THEN PerfChanged(State.waiting) END;
    LOOP
      IF alertable AND self.alerted THEN
        self.alerted := FALSE;
        &lt;*ASSERT self.waitingOn = c.mutex*&gt;
        WITH r = pthread_mutex_lock(c.mutex) DO &lt;*ASSERT r=0*&gt; END;
        next := c.waiters; prev := NIL;
        WHILE next # self DO
          &lt;*ASSERT next # NIL*&gt;
          prev := next; next := next.nextWaiter;
        END;
        IF prev = NIL
          THEN c.waiters := self.nextWaiter;
          ELSE prev.nextWaiter := self.nextWaiter;
        END;
        WITH r = pthread_mutex_unlock(c.mutex) DO &lt;*ASSERT r=0*&gt; END;
        self.nextWaiter := NIL;
        self.waitingOn := NIL;
        WITH r = pthread_mutex_unlock(self.mutex) DO &lt;*ASSERT r=0*&gt; END;
        m.acquire();
        RAISE Alerted;
      END;
      WITH r = pthread_cond_wait(self.cond, self.mutex) DO &lt;*ASSERT r=0*&gt; END;
      IF self.waitingOn = NIL THEN
        &lt;*ASSERT self.nextWaiter = NIL*&gt;
        WITH r = pthread_mutex_unlock(self.mutex) DO &lt;*ASSERT r=0*&gt; END;
        m.acquire();
        RETURN;
      END;
    END;
  END XWait;

PROCEDURE <A NAME="AlertWait"><procedure>AlertWait</procedure></A> (m: Mutex; c: Condition) RAISES {Alerted} =
  (* LL = m *)
  BEGIN
    XWait(GetActivation(), m, c, alertable := TRUE);
  END AlertWait;

PROCEDURE <A NAME="Wait"><procedure>Wait</procedure></A> (m: Mutex; c: Condition) =
  &lt;*FATAL Alerted*&gt;
  (* LL = m *)
  VAR self := GetActivation();
  BEGIN
    XWait(self, m, c, alertable := FALSE);
  END Wait;

PROCEDURE <A NAME="DequeueHead"><procedure>DequeueHead</procedure></A>(c: Condition) =
  (* LL = c *)
  VAR t := c.waiters;
  BEGIN
    WITH r = pthread_mutex_lock(t.mutex) DO &lt;*ASSERT r=0*&gt; END;
    c.waiters := t.nextWaiter;
    t.nextWaiter := NIL;
    t.waitingOn := NIL;
    WITH r = pthread_cond_signal(t.cond) DO &lt;*ASSERT r=0*&gt; END;
    WITH r = pthread_mutex_unlock(t.mutex) DO &lt;*ASSERT r=0*&gt; END;
  END DequeueHead;

PROCEDURE <A NAME="Signal"><procedure>Signal</procedure></A> (c: Condition) =
  BEGIN
    IF c.mutex = NIL THEN InitMutex(c.mutex, c, CleanCondition) END;
    WITH r = pthread_mutex_lock(c.mutex) DO &lt;*ASSERT r=0*&gt; END;
    IF c.waiters # NIL THEN DequeueHead(c) END;
    WITH r = pthread_mutex_unlock(c.mutex) DO &lt;*ASSERT r=0*&gt; END;
  END Signal;

PROCEDURE <A NAME="Broadcast"><procedure>Broadcast</procedure></A> (c: Condition) =
  BEGIN
    IF c.mutex = NIL THEN InitMutex(c.mutex, c, CleanCondition) END;
    WITH r = pthread_mutex_lock(c.mutex) DO &lt;*ASSERT r=0*&gt; END;
    WHILE c.waiters # NIL DO DequeueHead(c) END;
    WITH r = pthread_mutex_unlock(c.mutex) DO &lt;*ASSERT r=0*&gt; END;
  END Broadcast;

PROCEDURE <A NAME="Alert"><procedure>Alert</procedure></A> (thread: T) =
  VAR t := thread.act;
  BEGIN
    WITH r = pthread_mutex_lock(t.mutex) DO &lt;*ASSERT r=0*&gt; END;
    t.alerted := TRUE;
    WITH r = pthread_cond_signal(t.cond) DO &lt;*ASSERT r=0*&gt; END;
    WITH r = pthread_mutex_unlock(t.mutex) DO &lt;*ASSERT r=0*&gt; END;
  END Alert;

PROCEDURE <A NAME="XTestAlert"><procedure>XTestAlert</procedure></A> (self: Activation): BOOLEAN =
  VAR result: BOOLEAN;
  BEGIN
    WITH r = pthread_mutex_lock(self.mutex) DO &lt;*ASSERT r=0*&gt; END;
    result := self.alerted;
    self.alerted := FALSE;
    WITH r = pthread_mutex_unlock(self.mutex) DO &lt;*ASSERT r=0*&gt; END;
    RETURN result;
  END XTestAlert;

PROCEDURE <A NAME="TestAlert"><procedure>TestAlert</procedure></A> (): BOOLEAN =
  VAR self := GetActivation();
  BEGIN
    RETURN XTestAlert(self);
  END TestAlert;
</PRE>------------------------------------------------------------------ Self ---

<P><PRE>VAR (* LL = slotMu *)
  n_slotted := 0;
  next_slot := 1;
  slots: REF ARRAY OF T;    (* NOTE: we don't use slots[0] *)

PROCEDURE <A NAME="InitActivations"><procedure>InitActivations</procedure></A> (): Activation =
  VAR me := NEW(Activation);
  BEGIN
    me.handle := pthread_self();
    me.next := me;
    me.prev := me;
    SetActivation(me);
    (* Explicitly (re)initialize to handle fork(). *)
    next_slot := 1;     (* no threads created yet *)
    slots := NIL;       (* no threads created yet *)
    n_slotted := 0;     (* no threads created yet *)
    allThreads := me;
    FloatMode.InitThread(me.floatState);
    RETURN me;
  END InitActivations;

PROCEDURE <A NAME="Self"><procedure>Self</procedure></A> (): T =
  (* If not the initial thread and not created by Fork, returns NIL *)
  VAR
    me := GetActivation();
    t: T;
  BEGIN
    IF me = NIL THEN Die(ThisLine(), &quot;Thread primitive called from non-Modula-3 thread&quot;) END;
    WITH r = pthread_mutex_lock(slotsMu) DO &lt;*ASSERT r=0*&gt; END;
      t := slots[me.slot];
    WITH r = pthread_mutex_unlock(slotsMu) DO &lt;*ASSERT r=0*&gt; END;
    IF (t.act # me) THEN Die(ThisLine(), &quot;thread with bad slot!&quot;) END;
    RETURN t;
  END Self;

PROCEDURE <A NAME="AssignSlot"><procedure>AssignSlot</procedure></A> (t: T) =
  (* LL = 0, cause we allocate stuff with NEW! *)
  VAR n: CARDINAL;  new_slots: REF ARRAY OF T;
  BEGIN
    WITH r = pthread_mutex_lock(slotsMu) DO &lt;*ASSERT r=0*&gt; END;

      (* make sure we have room to register this guy *)
      IF (slots = NIL) THEN
        WITH r = pthread_mutex_unlock(slotsMu) DO &lt;*ASSERT r=0*&gt; END;
          slots := NEW (REF ARRAY OF T, 20);
        WITH r = pthread_mutex_lock(slotsMu) DO &lt;*ASSERT r=0*&gt; END;
      END;
      IF (n_slotted &gt;= LAST (slots^)) THEN
        n := NUMBER (slots^);
        WITH r = pthread_mutex_unlock(slotsMu) DO &lt;*ASSERT r=0*&gt; END;
          new_slots := NEW (REF ARRAY OF T, n+n);
        WITH r = pthread_mutex_lock(slotsMu) DO &lt;*ASSERT r=0*&gt; END;
        IF (n = NUMBER (slots^)) THEN
          (* we won any races that may have occurred. *)
          SUBARRAY (new_slots^, 0, n) := slots^;
          slots := new_slots;
        ELSIF (n_slotted &lt; LAST (slots^)) THEN
          (* we lost a race while allocating a new slot table,
             and the new table has room for us. *)
        ELSE
          (* ouch, the new table is full too!   Bail out and retry *)
          WITH r = pthread_mutex_unlock(slotsMu) DO &lt;*ASSERT r=0*&gt; END;
          AssignSlot (t);
          RETURN;
        END;
      END;

      (* look for an empty slot *)
      WHILE (slots [next_slot] # NIL) DO
        INC (next_slot);
        IF (next_slot &gt;= NUMBER (slots^)) THEN next_slot := 1; END;
      END;

      INC (n_slotted);
      t.act.slot := next_slot;
      slots [next_slot] := t;

    WITH r = pthread_mutex_unlock(slotsMu) DO &lt;*ASSERT r=0*&gt; END;
  END AssignSlot;

PROCEDURE <A NAME="FreeSlot"><procedure>FreeSlot</procedure></A> (t: T; act: Activation) =
  (* LL = 0 *)
  BEGIN
    WITH r = pthread_mutex_lock(slotsMu) DO &lt;*ASSERT r=0*&gt; END;

      DEC (n_slotted);
      WITH z = slots [act.slot] DO
        IF z # t THEN Die (ThisLine(), &quot;unslotted thread!&quot;); END;
        z := NIL;
      END;
      t := NIL; (* drop traced reference *)
      act.slot := 0;

    WITH r = pthread_mutex_unlock(slotsMu) DO &lt;*ASSERT r=0*&gt; END;
  END FreeSlot;

PROCEDURE <A NAME="DumpThread"><procedure>DumpThread</procedure></A> (t: Activation) =
  BEGIN
    RTIO.PutText(&quot;Activation:   &quot;); RTIO.PutAddr(t);             RTIO.PutChar('\n');
    RTIO.PutText(&quot;  slot:       &quot;); RTIO.PutInt(t.slot);         RTIO.PutChar('\n');
    RTIO.PutText(&quot;  mutex:      &quot;); RTIO.PutAddr(t.mutex);       RTIO.PutChar('\n');
    RTIO.PutText(&quot;  cond:       &quot;); RTIO.PutAddr(t.cond);        RTIO.PutChar('\n');
    RTIO.PutText(&quot;  alerted:    &quot;); RTIO.PutInt(ORD(t.alerted)); RTIO.PutChar('\n');
    RTIO.PutText(&quot;  waitingOn:  &quot;); RTIO.PutAddr(t.waitingOn);   RTIO.PutChar('\n');
    RTIO.PutText(&quot;  nextWaiter: &quot;); RTIO.PutAddr(t.nextWaiter);  RTIO.PutChar('\n');
    RTIO.PutText(&quot;  frame:      &quot;); RTIO.PutAddr(t.frame);       RTIO.PutChar('\n');
    RTIO.PutText(&quot;  next:       &quot;); RTIO.PutAddr(t.next);        RTIO.PutChar('\n');
    RTIO.PutText(&quot;  prev:       &quot;); RTIO.PutAddr(t.prev);        RTIO.PutChar('\n');
    RTIO.PutText(&quot;  handle:     &quot;); RTIO.PutAddr(t.handle);      RTIO.PutChar('\n');
    RTIO.PutText(&quot;  stackbase:  &quot;); RTIO.PutAddr(t.stackbase);   RTIO.PutChar('\n');
    RTIO.PutText(&quot;  context:    &quot;); RTIO.PutAddr(t.context);     RTIO.PutChar('\n');
    RTIO.PutText(&quot;  state:      &quot;);
    CASE t.state OF
    | ActState.Started =&gt; RTIO.PutText(&quot;Started\n&quot;);
    | ActState.Stopped =&gt; RTIO.PutText(&quot;Stopped\n&quot;);
    | ActState.Starting =&gt; RTIO.PutText(&quot;Starting\n&quot;);
    | ActState.Stopping =&gt; RTIO.PutText(&quot;Stopping\n&quot;);
    END;
    RTIO.Flush();
  END DumpThread;

PROCEDURE <A NAME="DumpThreads"><procedure>DumpThreads</procedure></A> () =
  VAR t := allThreads;
  BEGIN
    REPEAT
      DumpThread(t);
      t := t.next
    UNTIL t = allThreads;
  END DumpThreads;
</PRE>------------------------------------------------------------ Fork, Join ---

<P><PRE>VAR (* LL=activeMu *)
  allThreads: Activation := NIL;            (* global list of active threads *)

PROCEDURE <A NAME="CleanThread"><procedure>CleanThread</procedure></A> (r: REFANY) =
  VAR t := NARROW(r, T);
  BEGIN
    pthread_mutex_delete(t.act.mutex);
    pthread_cond_delete(t.act.cond);
    DISPOSE(t.act);
  END CleanThread;

PROCEDURE <A NAME="CreateT"><procedure>CreateT</procedure></A> (act: Activation): T =
  (* LL = 0, because allocating a traced reference may cause
     the allocator to start a collection which will call &quot;SuspendOthers&quot;
     which will try to acquire &quot;activeMu&quot;. *)
  VAR
    t := NEW(T, act := act);
    mutex := pthread_mutex_new();
    cond := pthread_cond_new();
  BEGIN
    IF (mutex = NIL) OR (cond = NIL) THEN
      pthread_mutex_delete(mutex);
      pthread_cond_delete(cond);
      RTE.Raise(RTE.T.OutOfMemory);
    END;
    act.mutex := mutex;
    act.cond := cond;
    RTHeapRep.RegisterFinalCleanup (t, CleanThread);
    t.join := NEW(Condition);
    AssignSlot (t);
    RETURN t;
  END CreateT;
</PRE> ThreadBase calls RunThread after finding (approximately) where
   its stack begins.  This dance ensures that all of ThreadMain's
   traced references are within the stack scanned by the collector. 

<P><PRE>PROCEDURE <A NAME="ThreadBase"><procedure>ThreadBase</procedure></A> (param: ADDRESS): ADDRESS =
  VAR me: Activation := param;
  BEGIN
    SetActivation(me);
    me.stackbase := ADR(me); (* enable GC scanning of this stack *)
    me.handle := pthread_self();

    (* add to the list of active threads *)
    WITH r = pthread_mutex_lock(activeMu) DO &lt;*ASSERT r=0*&gt; END;
      me.next := allThreads;
      me.prev := allThreads.prev;
      allThreads.prev.next := me;
      allThreads.prev := me;
    WITH r = pthread_mutex_unlock(activeMu) DO &lt;*ASSERT r=0*&gt; END;
    FloatMode.InitThread (me.floatState);

    RunThread(me);

    me.stackbase := NIL; (* disable GC scanning of my stack *)

    (* remove from the list of active threads *)
    WITH r = pthread_mutex_lock(activeMu) DO &lt;*ASSERT r=0*&gt; END;
      &lt;*ASSERT allThreads # me*&gt;
      me.next.prev := me.prev;
      me.prev.next := me.next;
      WITH r = pthread_detach_self() DO &lt;*ASSERT r=0*&gt; END;
    WITH r = pthread_mutex_unlock(activeMu) DO &lt;*ASSERT r=0*&gt; END;
    me.next := NIL;
    me.prev := NIL;
    RETURN NIL;
  END ThreadBase;

PROCEDURE <A NAME="RunThread"><procedure>RunThread</procedure></A> (me: Activation) =
  VAR self: T;
  BEGIN
    IF perfOn THEN PerfChanged(State.alive) END;

    WITH r = pthread_mutex_lock(slotsMu) DO &lt;*ASSERT r=0*&gt; END;
      self := slots [me.slot];
    WITH r = pthread_mutex_unlock(slotsMu) DO &lt;*ASSERT r=0*&gt; END;

    IF perfOn THEN PerfRunning() END;

    (*** Run the user-level code. ***)
    self.result := self.closure.apply();

    IF perfOn THEN PerfChanged(State.dying) END;

    (* Join *)
    LOCK joinMu DO
      Broadcast(self.join);
      self.join := NIL;     (* mark me done *)
    END;

    IF perfOn THEN PerfChanged(State.dead) END;

    (* we're dying *)
    RTHeapRep.FlushThreadState(me.heapState);

    IF perfOn THEN PerfDeleted() END;
    FreeSlot(self, me);
    (* Since we're no longer slotted, we cannot touch traced refs. *)
    self := NIL; (* drop traced reference *)
  END RunThread;

VAR joinMu: MUTEX;

PROCEDURE <A NAME="Fork"><procedure>Fork</procedure></A> (closure: Closure): T =
  VAR
    act := NEW(Activation);
    t := CreateT(act);
    size := defaultStackSize;
  BEGIN
    t.closure := closure;
    (* determine the initial size of the stack for this thread *)
    TYPECASE closure OF
    | SizedClosure (scl) =&gt; size := scl.stackSize;
    ELSE (*skip*)
    END;
    WITH r = thread_create(size * ADRSIZE(Word.T), ThreadBase, act) DO
      IF r # 0 THEN DieI(ThisLine(), r) END;
    END;
    RETURN t;
  END Fork;

PROCEDURE <A NAME="XJoin"><procedure>XJoin</procedure></A> (self: Activation; t: T; alertable: BOOLEAN):
  REFANY RAISES {Alerted} =
  BEGIN
    LOCK joinMu DO
      IF t.joined THEN Die(ThisLine(), &quot;attempt to join with thread twice&quot;) END;
      TRY
        t.joined := TRUE;
        WHILE t.join # NIL DO XWait(self, joinMu, t.join, alertable) END;
      FINALLY
        IF t.join # NIL THEN t.joined := FALSE END;
      END;
    END;
    RETURN t.result;
  END XJoin;

PROCEDURE <A NAME="Join"><procedure>Join</procedure></A> (t: T): REFANY =
  &lt;*FATAL Alerted*&gt;
  VAR self := GetActivation();
  BEGIN
    RETURN XJoin(self, t, alertable := FALSE);
  END Join;

PROCEDURE <A NAME="AlertJoin"><procedure>AlertJoin</procedure></A> (t: T): REFANY RAISES {Alerted} =
  VAR self := GetActivation();
  BEGIN
    RETURN XJoin(self, t, alertable := TRUE);
  END AlertJoin;
</PRE>---------------------------------------------------- Scheduling support ---

<P><PRE>PROCEDURE <A NAME="CommonSleep"><procedure>CommonSleep</procedure></A>() =
  VAR wait, remaining: Utime.struct_timespec;
  BEGIN
    wait.tv_sec := 0;
    wait.tv_nsec := WAIT_UNIT;
    WHILE Nanosleep(wait, remaining) # 0 DO
      wait := remaining;
    END;
  END CommonSleep;

PROCEDURE <A NAME="ToNTime"><procedure>ToNTime</procedure></A> (n: LONGREAL; VAR ts: Utime.struct_timespec) =
  BEGIN
    ts.tv_sec := TRUNC(n);
    ts.tv_nsec := ROUND((n - FLOAT(ts.tv_sec, LONGREAL)) * 1.0D9);
  END ToNTime;

PROCEDURE <A NAME="XPause"><procedure>XPause</procedure></A> (self: Activation; n: LONGREAL; alertable: BOOLEAN)
  RAISES {Alerted} =
  VAR until: Utime.struct_timespec;
  BEGIN
    IF n &lt;= 0.0d0 THEN RETURN END;
    ToNTime(Time.Now() + n, until);
    IF perfOn THEN PerfChanged(State.pausing) END;
    WITH r = pthread_mutex_lock(self.mutex) DO &lt;*ASSERT r=0*&gt; END;
    &lt;*ASSERT self.waitingOn = NIL*&gt;
    &lt;*ASSERT self.nextWaiter = NIL*&gt;

    LOOP
      IF alertable AND self.alerted THEN
        self.alerted := FALSE;
        WITH r = pthread_mutex_unlock(self.mutex) DO &lt;*ASSERT r=0*&gt; END;
        IF perfOn THEN PerfRunning() END;
        RAISE Alerted;
      END;
      WITH r = pthread_cond_timedwait(self.cond, self.mutex, until) DO
        IF r = Uerror.ETIMEDOUT THEN
          WITH r = pthread_mutex_unlock(self.mutex) DO &lt;*ASSERT r=0*&gt; END;
          IF perfOn THEN PerfRunning() END;
          RETURN;
        END;
        &lt;*ASSERT r=0*&gt;
      END;
    END;
  END XPause;

PROCEDURE <A NAME="Pause"><procedure>Pause</procedure></A> (n: LONGREAL) =
  &lt;*FATAL Alerted*&gt;
  VAR self := GetActivation();
  BEGIN
    XPause(self, n, alertable := FALSE);
  END Pause;

PROCEDURE <A NAME="AlertPause"><procedure>AlertPause</procedure></A> (n: LONGREAL) RAISES {Alerted} =
  VAR self := GetActivation();
  BEGIN
    XPause(self, n, alertable := TRUE);
  END AlertPause;

PROCEDURE <A NAME="Yield"><procedure>Yield</procedure></A> () =
  BEGIN
    WITH r = Usched.yield() DO
      IF r # 0 THEN DieI(ThisLine(), Cerrno.GetErrno()) END;
    END;
  END Yield;

CONST FDSetSize = BITSIZE(INTEGER);

TYPE
  FDSet = SET OF [0 .. FDSetSize-1];
  FDS = REF ARRAY OF FDSet;

PROCEDURE <A NAME="IOWait"><procedure>IOWait</procedure></A> (fd: CARDINAL; read: BOOLEAN;
                  timeoutInterval: LONGREAL := -1.0D0): WaitResult =
  &lt;*FATAL Alerted*&gt;
  VAR self := GetActivation();
  BEGIN
    TRY
      IF perfOn THEN PerfChanged(State.blocking) END;
      RETURN XIOWait(self, fd, read, timeoutInterval, alertable := FALSE);
    FINALLY
      IF perfOn THEN PerfRunning() END;
    END;
  END IOWait;

PROCEDURE <A NAME="IOAlertWait"><procedure>IOAlertWait</procedure></A> (fd: CARDINAL; read: BOOLEAN;
                       timeoutInterval: LONGREAL := -1.0D0): WaitResult
  RAISES {Alerted} =
  VAR self := GetActivation();
  BEGIN
    TRY
      IF perfOn THEN PerfChanged(State.blocking) END;
      RETURN XIOWait(self, fd, read, timeoutInterval, alertable := TRUE);
    FINALLY
      IF perfOn THEN PerfRunning() END;
    END;
  END IOAlertWait;

PROCEDURE <A NAME="XIOWait"><procedure>XIOWait</procedure></A> (self: Activation; fd: CARDINAL; read: BOOLEAN; interval: LONGREAL;
                   alertable: BOOLEAN): WaitResult
  RAISES {Alerted} =
  VAR
    res: INTEGER;
    fdindex := fd DIV FDSetSize;
    fdset := FDSet{fd MOD FDSetSize};
    gReadFDS, gWriteFDS, gExceptFDS: FDS := NEW(FDS, fdindex+1);
    subInterval: LONGREAL := 1.0d0;

  PROCEDURE TestFDS (index: CARDINAL; set: FDSet; read: BOOLEAN): WaitResult =
    BEGIN
      IF (set * gExceptFDS[index]) # FDSet{} THEN
        IF read THEN
          IF (set * gReadFDS[index]) # FDSet{} THEN
            RETURN WaitResult.Ready;
          END;
          IF (set * gWriteFDS[index]) = FDSet{} THEN
            RETURN WaitResult.FDError;
          END;
        ELSE
          IF (set * gWriteFDS[index]) # FDSet{} THEN
            RETURN WaitResult.Ready;
          END;
          IF (set * gReadFDS[index]) = FDSet{} THEN
            RETURN WaitResult.FDError;
          END;
        END;
      END;
      RETURN WaitResult.Timeout;
    END TestFDS;

  PROCEDURE CallSelect (nfd: CARDINAL; timeout: UNTRACED REF UTime): INTEGER =
    TYPE FDSPtr = UNTRACED REF Unix.FDSet;
    VAR res: INTEGER;
    BEGIN
      FOR i := 0 TO fdindex DO
        gExceptFDS[i] := gReadFDS[i] + gWriteFDS[i];
      END;
      res := Unix.select(nfd,
                         LOOPHOLE (ADR(gReadFDS[0]), FDSPtr),
                         LOOPHOLE (ADR(gWriteFDS[0]), FDSPtr),
                         LOOPHOLE (ADR(gExceptFDS[0]), FDSPtr),
                         timeout);
      IF res &gt; 0 THEN
        FOR i := 0 TO fdindex DO
          gExceptFDS[i] := gExceptFDS[i] + gReadFDS[i] + gWriteFDS[i];
        END;
      END;
      RETURN res;
    END CallSelect;

  BEGIN
    IF NOT alertable THEN
      subInterval := interval;
    ELSIF interval &lt; 0.0d0 THEN
      interval := LAST(LONGREAL);
    ELSIF interval &lt; subInterval THEN
      subInterval := interval;
    END;

    IF alertable AND XTestAlert(self) THEN RAISE Alerted END;
    LOOP
      FOR i := 0 TO fdindex-1 DO
        gReadFDS[i] := FDSet{};
        gWriteFDS[i] := FDSet{};
      END;
      IF read
        THEN gReadFDS[fdindex] := fdset;
        ELSE gWriteFDS[fdindex] := fdset;
      END;

      IF subInterval &gt;= 0.0D0 THEN
        VAR utimeout := UTimeFromTime(subInterval);
        BEGIN
          res := CallSelect(fd+1, ADR(utimeout));
        END;
      ELSE
        res := CallSelect(fd+1, NIL);
      END;

      IF alertable AND XTestAlert(self) THEN RAISE Alerted END;

      IF    res &gt; 0 THEN RETURN TestFDS(fdindex, fdset, read);
      ELSIF res = 0 THEN
        interval := interval - subInterval;
        IF interval &lt;= 0.0d0 THEN RETURN WaitResult.Timeout END;
        IF interval &lt; subInterval THEN
          subInterval := interval;
        END;
      ELSE
        IF Cerrno.GetErrno() = Uerror.EINTR THEN
          (* spurious wakeups are OK *)
        ELSE
          RETURN WaitResult.Error;
        END;
      END;
    END;
  END XIOWait;

TYPE UTime = Utime.struct_timeval;

PROCEDURE <A NAME="UTimeFromTime"><procedure>UTimeFromTime</procedure></A> (time: Time.T): UTime =
  VAR floor := FLOOR(time);
  BEGIN
    RETURN UTime{floor, FLOOR(1.0D6 * (time - FLOAT(floor, LONGREAL)))};
  END UTimeFromTime;

PROCEDURE <A NAME="WaitProcess"><procedure>WaitProcess</procedure></A> (pid: int; VAR status: int): int =
  (* ThreadPThread.m3 and ThreadPosix.m3 are very similar. *)
  BEGIN
    LOOP
      WITH r = Uexec.waitpid(pid, ADR(status), 0) DO
        &lt;*ASSERT r # 0*&gt;
        IF r &gt; 0 THEN RETURN r END;
        IF Cerrno.GetErrno() # Uerror.EINTR THEN RETURN r END;
      END;
    END;
  END WaitProcess;
</PRE>--------------------------------------------------- Stack size controls ---

<P><PRE>VAR defaultStackSize := 4096;

PROCEDURE <A NAME="GetDefaultStackSize"><procedure>GetDefaultStackSize</procedure></A> (): CARDINAL =
  BEGIN
    RETURN defaultStackSize;
  END GetDefaultStackSize;

PROCEDURE <A NAME="MinDefaultStackSize"><procedure>MinDefaultStackSize</procedure></A> (size: CARDINAL) =
  BEGIN
    defaultStackSize := MAX(defaultStackSize, size);
  END MinDefaultStackSize;

PROCEDURE <A NAME="IncDefaultStackSize"><procedure>IncDefaultStackSize</procedure></A> (inc: CARDINAL) =
  BEGIN
    INC(defaultStackSize, inc);
  END IncDefaultStackSize;
</PRE>--------------------------------------------- Garbage collector support ---
 NOTE: These routines are called indirectly by the low-level page fault
   handler of the garbage collector.  So, if they touched traced references,
   they could trigger indefinite invocations of the fault handler. 

<P> In versions of SuspendOthers prior to the addition of the incremental
   collector, it acquired 'cm' to guarantee that no suspended thread held it.
   That way when the collector tried to acquire a mutex or signal a
   condition, it wouldn't deadlock with the suspended thread that held cm.
<P>
   With the VM-synchronized, incremental collector this design is inadequate.
   Here's a deadlock that occurred:
      Thread.Broadcast held cm,
      then it touched its condition argument,
      the page containing the condition was protected by the collector,
      another thread started running the page fault handler,
      the handler called SuspendOthers,
      SuspendOthers tried to acquire cm.
<P>
   So, SuspendOthers does not grab <CODE>cm</CODE> before shutting down the other
   threads.  If the collector tries to use any of the thread functions
   that acquire <CODE>cm</CODE>, it'll be deadlocked.


<P><PRE>VAR suspended: BOOLEAN := FALSE;        (* LL=activeMu *)

PROCEDURE <A NAME="SuspendOthers"><procedure>SuspendOthers</procedure></A> () =
  (* LL=0. Always bracketed with ResumeOthers which releases &quot;activeMu&quot; *)
  BEGIN
    WITH r = pthread_mutex_lock(activeMu) DO &lt;*ASSERT r=0*&gt; END;
    StopWorld();
    &lt;*ASSERT NOT suspended*&gt;
    suspended := TRUE;
  END SuspendOthers;

PROCEDURE <A NAME="ResumeOthers"><procedure>ResumeOthers</procedure></A> () =
  (* LL=activeMu.  Always preceded by SuspendOthers. *)
  BEGIN
    &lt;*ASSERT suspended*&gt;
    suspended := FALSE;
    StartWorld();
    WITH r = pthread_mutex_unlock(activeMu) DO &lt;*ASSERT r=0*&gt; END;
  END ResumeOthers;

PROCEDURE <A NAME="ProcessStacks"><procedure>ProcessStacks</procedure></A> (p: PROCEDURE (start, limit: ADDRESS)) =
  (* LL=activeMu.  Only called within {SuspendOthers, ResumeOthers} *)
  VAR
    me := GetActivation();
    act: Activation;
  BEGIN
    ProcessMe(me, p);
    act := me.next;
    WHILE act # me DO
      ProcessOther(act, p);
      act := act.next;
    END;
  END ProcessStacks;

PROCEDURE <A NAME="ProcessEachStack"><procedure>ProcessEachStack</procedure></A> (p: PROCEDURE (start, limit: ADDRESS)) =
  (* LL=0 *)
  VAR
    me := GetActivation();
    act: Activation;
    state: ActState;
    acks: int;
    nLive, nDead, newlySent: INTEGER;
    wait_nsecs := RETRY_INTERVAL;
  BEGIN
    WITH r = pthread_mutex_lock(activeMu) DO &lt;*ASSERT r=0*&gt; END;

    ProcessMe(me, p);

    act := me.next;
    WHILE act # me DO
      (* stop *)
      LOOP
        &lt;*ASSERT act.state = ActState.Started*&gt;
        SetState(act, ActState.Stopping);
        IF SIG_SUSPEND = 0 THEN
          IF StopThread(act) THEN
            SetState(act, ActState.Stopped);
            EXIT;
          ELSE
            SetState(act, ActState.Started);
          END;
        ELSE
          SignalThread(act);
          INC(nLive);
          EXIT;
        END;
        CommonSleep();
      END;
      WHILE nLive &gt; 0 DO
        &lt;*ASSERT SIG_SUSPEND # 0*&gt;
        WITH r = sem_getvalue(acks) DO &lt;*ASSERT r=0*&gt; END;
        IF acks = nLive THEN EXIT END;
        &lt;*ASSERT acks &lt; nLive*&gt;
        IF wait_nsecs &lt;= 0 THEN
          newlySent := 0;
          state := act.state;
          &lt;*ASSERT state # ActState.Starting*&gt;
          IF state # ActState.Stopped THEN
            SignalThread(act);
            INC(newlySent);
          END;
          WITH r = sem_getvalue(acks) DO &lt;*ASSERT r=0*&gt; END;
          IF newlySent &lt; nLive - acks THEN
            (* how did we manage to lose some? *)
            nLive := acks + newlySent;
          END;
          wait_nsecs := RETRY_INTERVAL;
        ELSE
          CommonSleep();
          DEC(wait_nsecs, WAIT_UNIT);
        END;
      END;
      FOR i := 0 TO nLive - 1 DO
        WHILE sem_wait() # 0 DO
          WITH r = Cerrno.GetErrno() DO
            IF r # Uerror.EINTR THEN DieI(ThisLine(), r) END;
          END;
          (*retry*)
        END;
      END;

      (* process *)
      ProcessOther(act, p);

      (* start *)
      nDead := 0;
      LOOP
        &lt;*ASSERT act.state = ActState.Stopped*&gt;
        SetState(act, ActState.Starting);
        IF SIG_SUSPEND = 0 THEN
          IF StartThread(act) THEN
            SetState(act, ActState.Started);
            EXIT;
          ELSE
            SetState(act, ActState.Stopped);
          END;
        ELSE
          SignalThread(act);
          INC(nDead);
          EXIT;
        END;
        CommonSleep();
      END;
      WHILE nDead &gt; 0 DO
        &lt;*ASSERT SIG_SUSPEND # 0*&gt;
        WITH r = sem_getvalue(acks) DO &lt;*ASSERT r=0*&gt; END;
        IF acks = nDead THEN EXIT END;
        &lt;*ASSERT acks &lt; nDead*&gt;
        IF wait_nsecs &lt;= 0 THEN
          newlySent := 0;
          state := act.state;
          &lt;*ASSERT state # ActState.Stopping*&gt;
          IF state # ActState.Started THEN
            SignalThread(act);
            INC(newlySent);
          END;
          WITH r = sem_getvalue(acks) DO &lt;*ASSERT r=0*&gt; END;
          IF newlySent &lt; nDead - acks THEN
            (* how did we manage to lose some? *)
            nDead := acks + newlySent;
          END;
          wait_nsecs := RETRY_INTERVAL;
        ELSE
          CommonSleep();
          DEC(wait_nsecs, WAIT_UNIT);
        END;
      END;
      FOR i := 0 TO nDead - 1 DO
        WHILE sem_wait() # 0 DO
          WITH r = Cerrno.GetErrno() DO
            IF r # Uerror.EINTR THEN DieI(ThisLine(), r) END;
          END;
          (*retry*)
        END;
      END;
    END;

    WITH r = pthread_mutex_unlock(activeMu) DO &lt;*ASSERT r=0*&gt; END;
  END ProcessEachStack;

PROCEDURE <A NAME="ProcessMe"><procedure>ProcessMe</procedure></A> (me: Activation;  p: PROCEDURE (start, limit: ADDRESS)) =
  (* LL=activeMu *)
  BEGIN
    &lt;*ASSERT me.state # ActState.Stopped*&gt;
    IF DEBUG THEN
      RTIO.PutText(&quot;Processing act=&quot;); RTIO.PutAddr(me); RTIO.PutText(&quot;\n&quot;); RTIO.Flush();
    END;
    RTHeapRep.FlushThreadState(me.heapState);
    ProcessLive(me.stackbase, p);
  END ProcessMe;

PROCEDURE <A NAME="ProcessOther"><procedure>ProcessOther</procedure></A> (act: Activation;  p: PROCEDURE (start, stop: ADDRESS)) =
  (* LL=activeMu *)
  BEGIN
    &lt;*ASSERT act.state = ActState.Stopped*&gt;
    IF DEBUG THEN
      RTIO.PutText(&quot;Processing act=&quot;); RTIO.PutAddr(act); RTIO.PutText(&quot;\n&quot;); RTIO.Flush();
    END;
    IF act.stackbase = NIL THEN RETURN END;
    RTHeapRep.FlushThreadState(act.heapState);
    ProcessStopped(act.handle, act.stackbase, act.context, p);
  END ProcessOther;
</PRE> Signal based suspend/resume 

<P><PRE>PROCEDURE <A NAME="SignalThread"><procedure>SignalThread</procedure></A>(act: Activation) =
  BEGIN
    &lt;*ASSERT SIG_SUSPEND # 0*&gt;
    LOOP
      WITH z = pthread_kill(act.handle, SIG_SUSPEND) DO
        IF z = 0 THEN EXIT END;
        IF z # Uerror.EAGAIN THEN DieI(ThisLine(), z) END;
        (* try it again... *)
      END;
    END;
  END SignalThread;

PROCEDURE <A NAME="StopThread"><procedure>StopThread</procedure></A> (act: Activation): BOOLEAN =
  BEGIN
    &lt;*ASSERT act.state = ActState.Stopping*&gt;
    &lt;*ASSERT SIG_SUSPEND = 0*&gt;
    IF NOT SuspendThread(act.handle) THEN RETURN FALSE END;
    IF act.heapState.inCritical # 0 THEN
      IF NOT RestartThread(act.handle) THEN &lt;*ASSERT FALSE*&gt; END;
      RETURN FALSE;
    END;
    RETURN TRUE;
  END StopThread;

PROCEDURE <A NAME="StartThread"><procedure>StartThread</procedure></A> (act: Activation): BOOLEAN =
  BEGIN
    &lt;*ASSERT act.state = ActState.Starting*&gt;
    &lt;*ASSERT SIG_SUSPEND = 0*&gt;
    RETURN RestartThread(act.handle);
  END StartThread;

PROCEDURE <A NAME="StopWorld"><procedure>StopWorld</procedure></A> () =
  (* LL=activeMu *)
  VAR
    me := GetActivation();
    act: Activation;
    state: ActState;
    acks: int;
    nLive, newlySent: INTEGER;
    retry: BOOLEAN;
    wait_nsecs := RETRY_INTERVAL;
  BEGIN
    IF DEBUG THEN
      RTIO.PutText(&quot;Stopping from act=&quot;); RTIO.PutAddr(me); RTIO.PutText(&quot;\n&quot;); RTIO.Flush();
    END;

    nLive := 0;
    LOOP
      retry := FALSE;
      act := me.next;
      WHILE act # me DO
        &lt;*ASSERT act.state # ActState.Starting*&gt;
        IF act.state = ActState.Started THEN
          SetState(act, ActState.Stopping);
          IF SIG_SUSPEND = 0 THEN
            IF StopThread(act) THEN
              SetState(act, ActState.Stopped);
            ELSE
              SetState(act, ActState.Started);
              retry := TRUE;
            END;
          ELSE
            SignalThread(act);
            INC(nLive);
          END;
        END;
        act := act.next;
      END;
      IF NOT retry THEN EXIT END;
      CommonSleep();
    END;
    WHILE nLive &gt; 0 DO
      &lt;*ASSERT SIG_SUSPEND # 0*&gt;
      WITH r = sem_getvalue(acks) DO &lt;*ASSERT r=0*&gt; END;
      IF acks = nLive THEN EXIT END;
      &lt;*ASSERT acks &lt; nLive*&gt;
      IF wait_nsecs &lt;= 0 THEN
        newlySent := 0;
        act := me.next;
        WHILE act # me DO
          state := act.state;
          &lt;*ASSERT state # ActState.Starting*&gt;
          IF state # ActState.Stopped THEN
            SignalThread(act);
            INC(newlySent);
          END;
          act := act.next;
        END;
        WITH r = sem_getvalue(acks) DO &lt;*ASSERT r=0*&gt; END;
        IF newlySent &lt; nLive - acks THEN
          (* how did we manage to lose some? *)
          nLive := acks + newlySent;
        END;
        wait_nsecs := RETRY_INTERVAL;
      ELSE
        CommonSleep();
        DEC(wait_nsecs, WAIT_UNIT);
      END;
    END;
    (* drain semaphore *)
    FOR i := 0 TO nLive-1 DO
      WHILE sem_wait() # 0 DO
        WITH r = Cerrno.GetErrno() DO
          IF r # Uerror.EINTR THEN DieI(ThisLine(), r) END;
        END;
        (*retry*)
      END;
    END;

    IF DEBUG THEN
      RTIO.PutText(&quot;Stopped from act=&quot;); RTIO.PutAddr(me); RTIO.PutText(&quot;\n&quot;); RTIO.Flush();
      DumpThreads();
    END;
  END StopWorld;

PROCEDURE <A NAME="StartWorld"><procedure>StartWorld</procedure></A> () =
  (* LL=activeMu *)
  VAR
    me := GetActivation();
    act: Activation;
    state: ActState;
    acks: int;
    nDead, newlySent: INTEGER;
    retry: BOOLEAN;
    wait_nsecs := RETRY_INTERVAL;
  BEGIN
    IF DEBUG THEN
      RTIO.PutText(&quot;Starting from act=&quot;); RTIO.PutAddr(me); RTIO.PutText(&quot;\n&quot;); RTIO.Flush();
    END;

    nDead := 0;
    LOOP
      retry := FALSE;
      act := me.next;
      WHILE act # me DO
        &lt;*ASSERT act.state # ActState.Stopping*&gt;
        IF act.state # ActState.Started THEN
          SetState(act, ActState.Starting);
          IF SIG_SUSPEND = 0 THEN
            IF StartThread(act) THEN
              SetState(act, ActState.Started);
            ELSE
              SetState(act, ActState.Stopped);
              retry := TRUE;
            END;
          ELSE
            SignalThread(act);
            INC(nDead);
          END;
        END;
        act := act.next;
      END;
      IF NOT retry THEN EXIT END;
      CommonSleep();
    END;
    WHILE nDead &gt; 0 DO
      &lt;*ASSERT SIG_SUSPEND # 0*&gt;
      WITH r = sem_getvalue(acks) DO &lt;*ASSERT r=0*&gt; END;
      IF acks = nDead THEN EXIT END;
      &lt;*ASSERT acks &lt; nDead*&gt;
      IF wait_nsecs &lt;= 0 THEN
        newlySent := 0;
        act := me.next;
        WHILE act # me DO
          state := act.state;
          &lt;*ASSERT state # ActState.Stopping*&gt;
          IF state # ActState.Started THEN
            SignalThread(act);
            INC(newlySent);
          END;
          act := act.next;
        END;
        WITH r = sem_getvalue(acks) DO &lt;*ASSERT r=0*&gt; END;
        IF newlySent &lt; nDead - acks THEN
          (* how did we manage to lose some? *)
          nDead := acks + newlySent;
        END;
        wait_nsecs := RETRY_INTERVAL;
      ELSE
        CommonSleep();
        DEC(wait_nsecs, WAIT_UNIT);
      END;
    END;
    (* drain semaphore *)
    FOR i := 0 TO nDead-1 DO
      WHILE sem_wait() # 0 DO
        WITH r = Cerrno.GetErrno() DO
          IF r # Uerror.EINTR THEN DieI(ThisLine(), r) END;
        END;
        (*retry*)
      END;
    END;

    IF DEBUG THEN
      RTIO.PutText(&quot;Started from act=&quot;); RTIO.PutAddr(me); RTIO.PutText(&quot;\n&quot;); RTIO.Flush();
      DumpThreads();
    END;
  END StartWorld;

PROCEDURE <A NAME="SignalHandler"><procedure>SignalHandler</procedure></A> (sig: int; &lt;*UNUSED*&gt;info: ADDRESS; context: ADDRESS) =
  VAR
    errno := Cerrno.GetErrno();
    me := GetActivation();
  BEGIN
    &lt;*ASSERT sig = SIG_SUSPEND*&gt;
    IF me.state = ActState.Stopping THEN
      IF me.heapState.inCritical # 0 THEN
        me.state := ActState.Started;
        RETURN;
      END;
      me.state := ActState.Stopped;
      &lt;*ASSERT me.context = NIL*&gt;
      me.context := context;
      WITH r = sem_post() DO &lt;*ASSERT r=0*&gt; END;
      REPEAT sigsuspend() UNTIL me.state = ActState.Starting;
      me.context := NIL;
      me.state := ActState.Started;
      WITH r = sem_post() DO &lt;*ASSERT r=0*&gt; END;
    END;
    Cerrno.SetErrno(errno);
  END SignalHandler;
</PRE>----------------------------------------------------------- misc. stuff ---

<P><PRE>PROCEDURE <A NAME="MyId"><procedure>MyId</procedure></A> (): Id RAISES {} =
  VAR me := GetActivation();
  BEGIN
    IF me = NIL
      THEN RETURN 0
      ELSE RETURN me.slot;
    END;
  END MyId;

PROCEDURE <A NAME="MyFPState"><procedure>MyFPState</procedure></A> (): UNTRACED REF FloatMode.ThreadState =
  VAR me := GetActivation();
  BEGIN
    RETURN ADR(me.floatState);
  END MyFPState;

PROCEDURE <A NAME="MyHeapState"><procedure>MyHeapState</procedure></A> (): UNTRACED REF RTHeapRep.ThreadState =
  VAR me := GetActivation();
  BEGIN
    RETURN ADR(me.heapState);
  END MyHeapState;

PROCEDURE <A NAME="DisableSwitching"><procedure>DisableSwitching</procedure></A> () =
  BEGIN
    (* no user-level thread switching *)
  END DisableSwitching;

PROCEDURE <A NAME="EnableSwitching"><procedure>EnableSwitching</procedure></A> () =
  BEGIN
    (* no user-level thread switching *)
  END EnableSwitching;
</PRE>---------------------------------------------------------------- errors ---

<P><PRE>PROCEDURE <A NAME="Die"><procedure>Die</procedure></A> (lineno: INTEGER; msg: TEXT) =
  BEGIN
    RTError.Msg (ThisFile(), lineno, &quot;Thread client error: &quot;, msg);
  END Die;

PROCEDURE <A NAME="DieI"><procedure>DieI</procedure></A> (lineno: INTEGER; i: INTEGER) =
  BEGIN
    RTError.MsgI (ThisFile(), lineno, &quot;Thread client error: &quot;, i);
  END DieI;
</PRE>------------------------------------------------------ ShowThread hooks ---

<P><PRE>VAR
  perfW : RTPerfTool.Handle;
  perfOn: BOOLEAN := FALSE;     (* LL = perfMu *)

PROCEDURE <A NAME="PerfStart"><procedure>PerfStart</procedure></A> () =
  BEGIN
    IF RTPerfTool.Start (&quot;showthread&quot;, perfW) THEN
      perfOn := TRUE;
      RTProcess.RegisterExitor (PerfStop);
    END;
  END PerfStart;

PROCEDURE <A NAME="PerfStop"><procedure>PerfStop</procedure></A> () =
  BEGIN
    (* UNSAFE, but needed to prevent deadlock if we're crashing! *)
    RTPerfTool.Close (perfW);
  END PerfStop;

CONST
  EventSize = (BITSIZE(ThreadEvent.T) + BITSIZE(CHAR) - 1) DIV BITSIZE(CHAR);

TYPE
  TE = ThreadEvent.Kind;

PROCEDURE <A NAME="PerfChanged"><procedure>PerfChanged</procedure></A> (s: State) =
  VAR
    e := ThreadEvent.T {kind := TE.Changed, id := MyId(), state := s};
  BEGIN
    WITH r = pthread_mutex_lock(perfMu) DO &lt;*ASSERT r=0*&gt; END;
      perfOn := RTPerfTool.Send (perfW, ADR (e), EventSize);
    WITH r = pthread_mutex_unlock(perfMu) DO &lt;*ASSERT r=0*&gt; END;
  END PerfChanged;

PROCEDURE <A NAME="PerfDeleted"><procedure>PerfDeleted</procedure></A> () =
  VAR
    e := ThreadEvent.T {kind := TE.Deleted, id := MyId()};
  BEGIN
    WITH r = pthread_mutex_lock(perfMu) DO &lt;*ASSERT r=0*&gt; END;
      perfOn := RTPerfTool.Send (perfW, ADR (e), EventSize);
    WITH r = pthread_mutex_unlock(perfMu) DO &lt;*ASSERT r=0*&gt; END;
  END PerfDeleted;

PROCEDURE <A NAME="PerfRunning"><procedure>PerfRunning</procedure></A> () =
  VAR
    e := ThreadEvent.T {kind := TE.Running, id := MyId()};
  BEGIN
    WITH r = pthread_mutex_lock(perfMu) DO &lt;*ASSERT r=0*&gt; END;
      perfOn := RTPerfTool.Send (perfW, ADR (e), EventSize);
    WITH r = pthread_mutex_unlock(perfMu) DO &lt;*ASSERT r=0*&gt; END;
  END PerfRunning;
</PRE>-------------------------------------------------------- Initialization ---

<P><PRE>PROCEDURE <A NAME="InitWithStackBase"><procedure>InitWithStackBase</procedure></A> (stackbase: ADDRESS) =
  VAR
    self: T;
    me: Activation;
  BEGIN
    InitC(stackbase);

    me := InitActivations();
    me.stackbase := stackbase;

    self := CreateT(me);
    joinMu := NEW(MUTEX);

    PerfStart();
    IF perfOn THEN PerfRunning() END;
    IF RTParams.IsPresent(&quot;backgroundgc&quot;) THEN
      RTCollectorSRC.StartBackgroundCollection();
    END;
    IF RTParams.IsPresent(&quot;foregroundgc&quot;) THEN
      RTCollectorSRC.StartForegroundCollection();
    END;
  END InitWithStackBase;

PROCEDURE <A NAME="Init"><procedure>Init</procedure></A> ()=
  VAR r: INTEGER;
  BEGIN
    r := RTProcess.RegisterForkHandlers(AtForkPrepare, AtForkParent, AtForkChild);
    IF r # 0 THEN DieI(ThisLine(), r) END;
    InitWithStackBase(ADR(r)); (* not quite accurate but hopefully ok *)
  END Init;

VAR locks := ARRAY [0..3] OF pthread_mutex_t{
			 activeMu, slotsMu, initMu, perfMu};

PROCEDURE <A NAME="PThreadLockMutex"><procedure>PThreadLockMutex</procedure></A>(mutex: pthread_mutex_t; line: INTEGER) =
  VAR r: INTEGER;
  BEGIN
	IF mutex # NIL THEN
      r := pthread_mutex_lock(mutex);
      IF r # 0 THEN DieI(line, r) END;
    END;
  END PThreadLockMutex;

PROCEDURE <A NAME="PThreadUnlockMutex"><procedure>PThreadUnlockMutex</procedure></A>(mutex: pthread_mutex_t; line: INTEGER) =
  VAR r: INTEGER;
  BEGIN
	IF mutex # NIL THEN
      r := pthread_mutex_unlock(mutex);
      IF r # 0 THEN DieI(line, r) END;
    END;
  END PThreadUnlockMutex;

PROCEDURE <A NAME="AtForkPrepare"><procedure>AtForkPrepare</procedure></A>() =
  VAR me := GetActivation();
      act: Activation;
      cond: Condition;
  BEGIN
    Thread.Acquire(joinMu);
    LockHeap();
    FOR i := FIRST(locks) TO LAST(locks) DO
      PThreadLockMutex(locks[i], ThisLine());
    END;
    (* Walk activations and lock all threads, conditions.
     * NOTE: We have initMu, activeMu, so slots
     * won't change, conditions and mutexes
     * won't be initialized on-demand.
     *)
    act := me;
    REPEAT
      PThreadLockMutex(act.mutex, ThisLine());
      (*PThreadLockMutex(act.waitingOn, ThisLine());*)
      cond := slots[act.slot].join;
      IF cond # NIL THEN
		PThreadLockMutex(cond.mutex, ThisLine());
      END;
      act := act.next;
    UNTIL act = me;
  END AtForkPrepare;

PROCEDURE <A NAME="AtForkParent"><procedure>AtForkParent</procedure></A>() =
  VAR me := GetActivation();
      act: Activation;
      cond: Condition;
  BEGIN
    (* Walk activations and unlock all threads, conditions. *)
    act := me;
    REPEAT
      cond := slots[act.slot].join;
      IF cond # NIL THEN
		PThreadUnlockMutex(cond.mutex, ThisLine());
      END;
      (*PThreadUnlockMutex(act.waitingOn, ThisLine());*)
      PThreadUnlockMutex(act.mutex, ThisLine());
      act := act.next;
    UNTIL act = me;

    FOR i := LAST(locks) TO FIRST(locks) BY -1 DO
      PThreadUnlockMutex(locks[i], ThisLine());
    END;
    UnlockHeap();
    Thread.Release(joinMu);
  END AtForkParent;

PROCEDURE <A NAME="AtForkChild"><procedure>AtForkChild</procedure></A>() =
  BEGIN
    AtForkParent();
    InitWithStackBase(GetActivation().stackbase);
  END AtForkChild;
</PRE>------------------------------------------------------------- collector ---
 These procedures provide synchronization primitives for the allocator
   and collector. 

<P><PRE>VAR
  holder: pthread_t;
  inCritical := 0;

PROCEDURE <A NAME="LockHeap"><procedure>LockHeap</procedure></A> () =
  VAR self := pthread_self();
  BEGIN
    IF pthread_equal(holder, self) = 0 THEN
      WITH r = pthread_mutex_lock(heapMu) DO &lt;*ASSERT r=0*&gt; END;
      holder := self;
    END;
    INC(inCritical);
  END LockHeap;

PROCEDURE <A NAME="UnlockHeap"><procedure>UnlockHeap</procedure></A> () =
  BEGIN
    &lt;*ASSERT pthread_equal(holder, pthread_self()) # 0*&gt;
    DEC(inCritical);
    IF inCritical = 0 THEN
      holder := NIL;
      WITH r = pthread_mutex_unlock(heapMu) DO &lt;*ASSERT r=0*&gt; END;
    END;
  END UnlockHeap;

PROCEDURE <A NAME="WaitHeap"><procedure>WaitHeap</procedure></A> () =
  VAR self := pthread_self();
  BEGIN
    &lt;*ASSERT pthread_equal(holder, self) # 0*&gt;
    DEC(inCritical);
    &lt;*ASSERT inCritical = 0*&gt;
    WITH r = pthread_cond_wait(heapCond, heapMu) DO &lt;*ASSERT r=0*&gt; END;
    holder := self;
    &lt;*ASSERT inCritical = 0*&gt;
    INC(inCritical);
  END WaitHeap;

PROCEDURE <A NAME="BroadcastHeap"><procedure>BroadcastHeap</procedure></A> () =
  BEGIN
    WITH r = pthread_cond_broadcast(heapCond) DO &lt;*ASSERT r=0*&gt; END;
  END BroadcastHeap;
</PRE>--------------------------------------------- exception handling support --

<P><PRE>PROCEDURE <A NAME="GetCurrentHandlers"><procedure>GetCurrentHandlers</procedure></A> (): ADDRESS =
  VAR me := GetActivation();
  BEGIN
    RETURN me.frame;
  END GetCurrentHandlers;

PROCEDURE <A NAME="SetCurrentHandlers"><procedure>SetCurrentHandlers</procedure></A> (h: ADDRESS) =
  VAR me := GetActivation();
  BEGIN
    me.frame := h;
  END SetCurrentHandlers;
</PRE>RTHooks.PushEFrame
<PRE>PROCEDURE <A NAME="PushEFrame"><procedure>PushEFrame</procedure></A> (frame: ADDRESS) =
  TYPE Frame = UNTRACED REF RECORD next: ADDRESS END;
  VAR
    me := GetActivation();
    f: Frame := frame;
  BEGIN
    f.next := me.frame;
    me.frame := f;
  END PushEFrame;
</PRE>RTHooks.PopEFrame
<PRE>PROCEDURE <A NAME="PopEFrame"><procedure>PopEFrame</procedure></A> (frame: ADDRESS) =
  VAR me := GetActivation();
  BEGIN
    me.frame := frame;
  END PopEFrame;

VAR DEBUG := RTParams.IsPresent(&quot;debugthreads&quot;);

BEGIN
END ThreadPThread.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface ThreadF is in:
</A><UL>
<LI><A HREF="../Common/ThreadF.i3.html#0TOP0">m3core/src/thread/Common/ThreadF.i3</A>
<LI><A HREF="ThreadF.i3.html#0TOP0">m3core/src/thread/PTHREAD/ThreadF.i3</A>
</UL>
<P>
<HR>
<A NAME="x2">interface RTThread is in:
</A><UL>
<LI><A HREF="../../runtime/POSIX/RTThread.i3.html#0TOP0">m3core/src/runtime/POSIX/RTThread.i3</A>
<LI><A HREF="../../runtime/common/RTThread.i3.html#0TOP0">m3core/src/runtime/common/RTThread.i3</A>
</UL>
<P>
<HR>
<A NAME="x3">interface Unix is in:
</A><UL>
<LI><A HREF="../../unix/Common/Unix.i3.html#0TOP0">m3core/src/unix/Common/Unix.i3</A>
<LI><A HREF="../../unix/linux-common/Unix.i3.html#0TOP0">m3core/src/unix/linux-common/Unix.i3</A>
</UL>
<P>
<HR>
<A NAME="x4">interface Utime is in:
</A><UL>
<LI><A HREF="../../unix/Common/Utime.i3.html#0TOP0">m3core/src/unix/Common/Utime.i3</A>
<LI><A HREF="../../unix/linux-common/Utime.i3.html#0TOP0">m3core/src/unix/linux-common/Utime.i3</A>
</UL>
<P>
<HR>
<A NAME="x5">interface Usched is in:
</A><UL>
<LI><A HREF="../../unix/Common/Usched.i3.html#0TOP0">m3core/src/unix/Common/Usched.i3</A>
<LI><A HREF="../../unix/linux-common/Usched.i3.html#0TOP0">m3core/src/unix/linux-common/Usched.i3</A>
</UL>
<P>
<HR>
<A NAME="x6">interface Uerror is in:
</A><UL>
<LI><A HREF="../../unix/Common/Uerror.i3.html#0TOP0">m3core/src/unix/Common/Uerror.i3</A>
<LI><A HREF="../../unix/linux-common/Uerror.i3.html#0TOP0">m3core/src/unix/linux-common/Uerror.i3</A>
</UL>
<P>
<HR>
<A NAME="x7">interface Uexec is in:
</A><UL>
<LI><A HREF="../../unix/Common/Uexec.i3.html#0TOP0">m3core/src/unix/Common/Uexec.i3</A>
<LI><A HREF="../../unix/linux-common/Uexec.i3.html#0TOP0">m3core/src/unix/linux-common/Uexec.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
