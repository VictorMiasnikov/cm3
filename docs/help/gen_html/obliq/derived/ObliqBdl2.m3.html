<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: obliq/derived/ObliqBdl2.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>obliq/derived/ObliqBdl2.m3</H2></A><HR>
<inModule>
<PRE>MODULE <module><implements><A HREF="ObliqBdl2.i3.html">ObliqBdl2</A></implements></module>;
</PRE><BLOCKQUOTE><EM> Generated by m3bundle; see its manpage. </EM></BLOCKQUOTE><PRE>

IMPORT <A HREF="../../libm3/src/bundleintf/Bundle.i3.html">Bundle</A>, <A HREF="../../libm3/src/bundleintf/BundleRep.i3.html">BundleRep</A>, <A HREF="../../m3core/src/text/Text.i3.html">Text</A>;
IMPORT <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="../../libm3/src/rw/TextWr.i3.html">TextWr</A>;

TYPE T = Bundle.T OBJECT OVERRIDES
           get      := LookUp;
           getNames := GetNames;
         END;

TYPE Texts = REF ARRAY OF TEXT;

VAR
  bundle: T     := NIL;
  names : Texts := NIL;

PROCEDURE <A NAME="Get"><procedure>Get</procedure></A>(): Bundle.T =
  BEGIN
    IF (bundle = NIL) THEN bundle := NEW (T) END;
    RETURN bundle;
  END Get;

PROCEDURE <A NAME="GetNames"><procedure>GetNames</procedure></A> (&lt;*UNUSED*&gt; self: T): Texts =
  BEGIN
    IF names = NIL THEN
      names := NEW (Texts, NUMBER (Names));
      names^ := Names;
    END;
    RETURN names;
  END GetNames;

PROCEDURE <A NAME="LookUp"><procedure>LookUp</procedure></A> (&lt;*UNUSED*&gt; self: T;  element: TEXT): TEXT =
  BEGIN
    FOR i := 0 TO LAST (Names)-1 DO
      IF Text.Equal (Names[i], element) THEN
        IF Elements[i] = NIL THEN Elements[i] := GetElt (i) END;
        RETURN Elements[i];
      END;
    END;
    RETURN NIL;
  END LookUp;

CONST Names = ARRAY [0..27] OF TEXT {
  &quot;ObliqHelpArray&quot;,
  &quot;ObliqHelpReal&quot;,
  &quot;ObliqHelpForm&quot;,
  &quot;ObliqHelpOnline&quot;,
  &quot;ObliqHelpVBT&quot;,
  &quot;ObliqHelpLex&quot;,
  &quot;ObliqHelpNet&quot;,
  &quot;ObliqHelpMath&quot;,
  &quot;ObliqHelpRects&quot;,
  &quot;ObliqHelpSys&quot;,
  &quot;ObliqHelpThread&quot;,
  &quot;ObliqHelpFmt&quot;,
  &quot;ObliqHelpReplica&quot;,
  &quot;ObliqHelpGraph&quot;,
  &quot;ObliqHelpChar&quot;,
  &quot;ObliqHelpBool&quot;,
  &quot;ObliqHelpRandom&quot;,
  &quot;ObliqSyntax&quot;,
  &quot;ObliqHelpPickle&quot;,
  &quot;ObliqHelpRd&quot;,
  &quot;ObliqHelpText&quot;,
  &quot;ObliqHelpZeus&quot;,
  &quot;ObliqHelpInt&quot;,
  &quot;ObliqHelpColor&quot;,
  &quot;ObliqLexicon&quot;,
  &quot;ObliqHelpProcess&quot;,
  &quot;ObliqHelpWr&quot;,
  NIL
};

VAR Elements := ARRAY [0..27] OF TEXT {
  E0,
  NIL (* E1 .. E1_0 *),
  NIL (* E2 .. E2_1 *),
  E3,
  E4,
  E5,
  E6,
  E7,
  E8,
  E9,
  NIL (* E10 .. E10_0 *),
  E11,
  E12,
  NIL (* E13 .. E13_1 *),
  E14,
  E15,
  E16,
  NIL (* E17 .. E17_1 *),
  E18,
  E19,
  NIL (* E20 .. E20_0 *),
  E21,
  E22,
  E23,
  E24,
  E25,
  E26,
  NIL
};

PROCEDURE <A NAME="GetElt"><procedure>GetElt</procedure></A> (n: INTEGER): TEXT =
  &lt;*FATAL Thread.Alerted, Wr.Failure *&gt;
  VAR wr := TextWr.New ();
  BEGIN
    CASE n OF
    | 1 =&gt;
        Wr.PutText (wr, E1);
        Wr.PutText (wr, E1_0);
    | 2 =&gt;
        Wr.PutText (wr, E2);
        Wr.PutText (wr, E2_0);
        Wr.PutText (wr, E2_1);
    | 10 =&gt;
        Wr.PutText (wr, E10);
        Wr.PutText (wr, E10_0);
    | 13 =&gt;
        Wr.PutText (wr, E13);
        Wr.PutText (wr, E13_0);
        Wr.PutText (wr, E13_1);
    | 17 =&gt;
        Wr.PutText (wr, E17);
        Wr.PutText (wr, E17_0);
        Wr.PutText (wr, E17_1);
    | 20 =&gt;
        Wr.PutText (wr, E20);
        Wr.PutText (wr, E20_0);
    ELSE (*skip*)
    END;
    RETURN TextWr.ToText (wr);
  END GetElt;

CONST E0 =
   &quot;  [e1, ..., en]: [T]\n    (for e1...en: T)\n  All(T) array_new(size: In&quot;
 &amp; &quot;t, init: T): [T]\n    An array of size \'size\', all filled with \'init&quot;
 &amp; &quot;\'.\n  All(T) array_gen(size: Int, proc: (Int)-&gt;T): [T]\n    An array o&quot;
 &amp; &quot;f size \'size\', filled with \'proc(i)\' for \'i\' between \'0\' and \n&quot;
 &amp; &quot;    \'size-1\'.\n  All(T) array_#(a: [T]): Int ! net_failure\n    (also&quot;
 &amp; &quot; \'#(a)\') Size of an array.\n  All(T) array_get(a: [T], i: Int): T ! n&quot;
 &amp; &quot;et_failure\n    (also \'a[i]\') The i-th element (if it exists), zero-b&quot;
 &amp; &quot;ased.\n  All(T) array_set(a: [T], i: Int, b: T): Ok ! net_failure\n    &quot;
 &amp; &quot;(also \'a[i]:=b\') Update the i-th element (if it exists).\n  All(T) ar&quot;
 &amp; &quot;ray_sub(a: [T], i: Int, n: Int): [T] ! net_failure\n    (also \'a[i for&quot;
 &amp; &quot; n]\') A new array, filled with the elements of \'a\' beginning \n    a&quot;
 &amp; &quot;t \'i\', and of size \'n\' (if it exists).\n  All(T) array_upd(a: [T], &quot;
 &amp; &quot;i: Int, n: Int, b: [T]): Ok ! net_failure\t\n    (also \'a[i for n]:=b\'&quot;
 &amp; &quot;) Same as \'a[n+i]:=b[n]; ... ; a[i]:=b[0]\'. \n    I.e. \'a[i for n]\'&quot;
 &amp; &quot; gets \'b[0 for n]\'.\n  All(T) array_@(a1: [T], a2: [T]): [T] ! net_fa&quot;
 &amp; &quot;ilure\n    (also infix \'@\') A new array, filled with the concatenatio&quot;
 &amp; &quot;n of the elements \n    of \'a1\' and \'a2\'.\n&quot;;

CONST E1 =
   &quot;  n.m: Int\n    Positive real constants; m is optional.\n  ~n.m: Int\n &quot;
 &amp; &quot;   Negative real constants; m is optional.\n  real_minus(n: Real): Real&quot;
 &amp; &quot;\n    (also \'-n\') Real negation.\n  real_minus(n: Int): Int\n    (als&quot;
 &amp; &quot;o \'-n\') Overloaded integer negation.\n  real_+(n1: Real, n2: Real): R&quot;
 &amp; &quot;eal\n    (also infix \'+\') Real addition.\n  real_+(n1: Int, n2: Int):&quot;
 &amp; &quot; Int\n    (also infix \'+\') Overloaded integer addition.\n  real_-(n1:&quot;
 &amp; &quot; Real, n2: Real): Real\n    (also infix \'-\') Real difference.\n  real&quot;
 &amp; &quot;_-(n1: Int, n2: Int): Int\n    (also infix \'-\') Overloaded integer di&quot;
 &amp; &quot;fference.\n  real_*(n1: Real, n2: Real): Real\n    (also infix \'*\') R&quot;
 &amp; &quot;eal multiplication.\n  real_*(n1: Int, n2: Int): Int\n    (also infix \'&quot;
 &amp; &quot;*\') Overloaded integer multiplication.\n  real_/(n1: Real, n2: Real): &quot;
 &amp; &quot;Real\n    (also infix \'/\') Real division.\n  real_/(n1: Int, n2: Int)&quot;
 &amp; &quot;: Int\n    (also infix \'/\') Overloaded integer division.\n  real_&lt;(n1&quot;
 &amp; &quot;: Real, n2: Real): Bool\n    (also infix \'&lt;\') Real less-than predicat&quot;
 &amp; &quot;e\n  real_&lt;(n1: Int, n2: Int): Bool\n    (also infix \'&lt;\') Overloaded &quot;
 &amp; &quot;integer less-than predicate\n  real_&gt;(n1: Real, n2: Real): Bool\n    (a&quot;
 &amp; &quot;lso infix \'&gt;\') Real greater-than predicate\n  real_&gt;(n1: Int, n2: Int&quot;
 &amp; &quot;): Bool\n    (also infix \'&gt;\') Overloaded integer greater-than predica&quot;
 &amp; &quot;te\n  real_&lt;=(n1: Real, n2: Real): Bool\n    (also infix \'&lt;=\') Real n&quot;
 &amp; &quot;o-greater-than predicate\n  real_&lt;=(n1: Int, n2: Int): Bool\n    (also &quot;
 &amp; &quot;infix \'&lt;=\') Overloaded integer no-greater-than pred.\n  real_&gt;=(n1: R&quot;
 &amp; &quot;eal, n2: Real): Bool\n    (also infix \'&gt;=\') Real no-less-than predica&quot;
 &amp; &quot;te.\n  real_&gt;=(n1: Int, n2: Int): Bool\n    (also infix \'&gt;=\') Overloa&quot;
 &amp; &quot;ded integer no-less-than pred.\n  real_float(n: Int): Real\n    (also \'&quot;
 &amp; &quot;float(n)\') Integer-to-real conversion.\n  real_float(n: Real): Real\n &quot;
 &amp; &quot;   (also \'float(n)\') Overloaded; identity on reals.\n  real_round(n: &quot;
 &amp; &quot;Real): Int\n    (also \'round(n)\') Real-to-integer rounding.\n  real_r&quot;
 &amp; &quot;ound(n: Int): Int\n    (also \'round(n)\') Overloaded; identity on inte&quot;
 &amp; &quot;gers.\n  real_floor(n: Real): Int\n    Greatest integers no greater tha&quot;
 &amp; &quot;n n.\n  real_floor(n: Int): Int\n &quot;;

CONST E1_0 =
   &quot;   Overloaded; identity on integers.\n  real_ceiling(n: Real): Int\n   &quot;
 &amp; &quot; Least integers no less than n.\n  real_ceiling(n: Int): Int\n    Overl&quot;
 &amp; &quot;oaded; identity on integers.\n&quot;;

CONST E2 =
   &quot;  form_failure: Exception\n  form_new(t: Text): Form ! form_failure\n  &quot;
 &amp; &quot;  Read a form description from a text.\n  form_fromFile(file: Text): Fo&quot;
 &amp; &quot;rm ! form_failure thread_alerted\n    Read a form description from a fi&quot;
 &amp; &quot;le.\n  form_attach(fv: Form, name: Text, f: (Form)-&gt;Ok): Ok ! form_fail&quot;
 &amp; &quot;ure\n    Attach a procedure to an event, under a form. The procedure is&quot;
 &amp; &quot; passed \n    back the form when the event happens.\n  form_getBool(fv:&quot;
 &amp; &quot; Form, name: Text, property: Text): Bool ! form_failure\n    Get the bo&quot;
 &amp; &quot;olean value of the property of the named interactor.\n    (Do not confu&quot;
 &amp; &quot;se with form_getBoolean.)\n  form_putBool(fv: Form, name: Text, propert&quot;
 &amp; &quot;y: Text, b: Bool): Ok \n    ! form_failure\n    Set the boolean value o&quot;
 &amp; &quot;f the named property of the named interactor.\n    (Do not confuse with&quot;
 &amp; &quot; form_putBoolean.)\n  form_getInt(fv: Form, name: Text, property: Text)&quot;
 &amp; &quot;: Int ! form_failure\n    Get the integer value of the named property o&quot;
 &amp; &quot;f the named interactor. If \n    property is the empty text, get the \322&quot;
 &amp; &quot;value\323 property.\n  form_putInt(fv: Form, name: Text, property: Text&quot;
 &amp; &quot;, n: Int): Ok \n    ! form_failure\n    Set the integer value of the na&quot;
 &amp; &quot;med property of the named interactor. If \n    property is the empty te&quot;
 &amp; &quot;xt, set the \322value\323 property.\n  form_getText(fv: Form, name: Tex&quot;
 &amp; &quot;t, property: Text): Text ! form_failure\n    Get the text value of the &quot;
 &amp; &quot;named property of the named interactor. If \n    property is the empty &quot;
 &amp; &quot;text, get the \322value\323 property.\n  form_putText(fv: Form, name: T&quot;
 &amp; &quot;ext, property: Text, t: Text, append: Bool)\n   : Ok ! form_failure\n  &quot;
 &amp; &quot;  Set the text value of the named property of the named interactor. If &quot;
 &amp; &quot;\n    property is the empty text, set the \322value\323 property.\n  fo&quot;
 &amp; &quot;rm_getBoolean(fv: Form, name: Text): Bool ! form_failure\n    Get the b&quot;
 &amp; &quot;oolean value of the named boolean-choice interactor.\n  form_putBoolean&quot;
 &amp; &quot;(fv: Form, name: Text, b: Bool): Ok ! form_failure\n    Set the boolean&quot;
 &amp; &quot; value of the named boolean-choice interactor.\n  form_getChoice(fv: Fo&quot;
 &amp; &quot;rm, radioName: Text): Text ! form_failure\n    Get the choice value &quot;;

CONST E2_0 =
   &quot;of the named radio interactor.\n  form_putChoice(fv: Form, radioName: T&quot;
 &amp; &quot;ext, choiceName: Text): Ok \n    ! form_failure\n    Set the choice val&quot;
 &amp; &quot;ue of the named radio interactor.\n  form_getReactivity(fv: Form, name:&quot;
 &amp; &quot; Text): Text ! form_failure\n    Get the reactivity of the named intera&quot;
 &amp; &quot;ctor. It can be \&quot;active\&quot;, \n    \&quot;passive\&quot;, \&quot;dormant\&quot;, or \&quot;vanish&quot;
 &amp; &quot;ed\&quot;.\n  form_putReactivity(fv: Form, name: Text, r: Text): Ok ! form_f&quot;
 &amp; &quot;ailure\n    Set the reactivity of the named interactor. It can be \&quot;act&quot;
 &amp; &quot;ive\&quot;, \n    \&quot;passive\&quot;, \&quot;dormant\&quot;, or \&quot;vanished\&quot;.\n  form_popUp(f&quot;
 &amp; &quot;v: Form, name: Text): Ok ! form_failure\n    Pop up the named interacto&quot;
 &amp; &quot;r.\n  form_popDown(fv: Form, name: Text): Ok ! form_failure\n    Pop do&quot;
 &amp; &quot;wn the named interactor.\n  form_numOfChildren(fv: Form, parent: Text):&quot;
 &amp; &quot; Int ! form_failure\n    Return the number of children of parent.\n  fo&quot;
 &amp; &quot;rm_child(fv: Form, parent: Text, n: Int): Text ! form_failure\n    Retu&quot;
 &amp; &quot;rn the n-th child of parent.\n  form_childIndex(fv: Form, parent: Text,&quot;
 &amp; &quot; child: Text): Int ! form_failure\n    Return the index of the given ch&quot;
 &amp; &quot;ild of parent.\n  form_insert(fv: Form, parent: Text, t: Text, n: Int):&quot;
 &amp; &quot; Ok ! form_failure\n    Insert the form described by t as child n of pa&quot;
 &amp; &quot;rent.\n  form_move(fv: Form, parent: Text, child: Text, toChild: Text, &quot;
 &amp; &quot;before: Bool)\n    : Ok ! form_failure\n    Move child before or after &quot;
 &amp; &quot;toChild of parent; after \&quot;\&quot; means first,\n    before \&quot;\&quot; means last.&quot;
 &amp; &quot;\n  form_delete(fv: Form, parent: Text, child: Text): Ok ! form_failure&quot;
 &amp; &quot;\n    Delete the named child of parent.\n  form_deleteRange(fv: Form, p&quot;
 &amp; &quot;arent: Text, n: Int, count: Int): Ok \n    ! form_failure\n    Delete c&quot;
 &amp; &quot;ount children of parent, from child n.\n  form_takeFocus(fv: Form, name&quot;
 &amp; &quot;: Text, select: Bool): Ok ! form_failure\n    Make the named interactor&quot;
 &amp; &quot; acquire the keyboard focus, and optionally \n    select its entire tex&quot;
 &amp; &quot;t contents.\n  form_show(fv: Form): Ok ! form_failure\n    Show a windo&quot;
 &amp; &quot;w containing the form on the default display.\n  form_showAt(fv: Form, &quot;
 &amp; &quot;at: Text, title: Text): Ok ! form_failure\n    Show a window containi&quot;;

CONST E2_1 =
   &quot;ng the form on a display. For an X display,\n    at=&lt;machine name&gt;(\':\'&quot;
 &amp; &quot;|\'::\')&lt;num&gt;(\'\'|\'.\'&lt;num&gt;); at=\&quot;\&quot; is the default \n    display. T&quot;
 &amp; &quot;he title is shown in the window header.\n  form_hide(fv: Form): Ok ! fo&quot;
 &amp; &quot;rm_failure\n    Hide the window containing the form.\n&quot;;

CONST E3 =
   &quot;  All(T) sys_print(x: T, depth: Int): Ok\n    Print an arbitrary value &quot;
 &amp; &quot;to stdout, up to some print depth. (Only available \n    on-line.)\n  s&quot;
 &amp; &quot;ys_printText(t: Text): Ok\n    Print a text to stdout. (Only available &quot;
 &amp; &quot;on-line.)\n  sys_printFlush(): Ok\n    Flush stdout. (Only available on&quot;
 &amp; &quot;-line.)\n  sys_pushSilence(): Ok\n    Push the silence stack; when non-&quot;
 &amp; &quot;empty nothing is printed. (Only available \n    on-line.)\n  sys_popSil&quot;
 &amp; &quot;ence(): Ok\n    Pop the silence stack (no-op on empty stack). (Only ava&quot;
 &amp; &quot;ilable on-line.)\n  sys_setPrompt(first: Text, next: Text): Ok\n    Set&quot;
 &amp; &quot; the interactive prompts (defaults: first=\&quot;- \&quot;, next=\&quot;  \&quot;). (Only \n&quot;
 &amp; &quot;    available on-line.)\n  sys_getSearchPath(): Text\n    Get the curre&quot;
 &amp; &quot;nt search path for \'load\' and such. (Only available on-line.)\n  sys_&quot;
 &amp; &quot;setSearchPath(t: Text): Ok\n    Set the current search path for \'load\'&quot;
 &amp; &quot; and such. (Only available on-line.)\n&quot;;

CONST E4 =
   &quot;  vbt_failure: Exception\n  vbt_mu: Mutex\n  vbt_show(vbt: VBT): Ok\n&quot;;

CONST E5 =
   &quot;  lex_failure: Exception\n  lex_scan(r: Rd, t: Text): Text ! rd_failure&quot;
 &amp; &quot; thread_alerted\n    Read from r the longest prefix formed of character&quot;
 &amp; &quot;s listed in t, and return \n    it.\n  lex_skip(r: Rd, t: Text): Ok ! r&quot;
 &amp; &quot;d_failure thread_alerted\n    Read from r the longest prefix formed of &quot;
 &amp; &quot;characters listed in t, and discard \n    it.\n  lex_match(r: Rd, t: Te&quot;
 &amp; &quot;xt): Ok ! lex_failure rd_failure thread_alerted\n    Read from r the st&quot;
 &amp; &quot;ring t and discard it; raise failure if not found.\n  lex_bool(r: Rd): &quot;
 &amp; &quot;Bool ! lex_failure rd_failure thread_alerted\n    Skip blanks, and atte&quot;
 &amp; &quot;mpt to read a boolean from r.\n  lex_int(r: Rd): Int ! lex_failure rd_f&quot;
 &amp; &quot;ailure thread_alerted\n    Skip blanks, and attempt to read an integer &quot;
 &amp; &quot;from r.\n  lex_real(r: Rd): Real ! lex_failure rd_failure thread_alerte&quot;
 &amp; &quot;d\n    Skip blanks, and attempt to read a real from r.\n&quot;;

CONST E6 =
   &quot;  net_failure: Exception\n  All(T)  net_who(o: T): Text ! net_failure t&quot;
 &amp; &quot;hread_alerted\n    Return a text indicating where a network object or e&quot;
 &amp; &quot;ngine is registered, or \n    the empty text if the argument is an obje&quot;
 &amp; &quot;ct that has not been registered \n    with a name server.\n  All(T&lt;:{})&quot;
 &amp; &quot; net_export(name: Text, server: Text, o: T): T \n    ! net_failure thre&quot;
 &amp; &quot;ad_alerted\n    Export an object under name \'name\', to the name serve&quot;
 &amp; &quot;r at IP address \n    \'server\'. The empty text denotes the local IP a&quot;
 &amp; &quot;ddress.\n  Some(T&lt;:{}) net_import(name: Text, server: Text): T \n    ! &quot;
 &amp; &quot;net_failure thread_alerted\n    Import the object of name \'name\', fro&quot;
 &amp; &quot;m the name server at IP address \n    \'server\'. The empty text denote&quot;
 &amp; &quot;s the local IP address.\n  All(T) net_exportEngine(name: Text, server: &quot;
 &amp; &quot;Text, arg: T): Ok \n    ! net_failure thread_alerted\n    Export an eng&quot;
 &amp; &quot;ine under name \'name\', to the name server at IP address \n    \'serve&quot;
 &amp; &quot;r\'. The empty text denotes the local IP address. The \'arg\' is given &quot;
 &amp; &quot;\n    as an argument to all procedures received by the engine to execut&quot;
 &amp; &quot;e.\n  Some(T)All(U) net_importEngine(name: Text, server: Text): ((T)-&gt;U&quot;
 &amp; &quot;)-&gt;U \n    ! net_failure thread_alerted\n    Import the object of name &quot;
 &amp; &quot;\'name\', from the name server at IP \n    address \'server\'. The empt&quot;
 &amp; &quot;y text denotes the local IP address.\n&quot;;

CONST E7 =
   &quot;  math_pi: Real\n    3.1415926535897932384626433833.\n  math_e: Real\n &quot;
 &amp; &quot;   2.7182818284590452353602874714.\n  math_degree: Real\n    0.01745329&quot;
 &amp; &quot;2519943295769236907684; 1 degree in radiants.\n  math_exp(n: Real): Rea&quot;
 &amp; &quot;l\n    e to the n-th power.\n  math_log(n: Real): Real\n    log base e.&quot;
 &amp; &quot;\n  math_sqrt(n: Real): Real\n    Square root.\n  math_hypot(n: Real, m&quot;
 &amp; &quot;: Real): Real\n    sqrt((n*n)+(m*m)).\n  math_pow(n: Real, m: Real): Re&quot;
 &amp; &quot;al\n    n to the m-th power.\n  math_cos(n: Real): Real\n    Cosine in &quot;
 &amp; &quot;radians.\n  math_sin(n: Real): Real\n    Sine in radians.\n  math_tan(n&quot;
 &amp; &quot;: Real): Real\n    Tangent in radians.\n  math_acos(n: Real): Real\n   &quot;
 &amp; &quot; Arc cosine in radians.\n  math_asin(n: Real): Real\n    Arc sine in ra&quot;
 &amp; &quot;dians.\n  math_atan(n: Real): Real\n    Arc tangent in radians.\n  math&quot;
 &amp; &quot;_atan2(n: Real, m: Real): Real\n    Arc tangent of n/m in radians.\n&quot;;

CONST E8 =
   &quot;  rects_failure: Exception \n  rects_new(): Rects \n    An empty displa&quot;
 &amp; &quot;y list of rectangles.\n  rects_setWorld(r: Rects, w: Real, e: Real, n: &quot;
 &amp; &quot;Real, s: Real): Ok\n    Set the world coordinates.\n  rects_setMargin(r&quot;
 &amp; &quot;: Rects, w: Real, e: Real, n: Real, s: Real): Ok\n    Set the window ma&quot;
 &amp; &quot;rgin in points.\n  rects_setMins(r: Rects, wd: Real, ht: Real): Ok\n   &quot;
 &amp; &quot; Set the minimum size for displaying an item, in points.\n  rects_setBg&quot;
 &amp; &quot;(r: Rects, c: Color): Ok\n    Set the window background color.\n  rects&quot;
 &amp; &quot;_setN(r: Rects, n: Int, redisplay: Bool): Ok\n    Set the number of rec&quot;
 &amp; &quot;tangles in the display list; they do not exist yet.\n  rects_setPositio&quot;
 &amp; &quot;n(r: Rects, n: Int, w: Real, e: Real, n: Real, s: Real,\n      redispla&quot;
 &amp; &quot;y: Bool): Ok\n    Set the position of the nth rectangle, then it exists&quot;
 &amp; &quot;.\n  rects_getPosition(r: Rects, n: Int): [4*Real]\n    Get the positio&quot;
 &amp; &quot;n of the nth rectangle; w,e,n,s.\n  rects_setColor(r: Rects, n: Int, c:&quot;
 &amp; &quot; Color, redisplay: Bool): Ok\n    Set the color of the nth rectangle, t&quot;
 &amp; &quot;hen it exists.\n  rects_delete(r: Rects, n: Int, redisplay: Bool): Ok\n&quot;
 &amp; &quot;    Delete the nth rectangle; then it does not exist.\n  rects_exists(r&quot;
 &amp; &quot;: Rects, n: Int): Ok\n    Does the nth rectangle exist.\n  rects_draw(r&quot;
 &amp; &quot;: Rects, n: Int): Ok\n    Draw the nth rectangle.\n  rects_erase(r: Rec&quot;
 &amp; &quot;ts, n: Int): Ok\n    Erase the nth rectangle.\n  rects_show(r: Rects): &quot;
 &amp; &quot;Ok \n    Show the window.\n  rects_hide(r: Rects): Ok \n    Hide the wi&quot;
 &amp; &quot;ndow.\n&quot;;

CONST E9 =
   &quot;  All(T) sys_copy(x: T): T ! net_failure\n    (also \'copy(x)\') Make a&quot;
 &amp; &quot; local copy of a value, including most distributed \n    values.\n  sys&quot;
 &amp; &quot;_getEnvVar(t: Text): Text\n    Return the value of the env variable who&quot;
 &amp; &quot;se name is t, or \&quot;\&quot; if there is no \n    such variable.\n  sys_paramC&quot;
 &amp; &quot;ount: Int\n    The number of program parameters.\n  sys_getParam(n: Int&quot;
 &amp; &quot;): Text\n    Return the n-th program parameter (indexed from 0).\n  sys&quot;
 &amp; &quot;_callFailure: Exception\n    Can be raised by Modula-3 code during a sy&quot;
 &amp; &quot;s_call.\n  Some(T)Some(U) sys_call(name: Text, args: [T]): U ! sys_call&quot;
 &amp; &quot;Failure\n    Call a pre-registered Modula-3 procedure.\n  sys_timeNow: &quot;
 &amp; &quot;Real\n    The current time\n  sys_timeGrain: Real\n    The time clock g&quot;
 &amp; &quot;ranularity\n&quot;;

CONST E10 =
   &quot;  thread_mutex(): Mutex\n    (also \'mutex()\') A new mutex.\n  thread_&quot;
 &amp; &quot;condition(): Condition\n    (also \'condition()\') A new condition.\n  &quot;
 &amp; &quot;Some(T) thread_self(): Thread(T)\n    The current thread.\n  All(T) thr&quot;
 &amp; &quot;ead_fork(f: ()-&gt;T, stackSize: Int): Thread(T)\n    (also \'fork(f,n)\')&quot;
 &amp; &quot; Fork a new thread executing f. If stackSize is zero, a \n    small def&quot;
 &amp; &quot;ault size is used.\n  All(T) thread_join(th: Thread(T)): T\n    (also \'&quot;
 &amp; &quot;join(th)\') Wait for a thread to complete, and return the result of \n &quot;
 &amp; &quot;   its procedure.\n  thread_wait(mx: Mutex, cd: Condition): Ok\n    (al&quot;
 &amp; &quot;so \'wait(mx,cd)\') Wait on a mutex and a condition.\n  thread_acquire(&quot;
 &amp; &quot;mx: Mutex): Ok\n    Acquire a mutex (use lock ... end instead).\n  thre&quot;
 &amp; &quot;ad_release(mx: Mutex): Ok\n    Release a mutex (use lock ... end instea&quot;
 &amp; &quot;d)\n  thread_broadcast(cd: Condition): Ok\n    (also \'broadcast(cd)\')&quot;
 &amp; &quot; Wake-up to all threads waiting on a condition. \n  thread_signal(cd: C&quot;
 &amp; &quot;ondition): Ok\n    (also \'signal(cd)\') Wake-up at least one thread wa&quot;
 &amp; &quot;iting on a condition.\n  thread_pause(r: Real): Ok\n    (also \'pause(r&quot;
 &amp; &quot;)\') Pause the current thread for r seconds.\n  All(T) thread_lock(m: M&quot;
 &amp; &quot;utex, body: ()-&gt;T): T\n    Execute under a locked mutex (use lock ... e&quot;
 &amp; &quot;nd instead).\n  thread_alerted: Exception\n    (See the threads spec.)\n&quot;
 &amp; &quot;  All(T) thread_alert(t: Thread(T)): Ok\n    (See the threads spec.)\n &quot;
 &amp; &quot; thread_testAlert(): Bool\n    (See the threads spec.)\n  thread_alertW&quot;
 &amp; &quot;ait(mx: Mutex, cd: Condition): Ok ! thread_alerted\n    (See the thread&quot;
 &amp; &quot;s spec.)\n  All(T) thread_alertJoin(th: Thread(T)): Ok ! thread_alerted&quot;
 &amp; &quot;\n    (See the threads spec.)\n  thread_alertPause(r: Real): Ok ! threa&quot;
 &amp; &quot;d_alerted\n    (See the threads spec.)\n  thread_pool(maxThreads maxIdl&quot;
 &amp; &quot;eThreads stackSize: int): WorkerPool\n    create a new thread worker po&quot;
 &amp; &quot;ol, with at most maxThreads active\n    threads, maxIdleThreads idle th&quot;
 &amp; &quot;reads.  If stackSize is zero, a \n    small default size is used.\n  th&quot;
 &amp; &quot;read_addWork(pool: WorkerPool, work: ()-&gt;ok): Ok\n    add a piece of wo&quot;
 &amp; &quot;rk to the work queue for the thread pool.  work \n    is represented b&quot;;

CONST E10_0 =
   &quot;y a procedure that performs the work\n  thread_stealWorker(pool: Worker&quot;
 &amp; &quot;Pool): Bool\n    steal a worker thread from a worker pool.  Removes the&quot;
 &amp; &quot; current thread\n    from the list of threads performing work for the p&quot;
 &amp; &quot;ool (allowing another\n    to be created).   If a piece of work will re&quot;
 &amp; &quot;quire a thread to be idle \n    for a long period of time,  this functi&quot;
 &amp; &quot;on can be called.\n  thread_finish(pool: WorkerPool): Ok\n    wait for &quot;
 &amp; &quot;all the work in the thread pool work queue to be finished.\n&quot;;

CONST E11 =
   &quot;  fmt_padLft(t: Text, length: Int): Text\n    If t is shorted then leng&quot;
 &amp; &quot;th, pad t with blanks on the left so that it has \n    the given length&quot;
 &amp; &quot;.\n  fmt_padRht(t: Text, length: Int): Text\n    If t is shorted then l&quot;
 &amp; &quot;ength, pad t with blanks on the right so that it has \n    the given le&quot;
 &amp; &quot;ngth.\n  fmt_bool(b: Bool): Text\n    Convert a boolean to its printabl&quot;
 &amp; &quot;e form.\n  fmt_int(n: Int): Text\n    Convert an integer to its printab&quot;
 &amp; &quot;le form.\n  fmt_real(r: Real): Text\n    Convert a real to its printabl&quot;
 &amp; &quot;e form.\n&quot;;

CONST E12 =
   &quot;  replica_failure: Exception       \n  replica_fatal: Exception        &quot;
 &amp; &quot;\n  All(T&lt;:[replica]{}) replica_acquire(o: T): Ok \n\t! replica_failure&quot;
 &amp; &quot; thread_alerted\n  All(T&lt;:[replica]{}) replica_release(o: T): Ok\n\t! r&quot;
 &amp; &quot;eplica_failure thread_alerted\n  replica_setNodeName(name: Text): Text &quot;
 &amp; &quot;! replica_failure thread_alerted  \n  replica_setDefaultSequencer(host &quot;
 &amp; &quot;name: Text): Ok \n\t! replica_failure thread_alerted  \n  All(T&lt;:[repli&quot;
 &amp; &quot;ca]{}, S:[simple]{}) replica_notify(o: T, n: S): callback\n\t! replica_&quot;
 &amp; &quot;failure\n  All(T&lt;:[replica]{}) replica_cancelNotifier(o: T)\n  replica_&quot;
 &amp; &quot;dumpState(): Ok;\n&quot;;

CONST E13 =
   &quot;  graph_failure: Exception \n  graph_new(): Graph \n  graph_redisplay(g&quot;
 &amp; &quot;: Graph): Ok \n  graph_animate(g: Graph, t0:Real, t1: Real): Ok \n  gra&quot;
 &amp; &quot;ph_clear(g: Graph): Ok \n  graph_setWorld(g: Graph, w: Real, e: Real, n&quot;
 &amp; &quot;: Real, s: Real): Ok \n  graph_setMargin(g: Graph, margin: Real): Ok \n&quot;
 &amp; &quot;  graph_setAspect(g: Graph, aspect: Real): Ok \n  graph_setPreferredSiz&quot;
 &amp; &quot;e(g: Graph, h: Real, v: Real): Ok \n  graph_setPixelSizeDivisor(g: Grap&quot;
 &amp; &quot;h, h: Real, v: Int): Ok \n  graph_verticesAt(g: Graph, w: Real, e: Real&quot;
 &amp; &quot;, n: Real, s: Real): [Vertex] \n  graph_vertexHiLisAt(g: Graph, w: Real&quot;
 &amp; &quot;, e: Real, n: Real, s: Real): [VertexHiLi]\n  graph_edgesAt(g: Graph, w&quot;
 &amp; &quot;: Real, e: Real, n: Real, s: Real): [Edge] \n  graph_polygonsAt(g: Grap&quot;
 &amp; &quot;h, w: Real, e: Real, n: Real, s: Real): [Polygon] \n  graph_setClickAct&quot;
 &amp; &quot;ion(g: Graph, p: (Graph,Real,Real)-&gt;Ok): Ok \n    set the procedure to &quot;
 &amp; &quot;be invoked on single AND double down mouse transitions\n  graph_setClic&quot;
 &amp; &quot;kReleaseAction(g: Graph, p: (Graph,Real,Real)-&gt;Ok): Ok \n    set the pr&quot;
 &amp; &quot;ocedure to be invoked on up mouse transitions\n  graph_setDoubleClickAc&quot;
 &amp; &quot;tion(g: Graph, p: (Graph,Real,Real)-&gt;Ok): Ok \n    set the procedure to&quot;
 &amp; &quot; be invoked on double down mouse transitions\n  \n  graph_newVertex(g: &quot;
 &amp; &quot;Graph): Vertex \n  graph_moveVertex(v: Vertex, x: Real, y: Real, animat&quot;
 &amp; &quot;e: Bool): Ok \n  graph_moveVertexOnPath(v: Vertex, path: (Real)-&gt;[2*Rea&quot;
 &amp; &quot;l]): Ok \n  graph_removeVertex(v: Vertex): Ok \n  graph_vertexToFront(v&quot;
 &amp; &quot;: Vertex): Ok \n  graph_vertexToBack(v: Vertex): Ok \n  graph_setVertex&quot;
 &amp; &quot;Size(v: Vertex, h: Real, v: Real): Ok \n  graph_setVertexShape(v: Verte&quot;
 &amp; &quot;x, shape: Text): Ok \n     (shape is \&quot;rectangle\&quot; or \&quot;ellipse\&quot;) \n  &quot;
 &amp; &quot;graph_setVertexColor(v: Vertex, c: Color): Ok \n  graph_setVertexFont(v&quot;
 &amp; &quot;: Vertex, f: Font): Ok \n  graph_setVertexLabel(v: Vertex, label: Text)&quot;
 &amp; &quot;: Ok \n  graph_setVertexLabelColor(v: Vertex, c: Color}): Ok \n  graph_&quot;
 &amp; &quot;setVertexBorder(v: Vertex, border: Real): Ok \n  graph_setVertexBorderC&quot;
 &amp; &quot;olor(v: Vertex, c: Color): Ok \n  graph_getVertexPosition(v: Vertex): [&quot;
 &amp; &quot;2*Real] \n  \n  graph_newVertexHiLi(v: Vertex): Vertex&quot;;

CONST E13_0 =
   &quot;HiLi \n  graph_moveVertexHiLi(vh: VertexHiLi, v: Vertex, animate: Bool)&quot;
 &amp; &quot;: Ok \n  graph_removeVertexHiLi(vh: VertexHiLi): Ok \n  graph_vertexHiL&quot;
 &amp; &quot;iToFront(vh: VertexHiLi): Ok \n  graph_vertexHiLiToBack(vh: VertexHiLi)&quot;
 &amp; &quot;: Ok \n  graph_setVertexHiLiColor(vh: VertexHiLi, c: Color): Ok \n  gra&quot;
 &amp; &quot;ph_setVertexHiLiBorder(vh: VertexHiLi, h v: Real): Ok \n  graph_getVert&quot;
 &amp; &quot;exHiLiVertex(vh: VertexHiLi): Vertex \n  \n  graph_newEdge(v1:Vertex, v&quot;
 &amp; &quot;2: Vertex): Edge \n  graph_moveEdge(e: Edge, v1: Vertex, v2: Vertex, an&quot;
 &amp; &quot;imate: Bool): Ok \n  graph_moveEdgeBezier(e: Edge, v1: Vertex, v2: Vert&quot;
 &amp; &quot;ex, c1: Vertex, c2: Vertex,\n    animate: Bool): Ok \n  graph_removeEdg&quot;
 &amp; &quot;e(e: Edge): Ok \n  graph_edgeToFront(e: Edge): Ok \n  graph_edgeToBack(&quot;
 &amp; &quot;e: Edge): Ok \n  graph_setEdgeWidth(e: Edge, width: Real): Ok \n  graph&quot;
 &amp; &quot;_setEdgeColor(e: Edge, c: Color): Ok \n  graph_setEdgeArrows(e: Edge, a&quot;
 &amp; &quot;rrowAtV1: Bool, arrowAtV2: Bool): Ok \n  graph_getEdgeVertices(e: Edge)&quot;
 &amp; &quot;: [2*Vertex] \n  graph_getEdgeControls(e: Edge): [Vertex]\n    (returns&quot;
 &amp; &quot; 0 or 2 vertices) \n  \n  graph_newPolygon(vs: [Vertex]): Polygon \n  g&quot;
 &amp; &quot;raph_movePolygon(p: Polygon, vs: [Vertex], animate: Bool): Ok \n  graph&quot;
 &amp; &quot;_removePolygon(p: Polygon): Ok \n  graph_polygonToFront(p: Polygon): Ok&quot;
 &amp; &quot; \n  graph_polygonToBack(p: Polygon): Ok \n  graph_setPolygonColor(p: P&quot;
 &amp; &quot;olygon, c: Color): Ok \n  \n  graph_newFont(g: Graph, family: Text, siz&quot;
 &amp; &quot;e: Real, \n                slant: Text, weight: Text, foundry: Text): F&quot;
 &amp; &quot;ont \n    (family is \&quot;Helvetica\&quot;...; normal size is 0.0353; slant is &quot;
 &amp; &quot;\&quot;Roman\&quot;,\n    \&quot;Italic\&quot;, \&quot;Oblique\&quot;, \&quot;ReverseItalic\&quot;, \&quot;ReverseOb&quot;
 &amp; &quot;lique\&quot;, \&quot;Other\&quot;, \&quot;Any\&quot;; \n     weight is \&quot;bold\&quot;...; foundry is \&quot;&quot;
 &amp; &quot;*\&quot;... \n  graph_defaultFont: Font \n  \n  graph_newSpectrum(g: Graph):&quot;
 &amp; &quot; Spectrum \n    a spectrum is an animatable color; it is a legal color &quot;
 &amp; &quot;\n  graph_setSpectrumColor(s: Spectrum, c: Color): Ok \n    set the vis&quot;
 &amp; &quot;ible-right-now color of the spectrum \n  graph_setSpectrumRange(s: Spec&quot;
 &amp; &quot;trum, range: (Real)-&gt;Color): Ok \n    set the color range for future an&quot;
 &amp; &quot;imations; domain in 0.0..1.0 \n  \n  graph_show(g: Graph): Ok \n  graph&quot;
 &amp; &quot;_hide&quot;;

CONST E13_1 =
   &quot;(g: Graph): Ok \n  \n  Some(T&lt;:{}) graph_setObjectLayer(o: T, layer: In&quot;
 &amp; &quot;t): Ok \n    Don\'t use this call! layer= 0(fore), 1(normal), 2(back) \n&quot;
;

CONST E14 =
   &quot;  c: Char\n    A character in single quotes.\n  ascii_char(n: Int): Cha&quot;
 &amp; &quot;r\n    The ascii character of integer code \'n\'.\n  ascii_val(c: Char)&quot;
 &amp; &quot;: Int\t\n    The integer code of the ascii character \'c\'.\n&quot;;

CONST E15 =
   &quot;  true: Bool\n    The constant true.\n  false: Bool\n    The constant f&quot;
 &amp; &quot;alse.\n  All(T)All(U) bool_is(x: T, y: U): Bool\n    (also infix \'is\'&quot;
 &amp; &quot;) Identity predicate: value equality for \n    Ok, Bool, Int, Real, Cha&quot;
 &amp; &quot;r, Text, Exception; pointer equality otherwise.\n  All(T)All(U) bool_is&quot;
 &amp; &quot;not(x: T, y: U): Bool\n    (also infix \'isnot\') Negation of \'is\'.\n&quot;
 &amp; &quot;  bool_not(b: Bool): Bool\n    (also \'not(b)\')\n  bool_and(b1: Bool, &quot;
 &amp; &quot;b2: Bool): Bool\n    (also infix \'and\')\n  bool_or(b1: Bool, b2: Bool&quot;
 &amp; &quot;): Bool\n    (also infix \'or\')\n&quot;;

CONST E16 =
   &quot;  random_int(min, max: int): int\n  random_real(min, max: real): real\n&quot;
 &amp; &quot;    return a random number in the range [min, max]\n&quot;;

CONST E17 =
   &quot;TOP-LEVEL PHRASES                    \tany term or definition ended by &quot;
 &amp; &quot;\&quot;;\&quot;\n  a;                                 \t\n\nDEFINITIONS (identifi&quot;
 &amp; &quot;ers are denoted by \&quot;x\&quot;, terms are denoted by \&quot;a\&quot;)\n  let x1=a1,...,&quot;
 &amp; &quot;xn=an                \tdefinition of constant identifiers\n  let rec x1&quot;
 &amp; &quot;=a1,...,xn=an            \tdefinition of recursive procedures\n  var x1&quot;
 &amp; &quot;=a1,...,xn=an                \tdefinition of updatable identifiers\n\nS&quot;
 &amp; &quot;EQUENCES (denoted by \&quot;s\&quot;)           \teach \&quot;ai\&quot; (a term or a defini&quot;
 &amp; &quot;tion) is\n  a1;...;an                          \texecuted; yields \&quot;an\&quot;&quot;
 &amp; &quot; (or \&quot;ok\&quot; if n=0)\n\nTERMS (denoted by \&quot;a\&quot;,\&quot;b\&quot;,\&quot;c\&quot;; identifiers&quot;
 &amp; &quot; are denoted by \&quot;x\&quot;,\&quot;l\&quot;; \n       modules are denoted by \&quot;m\&quot;)\n  &quot;
 &amp; &quot;x\tm_x                      \tidentifiers\n  x:=a                      &quot;
 &amp; &quot;         \tassignment\n\n  ok  true  false  \'a\'  \&quot;abc\&quot;  3  1.5\tcon&quot;
 &amp; &quot;stants\n\n  [a1,...,an]                     \tarrays\n  a[b]\ta[b]:=c  &quot;
 &amp; &quot;             \t        array selection, array update\n  a[b for b\']\ta&quot;
 &amp; &quot;[b for b\']:=c        \tsubarray selection, subarray update\n\n  option&quot;
 &amp; &quot; l =&gt; s end              \tterm \&quot;s\&quot; tagged by \&quot;l\&quot;\n\n  proc(x1,...,&quot;
 &amp; &quot;xn) s end              \tprocedures\n  a(b1,...,bn)                    &quot;
 &amp; &quot;   \tprocedure invocation\n  m_x(a1,...,an)                     \tinvoc&quot;
 &amp; &quot;ation of \&quot;x\&quot; from module \&quot;m\&quot;\n  a b c                              &quot;
 &amp; &quot;\tinfix (right-ass.) version of \&quot;b(a,c)\&quot;\n\n  meth(x,x1,...,xn) s end&quot;
 &amp; &quot;            \tmethod with self \&quot;x\&quot;\n  umeth(x,x1,...,xn) s end       &quot;
 &amp; &quot;     \treplicated object update method\n  {l1=&gt;a1,...,ln=&gt;an}          &quot;
 &amp; &quot;      \tobject with fields named \&quot;l1\&quot;...\&quot;ln\&quot;\n  {protected, seriali&quot;
 &amp; &quot;zed, ...}          protected and serialized object\n  {simple, ...}    &quot;
 &amp; &quot;                     simple object\n  {replicated, ...}                &quot;
 &amp; &quot;     replicated object\n  {l1=&gt;alias l2 of a2 end,...}        \tobject &quot;
 &amp; &quot;with delegated fields\n  a.l    a.l(a1, ..., an)            \tfield sel&quot;
 &amp; &quot;ection / method invocation\n  a.l:=b                             \tfiel&quot;
 &amp; &quot;d update / method override\n  clone(a1,...,an)                      obj&quot;
 &amp; &quot;ect cloning\n  replicate(a,umethlist)                t&quot;;

CONST E17_0 =
   &quot;urning into a replicated object\n  simple(a)\t\t                turning&quot;
 &amp; &quot; into a simple object\n  remote(a)\t                        turning int&quot;
 &amp; &quot;o a remote object\n  a1.l1:=alias l2 of a2 end             field delega&quot;
 &amp; &quot;tion\n  delegate a1 to a2 end \t        object delegation\n  notify a1 &quot;
 &amp; &quot;with a2                     unreachable data value notification  \n  se&quot;
 &amp; &quot;tpickler (a1,a2,a3)\t\t\tpickle a1 using a2 for reading and\n\t\t\t\t\t&quot;
 &amp; &quot;a3 for writing\n  modulehelp m sort \&quot;s\&quot; short \&quot;sh\&quot; \&quot;long\&quot;\n\t\t\t&quot;
 &amp; &quot;\t\tsetup help for a module\n\t\t\t\t\t\n  d                           &quot;
 &amp; &quot;       \tdefinition\n  if s1 then s2                      \tconditional&quot;
 &amp; &quot;\n    elsif s3 then s4... else sn end  \t(\&quot;elsif\&quot;, \&quot;else\&quot; optional)&quot;
 &amp; &quot;\n  a andif b\ta orif b             \tconditional conjunction/disjuncti&quot;
 &amp; &quot;on\n  case s of l1(x1)=&gt;s1,...,             case over the tag \&quot;li\&quot; of&quot;
 &amp; &quot; an option\n    ln(xn)=&gt;sn else s0 end     \t        binding \&quot;xi\&quot; in &quot;
 &amp; &quot;\&quot;si\&quot; (\&quot;else\&quot; optional)\n  loop s end                         \tloop&quot;
 &amp; &quot;\n  for i=a to b do s end              \titeration through successive i&quot;
 &amp; &quot;ntegers\n  foreach i in a do s end            \titeration through an ar&quot;
 &amp; &quot;ray\n  foreach i in a map s end           \tyielding an array of the re&quot;
 &amp; &quot;sults\n  exit                               \texit the innermost loop, &quot;
 &amp; &quot;for, foreach\n\n  exception(\&quot;exc\&quot;)                   \tnew exception &quot;
 &amp; &quot;value named \&quot;exc\&quot;\n  raise(a)                           \traise an ex&quot;
 &amp; &quot;ception\n  try s except                       \texception capture\n    &quot;
 &amp; &quot;a1=&gt;s1,...,an=&gt;sn else s0 end     \t  (\&quot;else\&quot; optional)\n  try s1 fin&quot;
 &amp; &quot;ally s2 end                \tfinalization\n\n  condition()  signal(a)  &quot;
 &amp; &quot;broadcast(a)\tcreating and signaling a condition\n  watch s1 until s2 e&quot;
 &amp; &quot;nd                \twaiting for a signal and a boolean guard\n  fork(a1&quot;
 &amp; &quot;,a2)    join(a)\t        forking and joining a thread\n  pause(a)\t    &quot;
 &amp; &quot;                    pausing the current thread \n\n  mutex()\t         &quot;
 &amp; &quot;               creating a mutex\n  lock s1 do s2 end                \tl&quot;
 &amp; &quot;ocking a mutex in a scope\n  wait(a1,a2)                \t        waiti&quot;
 &amp; &quot;ng on a mutex for a condition\n\n  (s)          &quot;;

CONST E17_1 =
   &quot;                      \tblock structure / precedence group\n&quot;;

CONST E18 =
   &quot;  pickle_failure: Exception\n  All(T) pickle_write(w: Wr, v: T): Ok \n &quot;
 &amp; &quot;   ! pickle_failure wr_failure thread_alerted\n    Copy a value to a wr&quot;
 &amp; &quot;iter, similarly to sys_copy.\n  Some(T) pickle_read(r: Rd): T \n    ! p&quot;
 &amp; &quot;ickle_failure rd_failure rd_eofFailure thread_alerted\n    Copy a value&quot;
 &amp; &quot; from a reader, similarly to sys_copy.\n&quot;;

CONST E19 =
   &quot;  rd_failure: Exception\n  rd_eofFailure: Exception\n  rd_new(t: Text):&quot;
 &amp; &quot; Rd\n    A reader on a text (a Modula-3 TextRd).\n  rd_stdin: Rd\n    T&quot;
 &amp; &quot;he standard input (the Modula-3 Stdio.Stdin).\n  rd_open(fs: FileSystem&quot;
 &amp; &quot;, t: Text): Rd ! rd_failure\n    Given a file system and a file name, r&quot;
 &amp; &quot;eturns a reader on a file \n    (a Modula-3 FileRd, open for read). The&quot;
 &amp; &quot; local file system is available\n    through the predefined lexically s&quot;
 &amp; &quot;coped identifier \&quot;fileSys\&quot;.\n    Moreover, \&quot;fileSysReader\&quot; is a rea&quot;
 &amp; &quot;d-only local file system.\n  rd_getChar(r: Rd): Char ! rd_failure rd_eo&quot;
 &amp; &quot;fFailure thread_alerted\n    Get the next character from a reader.\n  r&quot;
 &amp; &quot;d_eof(r: Rd): Bool ! rd_failure thread_alerted\n    Test for the end-of&quot;
 &amp; &quot;-stream on a reader.\n  rd_unGetChar(r: Rd): Ok\n    Put the last chara&quot;
 &amp; &quot;cter obtained by getChar back into the reader \n    (unfortunately, it &quot;
 &amp; &quot;may crash if misused!).\n  rd_charsReady(r: Rd): Int ! rd_failure\n    &quot;
 &amp; &quot;The number of characters that can be read without blocking. \n  rd_getT&quot;
 &amp; &quot;ext(r: Rd, n: Int): Text ! rd_failure thread_alerted\n    Read the next&quot;
 &amp; &quot; n characters, or at most n on end-of-file.\n  rd_getLine(r: Rd): Text &quot;
 &amp; &quot;! rd_failure rd_eofFailure thread_alerted\n    Read the next line and r&quot;
 &amp; &quot;eturn it without including the end-of-line \n    character.\n  rd_index&quot;
 &amp; &quot;(r: Rd): Int\n    The current reader position.\n  rd_length(r: Rd): Int&quot;
 &amp; &quot; ! rd_failure thread_alerted\n    Length of a reader (including read pa&quot;
 &amp; &quot;rt).\n  rd_seek(r: Rd, n: Int): Ok ! rd_failure thread_alerted\n    Rep&quot;
 &amp; &quot;osition a reader.\n  rd_close(r: Rd): Ok ! rd_failure thread_alerted\n &quot;
 &amp; &quot;   Close a reader.\n  rd_intermittent(r: Rd): Bool\n    Whether the rea&quot;
 &amp; &quot;der is stream-like (not file-like).\n  rd_seekable(r: Rd): Bool\n    Wh&quot;
 &amp; &quot;ether the reader can be repositioned.\n  rd_closed(r: Rd): Bool\n    Wh&quot;
 &amp; &quot;ether the reader is closed.\n&quot;;

CONST E20 =
   &quot;  t: Text\n    A string in double quotes.\n  text_new(size: Int, init: &quot;
 &amp; &quot;Char): Text\n    A text of size \'size\', all filled with \'init\'.\n  &quot;
 &amp; &quot;text_empty(t: Text): Bool\n    Test for empty text.\n  text_length(t: T&quot;
 &amp; &quot;ext): Int\n    Length of a text.\n  text_equal(t1: Text, t2: Text): Boo&quot;
 &amp; &quot;l\n    Text equality (case sensitive).\n  text_char(t: Text, i: Int): C&quot;
 &amp; &quot;har\n    The i-th character of a text (if it exists); zero-indexed.\n  &quot;
 &amp; &quot;text_sub(t: Text, start: Int, size: Int): Text\n    The subtext beginni&quot;
 &amp; &quot;ng at \'start\', and of size \'size\' (if it exists).\n  text_&amp;(t1: Tex&quot;
 &amp; &quot;t, t2: Text): Text\n    (also infix \'&amp;\') The concatenation of two tex&quot;
 &amp; &quot;ts.\n  text_precedes(t1: Text, t2: Text): Bool\n    Whether \'t1\' prec&quot;
 &amp; &quot;edes \'t2\' in lexicographic (ascii) order.\n  text_decode(t: Text): Te&quot;
 &amp; &quot;xt\n    Every occurrence of an escape sequence is replaced by the corre&quot;
 &amp; &quot;sponding \n    non-printing formatting character:  \\\\ = \\;  \\\' = \'&quot;
 &amp; &quot;;  \\\&quot; = \&quot;;  \\n = LF; \n    \\r = CR;  \\t = HT;  \\f = FF;  \\t = H&quot;
 &amp; &quot;T;  \\xxx = xxx (octals 000..177);  \n    \\c = c (otherwise).\n  text_&quot;
 &amp; &quot;encode(t: Text): Text\n    Every occurrence of a non-printing formattin&quot;
 &amp; &quot;g character is replaced by an \n    escape sequence.\n  text_explode(se&quot;
 &amp; &quot;ps: Text, t: Text): [Text]\n    Splits an input text into a similarly o&quot;
 &amp; &quot;rdered array of texts, each a maximal \n    subsequence of the input te&quot;
 &amp; &quot;xt not containing sep chars. The empty text is \n    exploded as a sing&quot;
 &amp; &quot;leton array of the empty text. Each sep char in the input \n    produce&quot;
 &amp; &quot;s a break, so the size of the result is 1 + the number of sep chars \n &quot;
 &amp; &quot;   in the text. implode(explode( \&quot;c\&quot;,text),\'c\') is the identity.\n &quot;
 &amp; &quot; text_implode(sep: Char, a: [Text]): Text ! net_failure\n    Concatenat&quot;
 &amp; &quot;e an array of texts into a single text, separating the pieces by a \n  &quot;
 &amp; &quot;  single sep char. A zero-length array is imploded as the empty text. \n&quot;
 &amp; &quot;    explode(\&quot;c\&quot;,implode( \'c\',text)) is the identity provided that t&quot;
 &amp; &quot;he array has \n    positive size and sep does not occur in the array el&quot;
 &amp; &quot;ements.\n  text_hash(t: Text): Int\n    A hash function.\n  text_toInt(&quot;
 &amp; &quot;t: Text): Int\n  &quot;;

CONST E20_0 =
   &quot;  Convert a text to an integer (see also fmt_).\n  text_fromInt(n: Int)&quot;
 &amp; &quot;: Text\n    Convert an integer to a text (see also lex_).\n  text_findF&quot;
 &amp; &quot;irstChar(c: Char, t: Text, n: Int): Int\t\n    The index of the first o&quot;
 &amp; &quot;ccurrence of \'c\' in \'t\', past \'n\'. -1 if not found.\n  text_findL&quot;
 &amp; &quot;astChar(c: Char, t: Text, n: Int): Int\n    The index of the last occur&quot;
 &amp; &quot;rence of \'c\' in \'t\', before \'n\'. -1 if not found.\n  text_findFir&quot;
 &amp; &quot;st(p: Text, t: Text, n: Int): Int\n    The index of the first char of t&quot;
 &amp; &quot;he first occurrence of \'p\' in \'t\', past \'n\'. \n    -1 if not foun&quot;
 &amp; &quot;d.\n  text_findLast(p: Text, t: Text, n: Int): Int\n    The index of th&quot;
 &amp; &quot;e first char of the last occurrence of \'p\' in \'t\', before \n    \'n&quot;
 &amp; &quot;\'. -1 if not found.\n  text_replaceAll(old: Text, new: Text, t: Text):&quot;
 &amp; &quot; Text\n    Replace all occurrences of \'old\' by \'new\' in \'t\', as f&quot;
 &amp; &quot;ound by iterating \n    \'findFirst\'.\n&quot;;

CONST E21 =
   &quot;  zeus_failure: Exception\n  zeus_animate(g: Graph, t0: Real, t1: Real)&quot;
 &amp; &quot;: Ok\n&quot;;

CONST E22 =
   &quot;  n: Int\n    Positive integer constants.\n  ~n: Int\n    Negative inte&quot;
 &amp; &quot;ger constants.\n  int_minus(n: Int): Int\n      Integer negation.\n  in&quot;
 &amp; &quot;t_+(n1: Int, n2: Int): Int\n    Integer addition.\n  int_-(n1: Int, n2:&quot;
 &amp; &quot; Int): Int\n    Integer difference.\n  int_*(n1: Int, n2: Int): Int\n  &quot;
 &amp; &quot;  Integer multiplication.\n  int_/(n1: Int, n2: Int): Int\n    Integer &quot;
 &amp; &quot;division.\n  int_%(n1: Int, n2: Int): Int\n    (also infix \'%\') Integ&quot;
 &amp; &quot;er modulo.\n  int_&lt;(n1: Int, n2: Int): Bool\n    Integer less-than pred&quot;
 &amp; &quot;icate.\n  int_&gt;(n1: Int, n2: Int): Bool\n    Integer greater-than predi&quot;
 &amp; &quot;cate.\n  int_&lt;=(n1: Int, n2: Int): Bool\n    Integer no-greater-than pr&quot;
 &amp; &quot;edicate.\n  int_&gt;=(n1: Int, n2: Int): Bool\n    Integer no-less-than pr&quot;
 &amp; &quot;edicate.\n&quot;;

CONST E23 =
   &quot;  color_named(name: Text): Color\n    Get a color from its name (see th&quot;
 &amp; &quot;e ColorName M3 interface).\n  color_rgb(r: Real, g: Real, b: Real): Col&quot;
 &amp; &quot;or\n    Get a color from rgb (each 0.0 .. 1.0).\n  color_hsv(hr: Real, &quot;
 &amp; &quot;sr: Real, v: Real): Color\n    Get a color from hsv (each 0.0 .. 1.0).\n&quot;
 &amp; &quot;  color_r(c: Color): Real\n    The red color component.\n  color_g(c: C&quot;
 &amp; &quot;olor): Real\n    The green color component.\n  color_b(c: Color): Real\n&quot;
 &amp; &quot;    The blue color component.\n  color_h(c: Color): Real\n    The hue c&quot;
 &amp; &quot;olor component.\n  color_s(c: Color): Real\n    The saturation color co&quot;
 &amp; &quot;mponent.\n  color_v(c: Color): Real\n    The value color component.\n  &quot;
 &amp; &quot;color_brightness(c: Color): Real\n    The total brightness (0.0 .. 1.0)&quot;
 &amp; &quot;.\n&quot;;

CONST E24 =
   &quot;The ASCII characters are divided into the following classes:\n\n  Blank&quot;
 &amp; &quot;         HT LF FF CR SP\n  Reserved      \&quot; \' ~\n  Delimiter     ( ) ,&quot;
 &amp; &quot; . ; [ ] _ { } ? !\n  Special       # $ % &amp; * + - / : &lt; = &gt; @ \\ ^ |\n &quot;
 &amp; &quot; Digit         0 ... 9\n  Letter        A ... Z ` a ... z\n  Illegal   &quot;
 &amp; &quot;    all the others\n\nMoreover:\n\n  a StringChar is either\n  - any si&quot;
 &amp; &quot;ngle character that is not an Illegal character or one of \', \&quot;, \\.\n&quot;
 &amp; &quot;  - any of the pairs of characters \\\', \\\&quot;, \\\\.\n\n  a Comment is,&quot;
 &amp; &quot; recursively, a sequence of non-Illegal characters and comments, \n  en&quot;
 &amp; &quot;closed between \&quot;(*\&quot; and \&quot;*)\&quot;.\n\nFrom these, the following lexemes &quot;
 &amp; &quot;are formed:\n\n  Space     a sequence of Blanks and Comments.\n  AlphaN&quot;
 &amp; &quot;um  a sequence of Letters and Digits starting with a Letter.\n  Symbol &quot;
 &amp; &quot;   a sequence of Specials.\n  Char      a single StringChar enclosed be&quot;
 &amp; &quot;tween two \'.\n  String    a sequence of StringChars enclosed between t&quot;
 &amp; &quot;wo \&quot;.\n  Int       a sequence of Digits, possibly preceded by a single&quot;
 &amp; &quot; minus sign ~.\n  Real      two Ints separated by ., possibly preceded &quot;
 &amp; &quot;by ~.\n  Delimiter a single Delimiter character.\n\nA stream of charact&quot;
 &amp; &quot;ers is split into lexemes by always extracting the longest \nprefix tha&quot;
 &amp; &quot;t is a lexeme. Note that Delimiters do not stick to each other or to\no&quot;
 &amp; &quot;ther tokens even when they are not separated by Space, but some care mu&quot;
 &amp; &quot;st be \ntaken so that Symbols are not inadvertently merged.\n\nA token &quot;
 &amp; &quot;is either a Char, String, Int, Real, Delimiter, Identifier, or Keyword.&quot;
 &amp; &quot;\nOnce a stream of characters has been split into lexemes, tokens are e&quot;
 &amp; &quot;xtracted\nas follows. \n\n  Space lexemes do not produce tokens.\n  Cha&quot;
 &amp; &quot;r, String, Int, Real, and Delimiter lexemes are also tokens.\n  AlphaNu&quot;
 &amp; &quot;m and Symbol lexemes are Identifier tokens, except when they have been\n&quot;
 &amp; &quot;    explicitly declared to be keywords, in which case they are Keyword &quot;
 &amp; &quot;tokens.\n&quot;;

CONST E25 =
   &quot;  process_new(pr: Processor, nameAndArgs: [Text], mergeOut: Bool): Proc&quot;
 &amp; &quot;ess\n    Create a process from a processor and the given process name a&quot;
 &amp; &quot;nd arguments.\n    The local processor is available as the lexically sc&quot;
 &amp; &quot;oped identifier \n    \&quot;processor\&quot;. If mergeOut is true, use a single &quot;
 &amp; &quot;pipe for stdout and stderr.\n  process_in(p: Process): Wr\n    The stdi&quot;
 &amp; &quot;n pipe of a process.\n  process_out(p: Process): Rd\n    The stdout pip&quot;
 &amp; &quot;e of a process.\n  process_err(p: Process): Rd\n    The stderr pipe of &quot;
 &amp; &quot;a process.\n  process_complete(p: Process): Int\n    Wait for the proce&quot;
 &amp; &quot;ss to exit, close all its pipes, and return the exit code.\n  process_f&quot;
 &amp; &quot;ilter(pr: Processor, nameAndArgs: [Text], input: Text): Text \n    ! ne&quot;
 &amp; &quot;t_failure\n    Create a process from a processor and the given process &quot;
 &amp; &quot;name and arguments.\n    The local processor is available as the lexica&quot;
 &amp; &quot;lly scoped identifier \n    \&quot;processor\&quot;. The stderr output is merged &quot;
 &amp; &quot;to stdout.\n    Usage: feed the input to its stdin pipe and close it; r&quot;
 &amp; &quot;ead all the output\n    from its stdout pipe and close it; return the o&quot;
 &amp; &quot;utput.\n&quot;;

CONST E26 =
   &quot;  wr_failure: Exception\n  wr_new(): Wr\n    A writer to a text (a Modu&quot;
 &amp; &quot;la-3 TextWr).\n  wr_toText(w: Wr): Text\n    Emptying a writer to a tex&quot;
 &amp; &quot;t..\n  wr_stdout: Wr\n    The standard output (the Modula-3 Stdio.Stdou&quot;
 &amp; &quot;t).\n  wr_stderr: Wr\n    The standard error (the Modula-3 Stdio.Stderr&quot;
 &amp; &quot;).\n  wr_open(fs: FileSystem, t: Text): Wr ! wr_failure\n    Given a fi&quot;
 &amp; &quot;le system and a file name, returns a writer to the beginning of \n    a&quot;
 &amp; &quot; file (a Modula-3 FileWr, open for write). The local file system is \n &quot;
 &amp; &quot;   available through the predefined lexically scoped identifier \&quot;fileS&quot;
 &amp; &quot;ys\&quot;.\n  wr_openAppend(fs: FileSystem, t: Text): Wr ! wr_failure\n    G&quot;
 &amp; &quot;iven a file system and a file name, returns a writer to the end of file&quot;
 &amp; &quot; \n    (a Modula-3 FileWr, open for append). The local file system is a&quot;
 &amp; &quot;vailable\n    through the predefined lexically scoped identifier \&quot;file&quot;
 &amp; &quot;Sys\&quot;.\n  wr_putChar(w: Wr, c: Char): Ok ! wr_failure thread_alerted\n &quot;
 &amp; &quot;   Put a character to a writer .\n  wr_putText(w: Wr, t: Text): Ok ! wr&quot;
 &amp; &quot;_failure thread_alerted\n    Put a text to a writer .\n  wr_flush(w: Wr&quot;
 &amp; &quot;): Ok ! wr_failure thread_alerted\n    Flush a writer: all buffered wri&quot;
 &amp; &quot;tes to their final destination.\n  wr_index(w: Wr): Int\n    The curren&quot;
 &amp; &quot;t writer position\n  wr_length(w: Wr): Int ! wr_failure thread_alerted\n&quot;
 &amp; &quot;    Length of a writer.\n  wr_seek(w: Wr, n: Int): Ok ! wr_failure thre&quot;
 &amp; &quot;ad_alerted\n    Reposition a writer.\n  wr_close(w: Wr): Ok ! wr_failur&quot;
 &amp; &quot;e thread_alerted\n    Close a writer.\n  wr_buffered(w: Wr): Bool\n    &quot;
 &amp; &quot;Whether the writer is buffered.\n  wr_seekable(w: Wr): Bool\n    Whethe&quot;
 &amp; &quot;r the writer can be repositioned.\n  wr_closed(w: Wr): Bool\n    Whethe&quot;
 &amp; &quot;r the writer is closed.\n&quot;;

BEGIN
END ObliqBdl2.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
