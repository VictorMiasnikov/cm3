<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: m3middle/src/M3CG_BinRd.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>m3middle/src/M3CG_BinRd.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright 1996-2000, Critical Mass, Inc.  All rights reserved. 
 See file COPYRIGHT-CMASS for details. 

<P><PRE>MODULE <module><implements><A HREF="M3CG_BinRd.i3.html">M3CG_BinRd</A></implements></module>;

IMPORT <A HREF="../../libm3/src/fmtlex/Fmt.i3.html">Fmt</A>, <A HREF="../../libm3/src/rw/Rd.i3.html">Rd</A>, <A HREF="../../libm3/src/rw/Stdio.i3.html">Stdio</A>, <A HREF="../../m3core/src/text/Text.i3.html">Text</A>, <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../m3core/src/word/Word.i3.html">Word</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>;
IMPORT <A HREF="#x1">M3ID</A>, <A HREF="M3CG.i3.html">M3CG</A>, <A HREF="M3CG_Ops.i3.html">M3CG_Ops</A>, <A HREF="M3CG_Binary.i3.html">M3CG_Binary</A>;
IMPORT <A HREF="Target.i3.html">Target</A>, <A HREF="TargetMap.i3.html">TargetMap</A>, <A HREF="TInt.i3.html">TInt</A>, <A HREF="TFloat.i3.html">TFloat</A>, <A HREF="TWord.i3.html">TWord</A>;
FROM <A HREF="M3CG.i3.html">M3CG</A> IMPORT CompareOp, ConvertOp, AtomicOp, RuntimeError, MemoryOrder;

TYPE
  Bop = M3CG_Binary.Op;

CONST
  BufSize = 4096;

TYPE
  InputBuffer = REF ARRAY [0..BufSize-1] OF CHAR;

TYPE
  State = RECORD
    rd     : Rd.T;
    cg     : M3CG.T;
    buf    : InputBuffer;
    buf_len: CARDINAL;
    buf_ptr: CARDINAL;
    hit_eof: BOOLEAN;
    vars   : REF ARRAY OF M3CG.Var;
    procs  : REF ARRAY OF M3CG.Proc;
    labels : REF ARRAY OF M3CG.Label;
  END;

TYPE
  Cmd = RECORD
    bop  : Bop;
    proc : PROCEDURE (VAR s: State);
  END;

CONST
  CmdMap = ARRAY Bop OF Cmd {
    Cmd {Bop.begin_unit, begin_unit},
    Cmd {Bop.end_unit, end_unit},
    Cmd {Bop.import_unit, import_unit},
    Cmd {Bop.export_unit, export_unit},
    Cmd {Bop.set_source_file, set_source_file},
    Cmd {Bop.set_source_line, set_source_line},
    Cmd {Bop.declare_typename, declare_typename},
    Cmd {Bop.declare_array, declare_array},
    Cmd {Bop.declare_open_array, declare_open_array},
    Cmd {Bop.declare_enum, declare_enum},
    Cmd {Bop.declare_enum_elt, declare_enum_elt},
    Cmd {Bop.declare_packed, declare_packed},
    Cmd {Bop.declare_record, declare_record},
    Cmd {Bop.declare_field, declare_field},
    Cmd {Bop.declare_set, declare_set},
    Cmd {Bop.declare_subrange, declare_subrange},
    Cmd {Bop.declare_pointer, declare_pointer},
    Cmd {Bop.declare_indirect, declare_indirect},
    Cmd {Bop.declare_proctype, declare_proctype},
    Cmd {Bop.declare_formal, declare_formal},
    Cmd {Bop.declare_raises, declare_raises},
    Cmd {Bop.declare_object, declare_object},
    Cmd {Bop.declare_method, declare_method},
    Cmd {Bop.declare_opaque, declare_opaque},
    Cmd {Bop.reveal_opaque, reveal_opaque},
    Cmd {Bop.declare_exception, declare_exception},
    Cmd {Bop.set_runtime_proc, set_runtime_proc},
    Cmd {Bop.set_runtime_hook, set_runtime_hook},
    Cmd {Bop.import_global, import_global},
    Cmd {Bop.declare_segment, declare_segment},
    Cmd {Bop.bind_segment, bind_segment},
    Cmd {Bop.declare_global, declare_global},
    Cmd {Bop.declare_constant, declare_constant},
    Cmd {Bop.declare_local, declare_local},
    Cmd {Bop.declare_param, declare_param},
    Cmd {Bop.declare_temp, declare_temp},
    Cmd {Bop.free_temp, free_temp},
    Cmd {Bop.begin_init, begin_init},
    Cmd {Bop.end_init, end_init},
    Cmd {Bop.init_int, init_int},
    Cmd {Bop.init_proc, init_proc},
    Cmd {Bop.init_label, init_label},
    Cmd {Bop.init_var, init_var},
    Cmd {Bop.init_offset, init_offset},
    Cmd {Bop.init_chars, init_chars},
    Cmd {Bop.init_float, init_float},
    Cmd {Bop.import_procedure, import_procedure},
    Cmd {Bop.declare_procedure, declare_procedure},
    Cmd {Bop.begin_procedure, begin_procedure},
    Cmd {Bop.end_procedure, end_procedure},
    Cmd {Bop.begin_block, begin_block},
    Cmd {Bop.end_block, end_block},
    Cmd {Bop.note_procedure_origin, note_procedure_origin},
    Cmd {Bop.set_label, set_label},
    Cmd {Bop.jump, jump},
    Cmd {Bop.if_true, if_true},
    Cmd {Bop.if_false, if_false},
    Cmd {Bop.if_eq, if_eq},
    Cmd {Bop.if_ne, if_ne},
    Cmd {Bop.if_gt, if_gt},
    Cmd {Bop.if_ge, if_ge},
    Cmd {Bop.if_lt, if_lt},
    Cmd {Bop.if_le, if_le},
    Cmd {Bop.case_jump, case_jump},
    Cmd {Bop.exit_proc, exit_proc},
    Cmd {Bop.load, load},
    Cmd {Bop.load_address, load_address},
    Cmd {Bop.load_indirect, load_indirect},
    Cmd {Bop.store, store},
    Cmd {Bop.store_indirect, store_indirect},
    Cmd {Bop.load_nil, load_nil},
    Cmd {Bop.load_integer, load_integer},
    Cmd {Bop.load_float, load_float},
    Cmd {Bop.eq, eq},
    Cmd {Bop.ne, ne},
    Cmd {Bop.gt, gt},
    Cmd {Bop.ge, ge},
    Cmd {Bop.lt, lt},
    Cmd {Bop.le, le},
    Cmd {Bop.add, add},
    Cmd {Bop.subtract, subtract},
    Cmd {Bop.multiply, multiply},
    Cmd {Bop.divide, divide},
    Cmd {Bop.negate, negate},
    Cmd {Bop.abs, abs},
    Cmd {Bop.max, max},
    Cmd {Bop.min, min},
    Cmd {Bop.round, round},
    Cmd {Bop.trunc, trunc},
    Cmd {Bop.floor, floor},
    Cmd {Bop.ceiling, ceiling},
    Cmd {Bop.cvt_float, cvt_float},
    Cmd {Bop.div, div},
    Cmd {Bop.mod, mod},
    Cmd {Bop.set_union, set_union},
    Cmd {Bop.set_difference, set_difference},
    Cmd {Bop.set_intersection, set_intersection},
    Cmd {Bop.set_sym_difference, set_sym_difference},
    Cmd {Bop.set_member, set_member},
    Cmd {Bop.set_eq, set_eq},
    Cmd {Bop.set_ne, set_ne},
    Cmd {Bop.set_lt, set_lt},
    Cmd {Bop.set_le, set_le},
    Cmd {Bop.set_gt, set_gt},
    Cmd {Bop.set_ge, set_ge},
    Cmd {Bop.set_range, set_range},
    Cmd {Bop.set_singleton, set_singleton},
    Cmd {Bop.not, not},
    Cmd {Bop.and, and},
    Cmd {Bop.or, or},
    Cmd {Bop.xor, xor},
    Cmd {Bop.shift, shift},
    Cmd {Bop.shift_left, shift_left},
    Cmd {Bop.shift_right, shift_right},
    Cmd {Bop.rotate, rotate},
    Cmd {Bop.rotate_left, rotate_left},
    Cmd {Bop.rotate_right, rotate_right},
    Cmd {Bop.widen, widen},
    Cmd {Bop.chop, chop},
    Cmd {Bop.extract, extract},
    Cmd {Bop.extract_n, extract_n},
    Cmd {Bop.extract_mn, extract_mn},
    Cmd {Bop.insert, insert},
    Cmd {Bop.insert_n, insert_n},
    Cmd {Bop.insert_mn, insert_mn},
    Cmd {Bop.swap, swap},
    Cmd {Bop.pop, pop},
    Cmd {Bop.copy_n, copy_n},
    Cmd {Bop.copy, copy},
    Cmd {Bop.zero_n, zero_n},
    Cmd {Bop.zero, zero},
    Cmd {Bop.loophole, loophole},
    Cmd {Bop.abort, abort},
    Cmd {Bop.check_nil, check_nil},
    Cmd {Bop.check_lo, check_lo},
    Cmd {Bop.check_hi, check_hi},
    Cmd {Bop.check_range, check_range},
    Cmd {Bop.check_index, check_index},
    Cmd {Bop.check_eq, check_eq},
    Cmd {Bop.add_offset, add_offset},
    Cmd {Bop.index_address, index_address},
    Cmd {Bop.start_call_direct, start_call_direct},
    Cmd {Bop.call_direct, call_direct},
    Cmd {Bop.start_call_indirect, start_call_indirect},
    Cmd {Bop.call_indirect, call_indirect},
    Cmd {Bop.pop_param, pop_param},
    Cmd {Bop.pop_struct, pop_struct},
    Cmd {Bop.pop_static_link, pop_static_link},
    Cmd {Bop.load_procedure, load_procedure},
    Cmd {Bop.load_static_link, load_static_link},
    Cmd {Bop.comment, comment},
    Cmd {Bop.store_ordered, store_ordered},
    Cmd {Bop.load_ordered, load_ordered},
    Cmd {Bop.exchange, exchange},
    Cmd {Bop.compare_exchange, compare_exchange},
    Cmd {Bop.fence, fence},
    Cmd {Bop.fetch_and_add,  fetch_and_add},
    Cmd {Bop.fetch_and_sub,  fetch_and_sub},
    Cmd {Bop.fetch_and_or,   fetch_and_or},
    Cmd {Bop.fetch_and_and,  fetch_and_and},
    Cmd {Bop.fetch_and_xor,  fetch_and_xor}
  };

PROCEDURE <A NAME="Inhale"><procedure>Inhale</procedure></A> (rd: Rd.T;  cg: M3CG.T) =
  VAR s: State;  op: M3CG.Name;  cmd: INTEGER;
  BEGIN
    s.rd      := rd;
    s.cg      := cg;
    s.buf     := NEW (InputBuffer);
    s.buf_len := 0;
    s.buf_ptr := 0;
    s.hit_eof := FALSE;
    s.vars    := NEW (REF ARRAY OF M3CG.Var, 400);
    s.procs   := NEW (REF ARRAY OF M3CG.Proc, 50);
    s.labels  := NEW (REF ARRAY OF M3CG.Label, 400);

    FOR i := 0 TO LAST(s.labels^) DO s.labels[i] := M3CG.No_label END;

    cmd := Scan_int (s);
    IF (cmd # M3CG_Binary.Version) THEN
      Error (s, &quot;** bad intermediate code version: expected &quot;,
                Fmt.Int (M3CG_Binary.Version) &amp; &quot;, but found &quot;,
                Fmt.Int (cmd));
    END;

    LOOP
      op := Scan_int (s);
      IF (s.hit_eof) THEN
        EXIT;
      ELSIF (op &lt; 0) OR (ORD (LAST (Bop)) &lt; op) THEN
        Error (s, &quot;** bad intermediate code operator: &quot;, Fmt.Int (op));
      ELSE
        CmdMap [VAL (op, Bop)].proc (s);
      END;
    END;
  END Inhale;

PROCEDURE <A NAME="Error"><procedure>Error</procedure></A> (&lt;*UNUSED*&gt; VAR s: State;  a, b, c: TEXT := NIL) =
  &lt;*FATAL Wr.Failure, Thread.Alerted*&gt;
  VAR msg := Target.EOL &amp; &quot;** ERROR in M3CG_BinRd.Inhale: &quot;;
  BEGIN
    IF (a # NIL) THEN msg := msg &amp; a END;
    IF (b # NIL) THEN msg := msg &amp; b END;
    IF (c # NIL) THEN msg := msg &amp; c END;
    msg := msg &amp; &quot; **&quot; &amp; Target.EOL;
    Wr.PutText (Stdio.stdout, msg);
    Wr.Flush(Stdio.stdout);
  END Error;
</PRE>--------------------------------------------------------------- parsing ---

<P><PRE>PROCEDURE <A NAME="Scan_name"><procedure>Scan_name</procedure></A> (VAR s: State): M3CG.Name =
  VAR txt := Scan_text (s);
  BEGIN
    IF (txt = NIL)
      THEN RETURN M3ID.NoID;
      ELSE RETURN M3ID.Add (txt);
    END;
  END Scan_name;

PROCEDURE <A NAME="Scan_text"><procedure>Scan_text</procedure></A> (VAR s: State): TEXT =
  VAR
    len := Scan_int (s);
    txt : TEXT;
    buf : ARRAY [0..255] OF CHAR;
  BEGIN
    IF (len &lt; 0) THEN  RETURN NIL; END;
    txt := &quot;&quot;;
    WHILE (len &gt; NUMBER (buf)) DO
      FOR i := 0 TO LAST(buf) DO buf[i] := VAL (GetByte (s), CHAR); END;
      txt := txt &amp; Text.FromChars (buf);
      DEC (len, NUMBER (buf));
    END;
    IF (len &gt; 0) THEN
      FOR i := 0 TO len-1 DO buf[i] := VAL (GetByte (s), CHAR); END;
      txt := txt &amp; Text.FromChars (SUBARRAY (buf, 0, len));
    END;
    RETURN txt;
  END Scan_text;

PROCEDURE <A NAME="Scan_type"><procedure>Scan_type</procedure></A> (VAR s: State): M3CG.Type =
  VAR x := Scan_int (s);
  BEGIN
    IF (ORD (FIRST (M3CG.Type)) &lt;= x) AND (x &lt;= ORD (LAST (M3CG.Type))) THEN
      RETURN VAL (x, M3CG.Type);
    ELSE
      Error (s, &quot;illegal type: &quot;, Fmt.Int (x));
      RETURN M3CG.Type.Int32;
    END;
  END Scan_type;

PROCEDURE <A NAME="Scan_bool"><procedure>Scan_bool</procedure></A> (VAR s: State): BOOLEAN =
  VAR x := Scan_int (s);
  BEGIN
    CASE x OF
    | ORD (FALSE) =&gt; RETURN FALSE;
    | ORD (TRUE)  =&gt; RETURN TRUE;
    ELSE Error (s, &quot;illegal boolean: &quot;, Fmt.Int (x));
    END;
    RETURN TRUE;
  END Scan_bool;

PROCEDURE <A NAME="Scan_label"><procedure>Scan_label</procedure></A> (VAR s: State): INTEGER =
  VAR val, x: INTEGER;
  BEGIN
    val := Scan_int (s);
    IF (val &lt; 0) THEN RETURN M3CG.No_label; END;

    WHILE (val &gt; LAST (s.labels^)) DO ExpandLabels (s) END;

    x := s.labels[val];
    IF (x = M3CG.No_label) THEN
      x := s.cg.next_label ();
      s.labels[val] := x;
    END;
    RETURN x;
  END Scan_label;

PROCEDURE <A NAME="ExpandLabels"><procedure>ExpandLabels</procedure></A> (VAR s: State) =
  VAR new := NEW (REF ARRAY OF M3CG.Label, 2 * NUMBER (s.labels^));
  BEGIN
    SUBARRAY (new^, 0, NUMBER (s.labels^)) := s.labels^;
    FOR i := NUMBER (s.labels^) TO LAST (new^) DO new[i] := M3CG.No_label END;
    s.labels := new;
  END ExpandLabels;

PROCEDURE <A NAME="Scan_tipe"><procedure>Scan_tipe</procedure></A> (VAR s: State): M3CG.TypeUID =
  BEGIN
    RETURN Scan_int (s);
  END Scan_tipe;

PROCEDURE <A NAME="Scan_var"><procedure>Scan_var</procedure></A> (VAR s: State): M3CG.Var =
  VAR id := Scan_int (s);
  BEGIN
    IF (id &lt;= 0)
      THEN RETURN NIL;
      ELSE RETURN s.vars[id];
    END;
  END Scan_var;

PROCEDURE <A NAME="Scan_proc"><procedure>Scan_proc</procedure></A> (VAR s: State): M3CG.Proc =
  VAR id := Scan_int (s);
  BEGIN
    IF (id &lt;= 0)
      THEN RETURN NIL;
      ELSE RETURN s.procs[id];
    END;
  END Scan_proc;

PROCEDURE <A NAME="Scan_sign"><procedure>Scan_sign</procedure></A> (VAR s: State): M3CG.Sign =
  VAR x := Scan_int (s);
  BEGIN
    CASE x OF
    | ORD (M3CG.Sign.Positive) =&gt; RETURN M3CG.Sign.Positive;
    | ORD (M3CG.Sign.Negative) =&gt; RETURN M3CG.Sign.Negative;
    | ORD (M3CG.Sign.Unknown)  =&gt; RETURN M3CG.Sign.Unknown;
    ELSE Error (s, &quot;bad sign: &quot;, Fmt.Int (x));
    END;
    RETURN M3CG.Sign.Unknown;
  END Scan_sign;

PROCEDURE <A NAME="Scan_callConv"><procedure>Scan_callConv</procedure></A> (VAR s: State): Target.CallingConvention =
  VAR
    id := Scan_int (s);
    cc := Target.ConventionFromID (id);
  BEGIN
    IF (cc = NIL) THEN
      Error (s, &quot;unknown calling convention: &quot;, Fmt.Int (id));
    END;
    RETURN cc;
  END Scan_callConv;

PROCEDURE <A NAME="Scan_float"><procedure>Scan_float</procedure></A> (VAR s: State): Target.Float =
  VAR
    i       := Scan_int (s);
    pre     := Target.Precision.Short;
    n_bytes : INTEGER;
    bytes   : ARRAY [0..BYTESIZE(EXTENDED)] OF TFloat.Byte;
    result  : Target.Float;
  BEGIN
    CASE i OF
    | ORD (Target.Precision.Short)    =&gt; pre := Target.Precision.Short;
    | ORD (Target.Precision.Long)     =&gt; pre := Target.Precision.Long;
    | ORD (Target.Precision.Extended) =&gt; pre := Target.Precision.Extended;
    ELSE Error (s, &quot;bad floating-point precision: &quot;, Fmt.Int (i));
    END;
    n_bytes := TargetMap.Float_types[pre].size DIV BITSIZE (TFloat.Byte);
    FOR x := 0 TO n_bytes-1 DO bytes[x] := Scan_int (s); END;
    TFloat.FromBytes (SUBARRAY (bytes, 0, n_bytes), pre, result);
    RETURN result;
  END Scan_float;

PROCEDURE <A NAME="Scan_Tint"><procedure>Scan_Tint</procedure></A> (VAR s: State): Target.Int =
  VAR
    i : INTEGER := GetByte (s);
    n_bytes, sign, shift: INTEGER;
    val, byte: Target.Int;
    ok: BOOLEAN;
  BEGIN
    CASE i OF
    | M3CG_Binary.Int1  =&gt;  n_bytes := 1;  sign := +1;
    | M3CG_Binary.NInt1 =&gt;  n_bytes := 1;  sign := -1;
    | M3CG_Binary.Int2  =&gt;  n_bytes := 2;  sign := +1;
    | M3CG_Binary.NInt2 =&gt;  n_bytes := 2;  sign := -1;
    | M3CG_Binary.Int4  =&gt;  n_bytes := 4;  sign := +1;
    | M3CG_Binary.NInt4 =&gt;  n_bytes := 4;  sign := -1;
    | M3CG_Binary.Int8  =&gt;  n_bytes := 8;  sign := +1;
    | M3CG_Binary.NInt8 =&gt;  n_bytes := 8;  sign := -1;
    ELSE
      ok := TInt.FromInt (i, NUMBER (val.x), val);  &lt;*ASSERT ok*&gt;
      RETURN val;
    END;

    val := TInt.Zero;  shift := 0;
    FOR i := 0 TO n_bytes-1 DO
      ok := TInt.FromInt (GetByte (s), NUMBER (byte.x), byte);  &lt;*ASSERT ok*&gt;
      TWord.Shift (byte, shift, byte);
      TWord.Or (val, byte, val);
      INC (shift, 8);
    END;
    IF (sign &lt; 0) THEN
      TWord.Subtract (TInt.Zero, val, val);
    END;

    RETURN val;
  END Scan_Tint;

PROCEDURE <A NAME="Scan_int"><procedure>Scan_int</procedure></A> (VAR s: State): INTEGER =
  VAR i := GetByte (s);  n_bytes, sign, val, shift: INTEGER;
  BEGIN
    CASE i OF
    | M3CG_Binary.Int1  =&gt;  RETURN GetByte (s);
    | M3CG_Binary.NInt1 =&gt;  RETURN - GetByte (s);
    | M3CG_Binary.Int2  =&gt;  n_bytes := 2;  sign := +1;
    | M3CG_Binary.NInt2 =&gt;  n_bytes := 2;  sign := -1;
    | M3CG_Binary.Int4  =&gt;  n_bytes := 4;  sign := +1;
    | M3CG_Binary.NInt4 =&gt;  n_bytes := 4;  sign := -1;
    | M3CG_Binary.Int8  =&gt;  n_bytes := 8;  sign := +1;
    | M3CG_Binary.NInt8 =&gt;  n_bytes := 8;  sign := -1;
    ELSE                    RETURN i;
    END;
    val := 0;  shift := 0;
    FOR x := 0 TO n_bytes-1 DO
      val := Word.Or (val, Word.LeftShift (GetByte (s), shift));
      INC (shift, 8);
    END;
    RETURN sign * val;
  END Scan_int;

PROCEDURE <A NAME="Scan_error"><procedure>Scan_error</procedure></A> (VAR s: State): RuntimeError =
  VAR x := Scan_int (s);
  BEGIN
    IF (x &lt; ORD (FIRST (RuntimeError))) OR (ORD (LAST (RuntimeError)) &lt; x) THEN
      Error (s, &quot;bad error code: &quot;, Fmt.Int (x));
      x := ORD (FIRST (RuntimeError));
    END;
    RETURN VAL (x, RuntimeError);
  END Scan_error;

TYPE Byte = [0..255];

PROCEDURE <A NAME="GetByte"><procedure>GetByte</procedure></A> (VAR s: State): Byte =
  VAR val: Byte;
  BEGIN
    IF (s.buf_ptr &gt;= s.buf_len) THEN RefillBuffer (s) END;
    val := ORD (s.buf[s.buf_ptr]);  INC (s.buf_ptr);
    RETURN val;
  END GetByte;

PROCEDURE <A NAME="RefillBuffer"><procedure>RefillBuffer</procedure></A> (VAR s: State) =
  &lt;*FATAL Rd.Failure, Thread.Alerted*&gt;
  BEGIN
    s.buf_ptr := 0;
    s.buf_len := Rd.GetSub (s.rd, s.buf^);
    IF (s.buf_len &lt;= 0) THEN
      s.hit_eof := TRUE;
      s.buf_len := 1;
      s.buf[0]  := '\000';
    END;
  END RefillBuffer;
</PRE>----------------------------------------------------- compilation units ---

<P><PRE>PROCEDURE <A NAME="begin_unit"><procedure>begin_unit</procedure></A> (VAR s: State) =
  VAR optimize := Scan_int (s);
  BEGIN
    s.cg.begin_unit (optimize);
  END begin_unit;

PROCEDURE <A NAME="end_unit"><procedure>end_unit</procedure></A>   (VAR s: State) =
  BEGIN
    s.cg.end_unit ();
  END end_unit;

PROCEDURE <A NAME="import_unit"><procedure>import_unit</procedure></A> (VAR s: State) =
  VAR name := Scan_name (s);
  BEGIN
    s.cg.import_unit (name);
  END import_unit;

PROCEDURE <A NAME="export_unit"><procedure>export_unit</procedure></A> (VAR s: State) =
  VAR name := Scan_name (s);
  BEGIN
    s.cg.export_unit (name);
  END export_unit;
</PRE>------------------------------------------------ debugging line numbers ---

<P><PRE>PROCEDURE <A NAME="set_source_file"><procedure>set_source_file</procedure></A> (VAR s: State) =
  VAR file := Scan_text (s);
  BEGIN
    s.cg.set_source_file (file);
  END set_source_file;

PROCEDURE <A NAME="set_source_line"><procedure>set_source_line</procedure></A> (VAR s: State) =
  VAR line := Scan_int (s);
  BEGIN
    s.cg.set_source_line (line);
  END set_source_line;
</PRE>------------------------------------------- debugging type declarations ---

<P><PRE>PROCEDURE <A NAME="declare_typename"><procedure>declare_typename</procedure></A> (VAR s: State) =
  VAR type := Scan_tipe (s);
      name := Scan_name (s);
  BEGIN
    s.cg.declare_typename (type, name);
  END declare_typename;

PROCEDURE <A NAME="declare_array"><procedure>declare_array</procedure></A> (VAR s: State)=
  VAR type  := Scan_tipe (s);
      index := Scan_tipe (s);
      elt   := Scan_tipe (s);
      size  := Scan_int (s);
  BEGIN
    s.cg.declare_array (type, index, elt, size);
  END declare_array;

PROCEDURE <A NAME="declare_open_array"><procedure>declare_open_array</procedure></A> (VAR s: State)=
  VAR type  := Scan_tipe (s);
      elt   := Scan_tipe (s);
      size  := Scan_int (s);
  BEGIN
    s.cg.declare_open_array (type, elt, size);
  END declare_open_array;

PROCEDURE <A NAME="declare_enum"><procedure>declare_enum</procedure></A> (VAR s: State) =
  VAR type   := Scan_tipe (s);
      n_elts := Scan_int (s);
      size   := Scan_int (s);
  BEGIN
    s.cg.declare_enum (type, n_elts, size);
  END declare_enum;

PROCEDURE <A NAME="declare_enum_elt"><procedure>declare_enum_elt</procedure></A> (VAR s: State) =
  VAR name := Scan_name (s);
  BEGIN
    s.cg.declare_enum_elt (name);
  END declare_enum_elt;

PROCEDURE <A NAME="declare_packed"><procedure>declare_packed</procedure></A>  (VAR s: State) =
  VAR type := Scan_tipe (s);
      size := Scan_int (s);
      base := Scan_tipe (s);
  BEGIN
    s.cg.declare_packed (type, size, base);
  END declare_packed;

PROCEDURE <A NAME="declare_record"><procedure>declare_record</procedure></A> (VAR s: State) =
  VAR type     := Scan_tipe (s);
      size     := Scan_int (s);
      n_fields := Scan_int (s);
  BEGIN
    s.cg.declare_record (type, size, n_fields);
  END declare_record;

PROCEDURE <A NAME="declare_field"><procedure>declare_field</procedure></A> (VAR s: State) =
  VAR name   := Scan_name (s);
      offset := Scan_int (s);
      size   := Scan_int (s);
      type   := Scan_tipe (s);
  BEGIN
    s.cg.declare_field (name, offset, size, type);
  END declare_field;

PROCEDURE <A NAME="declare_set"><procedure>declare_set</procedure></A> (VAR s: State) =
  VAR type   := Scan_tipe (s);
      domain := Scan_tipe (s);
      size   := Scan_int (s);
  BEGIN
    s.cg.declare_set (type, domain, size);
  END declare_set;

PROCEDURE <A NAME="declare_subrange"><procedure>declare_subrange</procedure></A> (VAR s: State) =
  VAR type   := Scan_tipe (s);
      domain := Scan_tipe (s);
      min    := Scan_Tint (s);
      max    := Scan_Tint (s);
      size   := Scan_int (s);
  BEGIN
    s.cg.declare_subrange (type, domain, min, max, size);
  END declare_subrange;

PROCEDURE <A NAME="declare_pointer"><procedure>declare_pointer</procedure></A> (VAR s: State) =
  VAR type   := Scan_tipe (s);
      target := Scan_tipe (s);
      brand  := Scan_text (s);
      traced := Scan_bool (s);
  BEGIN
    s.cg.declare_pointer (type, target, brand, traced);
  END declare_pointer;

PROCEDURE <A NAME="declare_indirect"><procedure>declare_indirect</procedure></A> (VAR s: State) =
  VAR type   := Scan_tipe (s);
      target := Scan_tipe (s);
  BEGIN
    s.cg.declare_indirect (type, target);
  END declare_indirect;

PROCEDURE <A NAME="declare_proctype"><procedure>declare_proctype</procedure></A> (VAR s: State) =
  VAR type      := Scan_tipe (s);
      n_formals := Scan_int (s);
      result    := Scan_tipe (s);
      n_raises  := Scan_int (s);
      calling   := Scan_callConv (s);
  BEGIN
    s.cg.declare_proctype (type, n_formals, result, n_raises, calling);
  END declare_proctype;

PROCEDURE <A NAME="declare_formal"><procedure>declare_formal</procedure></A> (VAR s: State) =
  VAR name := Scan_name (s);
      type := Scan_tipe (s);
  BEGIN
    s.cg.declare_formal (name, type);
  END declare_formal;

PROCEDURE <A NAME="declare_raises"><procedure>declare_raises</procedure></A> (VAR s: State) =
  VAR name := Scan_name (s);
  BEGIN
    s.cg.declare_raises (name);
  END declare_raises;

PROCEDURE <A NAME="declare_object"><procedure>declare_object</procedure></A> (VAR s: State) =
  VAR type       := Scan_tipe (s);
      super      := Scan_tipe (s);
      brand      := Scan_text (s);
      traced     := Scan_bool (s);
      n_fields   := Scan_int (s);
      n_methods  := Scan_int (s);
      field_size := Scan_int (s);
  BEGIN
    s.cg.declare_object (type, super, brand, traced,
                         n_fields, n_methods, field_size);
  END declare_object;

PROCEDURE <A NAME="declare_method"><procedure>declare_method</procedure></A> (VAR s: State) =
  VAR name := Scan_name (s);
      type := Scan_tipe (s);
  BEGIN
    s.cg.declare_method (name, type);
  END declare_method;

PROCEDURE <A NAME="declare_opaque"><procedure>declare_opaque</procedure></A> (VAR s: State) =
  VAR type    := Scan_tipe (s);
      super   := Scan_tipe (s);
  BEGIN
    s.cg.declare_opaque (type, super);
  END declare_opaque;

PROCEDURE <A NAME="reveal_opaque"><procedure>reveal_opaque</procedure></A> (VAR s: State) =
  VAR lhs     := Scan_tipe (s);
      rhs     := Scan_tipe (s);
  BEGIN
    s.cg.reveal_opaque (lhs, rhs);
  END reveal_opaque;

PROCEDURE <A NAME="declare_exception"><procedure>declare_exception</procedure></A> (VAR s: State) =
  VAR name       := Scan_name (s);
      arg_type   := Scan_tipe (s);
      raise_proc := Scan_bool (s);
      base       := Scan_var (s);
      offset     := Scan_int (s);
  BEGIN
    s.cg.declare_exception (name, arg_type, raise_proc, base, offset);
  END declare_exception;
</PRE>--------------------------------------------------------- runtime hooks ---

<P><PRE>PROCEDURE <A NAME="set_runtime_proc"><procedure>set_runtime_proc</procedure></A> (VAR s: State) =
  VAR name   := Scan_name (s);
      proc   := Scan_proc (s);
  BEGIN
    s.cg.set_runtime_proc (name, proc);
  END set_runtime_proc;

PROCEDURE <A NAME="set_runtime_hook"><procedure>set_runtime_hook</procedure></A> (VAR s: State) =
  VAR name   := Scan_name (s);
      var    := Scan_var (s);
      offset := Scan_int (s);
  BEGIN
    s.cg.set_runtime_hook (name, var, offset);
  END set_runtime_hook;
</PRE>------------------------------------------------- variable declarations ---

<P><PRE>PROCEDURE <A NAME="AddVar"><procedure>AddVar</procedure></A> (VAR s: State;  id: INTEGER;  v: M3CG.Var) =
  BEGIN
    WHILE (id &gt;= NUMBER (s.vars^)) DO ExpandVars (s) END;
    s.vars[id] := v;
  END AddVar;

PROCEDURE <A NAME="ExpandVars"><procedure>ExpandVars</procedure></A> (VAR s: State) =
  VAR new := NEW (REF ARRAY OF M3CG.Var, 2 * NUMBER (s.vars^));
  BEGIN
    SUBARRAY (new^, 0, NUMBER (s.vars^)) := s.vars^;
    s.vars := new;
  END ExpandVars;

PROCEDURE <A NAME="import_global"><procedure>import_global</procedure></A> (VAR s: State) =
  VAR name  := Scan_name (s);
      size  := Scan_int (s);
      align := Scan_int (s);
      type  := Scan_type (s);
      m3t   := Scan_tipe (s);
      v     := Scan_int (s);
  BEGIN
    AddVar (s, v, s.cg.import_global (name, size, align, type, m3t));
  END import_global;

PROCEDURE <A NAME="declare_segment"><procedure>declare_segment</procedure></A> (VAR s: State) =
  VAR name     := Scan_name (s);
      m3t      := Scan_tipe (s);
      is_const := Scan_bool (s);
      v        := Scan_int (s);
  BEGIN
    AddVar (s, v, s.cg.declare_segment (name, m3t, is_const));
  END declare_segment;

PROCEDURE <A NAME="bind_segment"><procedure>bind_segment</procedure></A> (VAR s: State) =
  VAR v      := Scan_var (s);
      size   := Scan_int (s);
      align  := Scan_int (s);
      type   := Scan_type (s);
      export := Scan_bool (s);
      init   := Scan_bool (s);
  BEGIN
    s.cg.bind_segment (v, size, align, type, export, init);
  END bind_segment;

PROCEDURE <A NAME="declare_global"><procedure>declare_global</procedure></A> (VAR s: State) =
  VAR name   := Scan_name (s);
      size   := Scan_int (s);
      align  := Scan_int (s);
      type   := Scan_type (s);
      m3t    := Scan_tipe (s);
      export := Scan_bool (s);
      init   := Scan_bool (s);
      v      := Scan_int (s);
  BEGIN
    AddVar (s, v, s.cg.declare_global (name, size, align, type,
                                       m3t, export, init));
  END declare_global;

PROCEDURE <A NAME="declare_constant"><procedure>declare_constant</procedure></A> (VAR s: State) =
  VAR name   := Scan_name (s);
      size   := Scan_int (s);
      align  := Scan_int (s);
      type   := Scan_type (s);
      m3t    := Scan_tipe (s);
      export := Scan_bool (s);
      init   := Scan_bool (s);
      v      := Scan_int (s);
  BEGIN
    AddVar (s, v, s.cg.declare_constant (name, size, align, type,
                                         m3t, export,init));
  END declare_constant;

PROCEDURE <A NAME="declare_local"><procedure>declare_local</procedure></A> (VAR s: State) =
  VAR name   := Scan_name (s);
      size   := Scan_int (s);
      align  := Scan_int (s);
      type   := Scan_type (s);
      m3t    := Scan_tipe (s);
      in_mem := Scan_bool (s);
      up_lev := Scan_bool (s);
      freq   := Scan_int (s);
      v      := Scan_int (s);
  BEGIN
    AddVar (s, v, s.cg.declare_local (name, size, align, type, m3t,
                                      in_mem, up_lev, freq));
  END declare_local;

PROCEDURE <A NAME="declare_param"><procedure>declare_param</procedure></A> (VAR s: State) =
  VAR name   := Scan_name (s);
      size   := Scan_int (s);
      align  := Scan_int (s);
      type   := Scan_type (s);
      m3t    := Scan_tipe (s);
      in_mem := Scan_bool (s);
      up_lev := Scan_bool (s);
      freq   := Scan_int (s);
      v      := Scan_int (s);
  BEGIN
    AddVar (s, v, s.cg.declare_param (name, size, align, type, m3t,
                                      in_mem, up_lev, freq));
  END declare_param;

PROCEDURE <A NAME="declare_temp"><procedure>declare_temp</procedure></A> (VAR s: State) =
  VAR size   := Scan_int (s);
      align  := Scan_int (s);
      type   := Scan_type (s);
      in_mem := Scan_bool (s);
      v      := Scan_int (s);
  BEGIN
    AddVar (s, v, s.cg.declare_temp (size, align, type, in_mem));
  END declare_temp;

PROCEDURE <A NAME="free_temp"><procedure>free_temp</procedure></A> (VAR s: State) =
  VAR v := Scan_var (s);
  BEGIN
    s.cg.free_temp (v);
  END free_temp;
</PRE>---------------------------------------- static variable initialization ---

<P><PRE>PROCEDURE <A NAME="begin_init"><procedure>begin_init</procedure></A> (VAR s: State) =
  VAR v := Scan_var (s);
  BEGIN
    s.cg.begin_init (v);
  END begin_init;

PROCEDURE <A NAME="end_init"><procedure>end_init</procedure></A> (VAR s: State) =
  VAR v := Scan_var (s);
  BEGIN
    s.cg.end_init (v);
  END end_init;

PROCEDURE <A NAME="init_int"><procedure>init_int</procedure></A> (VAR s: State) =
  VAR offset := Scan_int (s);
      value  := Scan_Tint (s);
      type   := Scan_type (s);
  BEGIN
    s.cg.init_int (offset, value, type);
  END init_int;

PROCEDURE <A NAME="init_proc"><procedure>init_proc</procedure></A> (VAR s: State) =
  VAR offset := Scan_int (s);
      value  := Scan_proc (s);
  BEGIN
    s.cg.init_proc (offset, value);
  END init_proc;

PROCEDURE <A NAME="init_label"><procedure>init_label</procedure></A> (VAR s: State) =
  VAR offset := Scan_int (s);
      value  := Scan_label (s);
  BEGIN
    s.cg.init_label (offset, value);
  END init_label;

PROCEDURE <A NAME="init_var"><procedure>init_var</procedure></A> (VAR s: State) =
  VAR offset := Scan_int (s);
      value  := Scan_var (s);
      bias   := Scan_int (s);
  BEGIN
    s.cg.init_var (offset, value, bias);
  END init_var;

PROCEDURE <A NAME="init_offset"><procedure>init_offset</procedure></A> (VAR s: State) =
  VAR offset := Scan_int (s);
      value  := Scan_var (s);
  BEGIN
    s.cg.init_offset (offset, value);
  END init_offset;

PROCEDURE <A NAME="init_chars"><procedure>init_chars</procedure></A> (VAR s: State) =
  VAR offset := Scan_int (s);
      value  := Scan_text (s);
  BEGIN
    s.cg.init_chars (offset, value);
  END init_chars;

PROCEDURE <A NAME="init_float"><procedure>init_float</procedure></A> (VAR s: State) =
  VAR offset := Scan_int (s);
      value  := Scan_float (s);
  BEGIN
    s.cg.init_float (offset, value);
  END init_float;
</PRE>------------------------------------------------------------ procedures ---

<P><PRE>PROCEDURE <A NAME="AddProc"><procedure>AddProc</procedure></A> (VAR s: State;  id: INTEGER;  p: M3CG.Proc) =
  BEGIN
    WHILE (id &gt;= NUMBER (s.procs^)) DO ExpandProcs (s) END;
    s.procs[id] := p;
  END AddProc;

PROCEDURE <A NAME="ExpandProcs"><procedure>ExpandProcs</procedure></A> (VAR s: State) =
  VAR new := NEW (REF ARRAY OF M3CG.Proc, 2 * NUMBER (s.procs^));
  BEGIN
    SUBARRAY (new^, 0, NUMBER (s.procs^)) := s.procs^;
    s.procs := new;
  END ExpandProcs;

PROCEDURE <A NAME="import_procedure"><procedure>import_procedure</procedure></A> (VAR s: State) =
  VAR name     := Scan_name (s);
      n_params := Scan_int (s);
      ret_type := Scan_type (s);
      calling  := Scan_callConv (s);
      p        := Scan_int (s);
  BEGIN
    AddProc (s, p, s.cg.import_procedure (name, n_params, ret_type, calling));
  END import_procedure;

PROCEDURE <A NAME="declare_procedure"><procedure>declare_procedure</procedure></A> (VAR s: State) =
  VAR name     := Scan_name (s);
      n_params := Scan_int (s);
      ret_type := Scan_type (s);
      level    := Scan_int (s);
      calling  := Scan_callConv (s);
      export   := Scan_bool (s);
      parent   := Scan_proc (s);
      p        := Scan_int (s);
  BEGIN
    AddProc (s, p, s.cg.declare_procedure (name, n_params, ret_type,
                                           level, calling, export, parent));
  END declare_procedure;

PROCEDURE <A NAME="begin_procedure"><procedure>begin_procedure</procedure></A> (VAR s: State) =
  VAR p := Scan_proc (s);
  BEGIN
    s.cg.begin_procedure (p);
  END begin_procedure;

PROCEDURE <A NAME="end_procedure"><procedure>end_procedure</procedure></A> (VAR s: State) =
  VAR p := Scan_proc (s);
  BEGIN
    s.cg.end_procedure (p);
  END end_procedure;

PROCEDURE <A NAME="begin_block"><procedure>begin_block</procedure></A> (VAR s: State) =
  BEGIN
    s.cg.begin_block ();
  END begin_block;

PROCEDURE <A NAME="end_block"><procedure>end_block</procedure></A> (VAR s: State) =
  BEGIN
    s.cg.end_block ();
  END end_block;

PROCEDURE <A NAME="note_procedure_origin"><procedure>note_procedure_origin</procedure></A> (VAR s: State) =
  VAR p := Scan_proc (s);
  BEGIN
    s.cg.note_procedure_origin (p);
  END note_procedure_origin;
</PRE>------------------------------------------------------------ statements ---

<P><PRE>PROCEDURE <A NAME="set_label"><procedure>set_label</procedure></A> (VAR s: State) =
  VAR label   := Scan_label (s);
      barrier := Scan_bool (s);
  BEGIN
    s.cg.set_label (label, barrier);
  END set_label;

PROCEDURE <A NAME="jump"><procedure>jump</procedure></A> (VAR s: State) =
  VAR label := Scan_label (s);
  BEGIN
    s.cg.jump (label);
  END jump;

PROCEDURE <A NAME="if_true"><procedure>if_true</procedure></A>  (VAR s: State) =
  VAR type  := Scan_type (s);
      label := Scan_label (s);
      freq  := Scan_int (s);
  BEGIN
    s.cg.if_true (type, label, freq);
  END if_true;

PROCEDURE <A NAME="if_false"><procedure>if_false</procedure></A> (VAR s: State) =
  VAR type  := Scan_type (s);
      label := Scan_label (s);
      freq  := Scan_int (s);
  BEGIN
    s.cg.if_false (type, label, freq);
  END if_false;

PROCEDURE <A NAME="if_eq"><procedure>if_eq</procedure></A> (VAR s: State) =
  BEGIN
    if_compare (s, CompareOp.EQ);
  END if_eq;

PROCEDURE <A NAME="if_ne"><procedure>if_ne</procedure></A> (VAR s: State) =
  BEGIN
    if_compare (s, CompareOp.NE);
  END if_ne;

PROCEDURE <A NAME="if_gt"><procedure>if_gt</procedure></A> (VAR s: State) =
  BEGIN
    if_compare (s, CompareOp.GT);
  END if_gt;

PROCEDURE <A NAME="if_ge"><procedure>if_ge</procedure></A> (VAR s: State) =
  BEGIN
    if_compare (s, CompareOp.GE);
  END if_ge;

PROCEDURE <A NAME="if_lt"><procedure>if_lt</procedure></A> (VAR s: State) =
  BEGIN
    if_compare (s, CompareOp.LT);
  END if_lt;

PROCEDURE <A NAME="if_le"><procedure>if_le</procedure></A> (VAR s: State) =
  BEGIN
    if_compare (s, CompareOp.LE);
  END if_le;

PROCEDURE <A NAME="if_compare"><procedure>if_compare</procedure></A> (VAR s: State;  op: CompareOp) =
  VAR type  := Scan_type (s);
      label := Scan_label (s);
      freq  := Scan_int (s);
  BEGIN
    s.cg.if_compare (type, op, label, freq);
  END if_compare;

PROCEDURE <A NAME="case_jump"><procedure>case_jump</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
      n    := Scan_int (s);
      x    := NEW (REF ARRAY OF M3CG.Label, n);
  BEGIN
    FOR i := 0 TO n-1 DO x[i] := Scan_label (s) END;
    s.cg.case_jump (type, x^);
  END case_jump;

PROCEDURE <A NAME="exit_proc"><procedure>exit_proc</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
  BEGIN
    s.cg.exit_proc (type);
  END exit_proc;
</PRE>------------------------------------------------------------ load/store ---

<P><PRE>PROCEDURE <A NAME="load"><procedure>load</procedure></A>  (VAR s: State) =
  VAR v      := Scan_var (s);
      offset := Scan_int (s);
      src    := Scan_type (s);
      dest   := Scan_type (s);
  BEGIN
    s.cg.load (v, offset, src, dest);
  END load;

PROCEDURE <A NAME="store"><procedure>store</procedure></A>  (VAR s: State) =
  VAR v      := Scan_var (s);
      offset := Scan_int (s);
      src    := Scan_type (s);
      dest   := Scan_type (s);
  BEGIN
    s.cg.store (v, offset, src, dest);
  END store;

PROCEDURE <A NAME="load_address"><procedure>load_address</procedure></A> (VAR s: State) =
  VAR v      := Scan_var (s);
      offset := Scan_int (s);
  BEGIN
    s.cg.load_address (v, offset);
  END load_address;

PROCEDURE <A NAME="load_indirect"><procedure>load_indirect</procedure></A> (VAR s: State) =
  VAR offset := Scan_int (s);
      src    := Scan_type (s);
      dest   := Scan_type (s);
  BEGIN
    s.cg.load_indirect (offset, src, dest);
  END load_indirect;

PROCEDURE <A NAME="store_indirect"><procedure>store_indirect</procedure></A> (VAR s: State) =
  VAR offset := Scan_int (s);
      src    := Scan_type (s);
      dest   := Scan_type (s);
  BEGIN
    s.cg.store_indirect (offset, src, dest);
  END store_indirect;
</PRE>-------------------------------------------------------------- literals ---

<P><PRE>PROCEDURE <A NAME="load_nil"><procedure>load_nil</procedure></A> (VAR s: State) =
  BEGIN
    s.cg.load_nil ();
  END load_nil;

PROCEDURE <A NAME="load_integer"><procedure>load_integer</procedure></A>  (VAR s: State) =
  VAR type  := Scan_type (s);
      value := Scan_Tint (s);
  BEGIN
    s.cg.load_integer (type, value);
  END load_integer;

PROCEDURE <A NAME="load_float"><procedure>load_float</procedure></A>    (VAR s: State) =
  VAR type  := Scan_type (s);
      value := Scan_float (s);
  BEGIN
    s.cg.load_float (type, value);
  END load_float;
</PRE>------------------------------------------------------------ arithmetic ---

<P><PRE>PROCEDURE <A NAME="eq"><procedure>eq</procedure></A> (VAR s: State) =
  BEGIN
    compare (s, CompareOp.EQ);
  END eq;

PROCEDURE <A NAME="ne"><procedure>ne</procedure></A> (VAR s: State) =
  BEGIN
    compare (s, CompareOp.NE);
  END ne;

PROCEDURE <A NAME="gt"><procedure>gt</procedure></A> (VAR s: State) =
  BEGIN
    compare (s, CompareOp.GT);
  END gt;

PROCEDURE <A NAME="ge"><procedure>ge</procedure></A> (VAR s: State) =
  BEGIN
    compare (s, CompareOp.GE);
  END ge;

PROCEDURE <A NAME="lt"><procedure>lt</procedure></A> (VAR s: State) =
  BEGIN
    compare (s, CompareOp.LT);
  END lt;

PROCEDURE <A NAME="le"><procedure>le</procedure></A> (VAR s: State) =
  BEGIN
    compare (s, CompareOp.LE);
  END le;

PROCEDURE <A NAME="compare"><procedure>compare</procedure></A> (VAR s: State;  op: CompareOp) =
  VAR src  := Scan_type (s);
      dest := Scan_type (s);
  BEGIN
    s.cg.compare (src, dest, op);
  END compare;

PROCEDURE <A NAME="add"><procedure>add</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
  BEGIN
    s.cg.add (type);
  END add;

PROCEDURE <A NAME="subtract"><procedure>subtract</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
  BEGIN
    s.cg.subtract (type);
  END subtract;

PROCEDURE <A NAME="multiply"><procedure>multiply</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
  BEGIN
    s.cg.multiply (type);
  END multiply;

PROCEDURE <A NAME="divide"><procedure>divide</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
  BEGIN
    s.cg.divide (type);
  END divide;

PROCEDURE <A NAME="div"><procedure>div</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
      a := Scan_sign (s);
      b := Scan_sign (s);
  BEGIN
    s.cg.div (type, a, b);
  END div;

PROCEDURE <A NAME="mod"><procedure>mod</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
      a := Scan_sign (s);
      b := Scan_sign (s);
  BEGIN
    s.cg.mod (type, a, b);
  END mod;

PROCEDURE <A NAME="negate"><procedure>negate</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
  BEGIN
    s.cg.negate (type);
  END negate;

PROCEDURE <A NAME="abs"><procedure>abs</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
  BEGIN
    s.cg.abs (type);
  END abs;

PROCEDURE <A NAME="max"><procedure>max</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
  BEGIN
    s.cg.max (type);
  END max;

PROCEDURE <A NAME="min"><procedure>min</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
  BEGIN
    s.cg.min (type);
  END min;

PROCEDURE <A NAME="round"><procedure>round</procedure></A> (VAR s: State) =
  BEGIN
    cvt_int (s, ConvertOp.Round);
  END round;

PROCEDURE <A NAME="trunc"><procedure>trunc</procedure></A> (VAR s: State) =
  BEGIN
    cvt_int (s, ConvertOp.Trunc);
  END trunc;

PROCEDURE <A NAME="floor"><procedure>floor</procedure></A> (VAR s: State) =
  BEGIN
    cvt_int (s, ConvertOp.Floor);
  END floor;

PROCEDURE <A NAME="ceiling"><procedure>ceiling</procedure></A> (VAR s: State) =
  BEGIN
    cvt_int (s, ConvertOp.Ceiling);
  END ceiling;

PROCEDURE <A NAME="cvt_int"><procedure>cvt_int</procedure></A> (VAR s: State;  op: ConvertOp) =
  VAR src  := Scan_type (s);
      dest := Scan_type (s);
  BEGIN
    s.cg.cvt_int (src, dest, op);
  END cvt_int;

PROCEDURE <A NAME="cvt_float"><procedure>cvt_float</procedure></A>    (VAR s: State) =
  VAR src  := Scan_type (s);
      dest := Scan_type (s);
  BEGIN
    s.cg.cvt_float (src, dest);
  END cvt_float;
</PRE>------------------------------------------------------------------ sets ---

<P><PRE>PROCEDURE <A NAME="set_union"><procedure>set_union</procedure></A> (VAR s: State) =
  VAR size := Scan_int (s);
  BEGIN
    s.cg.set_union (size);
  END set_union;

PROCEDURE <A NAME="set_difference"><procedure>set_difference</procedure></A> (VAR s: State) =
  VAR size := Scan_int (s);
  BEGIN
    s.cg.set_difference (size);
  END set_difference;

PROCEDURE <A NAME="set_intersection"><procedure>set_intersection</procedure></A> (VAR s: State) =
  VAR size := Scan_int (s);
  BEGIN
    s.cg.set_intersection (size);
  END set_intersection;

PROCEDURE <A NAME="set_sym_difference"><procedure>set_sym_difference</procedure></A> (VAR s: State) =
  VAR size := Scan_int (s);
  BEGIN
    s.cg.set_sym_difference (size);
  END set_sym_difference;

PROCEDURE <A NAME="set_member"><procedure>set_member</procedure></A> (VAR s: State) =
  VAR size := Scan_int (s);
      type := Scan_type (s);
  BEGIN
    s.cg.set_member (size, type);
  END set_member;

PROCEDURE <A NAME="set_eq"><procedure>set_eq</procedure></A> (VAR s: State) =
  BEGIN
    set_compare (s, CompareOp.EQ);
  END set_eq;

PROCEDURE <A NAME="set_ne"><procedure>set_ne</procedure></A> (VAR s: State) =
  BEGIN
    set_compare (s, CompareOp.NE);
  END set_ne;

PROCEDURE <A NAME="set_gt"><procedure>set_gt</procedure></A> (VAR s: State) =
  BEGIN
    set_compare (s, CompareOp.GT);
  END set_gt;

PROCEDURE <A NAME="set_ge"><procedure>set_ge</procedure></A> (VAR s: State) =
  BEGIN
    set_compare (s, CompareOp.GE);
  END set_ge;

PROCEDURE <A NAME="set_lt"><procedure>set_lt</procedure></A> (VAR s: State) =
  BEGIN
    set_compare (s, CompareOp.LT);
  END set_lt;

PROCEDURE <A NAME="set_le"><procedure>set_le</procedure></A> (VAR s: State) =
  BEGIN
    set_compare (s, CompareOp.LE);
  END set_le;

PROCEDURE <A NAME="set_compare"><procedure>set_compare</procedure></A> (VAR s: State;  op: CompareOp) =
  VAR size := Scan_int (s);
      type := Scan_type (s);
  BEGIN
    s.cg.set_compare (size, op, type);
  END set_compare;

PROCEDURE <A NAME="set_range"><procedure>set_range</procedure></A> (VAR s: State) =
  VAR size := Scan_int (s);
      type := Scan_type (s);
  BEGIN
    s.cg.set_range (size, type);
  END set_range;

PROCEDURE <A NAME="set_singleton"><procedure>set_singleton</procedure></A> (VAR s: State) =
  VAR size := Scan_int (s);
      type := Scan_type (s);
  BEGIN
    s.cg.set_singleton (size, type);
  END set_singleton;
</PRE>------------------------------------------------- Word.T bit operations ---

<P><PRE>PROCEDURE <A NAME="not"><procedure>not</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
  BEGIN
    s.cg.not (type);
  END not;

PROCEDURE <A NAME="and"><procedure>and</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
  BEGIN
    s.cg.and (type);
  END and;

PROCEDURE <A NAME="or"><procedure>or</procedure></A>  (VAR s: State) =
  VAR type := Scan_type (s);
  BEGIN
    s.cg.or (type);
  END or;

PROCEDURE <A NAME="xor"><procedure>xor</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
  BEGIN
    s.cg.xor (type);
  END xor;

PROCEDURE <A NAME="shift"><procedure>shift</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
  BEGIN
    s.cg.shift (type);
  END shift;

PROCEDURE <A NAME="shift_left"><procedure>shift_left</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
  BEGIN
    s.cg.shift_left (type);
  END shift_left;

PROCEDURE <A NAME="shift_right"><procedure>shift_right</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
  BEGIN
    s.cg.shift_right (type);
  END shift_right;

PROCEDURE <A NAME="rotate"><procedure>rotate</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
  BEGIN
    s.cg.rotate (type);
  END rotate;

PROCEDURE <A NAME="rotate_left"><procedure>rotate_left</procedure></A>  (VAR s: State) =
  VAR type := Scan_type (s);
  BEGIN
    s.cg.rotate_left (type);
  END rotate_left;

PROCEDURE <A NAME="rotate_right"><procedure>rotate_right</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
  BEGIN
    s.cg.rotate_right (type);
  END rotate_right;

PROCEDURE <A NAME="widen"><procedure>widen</procedure></A> (VAR s: State) =
  VAR sign_extend := Scan_bool (s);
  BEGIN
    s.cg.widen (sign_extend);
  END widen;

PROCEDURE <A NAME="chop"><procedure>chop</procedure></A> (VAR s: State) =
  BEGIN
    s.cg.chop ();
  END chop;

PROCEDURE <A NAME="extract"><procedure>extract</procedure></A> (VAR s: State) =
  VAR type        := Scan_type (s);
      sign_extend := Scan_bool (s);
  BEGIN
    s.cg.extract (type, sign_extend);
  END extract;

PROCEDURE <A NAME="extract_n"><procedure>extract_n</procedure></A> (VAR s: State) =
  VAR type        := Scan_type (s);
      sign_extend := Scan_bool (s);
      width       := Scan_int (s);
  BEGIN
    s.cg.extract_n (type, sign_extend, width);
  END extract_n;

PROCEDURE <A NAME="extract_mn"><procedure>extract_mn</procedure></A> (VAR s: State) =
  VAR type        := Scan_type (s);
      sign_extend := Scan_bool (s);
      offset      := Scan_int (s);
      width       := Scan_int (s);
  BEGIN
    s.cg.extract_mn (type, sign_extend, offset, width);
  END extract_mn;

PROCEDURE <A NAME="insert"><procedure>insert</procedure></A>  (VAR s: State) =
  VAR type := Scan_type (s);
  BEGIN
    s.cg.insert (type);
  END insert;

PROCEDURE <A NAME="insert_n"><procedure>insert_n</procedure></A>  (VAR s: State) =
  VAR type  := Scan_type (s);
      width := Scan_int (s);
  BEGIN
    s.cg.insert_n (type, width);
  END insert_n;

PROCEDURE <A NAME="insert_mn"><procedure>insert_mn</procedure></A>  (VAR s: State) =
  VAR type   := Scan_type (s);
      offset := Scan_int (s);
      width  := Scan_int (s);
  BEGIN
    s.cg.insert_mn (type, offset, width);
  END insert_mn;
</PRE>------------------------------------------------ misc. stack/memory ops ---

<P><PRE>PROCEDURE <A NAME="swap"><procedure>swap</procedure></A> (VAR s: State) =
  VAR a := Scan_type (s);
      b := Scan_type (s);
  BEGIN
    s.cg.swap (a, b);
  END swap;

PROCEDURE <A NAME="pop"><procedure>pop</procedure></A>  (VAR s: State) =
  VAR type := Scan_type (s);
  BEGIN
    s.cg.pop (type);
  END pop;

PROCEDURE <A NAME="copy_n"><procedure>copy_n</procedure></A> (VAR s: State) =
  VAR cnt_type := Scan_type (s);
      type     := Scan_type (s);
      overlap  := Scan_bool (s);
  BEGIN
    s.cg.copy_n (cnt_type, type, overlap);
  END copy_n;

PROCEDURE <A NAME="copy"><procedure>copy</procedure></A> (VAR s: State) =
  VAR cnt  := Scan_int (s);
      type := Scan_type (s);
      overlap := Scan_bool (s);
  BEGIN
    s.cg.copy (cnt, type, overlap);
  END copy;

PROCEDURE <A NAME="zero_n"><procedure>zero_n</procedure></A> (VAR s: State) =
  VAR cnt_type := Scan_type (s);
      type     := Scan_type (s);
  BEGIN
    s.cg.zero_n (cnt_type, type);
  END zero_n;

PROCEDURE <A NAME="zero"><procedure>zero</procedure></A> (VAR s: State) =
  VAR cnt  := Scan_int (s);
      type := Scan_type (s);
  BEGIN
    s.cg.zero (cnt, type);
  END zero;
</PRE>----------------------------------------------------------- conversions ---

<P><PRE>PROCEDURE <A NAME="loophole"><procedure>loophole</procedure></A> (VAR s: State) =
  VAR from := Scan_type (s);
      two  := Scan_type (s);
  BEGIN
    s.cg.loophole (from, two);
  END loophole;
</PRE>------------------------------------------------ traps &amp; runtime checks ---

<P><PRE>PROCEDURE <A NAME="abort"><procedure>abort</procedure></A> (VAR s: State) =
  VAR code := Scan_error (s);
  BEGIN
    s.cg.abort (code);
  END abort;

PROCEDURE <A NAME="check_nil"><procedure>check_nil</procedure></A> (VAR s: State) =
  VAR code := Scan_error (s);
  BEGIN
    s.cg.check_nil (code);
  END check_nil;

PROCEDURE <A NAME="check_lo"><procedure>check_lo</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
      i    := Scan_Tint (s);
      code := Scan_error (s);
  BEGIN
    s.cg.check_lo (type, i, code);
  END check_lo;

PROCEDURE <A NAME="check_hi"><procedure>check_hi</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
      i    := Scan_Tint (s);
      code := Scan_error (s);
  BEGIN
    s.cg.check_hi (type, i, code);
  END check_hi;

PROCEDURE <A NAME="check_range"><procedure>check_range</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
      a    := Scan_Tint (s);
      b    := Scan_Tint (s);
      code := Scan_error (s);
  BEGIN
    s.cg.check_range (type, a, b, code);
  END check_range;

PROCEDURE <A NAME="check_index"><procedure>check_index</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
      code := Scan_error (s);
  BEGIN
    s.cg.check_index (type, code);
  END check_index;

PROCEDURE <A NAME="check_eq"><procedure>check_eq</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
      code := Scan_error (s);
  BEGIN
    s.cg.check_eq (type, code);
  END check_eq;
</PRE>---------------------------------------------------- address arithmetic ---

<P><PRE>PROCEDURE <A NAME="add_offset"><procedure>add_offset</procedure></A> (VAR s: State) =
  VAR i := Scan_int (s);
  BEGIN
    s.cg.add_offset (i);
  END add_offset;

PROCEDURE <A NAME="index_address"><procedure>index_address</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
      size := Scan_int (s);
  BEGIN
    s.cg.index_address (type, size);
  END index_address;
</PRE>------------------------------------------------------- procedure calls ---

<P><PRE>PROCEDURE <A NAME="start_call_direct"><procedure>start_call_direct</procedure></A> (VAR s: State) =
  VAR p     := Scan_proc (s);
      level := Scan_int (s);
      type  := Scan_type (s);
  BEGIN
    s.cg.start_call_direct (p, level, type);
  END start_call_direct;

PROCEDURE <A NAME="start_call_indirect"><procedure>start_call_indirect</procedure></A> (VAR s: State) =
  VAR type    := Scan_type (s);
      calling := Scan_callConv (s);
  BEGIN
    s.cg.start_call_indirect (type, calling);
  END start_call_indirect;

PROCEDURE <A NAME="pop_param"><procedure>pop_param</procedure></A> (VAR s: State) =
  VAR type := Scan_type (s);
  BEGIN
    s.cg.pop_param (type);
  END pop_param;

PROCEDURE <A NAME="pop_struct"><procedure>pop_struct</procedure></A> (VAR s: State) =
  VAR size  := Scan_int (s);
      align := Scan_int (s);
  BEGIN
    s.cg.pop_struct (size, align);
  END pop_struct;

PROCEDURE <A NAME="pop_static_link"><procedure>pop_static_link</procedure></A> (VAR s: State) =
  BEGIN
    s.cg.pop_static_link ();
  END pop_static_link;

PROCEDURE <A NAME="call_direct"><procedure>call_direct</procedure></A> (VAR s: State) =
  VAR p    := Scan_proc (s);
      type := Scan_type (s);
  BEGIN
    s.cg.call_direct (p, type);
  END call_direct;

PROCEDURE <A NAME="call_indirect"><procedure>call_indirect</procedure></A> (VAR s: State) =
  VAR type    := Scan_type (s);
      calling := Scan_callConv (s);
  BEGIN
    s.cg.call_indirect (type, calling);
  END call_indirect;
</PRE>------------------------------------------- procedure and closure types ---

<P><PRE>PROCEDURE <A NAME="load_procedure"><procedure>load_procedure</procedure></A> (VAR s: State) =
  VAR p := Scan_proc (s);
  BEGIN
    s.cg.load_procedure (p);
  END load_procedure;

PROCEDURE <A NAME="load_static_link"><procedure>load_static_link</procedure></A> (VAR s: State) =
  VAR p := Scan_proc (s);
  BEGIN
    s.cg.load_static_link (p);
  END load_static_link;
</PRE>----------------------------------------------------------------- misc. ---

<P><PRE>PROCEDURE <A NAME="comment"><procedure>comment</procedure></A> (VAR s: State) =
  VAR x := Scan_text (s);
  BEGIN
    s.cg.comment (x);
  END comment;
</PRE>--------------------------------------------------------------- atomics ---

<P><PRE>PROCEDURE <A NAME="store_ordered"><procedure>store_ordered</procedure></A> (VAR s: State) =
  VAR src    := Scan_type (s);
      dest   := Scan_type (s);
      order  := Scan_int (s);
  BEGIN
    s.cg.store_ordered (src, dest, VAL(order, MemoryOrder));
  END store_ordered;

PROCEDURE <A NAME="load_ordered"><procedure>load_ordered</procedure></A> (VAR s: State) =
  VAR src    := Scan_type (s);
      dest   := Scan_type (s);
      order  := Scan_int (s);
  BEGIN
    s.cg.load_ordered (src, dest, VAL(order, MemoryOrder));
  END load_ordered;

PROCEDURE <A NAME="exchange"><procedure>exchange</procedure></A> (VAR s: State) =
  VAR src    := Scan_type (s);
      dest   := Scan_type (s);
      order  := Scan_int (s);
  BEGIN
    s.cg.exchange (src, dest, VAL(order, MemoryOrder));
  END exchange;

PROCEDURE <A NAME="compare_exchange"><procedure>compare_exchange</procedure></A> (VAR s: State) =
  VAR src     := Scan_type (s);
      dest    := Scan_type (s);
      res     := Scan_type (s);
      success := Scan_int (s);
      failure := Scan_int (s);
  BEGIN
    s.cg.compare_exchange (src, dest, res,
                           VAL(success, MemoryOrder),
                           VAL(failure, MemoryOrder));
  END compare_exchange;

PROCEDURE <A NAME="fence"><procedure>fence</procedure></A> (VAR s: State) =
  VAR order  := Scan_int (s);
  BEGIN
    s.cg.fence (VAL(order, MemoryOrder));
  END fence;

PROCEDURE <A NAME="fetch_and_op"><procedure>fetch_and_op</procedure></A> (VAR s: State;  op: AtomicOp) =
  VAR src    := Scan_type (s);
      dest   := Scan_type (s);
      order  := Scan_int (s);
  BEGIN
    s.cg.fetch_and_op (op, src, dest, VAL(order, MemoryOrder));
  END fetch_and_op;

PROCEDURE <A NAME="fetch_and_add"><procedure>fetch_and_add</procedure></A> (VAR s: State) =
  BEGIN
    fetch_and_op (s, AtomicOp.Add);
  END fetch_and_add;

PROCEDURE <A NAME="fetch_and_sub"><procedure>fetch_and_sub</procedure></A> (VAR s: State) =
  BEGIN
    fetch_and_op (s, AtomicOp.Sub);
  END fetch_and_sub;

PROCEDURE <A NAME="fetch_and_or"><procedure>fetch_and_or</procedure></A> (VAR s: State) =
  BEGIN
    fetch_and_op (s, AtomicOp.Or);
  END fetch_and_or;

PROCEDURE <A NAME="fetch_and_and"><procedure>fetch_and_and</procedure></A> (VAR s: State) =
  BEGIN
    fetch_and_op (s, AtomicOp.And);
  END fetch_and_and;

PROCEDURE <A NAME="fetch_and_xor"><procedure>fetch_and_xor</procedure></A> (VAR s: State) =
  BEGIN
    fetch_and_op (s, AtomicOp.Xor);
  END fetch_and_xor;

BEGIN
  FOR op := FIRST (CmdMap) TO LAST (CmdMap) DO
    &lt;*ASSERT CmdMap[op].bop = op *&gt;
  END;
END M3CG_BinRd.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface M3ID is in:
</A><UL>
<LI><A HREF="M3ID.i3.html#0TOP0">m3middle/src/M3ID.i3</A>
<LI><A HREF="../../m3scan/src/M3ID.i3.html#0TOP0">m3scan/src/M3ID.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
