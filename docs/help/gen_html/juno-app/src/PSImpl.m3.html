<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: juno-app/src/PSImpl.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>juno-app/src/PSImpl.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright (C) 1992, Digital Equipment Corporation                         
 All rights reserved.                                                      
 See the file COPYRIGHT for a full description.                            
                                                                           
 Last modified on Thu Mar 28 17:34:10 PST 1996 by heydon                   

<P><PRE>MODULE <module><implements><A HREF="PSImpl.i3.html">PSImpl</A></implements></module>;

IMPORT <A HREF="JunoConfig.i3.html">JunoConfig</A>, <A HREF="Drawing.i3.html">Drawing</A>, <A HREF="JunoPt.i3.html">JunoPt</A>, <A HREF="#x1">JunoRect</A>, <A HREF="#x2">PSFont</A>, <A HREF="JunoRsrc.i3.html">JunoRsrc</A>, <A HREF="#x3">View</A>;
IMPORT   <A HREF="ExternalProc.i3.html">ExternalProc</A>;
IMPORT <A HREF="../../juno-compiler/src/JunoScope.i3.html">JunoScope</A>;
IMPORT <A HREF="../../juno-machine/src/JunoRT.i3.html">JunoRT</A>, <A HREF="../../juno-machine/src/RTVal.i3.html">RTVal</A>, <A HREF="#x4">JunoValue</A>, <A HREF="../../juno-machine/src/JunoArgs.i3.html">JunoArgs</A>;
IMPORT <A HREF="../../ui/src/vbt/VBT.i3.html">VBT</A>, <A HREF="VBTExtras.i3.html">VBTExtras</A>, <A HREF="../../ui/src/split/Filter.i3.html">Filter</A>, <A HREF="../../ui/src/vbt/PaintOp.i3.html">PaintOp</A>, <A HREF="../../ui/src/vbt/Font.i3.html">Font</A>, <A HREF="../../libm3/src/geometry/Path.i3.html">Path</A>, <A HREF="../../libm3/src/geometry/Point.i3.html">Point</A>, <A HREF="../../libm3/src/geometry/Rect.i3.html">Rect</A>, <A HREF="../../ui/src/split/DblBufferVBT.i3.html">DblBufferVBT</A>;
IMPORT <A HREF="../../libm3/src/atom/Atom.i3.html">Atom</A>, <A HREF="../../libm3/src/rw/Rd.i3.html">Rd</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="../../libm3/src/fmtlex/Fmt.i3.html">Fmt</A>, <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../m3core/src/text/Text.i3.html">Text</A>, <A HREF="../../libm3/derived/TextRefTbl.i3.html">TextRefTbl</A>, <A HREF="../../m3core/src/time/Common/Time.i3.html">Time</A>, <A HREF="../../m3core/src/time/Common/Date.i3.html">Date</A>;
IMPORT   <A HREF="../../libm3/src/os/Common/Process.i3.html">Process</A>, <A HREF="../../libm3/src/pickle/ver1/Pickle.i3.html">Pickle</A>, <A HREF="../../vbtkit/src/vbtkitutils/Rsrc.i3.html">Rsrc</A>;
FROM <A HREF="ExternalProc.i3.html">ExternalProc</A> IMPORT Closure, Bind;
FROM <A HREF="../../libm3/src/rw/Stdio.i3.html">Stdio</A> IMPORT stderr;

&lt;* FATAL Thread.Alerted *&gt;

EXCEPTION Error;			 (* internal error *)
&lt;* FATAL Error *&gt;			 (* should never be raised *)

CONST
  MaxCacheSize = 40;  (* # of external procs replaced by StartToFile(). *)
  FindFontProc = &quot;FindFontISO&quot;;

TYPE
  ToFileClosure = Closure BRANDED &quot;PSImpl.ToFileClosure&quot; OBJECT
    i: Impl
  END;
  CacheRec = RECORD
    slot: CARDINAL;
    proc: Closure;
  END;

REVEAL
  View.<A NAME="PSImpl">PSImpl</A> = Public BRANDED &quot;View.PSImpl&quot; OBJECT OVERRIDES
    init := Init
  END;

  <A NAME="Impl">Impl</A> = ImplPublic BRANDED &quot;PSImpl.Impl&quot; OBJECT
    rt: View.Root;
    wr: Wr.T := NIL;
    extCnt: CARDINAL;
    page: CARDINAL;
    cache: ARRAY [0..MaxCacheSize - 1] OF CacheRec;
  OVERRIDES
    startToFile := StartToFile;
    prologue := Prologue;
    epilogue := Epilogue;
    endToFile := EndToFile;
  END;
</PRE> <CODE>StartToFile</CODE> replaces the external PostScript procedures that change the
   PostScript state by <CODE>ToFileClosure</CODE> objects. For <CODE>Impl</CODE> <CODE>i</CODE>, the method
   call <CODE>i.startToFile(wr)</CODE> sets <CODE>i.wr</CODE> to <CODE>wr</CODE>, <CODE>i.extCnt</CODE> to the number of
   replaced external procedures, and stores the replaced procedures and the
   slots from which they came in <CODE>i.cache</CODE>. 

<P><PRE>PROCEDURE <A NAME="Init"><procedure>Init</procedure></A>(d: T; ch: Drawing.ChildPublic; root: View.Root): T =
  BEGIN
    d.root := root;
    EVAL View.T.init(d, ch);
    d.ps.path := NEW(Path.T);
    d.psStack := NEW(REF ARRAY OF State, 10);
    RETURN d
  END Init;

CONST
  DefaultColor = Color{r := 0.0, g := 0.0, b := 0.0};
  DefaultColorOp = PaintOp.Fg;
  DefaultTextColorOp = PaintOp.TransparentFg;
  DefaultWidth = 1.0;
  DefaultEndStyle = VBT.EndStyle.Butt;
  DefaultJointStyle = VBT.JoinStyle.Miter;
  DefaultWindingStyle = VBT.WindingCondition.NonZero;
  DefaultFaceName = &quot;Times-Roman&quot;;
  DefaultFontSize = 4;			 (* PS.Large *)

VAR (* CONST *)
  fontTbl: TextRefTbl.T;
  metricTbl: TextRefTbl.T;
  defaultXFont: Font.T;			 (* cached copy of default X font *)
  defaultXFontPtSize: JunoValue.Real;	 (* cached value of it's point size *)
  defaultPSMetric: PSFont.Metric;	 (* cached metric of default font *)

&lt;* INLINE *&gt;
PROCEDURE <A NAME="ResetPath"><procedure>ResetPath</procedure></A>(VAR (*INOUT*) ps: State) =
  BEGIN
    Path.Reset(ps.path);
    ps.moveto := FALSE
  END ResetPath;

CONST
  PageWidth = 8.5 * 72.0;
  PageHeight = 11.0 * 72.0;
  HalfWidth = PageWidth / 2.0;
  HalfHeight = PageHeight / 2.0;

PROCEDURE <A NAME="DefaultBBox"><procedure>DefaultBBox</procedure></A>(d: T): JunoRect.T =
  TYPE
    OrientBBox = ARRAY JunoConfig.Orientation OF JunoRect.T;
  CONST
    BBoxSW = OrientBBox{
      JunoRect.T{0.0, PageWidth, PageHeight, 0.0},  (* Portrait *)
      JunoRect.T{0.0, PageHeight, PageWidth, 0.0}}; (* Landscape *)
    BBoxCenter = OrientBBox{
      JunoRect.T{-HalfWidth, HalfWidth, HalfHeight, -HalfHeight},
      JunoRect.T{-HalfHeight, HalfHeight, HalfWidth, -HalfWidth}};
    BBox = ARRAY JunoConfig.Origin OF OrientBBox{BBoxCenter, BBoxSW};
  VAR ch: Drawing.ChildPublic := Filter.Child(d); BEGIN
    RETURN BBox[ch.getOrigin(), JunoConfig.orientation]
  END DefaultBBox;

PROCEDURE <A NAME="Reset"><procedure>Reset</procedure></A>(d: T; &lt;*UNUSED*&gt; inExec := TRUE) =
  BEGIN
    WITH ps = d.ps DO
      ps.color := DefaultColor;
      ps.width := DefaultWidth;
      ps.end := DefaultEndStyle;
      ps.join := DefaultJointStyle;
      ps.wind := DefaultWindingStyle;
      ResetPath(ps);
      ps.face := DefaultFaceName;
      ps.size := DefaultFontSize;
      ps.ptSize := defaultXFontPtSize;
      ps.bbox := DefaultBBox(d);
      ps.colorOp := DefaultColorOp;
      ps.textColorOp := DefaultTextColorOp;
      ps.xFont := defaultXFont;
      ps.psMetric := defaultPSMetric
    END
  END Reset;

VAR (*CONST*)
  PSAtom   := Atom.FromText(&quot;PS&quot;);
  Save     := Atom.FromText(&quot;Save&quot;);
  Restore  := Atom.FromText(&quot;Restore&quot;);
  NewPath  := Atom.FromText(&quot;NewPath&quot;);
  MoveTo   := Atom.FromText(&quot;MoveTo&quot;);
  LineTo   := Atom.FromText(&quot;LineTo&quot;);
  CurveTo  := Atom.FromText(&quot;CurveTo&quot;);
  Close    := Atom.FromText(&quot;Close&quot;);
  Stroke   := Atom.FromText(&quot;Stroke&quot;);
  Fill     := Atom.FromText(&quot;Fill&quot;);
  Type     := Atom.FromText(&quot;Type&quot;);
  SetWidth := Atom.FromText(&quot;SetWidth&quot;);
  SetEnd   := Atom.FromText(&quot;SetEndStyle&quot;);
  SetJoin  := Atom.FromText(&quot;SetJointStyle&quot;);
  GetWidth := Atom.FromText(&quot;GetWidth&quot;);
  GetEnd   := Atom.FromText(&quot;GetEndStyle&quot;);
  GetJoin  := Atom.FromText(&quot;GetJointStyle&quot;);
  SetColor := Atom.FromText(&quot;SetColor&quot;);
  SetWind  := Atom.FromText(&quot;SetWinding&quot;);
  GetColor := Atom.FromText(&quot;GetColor&quot;);
  GetWind  := Atom.FromText(&quot;GetWinding&quot;);
  SetFace  := Atom.FromText(&quot;SetFontFace&quot;);
  SetSize  := Atom.FromText(&quot;SetFontSize&quot;);
  SetFont  := Atom.FromText(&quot;SetFont&quot;);
  GetFace  := Atom.FromText(&quot;GetFontFace&quot;);
  GetSize  := Atom.FromText(&quot;GetFontSize&quot;);
  GetFont  := Atom.FromText(&quot;GetFont&quot;);
  GetPtSz  := Atom.FromText(&quot;GetFontPtSize&quot;);
  FontH    := Atom.FromText(&quot;FontHeight&quot;);
  StringW  := Atom.FromText(&quot;StringWidth&quot;);
  StringBB := Atom.FromText(&quot;StringBBox&quot;);
  CurrPt   := Atom.FromText(&quot;CurrentPoint&quot;);
  CurrPath := Atom.FromText(&quot;CurrentPath&quot;);
  SetBBox  := Atom.FromText(&quot;SetBBox&quot;);
  GetBBox  := Atom.FromText(&quot;GetBBox&quot;);
  ShowPage := Atom.FromText(&quot;ShowPage&quot;);
  ResetSym := Atom.FromText(&quot;Reset&quot;);
  SavePage := Atom.FromText(&quot;SavePage&quot;);
  RestPage := Atom.FromText(&quot;RestorePage&quot;);

CONST
  ButtEndsVal    = 0;
  RoundEndsVal   = 1;
  SquareEndsVal  = 2;
  MiterJointsVal = 0;
  RoundJointsVal = 1;
  BevelJointsVal = 2;
  NZWindingVal   = 0;
  OddWindingVal  = 1;

PROCEDURE <A NAME="New"><procedure>New</procedure></A>(rt: View.Root): Impl =
  VAR
    scp := JunoScope.New(NIL, size := 24);
    res := NEW(Impl, rt := rt, public_scp := scp, scp := scp);
  BEGIN
    ExternalProc.SetupBind(PSAtom, scp, rt);
    Bind(Save,	   NEW(Closure, invoke := SaveProc),	     in := 0);
    Bind(Restore,  NEW(Closure, invoke := RestoreProc),	     in := 0);
    Bind(NewPath,  NEW(Closure, invoke := NewPathProc),	     in := 0);
    Bind(MoveTo,   NEW(Closure, invoke := MoveToProc),	     in := 1);
    Bind(LineTo,   NEW(Closure, invoke := LineToProc),	     in := 1);
    Bind(CurveTo,  NEW(Closure, invoke := CurveToProc),	     in := 3);
    Bind(Close,	   NEW(Closure, invoke := CloseProc),	     in := 0);
    Bind(Fill,	   NEW(Closure, invoke := FillProc),	     in := 0);
    Bind(Stroke,   NEW(Closure, invoke := StrokeProc),	     in := 0);
    Bind(Type,     NEW(Closure, invoke := TypeProc),	     in := 2);
    Bind(SetWidth, NEW(Closure, invoke := SetWidthProc),     in := 1);
    Bind(SetEnd,   NEW(Closure, invoke := SetEndStyleProc),  in := 1);
    Bind(SetJoin,  NEW(Closure, invoke := SetJoinStyleProc), in := 1);
    Bind(SetColor, NEW(Closure, invoke := SetColorProc),     in := 1);
    Bind(SetWind,  NEW(Closure, invoke := SetWindingProc),   in := 1);
    Bind(SetFace,  NEW(Closure, invoke := SetFaceProc),	     in := 1);
    Bind(SetSize,  NEW(Closure, invoke := SetSizeProc),	     in := 1);
    Bind(SetFont,  NEW(Closure, invoke := SetFontProc),	     in := 2);
    Bind(SetBBox,  NEW(Closure, invoke := SetBBoxProc),	     in := 2);
    Bind(ShowPage, NEW(Closure, invoke := ShowPageProc),     in := 0);
    Bind(ResetSym, NEW(Closure, invoke := ResetProc),        in := 0);
    Bind(SavePage, NEW(Closure, invoke := SavePageProc),     in := 0);
    Bind(RestPage, NEW(Closure, invoke := RestorePageProc),  in := 0);
    Bind(GetWidth, NEW(Closure, invoke := GetWidthProc),
      in := 0, out := 1);
    Bind(GetEnd,   NEW(Closure, invoke := GetEndStyleProc),
      in := 0, out := 1);
    Bind(GetJoin,  NEW(Closure, invoke := GetJoinStyleProc),
      in := 0, out := 1);
    Bind(GetColor, NEW(Closure, invoke := GetColorProc),
      in := 0, out := 1);
    Bind(GetWind,  NEW(Closure, invoke := GetWindingProc),
      in := 0, out := 1);
    Bind(GetFace,  NEW(Closure, invoke := GetFaceProc),
      in := 0, out := 1);
    Bind(GetSize,  NEW(Closure, invoke := GetSizeProc),
      in := 0, out := 1);
    Bind(GetFont,  NEW(Closure, invoke := GetFontProc),
      in := 0, out := 2);
    Bind(GetPtSz,  NEW(Closure, invoke := GetPtSizeProc),
      in := 0, out := 1);
    Bind(FontH,    NEW(Closure, invoke := FontHProc),
      in := 0, out := 2);
    Bind(StringW,  NEW(Closure, invoke := StringWProc),
      in := 1, out := 1);
    Bind(StringBB, NEW(Closure, invoke := StringBBProc),
      in := 1, out := 1);
    Bind(CurrPt,  NEW(Closure, invoke := CurrPtProc),
      in := 0, out := 1);
    Bind(CurrPath, NEW(Closure, invoke := CurrPathProc),
      in := 0, out := 1);
    Bind(GetBBox,  NEW(Closure, invoke := GetBBoxProc),
      in := 0, out := 2);
    RETURN res
  END New;

PROCEDURE <A NAME="StartToFile"><procedure>StartToFile</procedure></A>(impl: Impl; wr: Wr.T) =
</PRE><BLOCKQUOTE><EM> An implementation of the <CODE>startToFile</CODE> method of an <CODE>Impl</CODE>. </EM></BLOCKQUOTE><PRE>

  PROCEDURE Replace(name: Atom.T; cl: ToFileClosure) =
  (* Store the current external procedure stored under &quot;name&quot; in &quot;impl&quot;'s
     cache, replace it by &quot;cl&quot; in the external code table, and set the &quot;rt&quot;
     and &quot;i&quot; fields of &quot;cl&quot;. *)
    VAR p: JunoScope.Proc := JunoScope.Lookup(impl.scp, name); BEGIN
      WITH entry = impl.cache[impl.extCnt] DO
        entry.slot := p.index;
        entry.proc := JunoRT.ext_code_tbl[p.index];
        cl.rt := entry.proc.rt
      END;
      cl.i := impl;
      JunoRT.ext_code_tbl[p.index] := cl;
      INC(impl.extCnt)
    END Replace;

  (* StartToFile *)
  BEGIN
    impl.wr := wr;
    impl.extCnt := 0;
    impl.page := 1;
    Replace(Save,     NEW(ToFileClosure, invoke := SaveProc2));
    Replace(Restore,  NEW(ToFileClosure, invoke := RestoreProc2));
    Replace(NewPath,  NEW(ToFileClosure, invoke := NewPathProc2));
    Replace(MoveTo,   NEW(ToFileClosure, invoke := MoveToProc2));
    Replace(LineTo,   NEW(ToFileClosure, invoke := LineToProc2));
    Replace(CurveTo,  NEW(ToFileClosure, invoke := CurveToProc2));
    Replace(Close,    NEW(ToFileClosure, invoke := CloseProc2));
    Replace(Stroke,   NEW(ToFileClosure, invoke := StrokeProc2));
    Replace(Fill,     NEW(ToFileClosure, invoke := FillProc2));
    Replace(Type,     NEW(ToFileClosure, invoke := TypeProc2));
    Replace(SetWidth, NEW(ToFileClosure, invoke := SetWidthProc2));
    Replace(SetEnd,   NEW(ToFileClosure, invoke := SetEndStyleProc2));
    Replace(SetJoin,  NEW(ToFileClosure, invoke := SetJoinStyleProc2));
    Replace(SetColor, NEW(ToFileClosure, invoke := SetColorProc2));
    Replace(SetFace,  NEW(ToFileClosure, invoke := SetFaceProc2));
    Replace(SetSize,  NEW(ToFileClosure, invoke := SetSizeProc2));
    Replace(SetFont,  NEW(ToFileClosure, invoke := SetFontProc2));
    Replace(FontH,    NEW(ToFileClosure, invoke := FontHProc2));
    Replace(StringW,  NEW(ToFileClosure, invoke := StringWProc2));
    Replace(StringBB, NEW(ToFileClosure, invoke := StringBBProc2));
    Replace(ShowPage, NEW(ToFileClosure, invoke := ShowPageProc2));
    Replace(SavePage, NEW(ToFileClosure, invoke := SavePageProc2));
    Replace(RestPage, NEW(ToFileClosure, invoke := RestorePageProc2));
  END StartToFile;

PROCEDURE <A NAME="Prologue"><procedure>Prologue</procedure></A>(impl: Impl) RAISES {Wr.Failure} =
  BEGIN
    &lt;* ASSERT impl.wr # NIL *&gt;
    WriteHeader(impl.wr);
    WritePrologue(impl.wr, impl.rt.currView);
    WriteSetup(impl.wr, impl.rt.currView);
    WritePageHeader(impl.wr, impl.page)
  END Prologue;

PROCEDURE <A NAME="WriteHeader"><procedure>WriteHeader</procedure></A>(wr: Wr.T) RAISES {Wr.Failure} =
  BEGIN
    Wr.PutText(wr, &quot;%!PS-Adobe-3.0\n&quot;);
    Wr.PutText(wr, &quot;%%Creator: Juno-2\n&quot;);
    Wr.PutText(wr, &quot;%%Title: Juno.ps\n&quot;);
    Wr.PutText(wr, &quot;%%CreationDate: &quot;);
    WriteTime(wr, Time.Now());
    Wr.PutText(wr, &quot;\n%%BoundingBox: (atend)\n&quot;);
    Wr.PutText(wr, &quot;%%Pages: (atend)\n&quot;);
    Wr.PutText(wr, &quot;%%PageOrder: Ascend\n&quot;);
    Wr.PutText(wr, &quot;%%Orientation: &quot;
      &amp; JunoConfig.OrientName[JunoConfig.orientation] &amp; &quot;\n&quot;);
    Wr.PutText(wr, &quot;%%EndComments\n&quot;);
  END WriteHeader;

PROCEDURE <A NAME="WritePrologue"><procedure>WritePrologue</procedure></A>(wr: Wr.T; d: T) RAISES {Wr.Failure} =
  VAR ch: Drawing.ChildPublic := Filter.Child(d); BEGIN
    Wr.PutText(wr, &quot;\n%%BeginPrologue\n&quot;);

    (* define &quot;InitializeJunoPage&quot; procedure *)
    Wr.PutText(wr, &quot;% InitializeJunoPage\n%\n&quot;);
    Wr.PutText(wr, &quot;% Sets the initial graphics state for a Juno page\n&quot;);
    Wr.PutText(wr, &quot;/InitializeJunoPage {\n  &quot;);
    Wr.PutText(wr, Fmt.Real(DefaultColor.r)); Wr.PutChar(wr, ' ');
    Wr.PutText(wr, Fmt.Real(DefaultColor.g)); Wr.PutChar(wr, ' ');
    Wr.PutText(wr, Fmt.Real(DefaultColor.b));
    Wr.PutText(wr, &quot; setrgbcolor\n  &quot;);
    Wr.PutText(wr, Fmt.Real(DefaultWidth));
    Wr.PutText(wr, &quot; setlinewidth\n  &quot;);
    Wr.PutText(wr, Fmt.Int(EndMapInv[DefaultEndStyle]));
    Wr.PutText(wr, &quot; setlinecap\n  &quot;);
    Wr.PutText(wr, Fmt.Int(JoinMapInv[DefaultJointStyle]));
    Wr.PutText(wr, &quot; setlinejoin\n  &quot;);
    Wr.PutText(wr, &quot;10.435 setmiterlimit\n  &quot;);
    (* Wr.PutText(wr, &quot;newpath\n  &quot;); *)
    Wr.PutChar(wr, '/');
    Wr.PutText(wr, DefaultFaceName);
    WriteFindFont(wr);
    Wr.PutText(wr, Fmt.Real(defaultXFontPtSize));
    Wr.PutText(wr, &quot; scalefont setfont\n  &quot;);

    (* Translate and rotate if necessary, based on &quot;ch.getOrigin()&quot; and
       &quot;JunoConfig.orientation&quot;. The PostScript variables &quot;xCenter&quot; and
       &quot;yCenter&quot; are set to the coordinate at the center of the page for use
       by the &quot;showerror.ps&quot; code in case a run-time error needs to be
       displayed. *)
    CASE ch.getOrigin() OF
      JunoConfig.Origin.Center =&gt;
      	Wr.PutText(wr, Fmt.Real(HalfWidth));  Wr.PutChar(wr, ' ');
      	Wr.PutText(wr, Fmt.Real(HalfHeight)); Wr.PutChar(wr, ' ');
      	Wr.PutText(wr, &quot;translate\n&quot;)
    | JunoConfig.Origin.SW =&gt;
      	IF JunoConfig.orientation = JunoConfig.Orientation.Landscape THEN
      	  Wr.PutText(wr, Fmt.Real(PageWidth));
      	  Wr.PutText(wr, &quot; 0 translate\n&quot;)
      	END
    END;
    IF JunoConfig.orientation = JunoConfig.Orientation.Landscape THEN
      Wr.PutText(wr, &quot;  90 rotate\n&quot;);
    END;
    Wr.PutText(wr, &quot;} def\n\n&quot;);

    (* copy &quot;prologue.ps&quot; file *)
    &lt;* FATAL Rd.Failure, Rd.EndOfFile, Thread.Alerted, Rsrc.NotFound *&gt;
    VAR rd: Rd.T := Rsrc.Open(&quot;prologue.ps&quot;, JunoRsrc.Path); BEGIN
      (* copy PostScript code to &quot;wr&quot; *)
      WHILE NOT Rd.EOF(rd) DO Wr.PutChar(wr, Rd.GetChar(rd)) END;
      Rd.Close(rd)
    END;
    Wr.PutText(wr, &quot;%%EndPrologue\n&quot;)
  END WritePrologue;

PROCEDURE <A NAME="WriteTime"><procedure>WriteTime</procedure></A>(wr: Wr.T; t: Time.T) RAISES {Wr.Failure} =
</PRE><BLOCKQUOTE><EM> Writes the time <CODE>t</CODE> to <CODE>wr</CODE> in the form:
<PRE>
         &quot;Wed, Jun 22, 11:19:40 PDT, 1994&quot;.
</EM></BLOCKQUOTE><PRE>
  CONST
    MonthName = ARRAY OF TEXT{
      &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;,
      &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;};
    DayName = ARRAY OF TEXT{
      &quot;Sun&quot;, &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;};
  VAR d: Date.T := Date.FromTime(t); BEGIN
    Wr.PutText(wr, DayName[ORD(d.weekDay)]); Wr.PutText(wr, &quot;, &quot;);
    Wr.PutText(wr, MonthName[ORD(d.month)]); Wr.PutChar(wr, ' ');
    Wr.PutText(wr, Fmt.Int(d.day));          Wr.PutText(wr, &quot;, &quot;);
    Wr.PutText(wr, Fmt.Int(d.hour));         Wr.PutChar(wr, ':');
    Wr.PutText(wr, Fmt.Int(d.minute));       Wr.PutChar(wr, ':');
    Wr.PutText(wr, Fmt.Int(d.second));       Wr.PutChar(wr, ' ');
    Wr.PutText(wr, d.zone);                  Wr.PutText(wr, &quot;, &quot;);
    Wr.PutText(wr, Fmt.Int(d.year))
  END WriteTime;

PROCEDURE <A NAME="WriteFindFont"><procedure>WriteFindFont</procedure></A>(wr: Wr.T) RAISES {Wr.Failure} =
</PRE><BLOCKQUOTE><EM> Writes the name of the <CODE>findfont</CODE> procedure to <CODE>wr</CODE> surrounded by space
   characters. </EM></BLOCKQUOTE><PRE>
  BEGIN
    Wr.PutChar(wr, ' ');
    Wr.PutText(wr, FindFontProc);
    Wr.PutChar(wr, ' ')
  END WriteFindFont;

PROCEDURE <A NAME="WriteSetup"><procedure>WriteSetup</procedure></A>(wr: Wr.T; d: T) RAISES {Wr.Failure} =
  VAR ch: Drawing.ChildPublic := Filter.Child(d); dx, dy := 0.0; BEGIN
    Wr.PutText(wr, &quot;\n%%BeginSetup\n&quot;);
    Wr.PutText(wr, &quot;% define the coordinates of the center of the page\n&quot;);
    IF ch.getOrigin() = JunoConfig.Origin.SW THEN
      CASE JunoConfig.orientation OF
        JunoConfig.Orientation.Portrait =&gt;  dx := HalfWidth; dy := HalfHeight
      | JunoConfig.Orientation.Landscape =&gt; dx := HalfHeight; dy := HalfWidth
      END
    END;
    Wr.PutText(wr, &quot;/xCenter &quot; &amp; Fmt.Real(dx) &amp; &quot; def &quot;);
    Wr.PutText(wr, &quot;/yCenter &quot; &amp; Fmt.Real(dy) &amp; &quot; def\n&quot;);
    Wr.PutText(wr, &quot;%%EndSetup\n&quot;)
  END WriteSetup;

PROCEDURE <A NAME="WritePageHeader"><procedure>WritePageHeader</procedure></A>(wr: Wr.T; pageNum: CARDINAL) RAISES {Wr.Failure} =
  VAR pg := Fmt.Int(pageNum); BEGIN
    Wr.PutText(wr, &quot;\n%%Page: &quot;);
    Wr.PutText(wr, pg); Wr.PutChar(wr, ' '); Wr.PutText(wr, pg);
    Wr.PutText(wr, &quot;\nsave\n&quot;);
    Wr.PutText(wr, &quot;InitializeJunoPage\n&quot;)
  END WritePageHeader;

PROCEDURE <A NAME="WritePageTrailer"><procedure>WritePageTrailer</procedure></A>(wr: Wr.T) RAISES {Wr.Failure} =
</PRE><BLOCKQUOTE><EM> Invoked at the end of each page; brackets the <CODE>save</CODE> done in
   <CODE>WritePageHeader</CODE>. </EM></BLOCKQUOTE><PRE>
  BEGIN
    Wr.PutText(wr, &quot;restore\n&quot;);
  END WritePageTrailer;

PROCEDURE <A NAME="Epilogue"><procedure>Epilogue</procedure></A>(impl: Impl; showPage := FALSE) RAISES {Wr.Failure} =
</PRE><BLOCKQUOTE><EM> An implementation of the <CODE>endToFile</CODE> method of an <CODE>Impl</CODE>. </EM></BLOCKQUOTE><PRE>
  VAR
    d := impl.rt.currView;
    ch: Drawing.ChildPublic := Filter.Child(d);
  BEGIN
    &lt;* ASSERT impl.wr # NIL *&gt;
    WritePageTrailer(impl.wr);
    IF showPage THEN Wr.PutText(impl.wr, &quot;showpage\n&quot;) END;
    Wr.PutText(impl.wr, &quot;\n%%Trailer\n&quot;);
    Wr.PutText(impl.wr, &quot;%%BoundingBox: &quot;);
    VAR bbox := d.ps.bbox; BEGIN
      (* rotate if in &quot;JunoConfig.Orientation.Landscape&quot; *)
      IF JunoConfig.orientation = JunoConfig.Orientation.Landscape THEN
        IF ch.getOrigin() = JunoConfig.Origin.SW THEN
          (* translate to portrait-page origin *)
          bbox := JunoRect.Add(bbox, JunoPt.T{0.0, -PageWidth})
        END;
        bbox := JunoRect.Rotate90(bbox);
      END;
      (* translate if at &quot;Origin.Center&quot; *)
      IF ch.getOrigin() = JunoConfig.Origin.Center THEN
        bbox := JunoRect.Add(bbox, JunoPt.T{HalfWidth, HalfHeight})
      END;
      WriteRect(impl.wr, bbox)
    END;
    Wr.PutText(impl.wr, &quot;\n%%Pages: &quot;);
    Wr.PutText(impl.wr, Fmt.Int(impl.page));
    Wr.PutText(impl.wr, &quot;\n%%EOF\n&quot;)
  END Epilogue;

PROCEDURE <A NAME="EndToFile"><procedure>EndToFile</procedure></A>(impl: Impl) =
  BEGIN
    &lt;* ASSERT impl.wr # NIL *&gt;
    FOR i := FIRST(impl.cache) TO impl.extCnt - 1 DO
      JunoRT.ext_code_tbl[impl.cache[i].slot] := impl.cache[i].proc
    END;
    impl.wr := NIL
  END EndToFile;

PROCEDURE <A NAME="CopyState"><procedure>CopyState</procedure></A>(READONLY from: State; VAR (*OUT*) to: State) =
  BEGIN
    to := from;
    to.path := Path.Copy(from.path);
  END CopyState;

PROCEDURE <A NAME="SaveProc"><procedure>SaveProc</procedure></A>(dc: Closure): BOOLEAN =
  VAR d := dc.rt.currView; BEGIN
    IF d.sp &gt; LAST(d.psStack^) THEN
      VAR new := NEW(REF ARRAY OF State, 2 * NUMBER(d.psStack^)); BEGIN
        SUBARRAY(new^, 0, NUMBER(d.psStack^)) := d.psStack^;
        d.psStack := new
      END
    END;
    CopyState(d.ps, d.psStack[d.sp]);
    INC(d.sp);
    RETURN TRUE
  END SaveProc;

PROCEDURE <A NAME="SaveProc2"><procedure>SaveProc2</procedure></A>(cl: ToFileClosure): BOOLEAN =
  BEGIN
    IF NOT SaveProc(cl) THEN RETURN FALSE END;
    TRY Wr.PutText(cl.i.wr, &quot;gsave\n&quot;) EXCEPT
      Wr.Failure =&gt; RETURN FALSE
    END;
    RETURN TRUE
  END SaveProc2;

PROCEDURE <A NAME="RestoreProc"><procedure>RestoreProc</procedure></A>(dc: Closure): BOOLEAN =
  VAR d := dc.rt.currView; BEGIN
    IF d.sp = 0 THEN RETURN FALSE END;
    DEC(d.sp);
    d.ps := d.psStack[d.sp];
    RETURN TRUE
  END RestoreProc;

PROCEDURE <A NAME="RestoreProc2"><procedure>RestoreProc2</procedure></A>(cl: ToFileClosure): BOOLEAN =
  BEGIN
    IF NOT RestoreProc(cl) THEN RETURN FALSE END;
    TRY Wr.PutText(cl.i.wr, &quot;grestore\n&quot;) EXCEPT
      Wr.Failure =&gt; RETURN FALSE
    END;
    RETURN TRUE
  END RestoreProc2;

&lt;* INLINE *&gt;
PROCEDURE <A NAME="WritePoint"><procedure>WritePoint</procedure></A>(wr: Wr.T; READONLY pt: JunoPt.T) RAISES {Wr.Failure} =
  BEGIN
    Wr.PutText(wr, Fmt.Real(pt.x)); Wr.PutChar(wr, ' ');
    Wr.PutText(wr, Fmt.Real(pt.y)); Wr.PutChar(wr, ' ')
  END WritePoint;

&lt;* INLINE *&gt;
PROCEDURE <A NAME="WriteRect"><procedure>WriteRect</procedure></A>(wr: Wr.T; READONLY rect: JunoRect.T) RAISES {Wr.Failure} =
  BEGIN
    Wr.PutText(wr, Fmt.Real(rect.west));  Wr.PutChar(wr, ' ');
    Wr.PutText(wr, Fmt.Real(rect.south)); Wr.PutChar(wr, ' ');
    Wr.PutText(wr, Fmt.Real(rect.east));  Wr.PutChar(wr, ' ');
    Wr.PutText(wr, Fmt.Real(rect.north)); Wr.PutChar(wr, ' ')
  END WriteRect;
</PRE> ======================== Callback Procedures ============================ 

<P> Implementation Note:
<P>
   In most cases, when examining Juno arguments passed on the Juno machine's
   stack, we must use a <CODE>NULL =&gt;</CODE> TYPECASE arm to handle the possibility of
   Modula-3 NIL being passed on the stack. However, we can omit this TYPECASE
   arm when the expected value is a point, since the subsequent call to the
   procedure <CODE>JunoPt.FromValuePair</CODE> on this argument will raise <CODE>JunoPt.BadPt</CODE>
   in that case. 

<P><PRE>PROCEDURE <A NAME="NewPathProc"><procedure>NewPathProc</procedure></A>(dc: Closure): BOOLEAN =
  BEGIN
    ResetPath(dc.rt.currView.ps);
    RETURN TRUE
  END NewPathProc;

PROCEDURE <A NAME="NewPathProc2"><procedure>NewPathProc2</procedure></A>(cl: ToFileClosure): BOOLEAN =
  BEGIN
    IF NewPathProc(cl) THEN
      TRY
        Wr.PutText(cl.i.wr, &quot;newpath\n&quot;);
        RETURN TRUE
      EXCEPT Wr.Failure =&gt; (* SKIP *)
      END
    END;
    RETURN TRUE
  END NewPathProc2;

PROCEDURE <A NAME="MoveToProc"><procedure>MoveToProc</procedure></A>(dc: Closure): BOOLEAN =
  VAR err := FALSE; pr := JunoArgs.ReadPair(1, err); BEGIN
    IF NOT err THEN
      WITH ps = dc.rt.currView.ps DO
        VAR pt: JunoPt.T; BEGIN
          TRY pt := JunoPt.FromValuePair(pr) EXCEPT
            JunoPt.BadPt =&gt; RETURN FALSE
          END;
          ps.moveto := TRUE;
          ps.movetoPt := pt;
          ps.currPt := pt;
          ps.subpathStartPt := pt;
          RETURN TRUE
        END
      END
    END;
    RETURN FALSE
  END MoveToProc;

PROCEDURE <A NAME="MoveToProc2"><procedure>MoveToProc2</procedure></A>(cl: ToFileClosure): BOOLEAN =
  BEGIN
    IF MoveToProc(cl) THEN
      TRY
        WITH wr = cl.i.wr DO
          WritePoint(wr, cl.rt.currView.ps.currPt);
          Wr.PutText(wr, &quot;moveto\n&quot;)
        END;
        RETURN TRUE
      EXCEPT
        Wr.Failure =&gt; (* SKIP *)
      END
    ELSE (* SKIP *)
    END;
    RETURN FALSE
  END MoveToProc2;

PROCEDURE <A NAME="StartSegment"><procedure>StartSegment</procedure></A>(VAR (*INOUT*) ps: State; ch: Drawing.ChildPublic):
    BOOLEAN =
</PRE><BLOCKQUOTE><EM> Code executed when a new straight or curved segment is added to the path to
   maintain the invariants on the <CODE>moveto</CODE> and <CODE>movetoPt</CODE> fields. Returns
   FALSE iff the current path is logically empty. </EM></BLOCKQUOTE><PRE>
  BEGIN
    IF ps.moveto THEN
      ps.moveto := FALSE;
      Path.MoveTo(ps.path, JunoPt.ToHV(ps.movetoPt, ch.xform))
    ELSIF Path.IsClosed(ps.path) THEN
      RETURN FALSE
    END;
    RETURN TRUE
  END StartSegment;

PROCEDURE <A NAME="LineToProc"><procedure>LineToProc</procedure></A>(dc: Closure): BOOLEAN =
  BEGIN
    WITH d = dc.rt.currView, ps = d.ps DO
      VAR ch: Drawing.ChildPublic := Filter.Child(d); BEGIN
      	IF StartSegment(ps, ch) THEN
      	  VAR err := FALSE; pr := JunoArgs.ReadPair(1, err); BEGIN
      	    IF NOT err THEN
	      TRY ps.currPt := JunoPt.FromValuePair(pr) EXCEPT
		JunoPt.BadPt =&gt; RETURN FALSE
	      END;
      	      Path.LineTo(ps.path, JunoPt.ToHV(ps.currPt, ch.xform));
	      RETURN TRUE
      	    END
      	  END
      	END
      END
    END;
    RETURN FALSE
  END LineToProc;

PROCEDURE <A NAME="LineToProc2"><procedure>LineToProc2</procedure></A>(cl: ToFileClosure): BOOLEAN =
  BEGIN
    IF LineToProc(cl) THEN
      TRY
        WritePoint(cl.i.wr, cl.rt.currView.ps.currPt);
        Wr.PutText(cl.i.wr, &quot;lineto\n&quot;);
        RETURN TRUE
      EXCEPT Wr.Failure =&gt; (* SKIP *)
      END
    END;
    RETURN FALSE
  END LineToProc2;

PROCEDURE <A NAME="CurveToProc"><procedure>CurveToProc</procedure></A>(dc: Closure): BOOLEAN =
  VAR dummy1, dummy2, dummy3: JunoPt.T; BEGIN
    RETURN CurveToWork(dc, dummy1, dummy2, dummy3)
  END CurveToProc;

PROCEDURE <A NAME="CurveToProc2"><procedure>CurveToProc2</procedure></A>(cl: ToFileClosure): BOOLEAN =
  VAR pt1, pt2, pt3: JunoPt.T; BEGIN
    IF CurveToWork(cl, pt1, pt2, pt3) THEN
      WITH wr = cl.i.wr DO
        TRY
	  WritePoint(wr, pt1);
	  WritePoint(wr, pt2);
	  WritePoint(wr, pt3);
	  Wr.PutText(wr, &quot;curveto\n&quot;);
	  RETURN TRUE
        EXCEPT
          Wr.Failure =&gt; (* SKIP *)
        END;
      END
    END;
    RETURN FALSE
  END CurveToProc2;

PROCEDURE <A NAME="CurveToWork"><procedure>CurveToWork</procedure></A>(dc: Closure; VAR (*OUT*) pt1, pt2, pt3: JunoPt.T):
    BOOLEAN =
  BEGIN
    WITH d = dc.rt.currView, ps = d.ps DO
      VAR ch: Drawing.ChildPublic := Filter.Child(d); BEGIN
      	IF StartSegment(ps, ch) THEN
      	  VAR
      	    err := FALSE;
      	    pr1 := JunoArgs.ReadPair(3, err);
      	    pr2 := JunoArgs.ReadPair(2, err);
      	    pr3 := JunoArgs.ReadPair(1, err);
      	  BEGIN
      	    IF NOT err THEN
	      TRY
      		pt1 := JunoPt.FromValuePair(pr1);
      		pt2 := JunoPt.FromValuePair(pr2);
      		pt3 := JunoPt.FromValuePair(pr3)
	      EXCEPT
      		JunoPt.BadPt =&gt; RETURN FALSE
	      END;
	      Path.CurveTo(ps.path,
      		JunoPt.ToHV(pt1, ch.xform),
      		JunoPt.ToHV(pt2, ch.xform),
      		JunoPt.ToHV(pt3, ch.xform));
      	      ps.currPt := pt3;
	      RETURN TRUE
      	    END
	  END
      	END
      END
    END;
    RETURN FALSE
  END CurveToWork;

PROCEDURE <A NAME="CloseProc"><procedure>CloseProc</procedure></A>(dc: Closure): BOOLEAN =
  BEGIN
    WITH d = dc.rt.currView, ps = d.ps DO
      IF ps.moveto THEN
        ps.moveto := FALSE;
        VAR ch: Drawing.ChildPublic := Filter.Child(d); BEGIN
          Path.MoveTo(ps.path, JunoPt.ToHV(ps.movetoPt, ch.xform))
        END
      ELSIF Path.IsClosed(ps.path) THEN
        RETURN FALSE
      END;
      Path.Close(ps.path);
      ps.currPt := ps.subpathStartPt
    END;
    RETURN TRUE
  END CloseProc;

PROCEDURE <A NAME="CloseProc2"><procedure>CloseProc2</procedure></A>(cl: ToFileClosure): BOOLEAN =
  BEGIN
    IF CloseProc(cl) THEN
      TRY
        Wr.PutText(cl.i.wr, &quot;closepath\n&quot;);
        RETURN TRUE
      EXCEPT Wr.Failure =&gt; (* SKIP *)
      END;
    END;
    RETURN FALSE
  END CloseProc2;

PROCEDURE <A NAME="StrokeProc"><procedure>StrokeProc</procedure></A>(dc: Closure): BOOLEAN =
  BEGIN
    WITH d = dc.rt.currView, ps = d.ps DO
      VAR ch: Drawing.ChildPublic := Filter.Child(d); BEGIN
      	VBT.Stroke(ch, Rect.Full, ps.path,
      	  width := ROUND(ps.width * ch.xform.widthScale),
      	  end := ps.end, join := ps.join, op := ps.colorOp)
      END;
      ResetPath(ps)
    END;
    RETURN TRUE
  END StrokeProc;

PROCEDURE <A NAME="StrokeProc2"><procedure>StrokeProc2</procedure></A>(cl: ToFileClosure): BOOLEAN =
  BEGIN
    TRY Wr.PutText(cl.i.wr, &quot;stroke\n&quot;) EXCEPT
      Wr.Failure =&gt; RETURN FALSE
    END;
    ResetPath(cl.rt.currView.ps);
    RETURN TRUE
  END StrokeProc2;

PROCEDURE <A NAME="FillProc"><procedure>FillProc</procedure></A>(dc: Closure): BOOLEAN =
  BEGIN
    WITH d = dc.rt.currView, ps = d.ps DO
      VAR ch: Drawing.ChildPublic := Filter.Child(d); BEGIN
        VBT.Fill(ch, Rect.Full, ps.path, wind := ps.wind, op := ps.colorOp)
      END;
      ResetPath(ps)
    END;
    RETURN TRUE
  END FillProc;

PROCEDURE <A NAME="FillProc2"><procedure>FillProc2</procedure></A>(cl: ToFileClosure): BOOLEAN =
  BEGIN
    TRY
      CASE cl.rt.currView.ps.wind OF
    	VBT.WindingCondition.NonZero =&gt; Wr.PutText(cl.i.wr, &quot;fill\n&quot;)
      | VBT.WindingCondition.Odd     =&gt; Wr.PutText(cl.i.wr, &quot;eofill\n&quot;)
      END
    EXCEPT
      Wr.Failure =&gt; RETURN FALSE
    END;
    ResetPath(cl.rt.currView.ps);
    RETURN TRUE
  END FillProc2;

PROCEDURE <A NAME="TypeProc"><procedure>TypeProc</procedure></A>(dc: Closure): BOOLEAN =
  VAR
    err := FALSE;
    pr := JunoArgs.ReadPair(2, err);
    t := JunoArgs.ReadText(1, err);
  BEGIN
    IF NOT err THEN
      WITH d = dc.rt.currView, ps = d.ps DO
        VAR ch: Drawing.ChildPublic := Filter.Child(d); pt: JunoPt.T; BEGIN
          TRY pt := JunoPt.FromValuePair(pr) EXCEPT
            JunoPt.BadPt =&gt; RETURN FALSE
          END;
          VBT.PaintText(ch, fnt := ps.xFont, t := t,
            pt := JunoPt.ToHV(pt, ch.xform),
            op := ps.textColorOp);
          RETURN TRUE
        END
      END
    END;
    RETURN FALSE
  END TypeProc;

PROCEDURE <A NAME="TypeProc2"><procedure>TypeProc2</procedure></A>(cl: ToFileClosure): BOOLEAN =
  VAR
    err := FALSE;
    pr := JunoArgs.ReadPair(2, err);
    t := JunoArgs.ReadText(1, err);
  BEGIN
    IF NOT err THEN
      VAR wr := cl.i.wr; pt: JunoPt.T; BEGIN
        TRY
          pt := JunoPt.FromValuePair(pr);
          Wr.PutText(wr, &quot;gsave\n&quot;);
          WritePoint(wr, pt);
          Wr.PutText(wr, &quot;moveto\n(&quot;);
          Wr.PutText(wr, EscapeString(t));
          Wr.PutText(wr, &quot;) show\n&quot;);
          Wr.PutText(wr, &quot;grestore\n&quot;)
        EXCEPT
          JunoPt.BadPt, Wr.Failure =&gt; RETURN FALSE
        END;
        RETURN TRUE
      END
    END;
    RETURN FALSE
  END TypeProc2;

PROCEDURE <A NAME="EscapeString"><procedure>EscapeString</procedure></A>(t: TEXT): TEXT =
</PRE><BLOCKQUOTE><EM> Return a text equivalent to <CODE>t</CODE>, but with non-printing and PostScript-
   special characters (namely, '(', ')', and '\') converted to octal escape
   sequences. </EM></BLOCKQUOTE><PRE>
  CONST
    PSSpecial = SET OF CHAR {'(', ')', '\\'};
    Printing = SET OF CHAR {' ' .. '~'} - PSSpecial;
  PROCEDURE OctalString(c: CHAR): TEXT =
    BEGIN
      IF c IN PSSpecial THEN RETURN Text.FromChar(c) END;
      RETURN Fmt.Pad(Fmt.Int(ORD(c), base := 8), 3, padChar := '0')
    END OctalString;
  VAR res := &quot;&quot;; start := 0; c: CHAR; len := Text.Length(t); BEGIN
    FOR i := 0 TO len - 1 DO
      c := Text.GetChar(t, i);
      IF NOT c IN Printing THEN
        (* flush batch of chars in [start, i) *)
        IF start &lt; i THEN res := res &amp; Text.Sub(t, start, i - start) END;
        res := res &amp; &quot;\\&quot; &amp; OctalString(c);
        start := i + 1
      END
    END;
    (* fast path: no escaped characters *)
    IF start = 0 THEN RETURN t END;
    (* otherwise, flush suffix if necessary *)
    IF start &lt; len THEN res := res &amp; Text.Sub(t, start, len - start) END;
    RETURN res
  END EscapeString;

PROCEDURE <A NAME="SetWidthProc"><procedure>SetWidthProc</procedure></A>(dc: Closure): BOOLEAN =
  VAR err := FALSE; r := JunoArgs.ReadReal(1, err); BEGIN
    IF NOT err AND r &gt;= 0.0 THEN
      dc.rt.currView.ps.width := r;
      RETURN TRUE
    END;
    RETURN FALSE
  END SetWidthProc;

PROCEDURE <A NAME="SetWidthProc2"><procedure>SetWidthProc2</procedure></A>(cl: ToFileClosure): BOOLEAN =
  BEGIN
    IF SetWidthProc(cl) THEN
      TRY
        Wr.PutText(cl.i.wr, Fmt.Real(cl.rt.currView.ps.width));
        Wr.PutText(cl.i.wr, &quot; setlinewidth\n&quot;);
        RETURN TRUE
      EXCEPT Wr.Failure =&gt; (* SKIP *)
      END
    END;
    RETURN FALSE
  END SetWidthProc2;

PROCEDURE <A NAME="GetWidthProc"><procedure>GetWidthProc</procedure></A>(dc: Closure): BOOLEAN =
  BEGIN
    JunoArgs.WriteReal(1, dc.rt.currView.ps.width);
    RETURN TRUE
  END GetWidthProc;

CONST EndMap = ARRAY [ButtEndsVal..SquareEndsVal] OF VBT.EndStyle{
  VBT.EndStyle.Butt, VBT.EndStyle.Round, VBT.EndStyle.Square};

PROCEDURE <A NAME="SetEndStyleProc"><procedure>SetEndStyleProc</procedure></A>(dc: Closure): BOOLEAN =
  VAR err := FALSE; es := JunoArgs.ReadInt(1, err); BEGIN
    IF NOT err AND ButtEndsVal &lt;= es AND es &lt;= SquareEndsVal THEN
      dc.rt.currView.ps.end := EndMap[es];
      RETURN TRUE
    END;
    RETURN FALSE
  END SetEndStyleProc;

CONST EndMapInv = ARRAY VBT.EndStyle OF INTEGER{
  RoundEndsVal, ButtEndsVal, SquareEndsVal};

PROCEDURE <A NAME="SetEndStyleProc2"><procedure>SetEndStyleProc2</procedure></A>(cl: ToFileClosure): BOOLEAN =
  BEGIN
    IF SetEndStyleProc(cl) THEN
      TRY
        Wr.PutText(cl.i.wr, Fmt.Int(EndMapInv[cl.rt.currView.ps.end]));
        Wr.PutText(cl.i.wr, &quot; setlinecap\n&quot;)
      EXCEPT Wr.Failure =&gt; (* SKIP *)
      END
    END;
    RETURN TRUE
  END SetEndStyleProc2;

PROCEDURE <A NAME="GetEndStyleProc"><procedure>GetEndStyleProc</procedure></A>(dc: Closure): BOOLEAN =
  BEGIN
    JunoArgs.WriteInt(1, EndMapInv[dc.rt.currView.ps.end]);
    RETURN TRUE
  END GetEndStyleProc;

CONST JoinMap = ARRAY [MiterJointsVal..BevelJointsVal] OF VBT.JoinStyle {
  VBT.JoinStyle.Miter, VBT.JoinStyle.Round, VBT.JoinStyle.Bevel};

PROCEDURE <A NAME="SetJoinStyleProc"><procedure>SetJoinStyleProc</procedure></A>(dc: Closure): BOOLEAN =
  VAR err := FALSE; js := JunoArgs.ReadInt(1, err); BEGIN
    IF NOT err AND MiterJointsVal &lt;= js AND js &lt;= BevelJointsVal THEN
      dc.rt.currView.ps.join := JoinMap[js];
      RETURN TRUE
    END;
    RETURN FALSE
  END SetJoinStyleProc;

CONST JoinMapInv = ARRAY VBT.JoinStyle OF INTEGER {
  RoundJointsVal, BevelJointsVal, MiterJointsVal};

PROCEDURE <A NAME="SetJoinStyleProc2"><procedure>SetJoinStyleProc2</procedure></A>(cl: ToFileClosure): BOOLEAN =
  BEGIN
    IF SetJoinStyleProc(cl) THEN
      TRY
        Wr.PutText(cl.i.wr, Fmt.Int(JoinMapInv[cl.rt.currView.ps.join]));
        Wr.PutText(cl.i.wr, &quot; setlinejoin\n&quot;)
      EXCEPT Wr.Failure =&gt; (* SKIP *)
      END
    END;
    RETURN TRUE
  END SetJoinStyleProc2;

PROCEDURE <A NAME="GetJoinStyleProc"><procedure>GetJoinStyleProc</procedure></A>(dc: Closure): BOOLEAN =
  BEGIN
    JunoArgs.WriteInt(1, JoinMapInv[dc.rt.currView.ps.join]);
    RETURN TRUE
  END GetJoinStyleProc;

PROCEDURE <A NAME="ReadColor"><procedure>ReadColor</procedure></A>(VAR (*OUT*) color: Color): BOOLEAN =
</PRE><BLOCKQUOTE><EM> If argument <CODE>-1</CODE> is a color value, set <CODE>color</CODE> to that value and return
   TRUE; otherwise, return FALSE. </EM></BLOCKQUOTE><PRE>
  VAR err := FALSE; p1 := JunoArgs.ReadPair(1, err); BEGIN
    IF NOT err THEN
     TYPECASE p1.cdr OF NULL =&gt; | RTVal.Pair (p2) =&gt;
      TYPECASE p2.cdr OF NULL =&gt; | RTVal.Pair (p3) =&gt;
       TYPECASE p1.car OF NULL =&gt; | RTVal.Number (r) =&gt;
        TYPECASE p2.car OF NULL =&gt; | RTVal.Number (g) =&gt;
         TYPECASE p3.car OF NULL =&gt; | RTVal.Number (b) =&gt;
          IF p3.cdr = RTVal.nil AND
             0.0 &lt;= r.val AND r.val &lt;= 1.0 AND
             0.0 &lt;= g.val AND g.val &lt;= 1.0 AND
             0.0 &lt;= b.val AND b.val &lt;= 1.0 THEN
            color := Color{r.val, g.val, b.val};
            RETURN TRUE
          END
         ELSE (* SKIP *)
         END
        ELSE (* SKIP *)
        END
       ELSE (* SKIP *)
       END
      ELSE (* SKIP *)
      END
     ELSE (* SKIP *)
     END
    END;
    RETURN FALSE
  END ReadColor;

PROCEDURE <A NAME="SetColorProc"><procedure>SetColorProc</procedure></A>(dc: Closure): BOOLEAN =
  BEGIN
    WITH ps = dc.rt.currView.ps, c = ps.color DO
      IF ReadColor(c) THEN
        ps.colorOp := PaintOp.FromRGB(c.r, c.g, c.b,
          mode := PaintOp.Mode.Accurate, bw := PaintOp.BW.UseFg);
        ps.textColorOp := PaintOp.Pair(PaintOp.Transparent, ps.colorOp);
        RETURN TRUE
      END
    END;
    RETURN FALSE
  END SetColorProc;

PROCEDURE <A NAME="SetColorProc2"><procedure>SetColorProc2</procedure></A>(cl: ToFileClosure): BOOLEAN =
  BEGIN
    WITH c = cl.rt.currView.ps.color DO
      TRY
        IF ReadColor(c) THEN
          WITH wr = cl.i.wr DO
            Wr.PutText(wr, Fmt.Real(c.r)); Wr.PutChar(wr, ' ');
            Wr.PutText(wr, Fmt.Real(c.g)); Wr.PutChar(wr, ' ');
            Wr.PutText(wr, Fmt.Real(c.b));
            Wr.PutText(wr, &quot; setrgbcolor\n&quot;)
          END;
          RETURN TRUE
        END
      EXCEPT Wr.Failure =&gt; (* SKIP *)
      END
    END;
    RETURN FALSE
  END SetColorProc2;

PROCEDURE <A NAME="GetColorProc"><procedure>GetColorProc</procedure></A>(dc: Closure): BOOLEAN =
  BEGIN
    WITH color = dc.rt.currView.ps.color DO
      JunoArgs.WriteValue(1,
        RTVal.FromPair(RTVal.FromReal(color.r),
          RTVal.FromPair(RTVal.FromReal(color.g),
            RTVal.FromPair(RTVal.FromReal(color.b),
              RTVal.nil))))
    END;
    RETURN TRUE
  END GetColorProc;

CONST WindMap = ARRAY [NZWindingVal..OddWindingVal] OF VBT.WindingCondition {
  VBT.WindingCondition.NonZero, VBT.WindingCondition.Odd};

PROCEDURE <A NAME="SetWindingProc"><procedure>SetWindingProc</procedure></A>(dc: Closure): BOOLEAN =
  VAR err := FALSE; ws := JunoArgs.ReadInt(1, err); BEGIN
    IF NOT err AND NZWindingVal &lt;= ws AND ws &lt;= OddWindingVal THEN
      dc.rt.currView.ps.wind := WindMap[ws];
      RETURN TRUE
    END;
    RETURN FALSE
  END SetWindingProc;

CONST WindMapInv = ARRAY VBT.WindingCondition OF INTEGER {
  OddWindingVal, NZWindingVal};

PROCEDURE <A NAME="GetWindingProc"><procedure>GetWindingProc</procedure></A>(dc: Closure): BOOLEAN =
  BEGIN
    JunoArgs.WriteInt(1, WindMapInv[dc.rt.currView.ps.wind]);
    RETURN TRUE
  END GetWindingProc;

PROCEDURE <A NAME="GetXInfo"><procedure>GetXInfo</procedure></A>(face: TEXT; size: INTEGER): PSFont.XInfo =
  VAR ref: REFANY; BEGIN
    IF NOT fontTbl.get(face &amp; Fmt.Int(size), ref) THEN ref := NIL END;
    RETURN NARROW(ref, PSFont.XInfo)
  END GetXInfo;

PROCEDURE <A NAME="SetFaceProc"><procedure>SetFaceProc</procedure></A>(dc: Closure): BOOLEAN =
  VAR err := FALSE; nm := JunoArgs.ReadText(1, err); BEGIN
    IF NOT err THEN
      WITH ps = dc.rt.currView.ps DO
	VAR xInfo := GetXInfo(nm, ps.size); BEGIN
          IF xInfo = NIL THEN RETURN FALSE END;
          ps.face := nm; ps.ptSize := xInfo.ptSize;
	  ps.xFont := Font.FromName(ARRAY OF TEXT{xInfo.name});
          RETURN TRUE
	END
      END
    END;
    RETURN FALSE
  END SetFaceProc;

PROCEDURE <A NAME="SetFaceProc2"><procedure>SetFaceProc2</procedure></A>(cl: ToFileClosure): BOOLEAN =
  VAR err := FALSE; nm := JunoArgs.ReadText(1, err); BEGIN
    IF NOT err THEN
      WITH ps = cl.rt.currView.ps, wr = cl.i.wr DO
	VAR ref: REFANY; xInfo := GetXInfo(nm, ps.size); BEGIN
	  IF xInfo = NIL OR NOT metricTbl.get(nm, ref) THEN
            RETURN FALSE
          END;
          ps.face := nm; ps.ptSize := xInfo.ptSize;
	  ps.psMetric := ref;
          TRY
            Wr.PutChar(wr, '/'); Wr.PutText(wr, nm);
            WriteFindFont(wr);
	    Wr.PutText(wr, Fmt.Real(xInfo.ptSize));
            Wr.PutText(wr, &quot; scalefont setfont\n&quot;)
          EXCEPT
            Wr.Failure =&gt; RETURN FALSE
          END;
          RETURN TRUE
	END
      END
    END;
    RETURN FALSE
  END SetFaceProc2;

PROCEDURE <A NAME="SetSizeProc"><procedure>SetSizeProc</procedure></A>(dc: Closure): BOOLEAN =
  VAR err := FALSE; sz := JunoArgs.ReadInt(1, err); BEGIN
    IF NOT err AND sz &gt;= 0 THEN
      WITH ps = dc.rt.currView.ps DO
        VAR xInfo := GetXInfo(ps.face, sz); BEGIN
    	  IF xInfo = NIL THEN RETURN FALSE END;
          ps.size := sz; ps.ptSize := xInfo.ptSize;
    	  ps.xFont := Font.FromName(ARRAY OF TEXT{xInfo.name});
          RETURN TRUE
        END
      END
    END;
    RETURN FALSE
  END SetSizeProc;

PROCEDURE <A NAME="SetSizeProc2"><procedure>SetSizeProc2</procedure></A>(cl: ToFileClosure): BOOLEAN =
  VAR err := FALSE; sz := JunoArgs.ReadInt(1, err); BEGIN
    IF NOT err AND sz &gt;= 0 THEN
      WITH ps = cl.rt.currView.ps, wr = cl.i.wr DO
        VAR xInfo := GetXInfo(ps.face, sz); BEGIN
    	  IF xInfo = NIL THEN RETURN FALSE END;
          ps.size := sz; ps.ptSize := xInfo.ptSize;
          TRY
            Wr.PutChar(wr, '/'); Wr.PutText(wr, ps.face);
            WriteFindFont(wr);
            Wr.PutText(wr, Fmt.Real(xInfo.ptSize));
            Wr.PutText(wr, &quot; scalefont setfont\n&quot;)
          EXCEPT
            Wr.Failure =&gt; RETURN FALSE
          END;
          RETURN TRUE
        END
      END
    END;
    RETURN FALSE
  END SetSizeProc2;

PROCEDURE <A NAME="SetFontProc"><procedure>SetFontProc</procedure></A>(dc: Closure): BOOLEAN =
  VAR
    err := FALSE;
    nm := JunoArgs.ReadText(2, err);
    sz := JunoArgs.ReadInt(1, err);
  BEGIN
    IF NOT err AND sz &gt;= 0 THEN
      VAR xInfo := GetXInfo(nm, sz); BEGIN
        IF xInfo = NIL THEN RETURN FALSE END;
        WITH ps = dc.rt.currView.ps DO
          ps.face := nm; ps.size := sz; ps.ptSize := xInfo.ptSize;
	  ps.xFont := Font.FromName(ARRAY OF TEXT{xInfo.name})
	END;
	RETURN TRUE
      END
    END;
    RETURN FALSE
  END SetFontProc;

PROCEDURE <A NAME="SetFontProc2"><procedure>SetFontProc2</procedure></A>(cl: ToFileClosure): BOOLEAN =
  VAR
    err := FALSE;
    nm := JunoArgs.ReadText(2, err);
    sz := JunoArgs.ReadInt(1, err);
  BEGIN
    IF NOT err AND sz &gt;= 0 THEN
      VAR xInfo := GetXInfo(nm, sz); BEGIN
        IF xInfo = NIL THEN RETURN FALSE END;
        WITH ps = cl.rt.currView.ps, wr = cl.i.wr DO
          VAR ref: REFANY; BEGIN
            IF NOT metricTbl.get(nm, ref) THEN RETURN FALSE END;
            ps.psMetric := ref
	  END;
	  ps.face := nm; ps.size := sz; ps.ptSize := xInfo.ptSize;
          TRY
            Wr.PutChar(wr, '/'); Wr.PutText(wr, nm);
            WriteFindFont(wr);
	    Wr.PutText(wr, Fmt.Real(xInfo.ptSize));
	    Wr.PutText(wr, &quot; scalefont setfont\n&quot;)
          EXCEPT
            Wr.Failure =&gt; RETURN FALSE
          END;
          RETURN TRUE
        END
      END
    END;
    RETURN FALSE
  END SetFontProc2;

PROCEDURE <A NAME="GetFaceProc"><procedure>GetFaceProc</procedure></A>(dc: Closure): BOOLEAN =
  BEGIN
    JunoArgs.WriteText(1, dc.rt.currView.ps.face);
    RETURN TRUE
  END GetFaceProc;

PROCEDURE <A NAME="GetSizeProc"><procedure>GetSizeProc</procedure></A>(dc: Closure): BOOLEAN =
  BEGIN
    JunoArgs.WriteInt(1, dc.rt.currView.ps.size);
    RETURN TRUE
  END GetSizeProc;

PROCEDURE <A NAME="GetFontProc"><procedure>GetFontProc</procedure></A>(dc: Closure): BOOLEAN =
  BEGIN
    JunoArgs.WriteText(2, dc.rt.currView.ps.face);
    JunoArgs.WriteInt(1, dc.rt.currView.ps.size);
    RETURN TRUE
  END GetFontProc;

PROCEDURE <A NAME="GetPtSizeProc"><procedure>GetPtSizeProc</procedure></A>(dc: Closure): BOOLEAN =
  BEGIN
    JunoArgs.WriteReal(1, dc.rt.currView.ps.ptSize);
    RETURN TRUE
  END GetPtSizeProc;

PROCEDURE <A NAME="FontHProc"><procedure>FontHProc</procedure></A>(dc: Closure): BOOLEAN =
</PRE><BLOCKQUOTE><EM> Note: We can use a <CODE>dummy</CODE> string, since we only care about the ascent and
   descent of the font, and <CODE>VBT.BoundingBox</CODE> returns the same ascent and
   descent regardless of its argument. </EM></BLOCKQUOTE><PRE>
  BEGIN
    WITH d = dc.rt.currView DO
      VAR
        ch: Drawing.ChildPublic := Filter.Child(d);
        bbox := VBT.BoundingBox(ch, &quot;a&quot;, d.ps.xFont);
      BEGIN
        WITH yScale = ch.xform.yScale DO
          JunoArgs.WriteReal(2, -FLOAT(bbox.north, JunoValue.Real) / yScale);
          JunoArgs.WriteReal(1,  FLOAT(bbox.south, JunoValue.Real) / yScale)
        END;
        RETURN TRUE
      END
    END
  END FontHProc;

PROCEDURE <A NAME="FontHProc2"><procedure>FontHProc2</procedure></A>(cl: ToFileClosure): BOOLEAN =
  BEGIN
    WITH
      ps = cl.rt.currView.ps,
      sz = ps.ptSize,
      bbox = ps.psMetric.bbox
    DO
      JunoArgs.WriteReal(2,  sz * bbox.north);
      JunoArgs.WriteReal(1, -sz * bbox.south)
    END;
    RETURN TRUE
  END FontHProc2;

PROCEDURE <A NAME="StringWProc"><procedure>StringWProc</procedure></A>(dc: Closure): BOOLEAN =
  VAR err := FALSE; t := JunoArgs.ReadText(1, err); BEGIN
    IF NOT err THEN
      WITH d = dc.rt.currView DO
        VAR
          ch: Drawing.ChildPublic := Filter.Child(d);
          w := VBT.TextWidth(ch, t, d.ps.xFont);
        BEGIN
          JunoArgs.WriteReal(2, FLOAT(w, JunoValue.Real) / ch.xform.xScale)
        END;
        RETURN TRUE
      END
    END;
    RETURN FALSE
  END StringWProc;

PROCEDURE <A NAME="StringWProc2"><procedure>StringWProc2</procedure></A>(cl: ToFileClosure): BOOLEAN =
  VAR err := FALSE; t := JunoArgs.ReadText(1, err); BEGIN
    IF NOT err THEN
      WITH metric = cl.rt.currView.ps.psMetric DO
        VAR total: JunoValue.Real := 0.0; BEGIN
          FOR i := 0 TO Text.Length(t) - 1 DO
            VAR code := ORD(Text.GetChar(t, i)); BEGIN
              IF metric.mapped[code] THEN
                total := total + metric.width[code]
              END
            END
          END;
          JunoArgs.WriteReal(2, total * cl.rt.currView.ps.ptSize);
          RETURN TRUE
        END
      END
    END;
    RETURN FALSE
  END StringWProc2;

PROCEDURE <A NAME="StringBBProc"><procedure>StringBBProc</procedure></A>(dc: Closure): BOOLEAN =
  VAR err := FALSE; t := JunoArgs.ReadText(1, err); BEGIN
    IF NOT err THEN
      WITH d = dc.rt.currView DO
      	VAR
      	  ch: Drawing.ChildPublic := Filter.Child(d);
          r: Rect.T := VBTExtras.TightBoundingBox(ch, t, d.ps.xFont);
          res: JunoRect.T;
      	BEGIN
          IF r = Rect.Empty THEN
            res := JunoRect.Empty
          ELSE
      	    WITH xScale = ch.xform.xScale, yScale = ch.xform.yScale DO
      	      res := JunoRect.T{
      	  	(FLOAT( r.west,  JunoValue.Real) - 0.49) / xScale,
      	  	(FLOAT( r.east,  JunoValue.Real) - 0.49) / xScale,
      	  	(FLOAT(-r.north, JunoValue.Real) + 0.51) / yScale,
      	  	(FLOAT(-r.south, JunoValue.Real) + 0.51) / yScale}
            END
      	  END;
          JunoArgs.WriteValue(2, JunoRect.ToRTVal(res));
      	  RETURN TRUE
      	END
      END
    END;
    RETURN FALSE
  END StringBBProc;

PROCEDURE <A NAME="StringBBProc2"><procedure>StringBBProc2</procedure></A>(cl: ToFileClosure): BOOLEAN =
  VAR err := FALSE; t := JunoArgs.ReadText(1, err); BEGIN
    IF NOT err THEN
      WITH ps = cl.rt.currView.ps DO
        VAR res: JunoRect.T; empty := TRUE; refPt := 0.0; BEGIN
          FOR i := 0 TO Text.Length(t) - 1 DO
            VAR code := ORD(Text.GetChar(t, i)); BEGIN
              IF NOT ps.psMetric.mapped[code] THEN
                (* Map unencoded characters to the space character *)
                code := ORD(' ');
                &lt;* ASSERT ps.psMetric.mapped[code] *&gt;
              END;
              VAR
                bbox := ps.psMetric.charBB[code];
                bbox2: JunoRect.T;
              BEGIN
            	IF bbox # NIL THEN
            	  bbox2 := JunoRect.Add(bbox^, JunoPt.T{refPt, 0.0});
            	  IF empty
            	    THEN empty := FALSE; res := bbox2
            	    ELSE res := JunoRect.Join(res, bbox2)
            	  END
            	END;
            	refPt := refPt + ps.psMetric.width[code]
              END
            END
          END;
          IF empty
            THEN res := JunoRect.T{0.0, 0.0, 0.0, 0.0}
            ELSE res := JunoRect.Scale(res, ps.ptSize)
          END;
          JunoArgs.WriteValue(2, JunoRect.ToRTVal(res));
          RETURN TRUE
        END
      END
    END;
    RETURN FALSE
  END StringBBProc2;

PROCEDURE <A NAME="CurrPtProc"><procedure>CurrPtProc</procedure></A>(dc: Closure): BOOLEAN =
  BEGIN
    WITH ps = dc.rt.currView.ps DO
      IF NOT ps.moveto AND Path.IsClosed(ps.path)
        THEN JunoArgs.WriteValue(1, RTVal.nil)
        ELSE JunoArgs.WriteValue(1, JunoPt.ToValuePair(ps.currPt))
      END
    END;
    RETURN TRUE
  END CurrPtProc;

VAR Nil := RTVal.nil;

TYPE
  JunoMO = Path.MapObject BRANDED &quot;PSImpl.JunoMO&quot; OBJECT
    ch: Drawing.ChildPublic;
    head, curr: RTVal.Pair;
  METHODS
    init(): JunoMO := JunoMOInit
  OVERRIDES
    move := AddMoveTo;
    line := AddLineTo;
    curve := AddCurveTo;
    close := AddClose
  END;

PROCEDURE <A NAME="JunoMOInit"><procedure>JunoMOInit</procedure></A>(self: JunoMO): JunoMO =
  BEGIN
    self.head := RTVal.FromPair(Nil, Nil);
    self.curr := self.head;
    RETURN self
  END JunoMOInit;

PROCEDURE <A NAME="AddNewList"><procedure>AddNewList</procedure></A>(self: JunoMO; nm: TEXT): RTVal.Pair =
  VAR pr := RTVal.FromPair(RTVal.FromText(nm), Nil); BEGIN
    self.curr.cdr := RTVal.FromPair(pr, Nil);
    self.curr := self.curr.cdr;
    RETURN pr
  END AddNewList;

PROCEDURE <A NAME="AddPt"><procedure>AddPt</procedure></A>(
    VAR (*INOUT*) pr: RTVal.Pair;
    READONLY pt: Point.T;
    ch: Drawing.ChildPublic) =
  VAR pair := JunoPt.ToValuePair(JunoPt.FromHV(pt, ch.xform)); BEGIN
    pr.cdr := RTVal.FromPair(pair, Nil);
    pr := pr.cdr;
  END AddPt;

PROCEDURE <A NAME="AddMoveTo"><procedure>AddMoveTo</procedure></A>(self: JunoMO; READONLY pt: Point.T) =
  VAR pr := AddNewList(self, &quot;MoveTo&quot;); BEGIN
    AddPt(pr, pt, self.ch);
    pr.cdr := Nil
  END AddMoveTo;

PROCEDURE <A NAME="AddLineTo"><procedure>AddLineTo</procedure></A>(
    self: JunoMO;
    &lt;*UNUSED*&gt; READONLY pt1: Point.T;
    READONLY pt2: Point.T) =
  VAR pr := AddNewList(self, &quot;LineTo&quot;); BEGIN
    AddPt(pr, pt2, self.ch);
    pr.cdr := Nil
  END AddLineTo;

PROCEDURE <A NAME="AddCurveTo"><procedure>AddCurveTo</procedure></A>(
    self: JunoMO;
    &lt;*UNUSED*&gt; READONLY pt1: Point.T;
    READONLY pt2, pt3, pt4: Point.T)=
  VAR pr := AddNewList(self, &quot;CurveTo&quot;); BEGIN
    AddPt(pr, pt2, self.ch);
    AddPt(pr, pt3, self.ch);
    AddPt(pr, pt4, self.ch);
    pr.cdr := Nil
  END AddCurveTo;

PROCEDURE <A NAME="AddClose"><procedure>AddClose</procedure></A>(self: JunoMO; &lt;*UNUSED*&gt; READONLY pt1, pt2: Point.T) =
  VAR pr := AddNewList(self, &quot;Close&quot;); BEGIN
    pr.cdr := Nil
  END AddClose;

PROCEDURE <A NAME="CurrPathProc"><procedure>CurrPathProc</procedure></A>(dc: Closure): BOOLEAN =
  &lt;* FATAL Path.Malformed *&gt;
  VAR jmo: JunoMO; BEGIN
    WITH d = dc.rt.currView, ps = d.ps DO
      jmo := NEW(JunoMO, ch := Filter.Child(d)).init();
      Path.Map(ps.path, jmo);
      IF ps.moveto THEN
        jmo.move(JunoPt.ToHV(ps.movetoPt, jmo.ch.xform))
      END;
      JunoArgs.WriteValue(1, jmo.head.cdr)
    END;
    RETURN TRUE
  END CurrPathProc;

PROCEDURE <A NAME="SetBBoxProc"><procedure>SetBBoxProc</procedure></A>(dc: Closure): BOOLEAN =
  VAR
    err := FALSE;
    pr1 := JunoArgs.ReadPair(2, err);
    pr2 := JunoArgs.ReadPair(1, err);
    pt1, pt2: JunoPt.T;
  BEGIN
    IF NOT err THEN
      TRY
        pt1 := JunoPt.FromValuePair(pr1);
        pt2 := JunoPt.FromValuePair(pr2)
      EXCEPT
        JunoPt.BadPt =&gt; RETURN FALSE
      END;
      WITH bbox = dc.rt.currView.ps.bbox DO
        bbox.west := MIN(pt1.x, pt2.x);
        bbox.east := MAX(pt1.x, pt2.x);
        bbox.south := MIN(pt1.y, pt2.y);
        bbox.north := MAX(pt1.y, pt2.y)
      END;
      RETURN TRUE
    END;
    RETURN FALSE
  END SetBBoxProc;

PROCEDURE <A NAME="GetBBoxProc"><procedure>GetBBoxProc</procedure></A>(dc: Closure): BOOLEAN =
  BEGIN
    WITH bbox = dc.rt.currView.ps.bbox DO
      JunoArgs.WriteValue(2, JunoPt.ToValuePair(
        JunoPt.T{x := bbox.west, y := bbox.south}));
      JunoArgs.WriteValue(1, JunoPt.ToValuePair(
        JunoPt.T{x := bbox.east, y := bbox.north}))
    END;
    RETURN TRUE
  END GetBBoxProc;

PROCEDURE <A NAME="ShowPageProc"><procedure>ShowPageProc</procedure></A>(dc: Closure): BOOLEAN =
  BEGIN
    Drawing.Sync(Filter.Child(dc.rt.currView));
    RETURN TRUE
  END ShowPageProc;

PROCEDURE <A NAME="ShowPageProc2"><procedure>ShowPageProc2</procedure></A>(cl: ToFileClosure): BOOLEAN =
  BEGIN
    INC(cl.i.page);
    TRY
      WITH wr = cl.i.wr DO
        WritePageTrailer(wr);
      	Wr.PutText(wr, &quot;showpage\n&quot;);
      	WritePageHeader(wr, cl.i.page)
      END;
      RETURN TRUE
    EXCEPT Wr.Failure =&gt; (* SKIP *)
    END;
    RETURN FALSE
  END ShowPageProc2;

PROCEDURE <A NAME="ResetProc"><procedure>ResetProc</procedure></A>(dc: Closure): BOOLEAN =
  VAR d := dc.rt.currView; ch: Drawing.ChildPublic := Filter.Child(d); BEGIN
    VBT.PaintTint(ch, Rect.Full, PaintOp.Bg);
    Reset(d);
    RETURN TRUE
  END ResetProc;

PROCEDURE <A NAME="SavePageProc"><procedure>SavePageProc</procedure></A>(dc: Closure): BOOLEAN =
  BEGIN
    DblBufferVBT.Save(Filter.Child(dc.rt.currView));
    RETURN TRUE
  END SavePageProc;

PROCEDURE <A NAME="SavePageProc2"><procedure>SavePageProc2</procedure></A>(&lt;*UNUSED*&gt; cl: ToFileClosure): BOOLEAN =
  BEGIN RETURN TRUE END SavePageProc2;

PROCEDURE <A NAME="RestorePageProc"><procedure>RestorePageProc</procedure></A>(dc: Closure): BOOLEAN =
  BEGIN
    DblBufferVBT.Restore(Filter.Child(dc.rt.currView));
    RETURN TRUE
  END RestorePageProc;

PROCEDURE <A NAME="RestorePageProc2"><procedure>RestorePageProc2</procedure></A>(&lt;*UNUSED*&gt; cl: ToFileClosure): BOOLEAN =
  BEGIN RETURN TRUE END RestorePageProc2;

BEGIN
  (* read the font data from the pickle *)
  &lt;* FATAL Rd.Failure, Rd.EndOfFile, Rsrc.NotFound *&gt;
  VAR
    rd := Rsrc.Open(&quot;FontData.pkl&quot;, JunoRsrc.Path);
    fontData: PSFont.Data;
  BEGIN
    TRY fontData := Pickle.Read(rd) EXCEPT Pickle.Error (msg) =&gt;
      &lt;* FATAL Wr.Failure *&gt; BEGIN
        Wr.PutText(stderr, &quot;Error reading pickled font data: &quot; &amp; msg &amp; &quot;\n&quot;);
        Wr.Flush(stderr)
      END;
      Process.Exit(1)
    END;
    Rd.Close(rd);
    fontTbl := fontData.fontTbl;
    metricTbl := fontData.metricTbl
  END;

  (* set defaultXFont *)
  VAR xInfo := GetXInfo(DefaultFaceName, DefaultFontSize); BEGIN
    IF xInfo = NIL THEN RAISE Error END;
    defaultXFont := Font.FromName(ARRAY OF TEXT{xInfo.name});
    defaultXFontPtSize := xInfo.ptSize
  END;

  (* set default metric *)
  VAR ref: REFANY; BEGIN
    IF metricTbl.get(DefaultFaceName, ref)
      THEN defaultPSMetric := ref
      ELSE RAISE Error
    END
  END
END PSImpl.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface JunoRect is in:
</A><UL>
<LI><A HREF="JunoRect.i3.html#0TOP0">juno-app/src/JunoRect.i3</A>
<LI><A HREF="../../pkl-fonts/src/JunoRect.i3.html#0TOP0">pkl-fonts/src/JunoRect.i3</A>
</UL>
<P>
<HR>
<A NAME="x2">interface PSFont is in:
</A><UL>
<LI><A HREF="PSFont.i3.html#0TOP0">juno-app/src/PSFont.i3</A>
<LI><A HREF="../../pkl-fonts/src/PSFont.i3.html#0TOP0">pkl-fonts/src/PSFont.i3</A>
</UL>
<P>
<HR>
<A NAME="x3">interface View is in:
</A><UL>
<LI><A HREF="View.i3.html#0TOP0">juno-app/src/View.i3</A>
<LI><A HREF="../../zeus/src/View.i3.html#0TOP0">zeus/src/View.i3</A>
</UL>
<P>
<HR>
<A NAME="x4">interface JunoValue is in:
</A><UL>
<LI><A HREF="../../juno-machine/src/JunoValue.i3.html#0TOP0">juno-machine/src/JunoValue.i3</A>
<LI><A HREF="../../pkl-fonts/src/JunoValue.i3.html#0TOP0">pkl-fonts/src/JunoValue.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
