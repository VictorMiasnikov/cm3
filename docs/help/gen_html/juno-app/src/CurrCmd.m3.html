<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: juno-app/src/CurrCmd.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>juno-app/src/CurrCmd.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright (C) 1992, Digital Equipment Corporation                         
 All rights reserved.                                                      
 See the file COPYRIGHT for a full description.                            
                                                                           
 Last modified on Sun Oct 26 13:38:54 PST 1997 by heydon                   
      modified on Tue May 30 12:01:27 PST 1995 by gnelson                  
      modified on Sat Aug 22 22:40:59 PDT 1992 by myers                    
<PRE>&lt;*PRAGMA LL*&gt;

MODULE <module><implements><A HREF="CurrCmd.i3.html">CurrCmd</A></implements></module>;

IMPORT <A HREF="JunoBuild.i3.html">JunoBuild</A>, <A HREF="JunoPt.i3.html">JunoPt</A>;
IMPORT <A HREF="../../juno-compiler/src/JunoAST.i3.html">JunoAST</A>, <A HREF="../../juno-compiler/src/JunoASTUtils.i3.html">JunoASTUtils</A>, <A HREF="../../juno-compiler/src/JunoChkBNF.i3.html">JunoChkBNF</A>, <A HREF="../../juno-compiler/src/JunoCompileErr.i3.html">JunoCompileErr</A>, <A HREF="../../juno-compiler/src/JunoScope.i3.html">JunoScope</A>;
IMPORT <A HREF="../../juno-machine/src/JunoRT.i3.html">JunoRT</A>, <A HREF="#x1">JunoValue</A> AS Value, <A HREF="../../juno-machine/src/JunoRTError.i3.html">JunoRTError</A>;
IMPORT <A HREF="../../libm3/src/atom/Atom.i3.html">Atom</A>, <A HREF="../../libm3/derived/AtomRefTbl.i3.html">AtomRefTbl</A>, <A HREF="../../libm3/src/fmtlex/Fmt.i3.html">Fmt</A>;

CONST InitCacheSize = 30;

REVEAL
  <A NAME="T">T</A> = TPublic BRANDED &quot;CurrCmd.T&quot; OBJECT
    ast: JunoAST.Cmd;
    scp: JunoScope.T;
    pointCache, oldPointCache: AtomRefTbl.Default;
    othersCache, oldOthersCache: AtomRefTbl.Default;
    changedVal: REF ARRAY OF BOOLEAN;
  END;
</PRE> A <CODE>CurrCmd.T</CODE> contains <CODE>ast</CODE>, an AST representing a current command. This
   field should never be <CODE>NIL</CODE>.
<P>
   <CODE>pointCache</CODE> maps names of variables representing points to their
   current positions, represented as <CODE>Value.T</CODE>'s. The <CODE>othersCache</CODE> is
   similar, but maps to all values that are not pairs of real numbers.
   The <CODE>old...</CODE> caches are used to tell when one of the cached values has
   changed, to avoid unnecessary compilations of the current command.
<P>
   The <CODE>changedVal</CODE> array is set by the <CODE>FillCache</CODE> procedure, and used by the
   <CODE>UpdateNearVars</CODE> procedure. If there are <CODE>n</CODE> variables in the current
   command, then <CODE>changedVal[i]</CODE> for <CODE>0 &lt;= i &lt; n</CODE> is true iff the current
   value of the <CODE>i</CODE>th variable is different from the cached value, or if there
   is no value cached for the <CODE>i</CODE>th variable. 

<P><PRE>VAR R2DotPlus := JunoASTUtils.QIdFromTexts(&quot;R2&quot;, &quot;Plus&quot;);
</PRE> ----------------- Creation / Replacement / Accessors -------------------- 

<P><PRE>PROCEDURE <A NAME="New"><procedure>New</procedure></A>(ast: JunoAST.Cmd; scp: JunoScope.T): T =
  VAR res: T; BEGIN
    &lt;* ASSERT ast # NIL *&gt;
    res := NEW(T, ast := ast,
      pointCache := NEW(AtomRefTbl.Default).init(sizeHint := InitCacheSize),
      oldPointCache := NEW(AtomRefTbl.Default).init(sizeHint := InitCacheSize),
      othersCache := NEW(AtomRefTbl.Default).init(sizeHint := InitCacheSize),
      oldOthersCache := NEW(AtomRefTbl.Default).init(sizeHint:=InitCacheSize),
      changedVal := NEW(REF ARRAY OF BOOLEAN, InitCacheSize));
    IF scp = NIL THEN scp := JunoScope.New(NIL) END;
    res.scp := scp;
    RETURN res
  END New;

PROCEDURE <A NAME="GetAST"><procedure>GetAST</procedure></A>(cc: T): JunoAST.Cmd =
  BEGIN RETURN cc.ast END GetAST;

PROCEDURE <A NAME="ChangeAST"><procedure>ChangeAST</procedure></A>(cc: T; ast: JunoAST.Cmd) =
  BEGIN
    &lt;* ASSERT ast # NIL *&gt;
    cc.ast := ast;
    cc.codeValid := FALSE;
    ClearCaches(cc)
  END ChangeAST;

PROCEDURE <A NAME="GetVariables"><procedure>GetVariables</procedure></A>(ast: JunoAST.Cmd): JunoAST.NearVarList =
  BEGIN
    TYPECASE ast OF JunoAST.Proj (p) =&gt;
      RETURN p.vars
    ELSE RETURN JunoAST.EmptyNVList
    END
  END GetVariables;

PROCEDURE <A NAME="GetVariable"><procedure>GetVariable</procedure></A>(ast: JunoAST.T; name: JunoAST.Id): JunoAST.NearVarLink =
  VAR vars := GetVariables(ast); BEGIN
    VAR v: JunoAST.NearVarLink := vars.head; BEGIN
      WHILE v # NIL DO
        IF v.id = name THEN RETURN v END;
        v := v.next
      END
    END;
    RETURN NIL
  END GetVariable;

PROCEDURE <A NAME="GetConstraint"><procedure>GetConstraint</procedure></A>(ast: JunoAST.Cmd): JunoAST.Formula =
  BEGIN
    TYPECASE ast OF JunoAST.Proj (p) =&gt;
      TYPECASE p.body OF JunoAST.Guard (g) =&gt;
        RETURN g.grd
      ELSE (* SKIP *)
      END
    ELSE (* SKIP *)
    END;
    RETURN JunoAST.TrueVal
  END GetConstraint;

PROCEDURE <A NAME="GetCmd"><procedure>GetCmd</procedure></A>(ast: JunoAST.Cmd): JunoAST.Cmd =
  BEGIN
    TYPECASE ast OF JunoAST.Proj (p) =&gt;
      TYPECASE p.body OF JunoAST.Guard (g) =&gt;
        RETURN g.body
      ELSE RETURN p.body
      END
    ELSE RETURN ast
    END
  END GetCmd;
</PRE> --------------------- Scope-Related Operations -------------------------- 

<P><PRE>PROCEDURE <A NAME="GetScope"><procedure>GetScope</procedure></A>(cc: T): JunoScope.T =
  BEGIN RETURN cc.scp END GetScope;

PROCEDURE <A NAME="SetScope"><procedure>SetScope</procedure></A>(cc: T; scp: JunoScope.T) =
  BEGIN cc.scp := scp END SetScope;

PROCEDURE <A NAME="NewDeclName"><procedure>NewDeclName</procedure></A>(cc: T; prefix: TEXT; tryEmptySuffix := FALSE): TEXT =
  VAR res := prefix; i := 0; BEGIN
    WHILE
      (i = 0 AND NOT tryEmptySuffix) OR
      JunoScope.Lookup(cc.scp, Atom.FromText(res), localOnly := TRUE) # NIL
    DO
      res := prefix &amp; Fmt.Int(i);
      INC(i)
    END;
    RETURN res
  END NewDeclName;
</PRE> --------------------------- Modification -------------------------------- 

<P><PRE>PROCEDURE <A NAME="Skipify"><procedure>Skipify</procedure></A>(ast: JunoAST.Cmd): JunoAST.Cmd =
  BEGIN
    TYPECASE ast OF
      JunoAST.Proj (p) =&gt;
        RETURN NEW(JunoAST.Proj, bp := p,
          vars := p.vars, body := Skipify(p.body))
    | JunoAST.Guard (g) =&gt;
        RETURN NEW(JunoAST.Guard, bp := g,
          grd := g.grd, body := Skipify(g.body))
    ELSE RETURN JunoAST.SkipVal
    END
  END Skipify;

PROCEDURE <A NAME="AddVariable"><procedure>AddVariable</procedure></A>(
    cc: T;
    v: JunoAST.Id;
    loc: JunoPt.T;
    near: JunoAST.Expr;
    frozen := FALSE) =
  VAR
    new := NEW(JunoAST.NearVarLink, id := v,
      hint := near, frozen := frozen);
  BEGIN
    &lt;* ASSERT near # NIL *&gt;
    TYPECASE cc.ast OF &lt;* NOWARN *&gt;
      JunoAST.Proj (p) =&gt;
        VAR v2 := p.vars.head; BEGIN
          WHILE v2.next # NIL DO
            &lt;* ASSERT v2.id # v *&gt;
            v2 := v2.next
          END;
          v2.next := new;
          p.vars.size := p.vars.size + 1
        END
    | JunoAST.Cmd (c) =&gt;
        cc.ast := NEW(JunoAST.Proj, bp := JunoAST.End,
          vars := NEW(JunoAST.NearVarList, bp := JunoAST.End,
            size := 1, head := new),
          body := c)
    END;
    EVAL cc.pointCache.put(v, Value.NewPoint(loc.x, loc.y));
    cc.codeValid := FALSE
  END AddVariable;

PROCEDURE <A NAME="AddConstraint"><procedure>AddConstraint</procedure></A>(cc: T; con: JunoAST.Constraint) =
  BEGIN
    TYPECASE cc.ast OF &lt;* NOWARN *&gt;
      JunoAST.Proj (p) =&gt; AddConstraint1(p.body, con)
    | JunoAST.Cmd =&gt; AddConstraint1(cc.ast, con)
    END;
    cc.codeValid := FALSE
  END AddConstraint;

PROCEDURE <A NAME="AddConstraint1"><procedure>AddConstraint1</procedure></A>(
    VAR (*INOUT*) ast: JunoAST.Cmd;
    con: JunoAST.Constraint) =
  BEGIN
    TYPECASE ast OF &lt;* NOWARN *&gt;
      JunoAST.Guard (g) =&gt; AddConstraint2(g.grd, con)
    | JunoAST.Cmd (c) =&gt;
        ast := NEW(JunoAST.Guard, bp := JunoAST.End, grd := con, body := c)
    END
  END AddConstraint1;

PROCEDURE <A NAME="AddConstraint2"><procedure>AddConstraint2</procedure></A>(
    VAR (*INOUT*) f: JunoAST.Formula;
    con: JunoAST.Constraint) =
  BEGIN
    TYPECASE f OF
      JunoAST.Or (or) =&gt; AddConstraint2(or.f2, con)
    ELSE f := NEW(JunoAST.And, bp := JunoAST.End, f1 := f, f2 := con)
    END
  END AddConstraint2;

PROCEDURE <A NAME="AddCommand"><procedure>AddCommand</procedure></A>(cc: T; cmd: JunoAST.Cmd) =
  BEGIN
    TYPECASE cc.ast OF &lt;* NOWARN *&gt;
      JunoAST.Proj (p) =&gt; AddCommand1(p.body, cmd)
    | JunoAST.Cmd =&gt; AddCommand2(cc.ast, cmd)
    END;
    cc.codeValid := FALSE
  END AddCommand;

PROCEDURE <A NAME="AddCommand1"><procedure>AddCommand1</procedure></A>(VAR (*INOUT*) c1: JunoAST.Cmd; c2: JunoAST.Cmd) =
  BEGIN
    TYPECASE c1 OF &lt;* NOWARN *&gt;
      JunoAST.Guard (g) =&gt; AddCommand2(g.body, c2)
    | JunoAST.Cmd =&gt; AddCommand2(c1, c2)
    END
  END AddCommand1;

PROCEDURE <A NAME="AddCommand2"><procedure>AddCommand2</procedure></A>(VAR (*INOUT*) c1: JunoAST.Cmd; c2: JunoAST.Cmd) =
  BEGIN
    TYPECASE c1 OF &lt;* NOWARN *&gt;
      JunoAST.Skip =&gt; c1 := c2
    | JunoAST.Cmd =&gt;
        c1 := NEW(JunoAST.Seq, bp := JunoAST.End, c1 := c1, c2 := c2)
    END
  END AddCommand2;

PROCEDURE <A NAME="RemCommand"><procedure>RemCommand</procedure></A>(cc: T): BOOLEAN =
  VAR changed: BOOLEAN; BEGIN
    TYPECASE cc.ast OF &lt;* NOWARN *&gt;
      JunoAST.Skip =&gt; changed := FALSE
    | JunoAST.Proj (p) =&gt; changed := RemCommand1(p.body)
    | JunoAST.Cmd =&gt; changed := RemCommand2(cc.ast)
    END;
    cc.codeValid := cc.codeValid AND NOT changed;
    RETURN changed
  END RemCommand;

PROCEDURE <A NAME="RemCommand1"><procedure>RemCommand1</procedure></A>(VAR (*INOUT*) cmd: JunoAST.Cmd): BOOLEAN =
  BEGIN
    TYPECASE cmd OF &lt;* NOWARN *&gt;
      JunoAST.Guard (g) =&gt; RETURN RemCommand2(g.body)
    | JunoAST.Cmd =&gt; RETURN RemCommand2(cmd)
    END
  END RemCommand1;

PROCEDURE <A NAME="RemCommand2"><procedure>RemCommand2</procedure></A>(VAR (*INOUT*) ast: JunoAST.Cmd): BOOLEAN =
  VAR res: BOOLEAN; BEGIN
    TYPECASE ast OF
      JunoAST.Skip =&gt; res := FALSE;
    | JunoAST.Seq (seq) =&gt;
        res := RemCommand2(seq.c2);
        IF seq.c2 = JunoAST.SkipVal THEN ast := seq.c1; res := TRUE END
    | JunoAST.Cmd =&gt; ast := JunoAST.SkipVal; res := TRUE
    END;
    RETURN res
  END RemCommand2;

PROCEDURE <A NAME="DoRel"><procedure>DoRel</procedure></A>(cc: T; c, a, b: JunoAST.Id) =
  VAR v := GetVariable(cc.ast, c); BEGIN
    VAR aa, bb: JunoAST.Id; BEGIN
      IF IsRelHint(v.hint, aa, bb) AND a = aa AND b = bb THEN
        v.hint := PointValue(cc, c);
        cc.codeValid := FALSE;
        RETURN
      END
    END;
    (* Make the hint of the form &quot;c ~= (x, y) REL (a, b)&quot; *)
    VAR ax, ay, bx, by: Real; BEGIN
      EVAL PointLocation(cc, a, ax, ay);
      EVAL PointLocation(cc, b, bx, by);
      v.hint := MkRelHint(cc, c, a, ax, ay, b, bx, by, v.hint);
      cc.codeValid := FALSE
    END
  END DoRel;

PROCEDURE <A NAME="IsRelHint"><procedure>IsRelHint</procedure></A>(hint: JunoAST.Expr;
  VAR (*OUT*) a, b: JunoAST.Id): BOOLEAN =
</PRE><BLOCKQUOTE><EM> If <CODE>hint</CODE> is of the form (num, num) REL (p,q), for <CODE>Id</CODE>'s <CODE>p</CODE> and <CODE>q</CODE>,
   set <CODE>a,b := p,q</CODE> and return <CODE>TRUE</CODE>; else return <CODE>FALSE</CODE>. </EM></BLOCKQUOTE><PRE>
  BEGIN
    IF hint = NIL THEN RETURN FALSE END;
    TYPECASE hint OF JunoAST.Rel (rel) =&gt;
      TYPECASE rel.e2 OF JunoAST.Pair (p) =&gt;
        TYPECASE p.e1 OF JunoAST.QId (p1) =&gt;
	  TYPECASE p.e2 OF JunoAST.QId (p2) =&gt;
            IF p1.id0 = JunoAST.NilId AND
               p2.id0 = JunoAST.NilId AND
               IsNumericPoint(rel.e1)
            THEN
              a := p1.id1;
              b := p2.id1;
              RETURN TRUE
            END
	  ELSE (* SKIP *)
	  END
        ELSE (* SKIP *)
        END
      ELSE (* SKIP *)
      END
    ELSE (* SKIP *)
    END;
    RETURN FALSE
  END IsRelHint;

PROCEDURE <A NAME="IsRel1Hint"><procedure>IsRel1Hint</procedure></A>(hint: JunoAST.Expr; VAR (*OUT*) a: JunoAST.Id): BOOLEAN =
</PRE><BLOCKQUOTE><EM> If <CODE>hint</CODE> is of the form <CODE>R2.Plus(p, (num, num))</CODE>, for <CODE>Id</CODE> <CODE>p</CODE>,
   set <CODE>a := p</CODE> and return <CODE>TRUE</CODE>; else return <CODE>FALSE</CODE>. </EM></BLOCKQUOTE><PRE>
  BEGIN
    TYPECASE hint OF
      NULL =&gt; (*SKIP*)
    | JunoAST.Call (call) =&gt;
      IF call.ins.size = 2 THEN
        TYPECASE call.ins.head.expr OF
          JunoAST.QId (arg0) =&gt;
            IF arg0.id0 = JunoAST.NilId AND
               JunoASTUtils.EqualQIds(call.name, R2DotPlus) AND
               IsNumericPoint(call.ins.head.next.expr)
            THEN
              a := arg0.id1;
              RETURN TRUE
            END
        ELSE (* SKIP *)
        END
      END
    ELSE (* SKIP *)
    END;
    RETURN FALSE
  END IsRel1Hint;

PROCEDURE <A NAME="DoRel1"><procedure>DoRel1</procedure></A>(cc: T; c, a: JunoAST.Id) =
  VAR v := GetVariable(cc.ast, c); BEGIN
    VAR aa: JunoAST.Id; BEGIN
      IF IsRel1Hint(v.hint, aa) AND a = aa THEN
        v.hint := PointValue(cc, c);
        cc.codeValid := FALSE;
        RETURN
      END
    END;
    (* Make the hint of the form &quot;c ~= R2.Plus(a, (x, y))&quot; *)
    VAR ax, ay: Real; BEGIN
      EVAL PointLocation(cc, a, ax, ay);
      v.hint := MkRel1Hint(cc, c, a, ax, ay, v.hint);
      cc.codeValid := FALSE
    END
  END DoRel1;

PROCEDURE <A NAME="MkRelHint"><procedure>MkRelHint</procedure></A>(cc: T; c: JunoAST.Id;
  a: JunoAST.Id; ax, ay: Real;
  b: JunoAST.Id; bx, by: Real;
  else: JunoAST.Expr): JunoAST.Expr =
</PRE><BLOCKQUOTE><EM> Return <CODE>c</CODE>'s position relative to <CODE>a</CODE> and <CODE>b</CODE>, or return <CODE>else</CODE> if
   this is not possible. </EM></BLOCKQUOTE><PRE>
  VAR x, y, cx, cy: Real; BEGIN
    IF NOT PointLocation(cc, c, cx, cy) THEN RETURN else END;
    IF NOT JunoPt.RelVal(cx, cy, ax, ay, bx, by, x, y) THEN RETURN else END;
    RETURN
      NEW(JunoAST.Rel, bp := JunoAST.End,
	e1 := JunoASTUtils.NewPoint(x, y),
	e2 := NEW(JunoAST.Pair, bp := JunoAST.End,
	  e1 := JunoASTUtils.QIdFromIds(JunoAST.NilId, a),
	  e2 := JunoASTUtils.QIdFromIds(JunoAST.NilId, b)))
  END MkRelHint;

PROCEDURE <A NAME="MkRel1Hint"><procedure>MkRel1Hint</procedure></A>(cc: T; c: JunoAST.Id;
  a: JunoAST.Id; ax, ay: Real; else: JunoAST.Expr): JunoAST.Expr =
</PRE><BLOCKQUOTE><EM> Return <CODE>c</CODE>'s position relative to <CODE>a</CODE>. </EM></BLOCKQUOTE><PRE>
  VAR x, y, cx, cy: Real; BEGIN
    IF NOT PointLocation(cc, c, cx, cy) THEN RETURN else END;
    x := cx - ax;
    y := cy - ay;
    RETURN
      NEW(JunoAST.Call, bp := JunoAST.End,
	name := R2DotPlus,
	inouts := JunoAST.EmptyExprList,
	ins := NEW(JunoAST.ExprList, bp := JunoAST.End, size := 2, head :=
	  NEW(JunoAST.ExprLink,
	    expr := JunoASTUtils.QIdFromId(a),
	    next := NEW(JunoAST.ExprLink,
              expr := JunoASTUtils.NewPoint(x, y)))))
  END MkRel1Hint;
</PRE> ------------------------ Operations on Points --------------------------- 

<P><PRE>PROCEDURE <A NAME="PointLocation"><procedure>PointLocation</procedure></A>(cc: T; a: JunoAST.Id; VAR (*OUT*) h, v: Real):
    BOOLEAN =
</PRE><BLOCKQUOTE><EM> Set <CODE>h</CODE> and <CODE>v</CODE> to the coordinates of the point named <CODE>a</CODE> in
   <CODE>cc.pointCache</CODE> and return TRUE; return FALSE if there is no
   such point in the cache. </EM></BLOCKQUOTE><PRE>
  VAR vl: Value.T; BEGIN
    IF cc.pointCache.get(a, vl) THEN
      TYPECASE vl OF &lt;* NOWARN *&gt;
        REF Value.Pair (p) =&gt;
          h := NARROW(p.car, REF Real)^;
          v := NARROW(p.cdr, REF Real)^;
          RETURN TRUE
      END
    ELSE
      RETURN FALSE
    END
  END PointLocation;

PROCEDURE <A NAME="PointValue"><procedure>PointValue</procedure></A>(cc: T; a: JunoAST.Id): JunoAST.Pair =
</PRE><BLOCKQUOTE><EM> Requires that the point named <CODE>a</CODE> is in <CODE>cc.pointCache</CODE>. Returns an AST
   corresponding to the point's value in the cache. </EM></BLOCKQUOTE><PRE>
  VAR x, y: Real; inCache := PointLocation(cc, a, (*OUT*) x, (*OUT*) y); BEGIN
    &lt;* ASSERT inCache *&gt;
    RETURN JunoASTUtils.NewPoint(x, y)
  END PointValue;

PROCEDURE <A NAME="FreezePoint"><procedure>FreezePoint</procedure></A>(cc: T; a: JunoAST.Id) =
  VAR v := GetVariable(cc.ast, a); BEGIN
    &lt;* ASSERT v # NIL *&gt;
    v.frozen := NOT v.frozen;
    cc.codeValid := FALSE
  END FreezePoint;

PROCEDURE <A NAME="IsFrozen"><procedure>IsFrozen</procedure></A>(cc: T; a: JunoAST.Id): BOOLEAN =
  VAR v := GetVariable(cc.ast, a); BEGIN
    IF v = NIL
      THEN RETURN FALSE
      ELSE RETURN v.frozen
    END
  END IsFrozen;

PROCEDURE <A NAME="DiffNumericPair"><procedure>DiffNumericPair</procedure></A>(p: JunoAST.Pair; x, y: Real): BOOLEAN =
</PRE><BLOCKQUOTE><EM> Return TRUE iff <CODE>p</CODE> is a pair of constant numbers, but differs from the
   pair <CODE>(x, y)</CODE>. </EM></BLOCKQUOTE><PRE>
  VAR px, py: Real; BEGIN
    RETURN IsNumber(p.e1, px) AND IsNumber(p.e2, py) AND (x # px OR y # py)
  END DiffNumericPair;

PROCEDURE <A NAME="IsNumericPoint"><procedure>IsNumericPoint</procedure></A>(e: JunoAST.Expr): BOOLEAN =
</PRE><BLOCKQUOTE><EM> Return TRUE iff <CODE>e</CODE> is a pair of real numbers. </EM></BLOCKQUOTE><PRE>
  BEGIN
    TYPECASE e OF
      NULL =&gt; (*SKIP*)
    | JunoAST.Pair (p) =&gt;
        VAR dummy: Real; BEGIN
          RETURN IsNumber(p.e1, dummy) AND IsNumber(p.e2, dummy)
        END
    ELSE (*SKIP*)
    END;
    RETURN FALSE
  END IsNumericPoint;

PROCEDURE <A NAME="IsNumber"><procedure>IsNumber</procedure></A>(e: JunoAST.Expr; VAR (*OUT*) v: Real): BOOLEAN =
</PRE><BLOCKQUOTE><EM> Return TRUE iff <CODE>e</CODE> a numeric constant of the form <CODE>&lt;number&gt;</CODE> or
   <CODE>- &lt;number&gt;</CODE>, and if so, set <CODE>v</CODE> to its value. </EM></BLOCKQUOTE><PRE>
  BEGIN
    TYPECASE e OF
      JunoAST.Number (n) =&gt;
        v := n.val; RETURN TRUE
    | JunoAST.UMinus (u) =&gt;
        VAR res := IsNumber(u.e, v); BEGIN
          IF res THEN v := -v END;
          RETURN res
        END
    ELSE (* SKIP *)
    END;
    RETURN FALSE
  END IsNumber;

PROCEDURE <A NAME="MovePoint"><procedure>MovePoint</procedure></A>(cc: T; a: JunoAST.Id; x, y: Real) =
  VAR v: JunoAST.NearVarLink := GetVariable(cc.ast, a); BEGIN
    &lt;* ASSERT v # NIL AND v.hint # JunoAST.NilExpr *&gt;
    VAR newV := Value.NewPoint(x, y); oldV: Value.T; BEGIN
      (* only do work if the point does not already have the given value *)
      IF NOT (cc.pointCache.get(v.id, oldV) AND Value.Equal(newV, oldV)) THEN
        EVAL cc.pointCache.put(v.id, newV);
        EVAL MovePoint1(cc, v, x, y);
        cc.codeValid := FALSE
      END
    END
  END MovePoint;

PROCEDURE <A NAME="MovePoint1"><procedure>MovePoint1</procedure></A>(
  cc: T; v: JunoAST.NearVarLink; x, y: Real; changed := TRUE): BOOLEAN =
</PRE><BLOCKQUOTE><EM> Update <CODE>v.hint</CODE> to have the value <CODE>(x, y)</CODE>, preserving the current
   structure of the hint. For the current hint to be changed, it must be
   either a simple pair, a literal value, an expression of the form
   <CODE>(x,y) REL (a, b)</CODE>, where <CODE>x</CODE> and <CODE>y</CODE> are numbers, or an expression of the
   form <CODE>R2.Plus(a, (x,y))</CODE>. In the latter two cases, the values for the
   points <CODE>a</CODE> and <CODE>b</CODE> are read from <CODE>cc.pointCache</CODE>, and the pair <CODE>(x,y)</CODE> is
   updated. If none of these cases applies, the hint is unchanged. Returns
   TRUE iff the hint <CODE>v.hint</CODE> was changed.
<P>
   If <CODE>changed</CODE> is <CODE>FALSE</CODE> and the hint is absolute, then the hint is not
   changed and <CODE>FALSE</CODE> is returned. </EM></BLOCKQUOTE><PRE>
  VAR res := FALSE; aa, bb: JunoAST.Id; BEGIN
    &lt;* ASSERT v.hint # NIL AND v.hint # JunoAST.NilExpr *&gt;
    TYPECASE v.hint OF JunoAST.Pair (p) =&gt;
      (* The hint is of the form &quot;(x, y)&quot; *)
      IF changed AND DiffNumericPair(p, x, y) THEN
        res := TRUE;
        p.e1 := JunoASTUtils.NewNumber(x);
        p.e2 := JunoASTUtils.NewNumber(y)
      END
    ELSE
      IF IsLiteral(v.hint) THEN
        (* update hint if it is a literal of some sort *)
        res := TRUE;
        v.hint := JunoASTUtils.NewPoint(x, y)
      ELSIF IsRelHint(v.hint, aa, bb) THEN
        (* The hint is of the form &quot;(num, num) REL (aa, bb)&quot; *)
        VAR ax, ay, bx, by, x2, y2: Real; BEGIN
          IF PointLocation(cc, aa, ax, ay) AND
      	     PointLocation(cc, bb, bx, by) AND
      	     JunoPt.RelVal(x, y, ax, ay, bx, by, x2, y2)
      	  THEN
            VAR r: JunoAST.Rel := v.hint; p1: JunoAST.Pair := r.e1; BEGIN
              IF DiffNumericPair(p1, x2, y2) THEN
                res := TRUE;
                r.e1 := JunoASTUtils.NewPoint(x2, y2)
              END
            END
          END
        END
      ELSIF IsRel1Hint(v.hint, aa) THEN
        (* The hint is of the form &quot;R2.Plus(aa, (num, num))&quot; *)
        VAR ax, ay, x2, y2: Real; BEGIN
          IF PointLocation(cc, aa, ax, ay) THEN
            x2 := x - ax; y2 := y - ay;
            VAR
              call: JunoAST.Call := v.hint;
              p1: JunoAST.Pair := call.ins.head.next.expr;
            BEGIN
              IF DiffNumericPair(p1, x2, y2) THEN
                res := TRUE;
                call.ins.head.next.expr := JunoASTUtils.NewPoint(x2, y2)
              END
            END
          END
        END
      END
    END;
    RETURN res
  END MovePoint1;

PROCEDURE <A NAME="IsLiteral"><procedure>IsLiteral</procedure></A>(expr: JunoAST.Expr): BOOLEAN =
</PRE><BLOCKQUOTE><EM> Return TRUE iff <CODE>expr</CODE> is a literal value, namely, a (possibly negated)
   number, a text, the value Juno <CODE>NIL</CODE>, a list of literals, or a
   parenthesized literal. </EM></BLOCKQUOTE><PRE>
  BEGIN
    IF expr = JunoAST.NilExpr THEN RETURN TRUE END;
    TYPECASE expr OF
      JunoAST.Number, JunoAST.Text, JunoAST.Nil =&gt; RETURN TRUE
    | JunoAST.UMinus (minus) =&gt; RETURN IsLiteral(minus.e)
    | JunoAST.List (l) =&gt;
        VAR res := TRUE; curr := l.elts.head; BEGIN
          WHILE curr # NIL AND res DO
            res := res AND IsLiteral(curr.expr);
            curr := curr.next
          END;
          RETURN res
        END
    | JunoAST.GroupedExpr (g) =&gt; RETURN IsLiteral(g.expr)
    ELSE RETURN FALSE
    END
  END IsLiteral;

PROCEDURE <A NAME="ForAllPoints"><procedure>ForAllPoints</procedure></A>(cc: T; p: PointProc) =
  VAR it := cc.pointCache.iterate(); a: Atom.T; v: Value.T; BEGIN
    WHILE it.next(a, v) DO
      VAR
        pair := NARROW(v, REF Value.Pair);
        x := NARROW(pair.car, REF Real);
        y := NARROW(pair.cdr, REF Real);
      BEGIN
        p(a, JunoPt.T{x^, y^})
      END
    END;
  END ForAllPoints;
</PRE> ------------------------ Folding Operations ----------------------------- 

<P><PRE>PROCEDURE <A NAME="WrapProcHeader"><procedure>WrapProcHeader</procedure></A>(
    name: JunoAST.Id;
    ins: JunoAST.IdList;
    body: JunoAST.Cmd)
  : JunoAST.ProcDecl =
</PRE><BLOCKQUOTE><EM> Return a procedure declaration named <CODE>name</CODE> with IN parameters <CODE>ins</CODE> and
   body <CODE>body</CODE>. If <CODE>body</CODE> is not total, it is first bracketed by <CODE>IF...FI</CODE>. </EM></BLOCKQUOTE><PRE>
  BEGIN
    TRY JunoChkBNF.TotalCmd(body) EXCEPT JunoCompileErr.Error =&gt;
      body := NEW(JunoAST.If, body := body, bp := JunoAST.End)
    END;
    RETURN NEW(JunoAST.ProcDecl, bp := JunoAST.End,
      header := NEW(JunoAST.ProcHeader, name := name, ins := ins,
        outs := JunoAST.EmptyIdList, inouts := JunoAST.EmptyIdList),
      body := body)
  END WrapProcHeader;

PROCEDURE <A NAME="FoldNoArgs"><procedure>FoldNoArgs</procedure></A>(cc: T; name: JunoAST.Id): JunoAST.ProcDecl =
  BEGIN
    RETURN WrapProcHeader(name, JunoAST.EmptyIdList, cc.ast)
  END FoldNoArgs;

PROCEDURE <A NAME="GetFoldArgs"><procedure>GetFoldArgs</procedure></A>(cc: T): JunoAST.IdList =
  VAR
    res := NEW(JunoAST.IdList, bp := JunoAST.End);
    vars := JunoASTUtils.NearVarListCopy(GetVariables(cc.ast));
    nv := vars.head;
    last: JunoAST.IdLink := NIL;
  BEGIN
    WHILE nv # NIL DO
      IF nv.hint = JunoAST.NilExpr OR IsNumericPoint(nv.hint) THEN
        (* add to end of &quot;params&quot; list *)
        VAR new := NEW(JunoAST.IdLink, id := nv.id); BEGIN
          IF last = NIL
            THEN res.head := new
            ELSE last.next := new
          END;
          last := new
        END;
        INC(res.size)
      END;
      nv := nv.next
    END;
    RETURN res;
  END GetFoldArgs;

PROCEDURE <A NAME="FoldPred"><procedure>FoldPred</procedure></A>(
    cc: T;
    name: JunoAST.Id;
    params: JunoAST.IdList;
    locals: JunoAST.NearVarList): JunoAST.PredDecl =
</PRE><BLOCKQUOTE><EM> Fold the current command <CODE>cc</CODE> into a predicate declaration, and return it.
   <CODE>Name</CODE> is the predicate's name, <CODE>Params</CODE> are its arguments, and <CODE>locals</CODE>
   are its (existentially quantified) local variables. The body of the
   predicate is the constraint section of the current command <CODE>cc</CODE>. </EM></BLOCKQUOTE><PRE>
  VAR body := GetConstraint(cc.ast); BEGIN
    IF locals.size &gt; 0 THEN
      body := NEW(JunoAST.Exists, bp := JunoAST.End, vars := locals, f := body)
    END;
    RETURN NEW(JunoAST.PredDecl, bp := JunoAST.End,
      header := NEW(JunoAST.PredHeader, name := name, ins := params),
      body := body)
  END FoldPred;

PROCEDURE <A NAME="FoldProc"><procedure>FoldProc</procedure></A>(
    cc: T;
    name: JunoAST.Id;
    params: JunoAST.IdList;
    locals: JunoAST.NearVarList): JunoAST.ProcDecl =
</PRE><BLOCKQUOTE><EM> Fold the current command <CODE>cc</CODE> into a procedure declaration, and return it.
   <CODE>Name</CODE> is the procedure's name, <CODE>params</CODE> are its (IN) parameters, and
   <CODE>locals</CODE> are its (projected) local variables. The procedure's body is
   formed from the constraint section and command section of the current
   command <CODE>cc</CODE>. </EM></BLOCKQUOTE><PRE>
  VAR grd := GetConstraint(cc.ast); body := GetCmd(cc.ast); BEGIN
    IF grd # JunoAST.TrueVal THEN
      body := NEW(JunoAST.Guard, bp := JunoAST.End,
        grd := grd, body := body)
    END;
    IF locals.size &gt; 0 THEN
      body := NEW(JunoAST.Proj, bp := JunoAST.End,
        vars := locals, body := body)
    END;
    RETURN WrapProcHeader(name, params, body)
  END FoldProc;

TYPE RelToArray = ARRAY [0..1] OF RECORD id: JunoAST.Id; x,y: Real END;
</PRE> If <CODE>rt: RelToArray</CODE>, then <CODE>rt</CODE> holds the names and (point) values of up to
   two parameters relative to which the other variable's hints will be
   computed. 

<P><PRE>PROCEDURE <A NAME="SetUpRelTo"><procedure>SetUpRelTo</procedure></A>(
    cc: T;
    args: JunoAST.IdList;
    VAR (*OUT*) rt: RelToArray;
    VAR (*OUT*) i: INTEGER) =
</PRE><BLOCKQUOTE><EM> Find up to <CODE>NUMBER(rt)</CODE> elements of <CODE>args</CODE> whose values are points, store
   their names and values in <CODE>rt</CODE>, and set <CODE>i</CODE> to the number found. </EM></BLOCKQUOTE><PRE>
  VAR l := args.head; BEGIN
    i := 0;
    WHILE i &lt; NUMBER(rt) AND l # NIL DO
      IF PointLocation(cc, l.id, rt[i].x, rt[i].y) THEN
        rt[i].id := l.id;
        INC(i)
      END;
      l := l.next
    END
  END SetUpRelTo;

PROCEDURE <A NAME="AugmentRelTo"><procedure>AugmentRelTo</procedure></A>(
  cc: T;
  nv: JunoAST.NearVarLink;
  ignore: JunoAST.IdList;
  VAR (*INOUT*) rt: RelToArray;
  VAR (*INOUT*) i: INTEGER) =
</PRE><BLOCKQUOTE><EM> If <CODE>i=1</CODE> and there is some point in <CODE>nv</CODE> not named in the list <CODE>ignore</CODE>
   whose hint is <CODE>REL1</CODE> to <CODE>rt[0]</CODE>, add that point to <CODE>rt</CODE>. </EM></BLOCKQUOTE><PRE>
  BEGIN
    WHILE i = 1 AND nv # NIL DO
      IF NOT JunoASTUtils.MemIdList(nv.id, ignore) THEN
      	VAR aa: JunoAST.Id; BEGIN
      	  IF IsRel1Hint(nv.hint, aa) AND aa = rt[0].id THEN
      	    rt[i].id := nv.id;
      	    EVAL PointLocation(cc, nv.id, rt[i].x, rt[i].y);
      	    INC(i)
      	  END
        END
      END;
      nv := nv.next
    END
  END AugmentRelTo;

PROCEDURE <A NAME="CheckFoldArgs"><procedure>CheckFoldArgs</procedure></A>(ids: JunoAST.IdList; locals: JunoAST.NearVarList)
    RAISES {BadFoldArg} =
</PRE><BLOCKQUOTE><EM> Check that each variable in <CODE>ids</CODE> occurs in <CODE>locals</CODE>. Raise <CODE>BadFoldArg</CODE>
   with the name of the variable if there is one that doesn't appear in
   <CODE>locals</CODE>. This procedure is implemented by brute-force; it requires time
   on the order of <CODE>ids.size * locals.size</CODE>. </EM></BLOCKQUOTE><PRE>
  VAR curr := ids.head; BEGIN
    WHILE curr # NIL DO
      IF JunoASTUtils.MemNearVarList(curr.id, locals) = NIL THEN
        RAISE BadFoldArg(curr.id)
      END;
      curr := curr.next
    END
  END CheckFoldArgs;

PROCEDURE <A NAME="MkLocals"><procedure>MkLocals</procedure></A>(cc: T; args: JunoAST.IdList;
  args2: JunoAST.IdList := NIL): JunoAST.NearVarList
  RAISES {BadFoldArg} =
</PRE><BLOCKQUOTE><EM> Return the list of local variables for the procedure or predicate resulting
   from folding the current command <CODE>cc</CODE> with arguments <CODE>args</CODE>. The variables
   in the resulting list will have hints relative to the <CODE>args</CODE> if possible.
   Any variables named in <CODE>args2</CODE> will not be incorporated into the result
   either, but these variables are not used as a basis for relativizing the
   hints of the result variables. </EM></BLOCKQUOTE><PRE>
  VAR
    rt: RelToArray;
    rtCount: INTEGER;
    res := NEW(JunoAST.NearVarList, bp := JunoAST.End);
    locals := JunoASTUtils.NearVarListCopy(GetVariables(cc.ast));
    nv: JunoAST.NearVarLink := locals.head;
    last: JunoAST.NearVarLink := NIL;
  BEGIN
    CheckFoldArgs(args, locals);
    IF args2 = NIL
      THEN args2 := JunoAST.EmptyIdList
      ELSE CheckFoldArgs(args2, locals)
    END;
    SetUpRelTo(cc, args, (*OUT*) rt, (*OUT*) rtCount);
    AugmentRelTo(cc, nv, args2, (*INOUT*) rt, (*INOUT*) rtCount);
    WHILE nv # NIL DO
      IF NOT JunoASTUtils.MemIdList(nv.id, args) AND
         NOT JunoASTUtils.MemIdList(nv.id, args2) THEN
        IF IsNumericPoint(nv.hint) THEN
          (* make nv's hint relative to rt *)
          CASE rtCount OF &lt;* NOWARN *&gt;
            0 =&gt; (* SKIP *)
          | 1 =&gt; nv.hint :=
              MkRel1Hint(cc, nv.id, rt[0].id, rt[0].x, rt[0].y, nv.hint)
          | 2 =&gt; nv.hint :=
              MkRelHint(cc, nv.id, rt[0].id, rt[0].x,
                rt[0].y, rt[1].id, rt[1].x, rt[1].y, nv.hint)
          END
        END;
        (* add nv to the end of res *)
        IF last = NIL
          THEN res.head := nv
          ELSE last.next := nv
        END;
        last := nv;
        INC(res.size)
      END;
      nv := nv.next
    END;
    IF last # NIL THEN last.next := NIL END;
    RETURN res
  END MkLocals;

PROCEDURE <A NAME="FoldByHeader"><procedure>FoldByHeader</procedure></A>(cc: T; hdr: JunoAST.PredHeader; kind: FoldKind):
  JunoAST.Decl RAISES {BadFoldArg} =
  BEGIN
    IF kind = FoldKind.ProcNoArgs THEN
      RETURN FoldNoArgs(cc, hdr.name)
    END;
    &lt;* ASSERT hdr.ins # NIL *&gt;
    VAR locals := MkLocals(cc, hdr.ins); BEGIN
      CASE kind OF &lt;* NOWARN *&gt;
    	FoldKind.Pred =&gt; RETURN FoldPred(cc, hdr.name, hdr.ins, locals)
      | FoldKind.Proc =&gt; RETURN FoldProc(cc, hdr.name, hdr.ins, locals)
      END
    END
  END FoldByHeader;

PROCEDURE <A NAME="FoldByName"><procedure>FoldByName</procedure></A>(cc: T; name: JunoAST.Id; kind := FoldKind.Proc):
  JunoAST.Decl =
  BEGIN
    CASE kind OF
    | FoldKind.ProcNoArgs =&gt; RETURN FoldNoArgs(cc, name)
    | FoldKind.Pred, FoldKind.Proc =&gt;
        VAR
          hdr := NEW(JunoAST.PredHeader, bp := JunoAST.End,
            name := name, ins := GetFoldArgs(cc));
        &lt;* FATAL BadFoldArg *&gt; BEGIN
          RETURN FoldByHeader(cc, hdr, kind)
        END
    END
  END FoldByName;

PROCEDURE <A NAME="FoldAnim"><procedure>FoldAnim</procedure></A>(cc: T; hdr: JunoAST.PredHeader;
    sliderPts: JunoAST.IdList): JunoAST.ProcDecl
    RAISES {BadFoldArg} =
  VAR
    newHdr := NEW(JunoAST.PredHeader, bp := hdr, name := hdr.name,
      ins := JunoASTUtils.ConcatIdLists(hdr.ins, sliderPts));
    locals := MkLocals(cc, hdr.ins, sliderPts);
  BEGIN
    RETURN FoldProc(cc, newHdr.name, newHdr.ins, locals)
  END FoldAnim;

PROCEDURE <A NAME="AppendSuffix"><procedure>AppendSuffix</procedure></A>(cc: T; id: JunoAST.Id; suffix: TEXT): JunoAST.Id =
</PRE><BLOCKQUOTE><EM> Return the name resulting from concatenating <CODE>id</CODE> with <CODE>suffix</CODE>. If this
   name is already defined in the current scope, append additional digits as
   necessary to produce an unused name. </EM></BLOCKQUOTE><PRE>
  VAR resTxt := Atom.ToText(id) &amp; suffix; BEGIN
    resTxt := NewDeclName(cc, resTxt, tryEmptySuffix := TRUE);
    RETURN Atom.FromText(resTxt);
  END AppendSuffix;

VAR (* READONLY after init *)
  DurId := Atom.FromText(&quot;dur&quot;);
  TId := Atom.FromText(&quot;t&quot;);
  DurQId := JunoASTUtils.QIdFromId(DurId);
  TQId := JunoASTUtils.QIdFromId(TId);
  DurIdList := JunoASTUtils.NewIdList(DurId);
  TIdList := JunoASTUtils.NewIdList(TId);
  ZeroVal := NEW(JunoAST.Number, bp := JunoAST.End, val := 0.0);
  OneVal := NEW(JunoAST.Number, bp := JunoAST.End, val := 1.0);

PROCEDURE <A NAME="FoldAnimFrame"><procedure>FoldAnimFrame</procedure></A>(cc: T; hdr: JunoAST.PredHeader;
  sliderPts: JunoAST.IdList): JunoAST.ProcDecl =
</PRE><BLOCKQUOTE><EM> Construct a declaration of the form:
<P>
<PRE>
       PROC &lt;hdr.name&gt;Frame(&lt;hdr.ins&gt;, dur, t) IS
         IF
           VAR
         	 &lt;pt[0].nm&gt; = &lt;pt[0].value&gt;,
         	 &lt;pt[2].nm&gt; = &lt;pt[2].value&gt;,
         	 &lt;pt[1].nm&gt; = (t/dur, 0) REL (&lt;pt[0].nm&gt;, &lt;pt[2].nm&gt;)
           IN
         	 &lt;hdr.name&gt;(&lt;hdr.ins&gt;, &lt;sliderPts&gt;)
           END
         FI
</PRE>
   where &lt;pt[i]&gt; denotes the ith variable in the <CODE>sliderPts</CODE> argument,
   the <CODE>nm</CODE> field is the name of the point, and the <CODE>value</CODE> field is the
   value of that variable in the current command point cache. </EM></BLOCKQUOTE><PRE>
  VAR
    pHeader := NEW(JunoAST.ProcHeader, bp := JunoAST.End,
      name := AppendSuffix(cc, hdr.name, &quot;Frame&quot;),
      ins := JunoASTUtils.ConcatIdLists(hdr.ins,
        JunoASTUtils.ConcatIdLists(DurIdList, TIdList)),
      outs := JunoAST.EmptyIdList, inouts := JunoAST.EmptyIdList);
    s0Name := sliderPts.head.id;
    s0QName := JunoASTUtils.QIdFromId(s0Name);
    s1Name := sliderPts.head.next.id;
    s2Name := sliderPts.head.next.next.id;
    s2QName := JunoASTUtils.QIdFromId(s2Name);
    (* initialize local variables in reverse order *)
    div := NEW(JunoAST.Divide, bp := JunoAST.End, e1 := TQId, e2 := DurQId);
    s1Hint := NEW(JunoAST.Rel, bp := JunoAST.End,
      e2 := NEW(JunoAST.Pair, bp := JunoAST.End, e1 := s0QName, e2 := s2QName),
      e1 := NEW(JunoAST.Pair, bp := JunoAST.End, e1 := div, e2 := ZeroVal));
    s1Var := NEW(JunoAST.NearVarLink, id := s1Name,
      frozen := TRUE, hint := s1Hint);
    s2Var := NEW(JunoAST.NearVarLink, id := s2Name,
      frozen := TRUE, hint := PointValue(cc, s2Name), next := s1Var);
    s0Var := NEW(JunoAST.NearVarLink, id := s0Name,
      frozen := TRUE, hint := PointValue(cc, s0Name), next := s2Var);
    nearVars := NEW(JunoAST.NearVarList, bp := JunoAST.End,
      size := 3, head := s0Var);
    call := NEW(JunoAST.ProcCall, bp := JunoAST.End,
      name := JunoASTUtils.QIdFromId(hdr.name),
      ins := JunoASTUtils.IdListToQIdList(
        JunoASTUtils.ConcatIdLists(hdr.ins, sliderPts)),
      outs := JunoAST.EmptyQIdList, inouts := JunoAST.EmptyExprList);
    proj := NEW(JunoAST.Proj, bp := JunoAST.End,
      vars := nearVars, body := call);
    ifCmd := NEW(JunoAST.If, bp := JunoAST.End, body := proj);
  BEGIN
    RETURN NEW(JunoAST.ProcDecl, bp := JunoAST.End,
      header := pHeader, body := ifCmd)
  END FoldAnimFrame;

PROCEDURE <A NAME="FoldAnimCreator"><procedure>FoldAnimCreator</procedure></A>(cc: T; hdr: JunoAST.PredHeader;
  frameNm: JunoAST.Id): JunoAST.ProcDecl =
</PRE><BLOCKQUOTE><EM> Return a procedure declaration of the form:
<P>
<PRE>
       PROC an := &lt;hdr.name&gt;Anim(&lt;hdr.ins&gt;, dur) IS
         an := (CLOSE(&lt;frameNm&gt;, &lt;hdr.ins&gt;, dur), dur)
       END
</EM></BLOCKQUOTE><PRE>
  VAR
    anId := Atom.FromText(&quot;an&quot;);
    inArgs := JunoASTUtils.ConcatIdLists(hdr.ins, DurIdList);
    pHeader := NEW(JunoAST.ProcHeader, bp := JunoAST.End,
      name := AppendSuffix(cc, hdr.name, &quot;Anim&quot;), ins := inArgs,
      outs := JunoASTUtils.NewIdList(anId), inouts := JunoAST.EmptyIdList);
    closeArgs := JunoASTUtils.IdListToQIdList(
      JunoASTUtils.ConcatIdLists(JunoASTUtils.NewIdList(frameNm), inArgs));
    close := NEW(JunoAST.Call, bp := JunoAST.End,
      name := JunoASTUtils.QIdFromText(&quot;CLOSE&quot;),
      ins := closeArgs, inouts := JunoAST.EmptyExprList);
    animPair := NEW(JunoAST.Pair, bp := JunoAST.End,
      e1 := close, e2 := DurQId);
    assign := NEW(JunoAST.Assign, bp := JunoAST.End,
      vars := JunoASTUtils.NewQIdList(JunoASTUtils.QIdFromId(anId)),
      exprs := JunoASTUtils.NewExprList(animPair, bp := JunoAST.End));
  BEGIN
    RETURN NEW(JunoAST.ProcDecl, bp := JunoAST.End,
      header := pHeader, body := assign)
  END FoldAnimCreator;

PROCEDURE <A NAME="SelectVar"><procedure>SelectVar</procedure></A>(cc: T; nm: JunoAST.Id): JunoAST.NearVarLink =
</PRE><BLOCKQUOTE><EM> Return a new <CODE>NearVarLink</CODE> for the variable named <CODE>nm</CODE> whose hint is
   determined from the current value of <CODE>nm</CODE> in <CODE>cc</CODE>'s point cache. The hint
   is frozen or not according to whether it is frozen or hinted in <CODE>cc</CODE>. The
   fields other than <CODE>id</CODE>, <CODE>frozen</CODE>, and <CODE>hint</CODE> of the result are defaulted. </EM></BLOCKQUOTE><PRE>
  BEGIN
    RETURN NEW(JunoAST.NearVarLink, id := nm,
      frozen := IsFrozen(cc, nm), hint := PointValue(cc, nm))
  END SelectVar;

PROCEDURE <A NAME="SelectVars"><procedure>SelectVars</procedure></A>(cc: T; vars: JunoAST.IdList): JunoAST.NearVarList =
</PRE><BLOCKQUOTE><EM> Return a <CODE>NearVarList</CODE> containing the variables <CODE>vars</CODE> (in the same order),
   hinted to values determined from the current values of those variables in
   <CODE>cc</CODE>'s point cache, and with the hint being frozen or not according to
   whether it is frozen or hinted in the current command <CODE>cc</CODE>. </EM></BLOCKQUOTE><PRE>
  VAR head, last: JunoAST.NearVarLink := NIL; curr := vars.head; BEGIN
    WHILE curr # NIL DO
      VAR new := SelectVar(cc, curr.id); BEGIN
      	IF head = NIL
      	  THEN head := new
      	  ELSE last.next := new
      	END;
        last := new
      END;
      curr := curr.next
    END;
    RETURN NEW(JunoAST.NearVarList, bp := JunoAST.End,
      size := vars.size, head := head)
  END SelectVars;

PROCEDURE <A NAME="PrependVar"><procedure>PrependVar</procedure></A>(id: JunoAST.Id; hint: JunoAST.Expr;
  l: JunoAST.NearVarList; frozen := TRUE): JunoAST.NearVarList =
</PRE><BLOCKQUOTE><EM> Destructively prepend a <CODE>NearVarLink</CODE> of the form <CODE>&lt;id&gt; ~= &lt;hint&gt;</CODE> to the
   <CODE>NearVarList</CODE> <CODE>l</CODE>. The <CODE>frozen</CODE> parameter determines whether <CODE>~</CODE> or <CODE>=</CODE>
   is used. </EM></BLOCKQUOTE><PRE>
  VAR link := NEW(JunoAST.NearVarLink, id := id, frozen := frozen,
    hint := hint, next := l.head);
  BEGIN
    INC(l.size);
    l.head := link;
    RETURN l
  END PrependVar;

PROCEDURE <A NAME="FoldAnimCmd"><procedure>FoldAnimCmd</procedure></A>(cc: T; args: JunoAST.IdList; animProcNm: JunoAST.Id):
    JunoAST.Cmd =
</PRE><BLOCKQUOTE><EM> Produce an animation command of the form:
<PRE>
      
         VAR
           dur = 1,
           &lt;near-vars&gt;
         IN
           Slider.SetVisibility(Slider.Invisible);
           Anim.Play(&lt;animProcNm&gt;(&lt;args&gt;, dur))
         END
</PRE>
   The &lt;near-vars&gt; are formed from both <CODE>cc</CODE> and <CODE>args</CODE>.
</EM></BLOCKQUOTE><PRE>
  VAR
    nearVars := PrependVar(DurId, OneVal, SelectVars(cc, args));
    animCall := NEW(JunoAST.Call, bp := JunoAST.End,
      name := JunoASTUtils.QIdFromId(animProcNm),
      ins := JunoASTUtils.IdListToQIdList(
        JunoASTUtils.ConcatIdLists(args, DurIdList)),
      inouts := JunoAST.EmptyExprList);
    sliderCall := NEW(JunoAST.ProcCall, bp := JunoAST.End,
      name := JunoASTUtils.QIdFromTexts(&quot;Slider&quot;, &quot;SetVisibility&quot;),
      ins := JunoASTUtils.NewExprList(
        JunoASTUtils.QIdFromTexts(&quot;Slider&quot;, &quot;Invisible&quot;)),
      outs := JunoAST.EmptyQIdList, inouts := JunoAST.EmptyExprList);
    playCall := NEW(JunoAST.ProcCall, bp := JunoAST.End,
      name := JunoASTUtils.QIdFromTexts(&quot;Anim&quot;, &quot;Play&quot;),
      ins := JunoASTUtils.NewExprList(animCall),
      outs := JunoAST.EmptyQIdList, inouts := JunoAST.EmptyExprList);
    semi := NEW(JunoAST.Seq, bp := JunoAST.End,
      c1 := sliderCall, c2 := playCall);
  BEGIN
    RETURN NEW(JunoAST.Proj, bp := JunoAST.End,
      vars := nearVars, body := semi)
  END FoldAnimCmd;
</PRE> ------------------------- Running / Updating ---------------------------- 

<P><PRE>PROCEDURE <A NAME="Run"><procedure>Run</procedure></A>(cc: T; skipify: BOOLEAN): BOOLEAN
    RAISES {CompileError, RuntimeError} =
  BEGIN
    (* compile the current command if necessary *)
    TRY
      IF NOT cc.codeValid OR skipify # cc.skipify THEN
        VAR ast := cc.ast; BEGIN
          IF skipify THEN ast := Skipify(ast) END;
          cc.slot := JunoBuild.CurrCmd(ast, cc.scp);
          cc.codeValid := TRUE;
          cc.skipify := skipify
        END
      END
    EXCEPT
      JunoCompileErr.Error (err) =&gt;
        RAISE CompileError(err.msg)
    END;
    (* run it *)
    RETURN Run2(cc)
  END Run;

PROCEDURE <A NAME="Run2"><procedure>Run2</procedure></A>(cc: T): BOOLEAN RAISES {RuntimeError} =
  VAR
    res: BOOLEAN;
    runRes := JunoRT.ExecFromSlot(cc.slot, reset := TRUE);
  BEGIN
    (* We expect the command to halt *)
    IF runRes.trapCode = JunoRT.TrapCode.Error THEN
      IF runRes.errorCode # JunoRTError.Code.Halt THEN
        JunoRT.ResetMachine();
        RAISE RuntimeError(RTError{JunoRT.TrapMessage(runRes), runRes})
      END
    ELSE
      RAISE RuntimeError(RTError{JunoRT.TrapMessage(runRes), runRes})
    END;

    (* update hints from stack frame *)
    res := UpdateHints(cc);

    (* Finish running the command until completion (this will be a no-op *)
    runRes := JunoRT.Exec();
    &lt;* ASSERT runRes.trapCode = JunoRT.TrapCode.NormalHalt *&gt;
    RETURN res
  END Run2;

PROCEDURE <A NAME="ClearCaches"><procedure>ClearCaches</procedure></A>(cc: T) =
  BEGIN
    EVAL cc.pointCache.init(sizeHint := InitCacheSize);
    EVAL cc.othersCache.init(sizeHint := InitCacheSize)
  END ClearCaches;

PROCEDURE <A NAME="UpdateHints"><procedure>UpdateHints</procedure></A>(cc: T): BOOLEAN =
  PROCEDURE SwapTables(VAR t1, t2: AtomRefTbl.Default) =
    VAR t := t1; BEGIN t1 := t2; t2 := t END SwapTables;
  VAR res := FALSE; BEGIN
    SwapTables(cc.oldPointCache, cc.pointCache);
    SwapTables(cc.oldOthersCache, cc.othersCache);
    ClearCaches(cc);
    TYPECASE cc.ast OF
      NULL =&gt; (* SKIP *)
    | JunoAST.Proj (proj) =&gt;
        FillCache(cc, proj.vars);
        res := UpdateNearVars(cc, proj.vars)
    ELSE (* SKIP *)
    END;
    RETURN res
  END UpdateHints;

PROCEDURE <A NAME="FillCache"><procedure>FillCache</procedure></A>(cc: T; vars: JunoAST.NearVarList) =
</PRE><BLOCKQUOTE><EM> Read the values for the points declared in <CODE>vars</CODE> from
   the run-time stack, and store those values that are points in
   <CODE>cc.pointCache</CODE> and those that are not in <CODE>cc.othersCache</CODE>. The
   <CODE>changedVal</CODE> array is set to indicate which values have changed. If
   <CODE>cc.ast</CODE> is not a projection, then both caches are made empty, and
   <CODE>changedVal</CODE> is unchanged. </EM></BLOCKQUOTE><PRE>
  BEGIN
    &lt;* ASSERT cc.ast # NIL AND ISTYPE(cc.ast, JunoAST.Proj) *&gt;
    VAR nv := vars.head; frame := JunoRT.BaseFrame().up(); i := 0; BEGIN
      IF vars.size &gt; NUMBER(cc.changedVal^) THEN
        cc.changedVal := NEW(REF ARRAY OF BOOLEAN,
          MAX(vars.size, 2 * NUMBER(cc.changedVal^)))
      END;
      WHILE nv # NIL DO
        &lt;* ASSERT nv.index &gt; 0 *&gt;
        VAR v := frame.getLocal(nv.index); oldV: Value.T; BEGIN
          WITH changed = cc.changedVal[i] DO
            IF v # NIL THEN
              (* The frame contains a value for &quot;nv&quot; *)
              IF IsPointValue(v) THEN
            	changed := NOT (cc.oldPointCache.get(nv.id, oldV)
            	  AND Value.Equal(v, oldV));
            	EVAL cc.pointCache.put(nv.id, v)
              ELSE
            	changed := NOT (cc.oldOthersCache.get(nv.id, oldV)
            	  AND Value.Equal(v, oldV));
            	EVAL cc.othersCache.put(nv.id, v)
              END
            ELSE
              (* There is no value in the frame, so the value is being changed
                 only if it exists in one of the old caches. *)
              IF cc.oldPointCache.get(nv.id, oldV)
                 OR cc.oldOthersCache.get(nv.id, oldV) THEN
                changed := TRUE
              END
            END
          END
        END;
        nv := nv.next;
        INC(i)
      END
    END
  END FillCache;

PROCEDURE <A NAME="IsPointValue"><procedure>IsPointValue</procedure></A>(v: Value.T): BOOLEAN =
</PRE><BLOCKQUOTE><EM> Return TRUE iff <CODE>v</CODE> is the value of a 2D point, that is, a pair of two
   numbers. </EM></BLOCKQUOTE><PRE>
  BEGIN
    TYPECASE v OF REF Value.Pair (p) =&gt;
      TYPECASE p.car OF REF Value.Real =&gt;
        TYPECASE p.cdr OF REF Value.Real =&gt;
          RETURN TRUE
        ELSE (* SKIP *)
        END
      ELSE (* SKIP *)
      END
    ELSE (* SKIP *)
    END;
    RETURN FALSE
  END IsPointValue;

PROCEDURE <A NAME="UpdateNearVars"><procedure>UpdateNearVars</procedure></A>(cc: T; vars: JunoAST.NearVarList): BOOLEAN =
</PRE><BLOCKQUOTE><EM> Update the hints in <CODE>vars</CODE> from <CODE>cc.pointCache</CODE> and <CODE>cc.othersCache</CODE>, and
   mark the compiled code as being out-of-date iff some hint changed. Returns
   <CODE>TRUE</CODE> iff some hint changed.
<P>
   Requires that all values <CODE>v</CODE> in <CODE>cc.pointCache</CODE> satisfy <CODE>IsPointValue(v)</CODE>,
   and that <CODE>cc.changedVal</CODE> accurately reflects which values need updating. </EM></BLOCKQUOTE><PRE>
  VAR nv := vars.head; v: Value.T; changedHint := FALSE; i := 0; BEGIN
    &lt;* ASSERT NUMBER(cc.changedVal^) &gt;= vars.size *&gt;
    WHILE nv # NIL DO
      IF cc.pointCache.get(nv.id, v) THEN
        TYPECASE v OF &lt;* NOWARN *&gt; REF Value.Pair (p) =&gt;
          VAR
            x := NARROW(p.car, REF Real);
            y := NARROW(p.cdr, REF Real);
          BEGIN
            IF nv.hint = JunoAST.NilExpr THEN
              (* the value didn't previously have a hint; now it does *)
              changedHint := TRUE;
              nv.hint := JunoASTUtils.NewPoint(x^, y^)
            ELSE
              (* change the existing hint for the point *)
              changedHint := MovePoint1(cc, nv, x^, y^,
                changed := cc.changedVal[i]) OR changedHint
            END;
          END
        END
      ELSIF cc.changedVal[i] THEN
        changedHint := TRUE;
        IF cc.othersCache.get(nv.id, v) THEN
          (* only update the hint for a non-point if it already has
             a literal hint *)
          IF nv.hint # JunoAST.NilExpr AND IsLiteral(nv.hint) THEN
            nv.hint := JunoASTUtils.NewASTFromValue(v)
          END
        ELSE
          (* If not in either cache, then what has changed is that the
             variable no longer has a hint. *)
          nv.hint := JunoAST.NilExpr
        END
      END;
      INC(i);
      nv := nv.next
    END;
    cc.codeValid := cc.codeValid AND NOT changedHint;
    RETURN changedHint
  END UpdateNearVars;

BEGIN
END CurrCmd.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface JunoValue is in:
</A><UL>
<LI><A HREF="../../juno-machine/src/JunoValue.i3.html#0TOP0">juno-machine/src/JunoValue.i3</A>
<LI><A HREF="../../pkl-fonts/src/JunoValue.i3.html#0TOP0">pkl-fonts/src/JunoValue.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
