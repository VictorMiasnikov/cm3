<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: juno-app/src/Editor.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>juno-app/src/Editor.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright (C) 1992, Digital Equipment Corporation                         
 All rights reserved.                                                      
 See the file COPYRIGHT for a full description.                            
                                                                           
 Last modified on Sat Mar  1 00:36:12 PST 1997 by heydon                   
      modified on Mon Jun 12 14:03:54 PDT 1995 by gnelson                  
      modified on Fri Aug  7 21:51:56 PDT 1992 by myers                    
<PRE>&lt;* PRAGMA LL *&gt;

MODULE <module>Editor</module> EXPORTS <A HREF="#x1"><implements>Editor</A></implements>, <A HREF="JunoHandleLexErr.i3.html"><implements>JunoHandleLexErr</A></implements>, <A HREF="EditorUI.i3.html"><implements>EditorUI</A></implements>;

IMPORT <A HREF="JunoError.i3.html">JunoError</A>, <A HREF="#x2">View</A>, <A HREF="Drawing.i3.html">Drawing</A>, <A HREF="ToolBox.i3.html">ToolBox</A>, <A HREF="EditorXtra.i3.html">EditorXtra</A>, <A HREF="JunoConfig.i3.html">JunoConfig</A>;
IMPORT <A HREF="../../juno-compiler/src/JunoParse.i3.html">JunoParse</A>, <A HREF="../../juno-compiler/src/JunoLex.i3.html">JunoLex</A>, <A HREF="../../juno-compiler/src/JunoAST.i3.html">JunoAST</A>, <A HREF="../../juno-compiler/src/JunoUnparse.i3.html">JunoUnparse</A>, <A HREF="../../juno-compiler/src/JunoToken.i3.html">JunoToken</A>;
IMPORT   <A HREF="../../juno-compiler/src/JunoScope.i3.html">JunoScope</A>, <A HREF="../../juno-compiler/src/JunoCompile.i3.html">JunoCompile</A>;
FROM <A HREF="../../juno-compiler/src/JunoCompileErr.i3.html">JunoCompileErr</A> IMPORT Error, Raise;
IMPORT <A HREF="../../juno-machine/src/JunoRT.i3.html">JunoRT</A>;
IMPORT <A HREF="../../vbtkit/src/etext/TextPort.i3.html">TextPort</A>;
IMPORT <A HREF="../../ui/src/vbt/VBT.i3.html">VBT</A>, <A HREF="../../libm3/src/geometry/Rect.i3.html">Rect</A>, <A HREF="../../libm3/src/geometry/Axis.i3.html">Axis</A>, <A HREF="../../ui/src/split/TextVBT.i3.html">TextVBT</A>, <A HREF="../../ui/src/split/HVSplit.i3.html">HVSplit</A>, <A HREF="../../ui/src/split/Split.i3.html">Split</A>;
IMPORT <A HREF="../../libm3/src/rw/Rd.i3.html">Rd</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="../../libm3/src/formatter/Formatter.i3.html">Formatter</A>, <A HREF="../../libm3/src/rw/TextRd.i3.html">TextRd</A>, <A HREF="../../libm3/src/rw/TextWr.i3.html">TextWr</A>, <A HREF="../../m3core/src/text/Text.i3.html">Text</A>, <A HREF="../../libm3/src/atom/Atom.i3.html">Atom</A>, <A HREF="../../libm3/src/fmtlex/Lex.i3.html">Lex</A>, <A HREF="../../libm3/src/fmtlex/Fmt.i3.html">Fmt</A>, <A HREF="../../m3core/src/float/IEEE-default/FloatMode.i3.html">FloatMode</A>;
IMPORT   <A HREF="../../libm3/derived/AtomAtomTbl.i3.html">AtomAtomTbl</A>, <A HREF="../../libm3/derived/AtomRefTbl.i3.html">AtomRefTbl</A>;

FROM <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A> IMPORT Alerted;

&lt;* FATAL Rd.Failure, Wr.Failure, Alerted *&gt;

CONST
  MinUnparseWidth = 15;
  CmdPrefix = &quot;Cmd&quot;;

REVEAL
  <A NAME="T">T</A> = Public BRANDED &quot;Editor.T&quot; OBJECT
    trees, lastTree: Forest := NIL;
    currentTree: Forest;
    treesValid, textPretty := FALSE;
    width: INTEGER := -1;
    maxCurrCmd: INTEGER := -1;
    toolTypes: AtomAtomTbl.T;
    setMenus: AtomRefTbl.T;
  OVERRIDES
    init     := Init;
    reshape  := Reshape;
    shape    := Shape;
    modified := Modified;
    txtModified := NoOp;
    getToolType := GetToolType;
    getMenu := GetMenu;
  END;

  (* An &quot;Editor.T&quot; is an editor for a Juno module. If &quot;t: T&quot;, then &quot;t.trees&quot;
     is the list of parse trees for the top-level blocks of the module.
     &quot;t.trees&quot; holds the truth iff &quot;t.treesValid&quot;.

     The value of &quot;currentTree&quot; points at the tree containing the
     top line of the textport; it is set by Parse and maintained
     by Unparse, and is valid only if &quot;treesValid&quot; is true.  It
     is used to prevent the textport from scrolling undesirably
     when the user reshapes the editor or remakes it by clicking &quot;Run&quot;.

     The boolean &quot;t.textPretty&quot; is TRUE iff
     the editor contains the result of unparsing &quot;t.trees&quot;; note that
     &quot;t.textPretty =&gt; t.treesValid&quot;. Hence there are 3 combinations for the
     two booleans:

|    Valid  Pretty  Meaning
|      F      F     the editor contains the truth, and is not pretty-printed
|      T      F     &quot;t.trees&quot; is the result of successfully parsing the source
|      T      T     the editor contains the unparsed version of &quot;t.trees&quot;

     If &quot;t.textPretty&quot;, then &quot;t.width&quot; is the width at which the trees were
     unparsed. If the trees were unparsed into an empty window, then
     &quot;t.textPretty&quot; is TRUE, and &quot;t.width = -1&quot;.

     The editor also implements an abstract &quot;current command stack&quot;. The
     procedures declared in the editor with names of the form &quot;CmdPrefix &amp;
     Fmt.Int(X)&quot;, where &quot;CmdPrefix&quot; is a global constant and &quot;X&quot; is a
     non-negative integer, are on the stack. The value &quot;X&quot; is called the index
     of the current command. &quot;t.maxCurrCmd&quot; is the value of the maximum
     current command index; this is the current command on the top of the
     stack. The stack is empty iff &quot;t.maxCurrCmd = -1&quot;. *)

  <A NAME="Forest">Forest</A> = ForestPublic BRANDED &quot;Editor.Forest&quot; OBJECT
    start, end: CARDINAL;
  END;

  (* For each tree &quot;t&quot; in the list of trees, &quot;t.start&quot; and &quot;t.end&quot; are the
     indices in the module editor of the first and last character of the
     unparsed version of &quot;t&quot;. This interval includes the whitespace charcters
     following &quot;t&quot;. *)

PROCEDURE <A NAME="NoOp"><procedure>NoOp</procedure></A>(&lt;*UNUSED*&gt; tp: T) =
  BEGIN END NoOp;

PROCEDURE <A NAME="Init"><procedure>Init</procedure></A>(tp: T; src: TEXT; readOnly := FALSE): T =
  BEGIN
    EVAL TextPort.T.init(tp, font := JunoConfig.codeFont,
      wrap := FALSE, readOnly := readOnly);
    TextPort.SetModified(tp, TRUE);
    TextPort.SetText(tp, src);
    TextPort.SetModified(tp, FALSE);
    tp.toolTypes := NEW(AtomAtomTbl.Default).init();
    tp.setMenus := NEW(AtomRefTbl.Default).init();
    RETURN tp
  END Init;

PROCEDURE <A NAME="ScrollToCurrentTree"><procedure>ScrollToCurrentTree</procedure></A>(tp: T) =
  VAR pos: INTEGER; BEGIN
    IF tp.currentTree = NIL THEN
      pos := 0
    ELSE
      pos := tp.currentTree.start
    END;
    EditorXtra.IndexToTop(tp, pos)
  END ScrollToCurrentTree;

PROCEDURE <A NAME="SetCurrentTree"><procedure>SetCurrentTree</procedure></A>(tp: T) =
  VAR
    cpos := EditorXtra.TopLineIndex(tp);
    f := tp.trees;
  BEGIN
    WHILE f # NIL AND f.end &lt;= cpos DO
      f := f.next
    END;
    tp.currentTree := f
  END SetCurrentTree;

PROCEDURE <A NAME="Reshape"><procedure>Reshape</procedure></A>(tp: T; READONLY cd: VBT.ReshapeRec) =
  &lt;* LL.sup = VBT.mu.tp *&gt;
  BEGIN
    IF Rect.IsEmpty(cd.new) THEN
      tp.width := -1
    ELSE
      VAR width := Width(tp); BEGIN
        IF tp.treesValid AND (NOT tp.textPretty OR width # tp.width) THEN
          SetCurrentTree(tp);
          Unparse2(tp, width);
          ScrollToCurrentTree(tp)
        END
      END
    END;
    TextPort.T.reshape(tp, cd)
  END Reshape;

PROCEDURE <A NAME="Shape"><procedure>Shape</procedure></A>(tp: T; ax: Axis.T; n: CARDINAL): VBT.SizeRange =
  VAR res := TextPort.T.shape(tp, ax, n); BEGIN
    res.lo := 0;
    res.hi := VBT.DefaultShape.hi;
    RETURN res
  END Shape;

PROCEDURE <A NAME="Modified"><procedure>Modified</procedure></A> (tp: T) =
  &lt;* LL.sup &lt; VBT.mu *&gt;
  BEGIN
    TextPort.T.modified(tp);
    tp.treesValid := FALSE;
    tp.textPretty := FALSE;
    tp.txtModified()
  END Modified;

PROCEDURE <A NAME="GetToolType"><procedure>GetToolType</procedure></A>(ed: T; nm: Atom.T; VAR (*OUT*) type: Atom.T): BOOLEAN =
  BEGIN
    RETURN ed.toolTypes.get(nm, type)
  END GetToolType;

PROCEDURE <A NAME="GetMenu"><procedure>GetMenu</procedure></A>(ed: T; nm: Atom.T): VBT.T =
  VAR menuRef: REFANY; BEGIN
    IF ed.setMenus.get(nm, menuRef) THEN
      RETURN menuRef
    ELSE
      RETURN TextVBT.New(&quot;No parameters have been defined&quot;)
    END
  END GetMenu;

PROCEDURE <A NAME="Trees"><procedure>Trees</procedure></A>(tp: T): Forest =
  BEGIN
    RETURN tp.trees
  END Trees;

PROCEDURE <A NAME="Valid"><procedure>Valid</procedure></A> (tp: T): BOOLEAN =
  BEGIN
    RETURN tp.treesValid
  END Valid;

PROCEDURE <A NAME="HandleLexErr"><procedure>HandleLexErr</procedure></A>(
    err: JunoLex.ErrorRec;
    rd: Rd.T;
    wr: Wr.T;
    VAR (*OUT*) start, finish: INTEGER) =
  BEGIN
    Wr.PutText(wr, &quot;\n&quot;);
    CASE err.kind OF &lt;* NOWARN *&gt;
    | JunoLex.ErrorKind.UnclosedComment, JunoLex.ErrorKind.UnclosedText =&gt;
        start := Wr.Index(wr);
        Wr.PutText(wr, err.initialChars);
        Wr.PutText(wr, Rd.GetText(rd, LAST(CARDINAL)));
        finish := Wr.Index(wr)
    | JunoLex.ErrorKind.BadInitialChar, JunoLex.ErrorKind.BadEscapeChar,
        JunoLex.ErrorKind.BadReal =&gt;
      Wr.PutText(wr, err.initialChars);
      start := Wr.Index(wr);
      finish := start + 1;
      Wr.PutText(wr, Rd.GetText(rd, LAST(CARDINAL)));
      IF start = Wr.Index(wr) THEN Wr.PutChar(wr, ' ') END
    END
  END HandleLexErr;

PROCEDURE <A NAME="CurrCmdIndex"><procedure>CurrCmdIndex</procedure></A>(ast: JunoAST.T): INTEGER =
</PRE><BLOCKQUOTE><EM> If <CODE>ast</CODE> is a procedure declaration for a procedure whose name has the
   value of the global constant <CODE>CmdPrefix</CODE> as a prefix, then return the value
   of the suffix; otherwise, return -1. </EM></BLOCKQUOTE><PRE>
  BEGIN
    TYPECASE ast OF
      JunoAST.ProcDecl (pd) =&gt;
        VAR
          procName := Atom.ToText(pd.header.name);
          prefixLen := Text.Length(CmdPrefix);
          res: INTEGER;
        BEGIN
          IF Text.Equal(CmdPrefix, Text.Sub(procName, 0, prefixLen)) THEN
            TRY res := Lex.Int(TextRd.New(Text.Sub(procName, prefixLen)))
            EXCEPT Lex.Error, FloatMode.Trap, Rd.Failure =&gt; res := -1
            END;
            RETURN res
          END
        END
    ELSE (* SKIP *)
    END;
    RETURN -1
  END CurrCmdIndex;

PROCEDURE <A NAME="Parse"><procedure>Parse</procedure></A>(tp: T; time: VBT.TimeStamp): BOOLEAN =
  BEGIN
    IF tp.treesValid THEN RETURN TRUE END;
    RETURN Parse2(tp, time)
  END Parse;

PROCEDURE <A NAME="Parse2"><procedure>Parse2</procedure></A>(tp: T; time: VBT.TimeStamp): BOOLEAN =
  VAR
    errmsg: TEXT;
    rd := TextRd.New(TextPort.GetText(tp));
    wr: TextWr.T;
    w := Width(tp);
    start, finish := -1;
    cpos := EditorXtra.TopLineIndex(tp);
    ip: JunoParse.IterativeParse;
  &lt;*FATAL Rd.Failure, Wr.Failure *&gt;
  BEGIN
    TRY ip := JunoParse.StartIterativeParse(rd) EXCEPT
      JunoLex.Error (err) =&gt;
      	wr := TextWr.New();
      	errmsg := JunoLex.ErrorText(err.kind);
      	HandleLexErr(err, rd, wr, start, finish);
      	ip := NIL
    END;
    tp.trees := NIL;
    tp.lastTree := NIL;
    tp.currentTree := NIL;
    tp.maxCurrCmd := -1;
    IF ip # NIL THEN
  	LOOP
  	  VAR ast: JunoAST.Block; tokens: CARDINAL; BEGIN
  	    TRY
  	      JunoParse.Block(ip, ast, tokens)
  	    EXCEPT
  	      JunoLex.Error (err) =&gt;
              	wr := TextWr.New();
              	UnparseTrees(tp.trees, wr, w);
  		IF ast # NIL THEN
  		  JunoUnparse.Block(wr, ast, tokens,
                    indent := 0, width := w, prec := JunoConfig.realPrec)
  		END;
              	errmsg := JunoLex.ErrorText(err.kind);
  		  HandleLexErr(err, rd, wr, start, finish);
              	EXIT
  	    | JunoParse.Error(err) =&gt;
                wr := TextWr.New();
                UnparseTrees(tp.trees, wr, w);
  		IF ast # NIL THEN
  		  JunoUnparse.Block(wr, ast, tokens,
                    indent := 0, width := w, prec := JunoConfig.realPrec)
  		END;
  		Wr.PutChar(wr, '\n');
  		errmsg := &quot;Parse error&quot;;
  		IF err.expected # JunoToken.Kind.Unknown THEN
  		  errmsg := errmsg &amp; &quot; (expected &quot;
  		    &amp; JunoToken.KindName[err.expected] &amp; &quot;)&quot;
  		END;
  		start := Wr.Index(wr);
  		Wr.PutText(wr, JunoToken.ToText(err.found));
  		finish := Wr.Index(wr);
  		Wr.PutChar(wr, ' ');
  		Wr.PutText(wr, err.additional);
  		Wr.PutText(wr, Rd.GetText(rd, LAST(CARDINAL)));
  		EXIT
  	    END;
  	    IF ast = NIL THEN EXIT END;
            (* Next, append &quot;ast&quot; to the list ending at &quot;tp.lastTree&quot;.  Also,
               if it is the first parsed item that ends past the top line of
               the textport, record it in &quot;currentTree&quot;. *)
            VAR f := NEW(Forest, tree := ast, next := NIL); BEGIN
              AppendTree(tp, f);
  	      IF tp.currentTree = NIL AND JunoParse.GetIndex(ip) &gt; cpos THEN
  	        tp.currentTree := f
  	      END
  	    END;
            tp.maxCurrCmd := MAX(tp.maxCurrCmd, CurrCmdIndex(ast))
  	  END
  	END;                      (* loop *)
  	JunoParse.FinishIterativeParse(ip)
    END;                        (* if *)
    IF start # finish THEN
      &lt;* ASSERT start # -1 AND finish # -1 *&gt;
      TextPort.SetModified(tp, TRUE);
      TextPort.SetText(tp, TextWr.ToText(wr));
      TextPort.SetModified(tp, FALSE);
      Wr.Close(wr);
      JunoError.P(tp, errmsg, start, finish, time);
      RETURN FALSE
    ELSE
      TextPort.SetModified(tp, FALSE);
      TextPort.Normalize(tp, cpos);
      tp.treesValid := TRUE;
      RETURN TRUE
    END
  END Parse2;

PROCEDURE <A NAME="Unparse"><procedure>Unparse</procedure></A>(tp: T; errast: JunoAST.T := NIL;
  msg: TEXT := NIL; time: VBT.TimeStamp := 0) =
  &lt;* LL.sup &lt; tp *&gt;
  BEGIN
    &lt;* ASSERT tp.treesValid *&gt;
    &lt;* ASSERT (errast # NIL) = (msg # NIL) *&gt;
    IF Rect.IsEmpty(VBT.Domain(tp)) THEN
      tp.width := -1
    ELSE
      VAR width := Width(tp); BEGIN
        IF NOT tp.textPretty OR width # tp.width THEN
          Unparse2(tp, width, errast, msg, time)
        END
      END;
      IF errast = NIL THEN ScrollToCurrentTree(tp) END
    END
  END Unparse;

PROCEDURE <A NAME="Unparse2"><procedure>Unparse2</procedure></A>(tp: T; width: CARDINAL;
  errast: JunoAST.T := NIL; msg: TEXT := NIL; time: VBT.TimeStamp := 0) =
  &lt;* FATAL Wr.Failure *&gt;
  VAR wr := TextWr.New(); BEGIN
    UnparseTrees(tp.trees, wr, width, errast := errast);
    VAR txt := TextWr.ToText(wr); start, finish: INTEGER; BEGIN
      IF errast # NIL THEN
  	start := Text.FindChar(txt, '\001');
        finish := Text.FindChar(txt, '\002');
        &lt;* ASSERT start # -1 AND finish # -1 *&gt;
  	txt := Text.Sub(txt, 0, start)
  	  &amp; Text.Sub(txt, start + 1, finish - start - 1)
  	  &amp; Text.Sub(txt, finish + 1)
      END;
      TextPort.SetModified(tp, TRUE);
      TextPort.SetText(tp, txt);
      TextPort.SetModified(tp, FALSE);
      IF errast # NIL THEN
        VAR t := tp.trees; BEGIN
          (* update the &quot;start&quot; and &quot;end&quot; values for blocks appearing after
             the erroneous tree &quot;errast&quot; *)
          WHILE t # NIL DO
            IF t.start &gt; finish THEN
              DEC(t.start, 2); DEC(t.end, 2)
            ELSIF t.end &gt; finish THEN
              DEC(t.end, 2)
            END;
            t := t.next
          END
        END;
        IF time # 0 THEN
          JunoError.P(tp, msg, start, finish - 1, time)
        END
      END;
      Wr.Close(wr)
    END;
    tp.textPretty := TRUE;
    tp.width := width
  END Unparse2;

PROCEDURE <A NAME="UnparseTrees"><procedure>UnparseTrees</procedure></A>(f: Forest; wr: Wr.T;
  width: CARDINAL; errast: JunoAST.T  := NIL) =
</PRE><BLOCKQUOTE><EM> Unparse the list of trees <CODE>f</CODE> to <CODE>wr</CODE> at the width <CODE>width</CODE>. If <CODE>errast #
   NIL</CODE>, then bracket the unparsing of <CODE>errast</CODE> by the characters '\001' and
   '\002' when unparsing. This procedure also sets the <CODE>start</CODE> and <CODE>end</CODE>
   fields of each tree in <CODE>f</CODE>. </EM></BLOCKQUOTE><PRE>
  VAR fmt := Formatter.New(wr, width); BEGIN
    WHILE f # NIL DO
      f.start := Wr.Index(wr);
      JunoUnparse.ToFmt(fmt, f.tree, indent := 0,
        prec := JunoConfig.realPrec, errast := errast);
      Formatter.NewLine(fmt, freshLine := FALSE);
      (* Print a second newline so long as it would not separate two
         consecutive UI declarations. *)
      IF NOT (ISTYPE(f.tree, JunoAST.UIDecl) AND f.next # NIL AND
              ISTYPE(f.next.tree, JunoAST.UIDecl)) THEN
        Formatter.NewLine(fmt, freshLine := FALSE)
      END;
      Formatter.Flush(fmt);
      f.end := Wr.Index(wr);
      f := f.next
    END;
    Formatter.Close(fmt)
  END UnparseTrees;

PROCEDURE <A NAME="AppendTree"><procedure>AppendTree</procedure></A>(tp: T; t: Forest) =
</PRE><BLOCKQUOTE><EM> Append <CODE>t</CODE> to <CODE>tp</CODE>'s list of trees. </EM></BLOCKQUOTE><PRE>
  BEGIN
    IF tp.trees = NIL
      THEN tp.trees := t
      ELSE tp.lastTree.next := t
    END;
    tp.lastTree := t
  END AppendTree;

PROCEDURE <A NAME="AddTree"><procedure>AddTree</procedure></A>(ed: T; ast: JunoAST.T) =
  VAR t := NEW(Forest, tree := ast); BEGIN
    AppendTree(ed, t);
    ed.maxCurrCmd := MAX(ed.maxCurrCmd, CurrCmdIndex(ast));
    (* unparse the new tree to the end of the editor *)
    VAR wr := TextWr.New(); BEGIN
      t.start := TextPort.Length(ed);
      JunoUnparse.P(wr, ast, 0, Width(ed),
        prec := JunoConfig.realPrec, errast := NIL);
      Wr.PutText(wr, &quot;\n\n&quot;);
      VAR wasMod := TextPort.IsModified(ed); BEGIN
      	TextPort.SetModified(ed, TRUE);
      	TextPort.PutText(ed, TextWr.ToText(wr));
      	t.end := TextPort.Length(ed);
      	TextPort.Normalize(ed, t.start);
      	TextPort.SetModified(ed, wasMod)
      END;
      Wr.Close(wr)
    END;
    (* update the editor's tables for a UIDecl *)
    TYPECASE ast OF JunoAST.UIDecl (ui) =&gt;
      &lt;* FATAL Error *&gt; BEGIN
      	IF ed.toolTypes.put(FirstName(ui, 1).id1, ui.name) THEN
      	  &lt;* ASSERT FALSE *&gt;
        END
      END
    ELSE (* SKIP *)
    END
  END AddTree;

PROCEDURE <A NAME="NextCmdNum"><procedure>NextCmdNum</procedure></A>(ed: T): CARDINAL =
  BEGIN RETURN ed.maxCurrCmd + 1 END NextCmdNum;

PROCEDURE <A NAME="NextCmdName"><procedure>NextCmdName</procedure></A>(ed: T): Atom.T =
  BEGIN
    RETURN Atom.FromText(CmdPrefix &amp; Fmt.Int(NextCmdNum(ed)))
  END NextCmdName;

PROCEDURE <A NAME="PopCurrCmd"><procedure>PopCurrCmd</procedure></A>(ed: T; VAR (*OUT*) nm: JunoAST.Id): JunoAST.Cmd =
  &lt;* LL.sup &lt;= VBT.mu *&gt;
  BEGIN
    IF NOT ed.treesValid OR ed.maxCurrCmd &lt; 0 THEN RETURN NIL END;
    Unparse(ed);
    VAR t: Forest := NIL; BEGIN
      VAR curr := ed.trees; prev: Forest := NIL; max := -1; BEGIN
      	(* Set &quot;t&quot; to the tree to delete, set &quot;max&quot; to the new current
           command maximum, and set &quot;prev&quot; to the tree before &quot;t&quot; (or
           &quot;NIL&quot; if &quot;t&quot; is the first tree in the list). *)
        WHILE curr # NIL DO
          VAR ix := CurrCmdIndex(curr.tree); BEGIN
            IF ix = ed.maxCurrCmd
              THEN t := curr
              ELSE max := MAX(max, ix)
            END
          END;
          IF t = NIL THEN prev := curr END;
          curr := curr.next
      	END;
        ed.maxCurrCmd := max;
      	(* remove &quot;t&quot; from &quot;trees[ed]&quot; *)
        IF ed.lastTree = t THEN
          ed.lastTree := prev
        END;
      	IF prev = NIL
      	  THEN ed.trees := t.next
      	  ELSE prev.next := t.next
      	END;
      END;
      (* delete the text for &quot;t&quot; from &quot;src[ed]&quot; *)
      VAR wasMod := TextPort.IsModified(ed); BEGIN
        TextPort.SetModified(ed, TRUE);
        TextPort.Replace(ed, t.start, t.end, &quot;&quot;);
        TextPort.SetModified(ed, wasMod)
      END;
      (* return the procedure body *)
      VAR decl := NARROW(t.tree, JunoAST.ProcDecl); body := decl.body; BEGIN
        nm := decl.header.name;
        TYPECASE body OF JunoAST.If (if) =&gt;
          IF ISTYPE(if.body, JunoAST.Proj)
            THEN RETURN if.body
            ELSE RETURN body
          END
        ELSE RETURN body
        END
      END
    END
  END PopCurrCmd;

PROCEDURE <A NAME="Width"><procedure>Width</procedure></A>(ed: TextPort.T): CARDINAL =
  VAR res := VBT.TextWidth(ed, &quot;m&quot;, ed.getFont()); BEGIN
    IF res # 0 THEN
      res := Rect.HorSize(VBT.Domain(ed)) DIV res - 2;
    END;
    RETURN MAX(MinUnparseWidth, res)
  END Width;

PROCEDURE <A NAME="ModuleName"><procedure>ModuleName</procedure></A>(ed: T): Atom.T =
  VAR first := ed.trees; BEGIN
    WHILE first # NIL DO
      TYPECASE first.tree OF
        JunoAST.Module (m) =&gt; RETURN m.name
      | JunoAST.Comment =&gt; first := first.next
      ELSE EXIT
      END
    END;
    RETURN NIL
  END ModuleName;

VAR (* CONST *)
  global_mod := Atom.FromText(&quot;_GLOBAL_MOD&quot;);
  global_cmd := Atom.FromText(&quot;_GLOBAL_CMD&quot;);
  global_slot := JunoRT.GetCodeIndex(JunoRT.ProcAttr{
    global_mod, global_cmd, JunoRT.Sig{0,0,0}});

PROCEDURE <A NAME="ProcessExecRes"><procedure>ProcessExecRes</procedure></A>(READONLY res: JunoRT.ExecRes; error_ast: JunoAST.T)
    RAISES {Error} =
</PRE><BLOCKQUOTE><EM> Raises <CODE>Error</CODE> if <CODE>res.trapCode # JunoRT.TrapCode.NormalHalt</CODE>, with a
   message constructed from <CODE>res.errorCode</CODE>, and with error AST <CODE>error_ast</CODE>. </EM></BLOCKQUOTE><PRE>
  BEGIN
    IF res.trapCode # JunoRT.TrapCode.NormalHalt THEN
      Raise(JunoRT.TrapMessage(res), error_ast)
    END
  END ProcessExecRes;

PROCEDURE <A NAME="Pass0"><procedure>Pass0</procedure></A>(
    VAR forest: Forest;
    scp: JunoScope.T;
    uniqueModName: BOOLEAN;
    VAR (*OUT*) mod: JunoAST.Id)
  : JunoScope.T RAISES {Error} =
</PRE><BLOCKQUOTE><EM> Process the <CODE>MODULE</CODE> and <CODE>IMPORT</CODE> declarations in <CODE>forest</CODE>, set <CODE>mod</CODE> to
   the name of the initial module declaration (or NIL if there is none), and
   set <CODE>forest</CODE> to point to the first declaration after the longest prefix
   of the form <CODE>&lt;comment&gt;* &lt;module&gt; (&lt;comment&gt; | &lt;import&gt;)*</CODE>.
<P>
   Returns a restricted version of <CODE>scp</CODE> as determined by any IMPORT
   statements, or <CODE>scp</CODE> itself if there were no IMPORT statements. This
   implementation assumes that all bundled modules are defined in <CODE>scp</CODE>, and
   that identifiers for <CODE>BuiltIn.juno</CODE> are defined in proper ancestor scopes
   of <CODE>scp</CODE>.
<P>
   If <CODE>uniqueModName = TRUE</CODE>, then any specified module name must not appear
   in <CODE>scp</CODE>; if it does, <CODE>Error</CODE> is raised. Similarly, any modules specified
   in an <CODE>IMPORT</CODE> statement must appear in <CODE>scp</CODE>; if they do not, <CODE>Error</CODE> is
   raised. </EM></BLOCKQUOTE><PRE>
  VAR res: JunoScope.T := NIL; BEGIN
    mod := NIL;
    WHILE forest # NIL DO
      TYPECASE forest.tree OF
      | JunoAST.Comment =&gt; (* SKIP *)
      | JunoAST.Module (md) =&gt;
          IF mod # NIL THEN EXIT END;
          IF uniqueModName AND JunoScope.Lookup(scp, md.name) # NIL THEN
            Raise(&quot;A \&quot;&quot; &amp; Atom.ToText(md.name) &amp;
              &quot;\&quot; module is already defined&quot;, md)
          END;
          mod := md.name
      ELSE EXIT
      END;
      forest := forest.next
    END;
    WHILE forest # NIL DO
      TYPECASE forest.tree OF
        JunoAST.Comment =&gt; (* SKIP *)
      | JunoAST.Import (imp) =&gt;
          (* form new scope if necessary *)
          IF res = NIL THEN res := JunoScope.New(JunoScope.Parent(scp)) END;

          (* copy imported modules bound in &quot;scp&quot; to &quot;res&quot; *)
          VAR curr := imp.idList.head; ent: JunoScope.Entity; BEGIN
            WHILE curr # NIL DO
              ent := JunoScope.Lookup(scp, curr.id, localOnly := TRUE);
              IF ent = NIL THEN
            	Raise(&quot;\&quot;&quot;&amp; Atom.ToText(curr.id) &amp;&quot;\&quot; is not a bundled module&quot;,
            	  imp.idList)
              END;
              TRY JunoScope.Bind(res, curr.id, ent) EXCEPT
                JunoScope.NameClash =&gt;
                  Raise(&quot;\&quot;&quot;&amp; Atom.ToText(curr.id) &amp;&quot;\&quot; repeated in IMPORTs&quot;,
            	    imp.idList)
              END;
              curr := curr.next
            END
          END
      ELSE EXIT
      END;
      forest := forest.next
    END;
    IF res = NIL
      THEN RETURN scp
      ELSE RETURN res
    END
  END Pass0;

PROCEDURE <A NAME="Pass1"><procedure>Pass1</procedure></A>(
    forest: Forest;
    public, scp: JunoScope.T;
    mod: JunoAST.Id)
    RAISES {Error} =
</PRE><BLOCKQUOTE><EM> Pass1 processes the top-level declarations in <CODE>forest</CODE> for the module named
   <CODE>mod</CODE>. <CODE>Forest</CODE> is assumed to have been produced by Pass0, so it does not
   contain the MODULE and IMPORT declarations at the start of the module.
   Pass1 treats each type of top-level declaration as follows:
<PRE>
      
         (* Comment 
</EM></BLOCKQUOTE><PRE>      Skip.
|    MODULE, IMPORT     Raise Error.
|    CONST, VAR, PROC   Only install entries in &quot;scp&quot; (and &quot;public&quot;).
|    PRED, FUNC         Install entries in &quot;scp&quot; (and &quot;public&quot;) and compile
|                         bodies in order of occurrence.
|    UI                 Skip.
|
   Entries are only installed in the &quot;public&quot; scope if the declaration is not
   PRIVATE. *)
  &lt;* FATAL JunoScope.NameClash *&gt;
  BEGIN
    WHILE forest # NIL DO
      TYPECASE forest.tree OF &lt;*NOWARN*&gt;
      | JunoAST.Module (md) =&gt;
          IF mod = NIL
            THEN Raise(&quot;MODULE header not at start of file&quot;, md)
            ELSE Raise(&quot;Only one MODULE header is allowed&quot;, md)
          END
      | JunoAST.Import (import) =&gt;
          Raise(&quot;IMPORT may only be preceded by MODULE header&quot;, import)
      | JunoAST.Comment =&gt; (* SKIP *)
      | JunoAST.ConstDecl (cd) =&gt;
          VAR curr := cd.head; BEGIN
            WHILE curr # NIL DO
              IF JunoScope.Lookup(scp, curr.name) # NIL THEN
                Raise(&quot;\&quot;&quot;&amp;Atom.ToText(curr.name)&amp;&quot;\&quot; is already declared&quot;, cd)
              END;
              VAR
                c := NEW(JunoScope.Const, init := curr.value,
                  index := JunoRT.GetVarIndex(mod, curr.name));
              BEGIN
                JunoScope.Bind(scp, curr.name, c);
                IF NOT cd.private THEN
                  JunoScope.Bind(public, curr.name, c)
                END
              END;
              curr := curr.next
            END
          END
      | JunoAST.VarDecl (vd) =&gt;
          VAR curr := vd.head; BEGIN
            WHILE curr # NIL DO
              IF JunoScope.Lookup(scp, curr.name) # NIL THEN
                Raise(&quot;\&quot;&quot;&amp;Atom.ToText(curr.name)&amp;&quot;\&quot; is already declared&quot;, vd)
              END;
              VAR
                v := NEW(JunoScope.Var, init := curr.value,
                  index := JunoRT.GetVarIndex(mod, curr.name));
              BEGIN
                JunoScope.Bind(scp, curr.name, v);
                IF NOT vd.private THEN
                  JunoScope.Bind(public, curr.name, v)
                END
              END;
              curr := curr.next
            END
          END
      | JunoAST.ProcDecl (proc) =&gt;
          WITH pnm = proc.header.name DO
            IF JunoScope.Lookup(scp, pnm) # NIL THEN
              Raise(&quot;\&quot;&quot; &amp; Atom.ToText(pnm) &amp; &quot;\&quot; is already declared&quot;,
                proc.header)
            END;
            VAR p := JunoScope.NewProc(proc, mod); BEGIN
              JunoScope.Bind(scp, pnm, p);
              IF NOT proc.private THEN JunoScope.Bind(public, pnm, p) END
            END
          END
      | JunoAST.PredDecl (pred) =&gt;
          WITH pnm = pred.header.name DO
            IF JunoScope.Lookup(scp, pnm) # NIL THEN
              Raise(&quot;\&quot;&quot; &amp; Atom.ToText(pnm) &amp; &quot;\&quot; is already declared&quot;,
                pred.header)
            END;
            VAR p := JunoScope.NewPred(pred, mod); BEGIN
              JunoCompile.PredDecl(pnm, p, scp);
              JunoScope.Bind(scp, pnm, p);
              IF NOT pred.private THEN JunoScope.Bind(public, pnm, p) END
            END
          END
      | JunoAST.FuncDecl (func) =&gt;
          WITH fnm = func.header.name DO
            IF JunoScope.Lookup(scp, fnm) # NIL THEN
              Raise(&quot;\&quot;&quot; &amp; Atom.ToText(fnm) &amp; &quot;\&quot; is already declared&quot;,
                func.header)
            END;
            VAR f := JunoScope.NewFunc(func, mod); BEGIN
              JunoCompile.FuncDecl(fnm, f, scp);
              JunoScope.Bind(scp, fnm, f);
              IF NOT func.private THEN JunoScope.Bind(public, fnm, f) END
            END
          END
      | JunoAST.UIDecl =&gt; (* SKIP *)
      END;
      forest := forest.next
    END
  END Pass1;

PROCEDURE <A NAME="Pass2"><procedure>Pass2</procedure></A>(forest: Forest; scp: JunoScope.T) RAISES {Error} =
</PRE><BLOCKQUOTE><EM> Compile procedure bodies. </EM></BLOCKQUOTE><PRE>
  BEGIN
    WHILE forest # NIL DO
      TYPECASE forest.tree OF
      | JunoAST.ProcDecl(proc) =&gt;
          VAR p: JunoScope.Proc :=
            JunoScope.Lookup(scp, proc.header.name, localOnly := TRUE);
          BEGIN
            EVAL JunoCompile.ProcDecl(proc.header.name, p, scp)
          END
      ELSE (* SKIP *)
      END;
      forest := forest.next
    END
  END Pass2;

PROCEDURE <A NAME="Pass3"><procedure>Pass3</procedure></A>(forest: Forest; scp: JunoScope.T) RAISES {Error} =
</PRE><BLOCKQUOTE><EM> Compile and run constant and global variable initializers. </EM></BLOCKQUOTE><PRE>
  BEGIN
    WHILE forest # NIL DO
      TYPECASE forest.tree OF
      | JunoAST.ConstDecl (cd) =&gt;
          VAR curr := cd.head; BEGIN
            WHILE curr # NIL DO
              VAR
                c: JunoScope.Const := JunoScope.Lookup(
                  scp, curr.name, localOnly := TRUE);
                res_slot: CARDINAL;
              BEGIN
                JunoRT.code_tbl[global_slot] := JunoCompile.Expr(
                  c.init, scp, curr.name, (*OUT*) res_slot, pure := FALSE);
                ProcessExecRes(JunoRT.ExecFromSlot(global_slot), cd);
                JunoRT.value_tbl[c.index] := JunoRT.value_tbl[res_slot]
              END;
              curr := curr.next
            END
          END
      | JunoAST.VarDecl (vd) =&gt;
          VAR curr := vd.head; BEGIN
            WHILE curr # NIL DO
              VAR
                v: JunoScope.Var := JunoScope.Lookup(
                  scp, curr.name, localOnly := TRUE);
                res_slot: CARDINAL;
                init: JunoAST.Expr := v.init;
              BEGIN
                IF init = JunoAST.NilExpr THEN init := JunoAST.NilVal END;
                JunoRT.code_tbl[global_slot] := JunoCompile.Expr(
                  init, scp, curr.name, res_slot, pure := FALSE);
                ProcessExecRes(JunoRT.ExecFromSlot(global_slot), vd);
                JunoRT.value_tbl[v.index] := JunoRT.value_tbl[res_slot]
              END;
              curr := curr.next
            END
          END
      ELSE (* SKIP *)
      END;
      forest := forest.next
    END
  END Pass3;

PROCEDURE <A NAME="Compile"><procedure>Compile</procedure></A>(
    te: T;
    time: VBT.TimeStamp;
    scp: JunoScope.T;
    VAR (*OUT*) nm: JunoAST.Id;
    VAR (*OUT*) entity: JunoScope.Mod;
    uniqueModName := TRUE): BOOLEAN =
  &lt;* LL.sup &lt; te *&gt;
  BEGIN
    IF NOT Parse(te, time) THEN RETURN FALSE END;
    RETURN Compile2(te, time, scp, uniqueModName, nm, entity)
  END Compile;

PROCEDURE <A NAME="Compile2"><procedure>Compile2</procedure></A>(
    te: T;
    time: VBT.TimeStamp;
    parent: JunoScope.T;
    uniqueModName: BOOLEAN;
    VAR (*OUT*) nm: JunoAST.Id;
    VAR (*OUT*) entity: JunoScope.Mod)
  : BOOLEAN =
  &lt;* LL.sup &lt; te *&gt;
  VAR forest := te.trees; restrict, public, scp: JunoScope.T; BEGIN
    TRY
      restrict := Pass0(forest, parent, uniqueModName, nm);
      (* Initialize &quot;public&quot;, &quot;scp&quot; so module is compiled under restricted
         scope. *)
      public := JunoScope.New(restrict);
      scp := JunoScope.New(restrict);
      Pass1(forest, public, scp, nm);
      Pass2(forest, scp);
      Pass3(forest, scp);
      (* Make &quot;parent&quot; the parent scope of &quot;public&quot; and &quot;scp&quot; *)
      IF restrict # parent THEN
      	JunoScope.SetParent(public, parent);
      	JunoScope.SetParent(scp, parent)
      END
    EXCEPT
      Error (err) =&gt;
        &lt;* ASSERT err.ast # NIL *&gt;
        te.textPretty := FALSE; (* for error to be unparsed *)
        Unparse(te, err.ast, err.msg, time);
        RETURN FALSE
    END;
    entity := NEW(JunoScope.Mod, public_scp := public, scp := scp);
    RETURN TRUE
  END Compile2;

TYPE InCnt = { EqualsZero, EqualsOne, AtLeastOne, Any };

PROCEDURE <A NAME="Pass4"><procedure>Pass4</procedure></A>(rt: View.Root; ed: T; scp: JunoScope.T) RAISES {Error} =
</PRE><BLOCKQUOTE><EM> Compile and process UI declarations. </EM></BLOCKQUOTE><PRE>
  VAR forest := ed.trees; BEGIN
    (* clear the &quot;UI&quot; tables *)
    EVAL NARROW(ed.toolTypes, AtomAtomTbl.Default).init(
      sizeHint := ed.toolTypes.size());
    EVAL NARROW(ed.setMenus, AtomRefTbl.Default).init(
      sizeHint := ed.setMenus.size());

    WHILE forest # NIL DO
      TYPECASE forest.tree OF
      | JunoAST.UIDecl (ui) =&gt;
          IF ui.name = PointToolSym OR ui.name = TextToolSym
             OR ui.name = SetToolSym OR ui.name = TemplToolSym THEN
            VAR nm: JunoAST.QId; ent: JunoScope.Entity; BEGIN
              nm := FirstName(ui, argCnt := 1);
              ent := CheckEnt(nm, scp);
              IF ui.name = PointToolSym THEN
                IF NOT ISTYPE(ent, JunoScope.Code) THEN
                  (* not a predicate, function, or procedure *)
                  Raise(&quot;Must be a predicate, function, or procedure&quot;, nm)
                END;
                IF ISTYPE(ent, JunoScope.Proc) THEN
                  CheckProc(ent, nm)	 (* check for no OUT or INOUT args *)
                END
              ELSIF ui.name = TextToolSym THEN
                CheckProc(ent, nm, InCnt.AtLeastOne)
              ELSIF ui.name = SetToolSym THEN
                CheckProc(ent, nm, InCnt.EqualsOne)
              ELSIF ui.name = TemplToolSym THEN
                CheckProc(ent, nm, InCnt.EqualsZero)
              END;
              IF ed.toolTypes.put(nm.id1, ui.name) THEN
                Raise(&quot;Duplicate UI declaration&quot;, nm)
              END
            END
          ELSIF ui.name = ParamSym THEN
            VAR
              nm := FirstName(ui, argCnt := 2);
              ent := CheckEnt(nm, scp);
              valueAST := ui.args.head.next.expr;
              mod := ModuleName(ed);
              buttonName: TEXT;
              button: VBT.T;
              menu: VBT.T;
              menuRef: REFANY;
            BEGIN
              CheckProc(ent, nm, InCnt.EqualsOne);
              TYPECASE valueAST OF
                JunoAST.LitValue =&gt; (*SKIP*)
              | JunoAST.QId (qid) =&gt;
                  (* Check that &quot;qid&quot; names a legal term *)
                  VAR res, unit: JunoScope.Entity; BEGIN
                    res := JunoScope.LookupQId(scp, qid, unit);
                    TYPECASE res OF
                      NULL =&gt;
                        Raise(&quot;Unknown identifier&quot;, qid)
                    | JunoScope.Const, JunoScope.Var, JunoScope.Proc =&gt;
                        (* SKIP - these are legal terms *)
                    ELSE
                        Raise(&quot;Parameter value must be\n&quot;
                          &amp; &quot;a CONST, VAR, or PROC&quot;, qid)
                    END
                  END;
                  valueAST := Qualify(qid, mod)
              ELSE
                Raise(&quot;Parameter value must be a\n&quot;
                  &amp; &quot;(qualified) identifier or literal&quot;, valueAST)
              END;
              &lt;* FATAL Wr.Failure *&gt;
              VAR twr := NEW(TextWr.T).init(); BEGIN
                JunoUnparse.Expr(twr, valueAST, tokens := LAST(INTEGER),
                  width := LAST(INTEGER), prec := JunoConfig.realPrec);
                buttonName := TextWr.ToText(twr)
              END;
              button :=
                NEW(ToolBox.SetButton).init(rt, buttonName,
                  Drawing.NewSetTool(Qualify(nm, mod), valueAST));
              IF NOT ed.setMenus.get(nm.id1, menuRef) THEN
                menu := NEW(HVSplit.T).init(Axis.T.Ver);
                EVAL ed.setMenus.put(nm.id1, menu)
              ELSE
                menu := menuRef
              END;
              Split.AddChild(menu, button)
            END
          ELSE
            Raise(&quot;Unknown UI declaration&quot;, ui)
          END
      ELSE (* SKIP *)
      END;
      forest := forest.next
    END
  END Pass4;

PROCEDURE <A NAME="Qualify"><procedure>Qualify</procedure></A>(qid: JunoAST.QId; mod: Atom.T): JunoAST.QId =
</PRE><BLOCKQUOTE><EM> If <CODE>qid</CODE> is unqualified and <CODE>mod # NIL</CODE>, return <CODE>mod . qid.id1</CODE>, else
   return <CODE>qid</CODE>. </EM></BLOCKQUOTE><PRE>
  BEGIN
    IF qid.id0 = JunoAST.NilId AND mod # NIL
      THEN RETURN NEW(JunoAST.QId, bp := qid, id0 := mod, id1 := qid.id1)
      ELSE RETURN qid
    END
  END Qualify;

PROCEDURE <A NAME="FirstName"><procedure>FirstName</procedure></A>(ui: JunoAST.UIDecl; argCnt: CARDINAL): JunoAST.QId
    RAISES {Error} =
</PRE><BLOCKQUOTE><EM> Checks that <CODE>ui</CODE> has <CODE>argCnt</CODE> arguments, which is required to be non-zero.
   If so, returns the unqualified identifier that is the first argument.
   Raises <CODE>Error</CODE> with the appropriate error message if the first argument is
   not an unqualified identifier. </EM></BLOCKQUOTE><PRE>
  BEGIN
    &lt;* ASSERT argCnt &gt; 0 *&gt;
    IF ui.args.size # argCnt THEN
      VAR errAST: JunoAST.T; BEGIN
        IF ui.args.size = 0 THEN errAST := ui ELSE errAST := ui.args END;
        Raise(&quot;Wrong number of arguments&quot;, errAST)
      END
    END;
    TYPECASE ui.args.head.expr OF
      JunoAST.QId (qid) =&gt;
        IF qid.id0 # JunoAST.NilId THEN
          Raise(&quot;Expecting unqualified identifier&quot;, qid)
        END;
        RETURN qid
    ELSE
      Raise(&quot;Expecting an identifier&quot;, ui.args.head.expr);
      RETURN NIL (* not reached -- just to surpress compiler warning *)
    END
  END FirstName;

PROCEDURE <A NAME="CheckEnt"><procedure>CheckEnt</procedure></A>(qid: JunoAST.QId; scp: JunoScope.T): JunoScope.Entity
    RAISES {Error} =
</PRE><BLOCKQUOTE><EM> Returns the entity bound to <CODE>qid</CODE> in <CODE>scp</CODE>. Requires that <CODE>qid</CODE> is
   unqualified. Raises <CODE>Error</CODE> with an appropriate error message if <CODE>qid</CODE> is
   not bound in <CODE>scp</CODE>. </EM></BLOCKQUOTE><PRE>
  VAR res := JunoScope.Lookup(scp, qid.id1); BEGIN
    IF res = NIL THEN
      Raise(&quot;Undefined&quot;, qid)
    END;
    RETURN res
  END CheckEnt;

PROCEDURE <A NAME="CheckProc"><procedure>CheckProc</procedure></A>(ent: JunoScope.Entity; ast: JunoAST.T; inCnt := InCnt.Any)
    RAISES {Error} =
</PRE><BLOCKQUOTE><EM> Check that <CODE>ent</CODE> is a procedure with no OUT or INOUT parameters. If <CODE>inCnt</CODE>
   is <CODE>EqualsOne</CODE>, then the procedure must have exactly one IN argument; if it
   is <CODE>AtLeastOne</CODE>, then it must have at least one IN argument. Raises <CODE>Error</CODE>
   so that <CODE>ast</CODE> will be highlighted if any of these checks fail; otherwise,
   this procedure is a no-op. </EM></BLOCKQUOTE><PRE>
  BEGIN
    TYPECASE ent OF JunoScope.Proc (p) =&gt;
      IF p.out_cnt # 0 OR p.inout_cnt # 0 THEN
        Raise(&quot;Procedure may not have any\nOUT or INOUT arguments&quot;, ast)
      END;
      IF inCnt = InCnt.EqualsOne AND p.in_cnt # 1 THEN
        Raise(&quot;Procedure must have\nexactly one IN argument&quot;, ast)
      ELSIF inCnt = InCnt.AtLeastOne AND p.in_cnt = 0 THEN
        Raise(&quot;Procedure must have\nat least one IN argument&quot;, ast)
      ELSIF inCnt = InCnt.EqualsZero AND p.in_cnt # 0 THEN
        Raise(&quot;Procedure must have\nno IN arguments&quot;, ast)
      END
    ELSE Raise(&quot;Must be a procedure&quot;, ast)
    END
  END CheckProc;

PROCEDURE <A NAME="CompileUI"><procedure>CompileUI</procedure></A>(
    rt: View.Root;
    te: T;
    time: VBT.TimeStamp;
    scp: JunoScope.T): BOOLEAN =
BEGIN
    &lt;* ASSERT te.treesValid *&gt;
    TRY
      Pass4(rt, te, scp)
    EXCEPT
      Error (err) =&gt;
        &lt;* ASSERT err.ast # NIL *&gt;
        Unparse(te, err.ast, err.msg, time);
        RETURN FALSE
    END;
    RETURN TRUE
END CompileUI;

PROCEDURE <A NAME="SaveSlots"><procedure>SaveSlots</procedure></A>(wr: Wr.T) =
  BEGIN
    Wr.PutText(wr, Fmt.Int(global_slot) &amp; &quot;\n&quot;)
  END SaveSlots;

PROCEDURE <A NAME="RestoreSlots"><procedure>RestoreSlots</procedure></A>(rd: Rd.T) =
  &lt;* FATAL FloatMode.Trap, Lex.Error, Rd.Failure, Rd.EndOfFile *&gt;
  BEGIN
    global_slot := Lex.Int(rd);
    IF Rd.GetChar(rd) # 'n' THEN &lt;* ASSERT FALSE *&gt; END
  END RestoreSlots;

BEGIN
  PointToolSym := Atom.FromText(&quot;PointTool&quot;);
  TextToolSym  := Atom.FromText(&quot;TextTool&quot;);
  SetToolSym   := Atom.FromText(&quot;SetTool&quot;);
  ParamSym     := Atom.FromText(&quot;Param&quot;);
  TemplToolSym := Atom.FromText(&quot;Template&quot;);
END Editor.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface Editor is in:
</A><UL>
<LI><A HREF="../../cm3ide/src/misc/Editor.i3.html#0TOP0">cm3ide/src/misc/Editor.i3</A>
<LI><A HREF="Editor.i3.html#0TOP0">juno-app/src/Editor.i3</A>
</UL>
<P>
<HR>
<A NAME="x2">interface View is in:
</A><UL>
<LI><A HREF="View.i3.html#0TOP0">juno-app/src/View.i3</A>
<LI><A HREF="../../zeus/src/View.i3.html#0TOP0">zeus/src/View.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
