<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: ktok/derived/tokformBundle.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>ktok/derived/tokformBundle.m3</H2></A><HR>
<inModule>
<PRE>MODULE <module><implements><A HREF="tokformBundle.i3.html">tokformBundle</A></implements></module>;
</PRE><BLOCKQUOTE><EM> Generated by m3bundle; see its manpage. </EM></BLOCKQUOTE><PRE>

IMPORT <A HREF="../../libm3/src/bundleintf/Bundle.i3.html">Bundle</A>, <A HREF="../../libm3/src/bundleintf/BundleRep.i3.html">BundleRep</A>, <A HREF="../../m3core/src/text/Text.i3.html">Text</A>;
IMPORT <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="../../libm3/src/rw/TextWr.i3.html">TextWr</A>;

TYPE T = Bundle.T OBJECT OVERRIDES
           get      := LookUp;
           getNames := GetNames;
         END;

TYPE Texts = REF ARRAY OF TEXT;

VAR
  bundle: T     := NIL;
  names : Texts := NIL;

PROCEDURE <A NAME="Get"><procedure>Get</procedure></A>(): Bundle.T =
  BEGIN
    IF (bundle = NIL) THEN bundle := NEW (T) END;
    RETURN bundle;
  END Get;

PROCEDURE <A NAME="GetNames"><procedure>GetNames</procedure></A> (&lt;*UNUSED*&gt; self: T): Texts =
  BEGIN
    IF names = NIL THEN
      names := NEW (Texts, NUMBER (Names));
      names^ := Names;
    END;
    RETURN names;
  END GetNames;

PROCEDURE <A NAME="LookUp"><procedure>LookUp</procedure></A> (&lt;*UNUSED*&gt; self: T;  element: TEXT): TEXT =
  BEGIN
    FOR i := 0 TO LAST (Names)-1 DO
      IF Text.Equal (Names[i], element) THEN
        IF Elements[i] = NIL THEN Elements[i] := GetElt (i) END;
        RETURN Elements[i];
      END;
    END;
    RETURN NIL;
  END LookUp;

CONST Names = ARRAY [0..4] OF TEXT {
  &quot;tokform.m3&quot;,
  &quot;tokform.case&quot;,
  &quot;tokform.i3&quot;,
  &quot;tokform.type&quot;,
  NIL
};

VAR Elements := ARRAY [0..4] OF TEXT {
  NIL (* E0 .. E0_0 *),
  E1,
  NIL (* E2 .. E2_0 *),
  E3,
  NIL
};

PROCEDURE <A NAME="GetElt"><procedure>GetElt</procedure></A> (n: INTEGER): TEXT =
  &lt;*FATAL Thread.Alerted, Wr.Failure *&gt;
  VAR wr := TextWr.New ();
  BEGIN
    CASE n OF
    | 0 =&gt;
        Wr.PutText (wr, E0);
        Wr.PutText (wr, E0_0);
    | 2 =&gt;
        Wr.PutText (wr, E2);
        Wr.PutText (wr, E2_0);
    ELSE (*skip*)
    END;
    RETURN TextWr.ToText (wr);
  END GetElt;

CONST E0 =
   &quot;MODULE %tok;\n%gen\nIMPORT Rd, Thread;\nIMPORT Wr;\nIMPORT Fmt;\nIMPORT&quot;
 &amp; &quot; RTAllocator;\nFROM Stdio IMPORT stdout;\n&lt;* FATAL Wr.Failure, Thread.A&quot;
 &amp; &quot;lerted *&gt;\n\nREVEAL\n  ParseType = ParseTypePublic BRANDED \&quot;%tok.Parse&quot;
 &amp; &quot;Type\&quot; OBJECT\n    x: REFANY := NIL;\n    (* if allocated, a is an allo&quot;
 &amp; &quot;cator.\n       if freed into an allocator, a is \&quot;tail\&quot;.\n       else,&quot;
 &amp; &quot; a is NIL *)\n  OVERRIDES\n    discard := Discard;\n    detach := Detac&quot;
 &amp; &quot;h;\n  END;\n  Allocator = BRANDED \&quot;%tok.PrivAlloc\&quot; OBJECT\n    m3type&quot;
 &amp; &quot;: INTEGER;\n    free: ParseType := NIL;\n    numAlloc: INTEGER := 0;\n &quot;
 &amp; &quot;   valid: BOOLEAN := TRUE;\n  END;\n\nPROCEDURE NewPT(VAR a: Allocator;&quot;
 &amp; &quot; m3type: INTEGER): ParseType =\n  VAR\n    result: ParseType;\n  BEGIN\n&quot;
 &amp; &quot;    IF a = NIL THEN\n      a := NEW(Allocator, m3type := m3type);\n    &quot;
 &amp; &quot;END;\n    &lt;* ASSERT a.m3type = m3type *&gt;\n    IF a.free = NIL THEN\n   &quot;
 &amp; &quot;   result := RTAllocator.NewTraced(m3type);\n    ELSE\n      result := &quot;
 &amp; &quot;a.free;\n      a.free := NARROW(a.free.x, ParseType); (* free := free.t&quot;
 &amp; &quot;ail *)\n    END;\n    INC(a.numAlloc);\n    result.x := a;\n    RETURN &quot;
 &amp; &quot;result;\n  END NewPT;\n\nPROCEDURE Discard(self: ParseType) =\n  VAR\n &quot;
 &amp; &quot;   a: Allocator;\n  BEGIN\n    IF self.x # NIL THEN\n      a := self.x;&quot;
 &amp; &quot;  (* this fails if self not allocated using New *)\n      IF a.valid TH&quot;
 &amp; &quot;EN\n        self.x := a.free; (* self.tail = a.free *)\n        a.free &quot;
 &amp; &quot;:= self;\n        DEC(a.numAlloc);\n      END;\n    END;\n  END Discard&quot;
 &amp; &quot;;\n\nPROCEDURE Detach(self: ParseType): ParseType = BEGIN\n  self.x := &quot;
 &amp; &quot;NIL; RETURN self; END Detach;\n\nPROCEDURE Purge(VAR a: Allocator): INT&quot;
 &amp; &quot;EGER =\n  VAR\n    result: INTEGER;\n  BEGIN\n    IF a = NIL THEN RETUR&quot;
 &amp; &quot;N 0;END;\n    a.valid := FALSE;\n    result := a.numAlloc;\n    a := NI&quot;
 &amp; &quot;L;\n    RETURN result;\n  END Purge;\n\nVAR\n  ConstTokens: ARRAY Const&quot;
 &amp; &quot;TokenCode OF ConstToken;\nPROCEDURE NewConstToken(val: ConstTokenCode):&quot;
 &amp; &quot; ConstToken =\n  BEGIN\n    &lt;* ASSERT val IN LegalConstTokenCodes *&gt;\n &quot;
 &amp; &quot;   RETURN ConstTokens[val];\n  END NewConstToken; \n\nPROCEDURE Test(le&quot;
 &amp; &quot;x: Lexer) =\n  VAR\n    typeName: TEXT;\n  BEGIN\n    TRY\n      LOOP\n&quot;
 &amp; &quot;        TYPECASE lex.get() OF\n   &quot;;

CONST E0_0 =
   &quot;     | ConstToken(t) =&gt; typeName := \&quot;&lt;CONST \&quot; &amp; Fmt.Int(t.val) &amp; \&quot;&gt;\&quot;&quot;
 &amp; &quot;;\n        | NULL =&gt; typeName := \&quot;&lt;NULL&gt;\&quot;;\n%case\\\n        ELSE\n  &quot;
 &amp; &quot;        typeName := \&quot;&lt;UNKNOWN&gt;\&quot;;\n        END;\n        TYPECASE lex &quot;
 &amp; &quot;OF RdLexer(l) =&gt; \n          Wr.PutText(stdout, typeName &amp; \&quot;: \\\&quot;\&quot; &amp;&quot;
 &amp; &quot; l.getText() &amp; \&quot;\\\&quot;\\n\&quot;);\n        ELSE\n          Wr.PutText(stdout&quot;
 &amp; &quot;, typeName &amp; \&quot;\\n\&quot;);\n        END;\n      END;\n    EXCEPT\n      Rd.&quot;
 &amp; &quot;EndOfFile =&gt;\n    END;\n  END Test;\n\nBEGIN\n  FOR i := FIRST(ConstTok&quot;
 &amp; &quot;ens) TO LAST(ConstTokens) DO\n    IF i IN LegalConstTokenCodes THEN\n  &quot;
 &amp; &quot;    ConstTokens[i] := NEW(ConstToken, val := i);\n    END;      \n  END&quot;
 &amp; &quot;;\nEND %tok.\n&quot;;

CONST E1 =
   &quot;        | %type =&gt; typeName := \&quot;%type\&quot;;\n&quot;;

CONST E2 =
   &quot;INTERFACE %tok;\n%gen\n(* original token definition *)\nIMPORT Rd;\nTYP&quot;
 &amp; &quot;E\n  ParseType &lt;: ParseTypePublic;\n  Token = ParseType BRANDED \&quot;%tok.&quot;
 &amp; &quot;Token\&quot; OBJECT END;\n\n  Lexer = OBJECT METHODS\n    get(): Token RAISE&quot;
 &amp; &quot;S {Rd.EndOfFile};\n    (* get next token, or raise Rd.EndOfFile if toke&quot;
 &amp; &quot;n cannot be formed\n       from remaining input *)\n\n    unget();\n   &quot;
 &amp; &quot; (* will be called at most once after get(), and only when lookahead is&quot;
 &amp; &quot;\n       required after last token when parsing without exhausting inpu&quot;
 &amp; &quot;t *)\n\n    error(message: TEXT);\n    (* might print file name, line n&quot;
 &amp; &quot;umber, and message, and exit *)\n  END;\n\n  RdLexer = Lexer OBJECT MET&quot;
 &amp; &quot;HODS\n    setRd(rd: Rd.T): RdLexer;\n    (* Prepare to read tokens star&quot;
 &amp; &quot;ting at cur(rd).\n       After every token, rd is repositionned after t&quot;
 &amp; &quot;hat token. *)\n\n    getRd(): Rd.T;\n    (* get reader  *)\n    \n    f&quot;
 &amp; &quot;romText(t: TEXT): RdLexer;\n    (* Calls setRd with a textReader. *)\n\n&quot;
 &amp; &quot;    rewind();\n    (* equivalent to Rd.Seek(rd, 0) followed by setRd *)&quot;
 &amp; &quot; \n\n    getText(): TEXT;\n    (* get TEXT of last token *)\n\n    purg&quot;
 &amp; &quot;e(): INTEGER;\n    (* Allow any internally allocated ParseTypes to be g&quot;
 &amp; &quot;arbage collected,\n       even if the lexer itself remains in scope. Re&quot;
 &amp; &quot;turn number of ParseType\n       objects allocated but not discarded (n&quot;
 &amp; &quot;ot the number of purged objects).\n       Can be called at any time by &quot;
 &amp; &quot;the thread calling get. *)\n  END;\n\n  (* token types *)\n  ConstToken&quot;
 &amp; &quot;Code = [1..%lastConst]; (* &lt; 256 means char code *)\n  ConstToken = Tok&quot;
 &amp; &quot;en BRANDED \&quot;%tok.ConstToken\&quot; OBJECT\n    val: ConstTokenCode;\n  END;&quot;
 &amp; &quot; (* neither extend this object nor reassign val *)\n%type\\\n\n  (* Par&quot;
 &amp; &quot;seType allocation *)\n  Allocator &lt;: ROOT;\n  ParseTypePublic = OBJECT &quot;
 &amp; &quot;METHODS\n    discard();\n    detach(): ParseType;\n  END;\n\nCONST\n  L&quot;
 &amp; &quot;egalConstTokenCodes = SET OF ConstTokenCode{\n%constSet};\n%constName\\&quot;
 &amp; &quot;\n\nPROCEDURE NewPT(VAR a: Allocator; m3type: INTEGER): ParseType;\n(* &quot;
 &amp; &quot;IF a = NIL, then let a = new allocator for m3type.\n   regardless, retu&quot;
 &amp; &quot;rn a new ParseType specifically of type m3type *)\n\nPROCEDURE Purge(VA&quot;
 &amp; &quot;R a: Allocator&quot;;

CONST E2_0 =
   &quot;): INTEGER;\n(* set a=NIL. return number of objects allocated using\n  &quot;
 &amp; &quot; New(a, ...) which were not discarded using discard(). *)\n\nPROCEDURE &quot;
 &amp; &quot;NewConstToken(val: ConstTokenCode): ConstToken;\n(* return a constToken&quot;
 &amp; &quot; with val=val (well it might not be so new) *)\n(* discard() will fail &quot;
 &amp; &quot;for a constToken *)\n\nPROCEDURE Test(lex: Lexer);\n(* get tokens and p&quot;
 &amp; &quot;rint their names to stdout until Rd.EndOfFile *)\n\nEND %tok.\n&quot;;

CONST E3 =
   &quot;  %type = Token BRANDED \&quot;%tok.%type\&quot; OBJECT END;\n&quot;;

BEGIN
END tokformBundle.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
