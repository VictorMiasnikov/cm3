<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: formsedit/src/FormsEditVBT.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>formsedit/src/FormsEditVBT.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright (C) 1992, Digital Equipment Corporation                         
 All rights reserved.                                                      
 See the file COPYRIGHT for a full description.                            
                                                                           
 Last modified on Fri May 17 11:43:43 PDT 1996 by mhb                      
      modified on Tue Jan 31 11:27:14 PST 1995 by kalsow                   
      modified on Wed Jun 29 16:17:48 PDT 1994 by bharat                   
      modified on Fri Jun  4 16:08:13 PDT 1993 by meehan                   
      modified on Tue Jun 16 21:55:39 PDT 1992 by muller                   

<P><PRE>MODULE <module><implements><A HREF="FormsEditVBT.i3.html">FormsEditVBT</A></implements></module>;

IMPORT <A HREF="../../vbtkit/src/vbtkitutils/AnyEvent.i3.html">AnyEvent</A>, <A HREF="../../libm3/src/geometry/Axis.i3.html">Axis</A>, <A HREF="../../ui/src/vbt/Cursor.i3.html">Cursor</A>, <A HREF="../../vbtkit/src/lego/FileBrowserVBT.i3.html">FileBrowserVBT</A>, <A HREF="../../libm3/src/rw/FileRd.i3.html">FileRd</A>, <A HREF="../../libm3/src/rw/FileWr.i3.html">FileWr</A>, <A HREF="../../ui/src/split/Filter.i3.html">Filter</A>,
       <A HREF="../../libm3/src/formatter/Formatter.i3.html">Formatter</A>, <A HREF="../derived/formseditBundle.i3.html">formseditBundle</A>, <A HREF="../../formsvbt/src/FormsVBT.i3.html">FormsVBT</A>, <A HREF="../../libm3/src/fmtlex/Fmt.i3.html">Fmt</A>, <A HREF="../../ui/src/vbt/Font.i3.html">Font</A>, <A HREF="../../libm3/src/os/Common/FS.i3.html">FS</A>, <A HREF="../../formsvbt/src/FVRuntime.i3.html">FVRuntime</A>,
       <A HREF="../../formsvbt/src/FVTypes.i3.html">FVTypes</A>, <A HREF="../../libm3/derived/IntRefTbl.i3.html">IntRefTbl</A>, <A HREF="../../libm3/src/rw/IO.i3.html">IO</A>, <A HREF="../../ui/src/vbt/KeyboardKey.i3.html">KeyboardKey</A>, <A HREF="../../vbtkit/src/etext/KeyTrans.i3.html">KeyTrans</A>, <A HREF="../../formsvbt/src/Manpage.i3.html">Manpage</A>, <A HREF="../../vbtkit/src/mtext/MText.i3.html">MText</A>,
       <A HREF="../../vbtkit/src/mtext/MTextRd.i3.html">MTextRd</A>, <A HREF="../../libm3/src/os/Common/OSError.i3.html">OSError</A>, <A HREF="../../ui/src/vbt/PaintOp.i3.html">PaintOp</A>, <A HREF="../../ui/src/vbt/Palette.i3.html">Palette</A>, <A HREF="../../libm3/src/os/Common/Pathname.i3.html">Pathname</A>, <A HREF="../../libm3/src/geometry/Point.i3.html">Point</A>, <A HREF="../../libm3/src/os/Common/Process.i3.html">Process</A>, <A HREF="../../libm3/src/rw/Rd.i3.html">Rd</A>,
       <A HREF="../../libm3/src/rw/RdUtils.i3.html">RdUtils</A>, <A HREF="../../libm3/src/geometry/Rect.i3.html">Rect</A>, <A HREF="../../libm3/derived/RefList.i3.html">RefList</A>, <A HREF="../../formsvbt/src/RefListUtils.i3.html">RefListUtils</A>, <A HREF="../../vbtkit/src/vbtkitutils/Rsrc.i3.html">Rsrc</A>, <A HREF="../../m3core/src/runtime/common/RTTypeSRC.i3.html">RTTypeSRC</A>, <A HREF="../../ui/src/vbt/ScreenType.i3.html">ScreenType</A>,
       <A HREF="../../ui/src/split/StableVBT.i3.html">StableVBT</A>, <A HREF="../../libm3/src/sx/Sx.i3.html">Sx</A>, <A HREF="../../m3core/src/text/Text.i3.html">Text</A>, <A HREF="../../vbtkit/src/etext/TextEditVBT.i3.html">TextEditVBT</A>, <A HREF="../../vbtkit/src/etext/TextPort.i3.html">TextPort</A>, <A HREF="../../vbtkit/src/etext/TextPortClass.i3.html">TextPortClass</A>, <A HREF="../../libm3/src/rw/TextRd.i3.html">TextRd</A>,
       <A HREF="../../libm3/src/rw/TextWr.i3.html">TextWr</A>, <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../ui/src/vbt/Trestle.i3.html">Trestle</A>, <A HREF="../../ui/src/vbt/TrestleComm.i3.html">TrestleComm</A>, <A HREF="../../ui/src/vbt/VBT.i3.html">VBT</A>, <A HREF="../../ui/src/vbt/VBTClass.i3.html">VBTClass</A>, <A HREF="../../vbtkit/src/vtext/VTDef.i3.html">VTDef</A>, <A HREF="../../vbtkit/src/vtext/VText.i3.html">VText</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>,
       <A HREF="../../vbtkit/src/vbtkitutils/XParam.i3.html">XParam</A>, <A HREF="../../vbtkit/src/lego/ZChassisVBT.i3.html">ZChassisVBT</A>, <A HREF="../../vbtkit/src/lego/ZChildVBT.i3.html">ZChildVBT</A>;

&lt;* FATAL FormsVBT.Unimplemented *&gt;(* Should never happen here. *)

&lt;* PRAGMA LL *&gt;

CONST
  DummyText = &quot;(Rim (Pen 10) (Text (Name ignoreMe) &quot;
                &amp; &quot;\&quot;This space available for a small fee\&quot;))&quot;;
  HelpFile  = &quot;formsedit.txt&quot;;
  STACKSIZE = 10000;

REVEAL
  FormsVBT.T &lt;: FVRuntime.SemiPublic; (* expose &quot;formstack&quot; field *)
  <A NAME="T">T</A> = Public BRANDED OBJECT
        ed                     : Editor;
        number                                   := 0;
        fullPathname, shortname: TEXT            := &quot;&quot;;
        display, geometry      : TEXT;
        rd                     : Rd.T;           (* For manpage *)
        prettyprintWidth       : CARDINAL        := 78;
        revertWidth            : CARDINAL        := 78;
        root                   : EditorRoot;
        mu                     : MUTEX;
        egrec                  : XParam.Geometry;
        path                   : Rsrc.Path;
      METHODS
        delete   ()                              := DeleteFrame;
        decorate () RAISES {TrestleComm.Failure} := DecorateFrame;
        spawn    ()                              := Spawn
      OVERRIDES
        editor       := GetEditor;
        init         := Init;
        initFromFile := InitFromFile;
      END;
  <A NAME="EditorRoot">EditorRoot</A> = PublicRoot BRANDED OBJECT
                 firstFrame: T;
                 mu        : MUTEX;
                 allClosed : NamedCondition;
                 frames    : RefList.T              := NIL; (* children *)
                 thread    : Thread.T;           (* our own thread *)
                 display   : TEXT;
                 drec      : XParam.Display;
                 trsl      : Trestle.T;
                 array     : Trestle.ScreenArray
               OVERRIDES
                 apply := EditorRootApply;
                 init  := EditorRootInit
               END;

TYPE                             (* in alphabetical order *)

  Attachment = FormsVBT.Closure OBJECT
                 frame: T;
                 proc : KeyProc
               OVERRIDES
                 apply := AttachmentApply
               END;

  Editor = FormsVBT.T OBJECT
             (* The components to which we need fast access *)
             buffer    : TextEditVBT.T;
             stderr    : TextEditVBT.T;
             errorPopup: ZChassisVBT.T;
             (* The internals of the buffer *)
             textport: EPort;
             vtext   : VText.T;
             mtext   : MText.T;
             (* Other things *)
             syntax      : Sx.Syntax;
             rangeTable  : IntRefTbl.Default;
             highlighter : VText.Interval;
             frame       : T;
             modelTsplits: RefList.T        := NIL;
             rd          : MTextRd.T
           METHODS
             init (Frame: T): Editor RAISES {FormsVBT.Error} := EditorInit;
             &lt;* LL = VBT.mu *&gt;
             decorate () RAISES {TrestleComm.Failure} := DecorateEditor;
           OVERRIDES
             realize := Realize
           END;

  EPort = FVTypes.Port OBJECT
            ed: Editor
          OVERRIDES
            modified := NoteModification;
            filter   := EPortFilter;
            error    := EPortError;
            notFound := EPortNotFound
          END;

  FinderClosure = FormsVBT.Closure OBJECT
                    first, next, prev, typein, textedit, close: TEXT
                  METHODS
                    init (fv: FormsVBT.T): FinderClosure := InitFCL
                  OVERRIDES
                    apply := ShowFindWindow
                  END;

  FrameClosure =
    Thread.Closure OBJECT frame: T OVERRIDES apply := FrameApply END;

  JustFVfileBrowser = FVTypes.FVFileBrowser OBJECT
                        ed: Editor
                      OVERRIDES
                        init  := FBinit;
                        error := FBerror
                      END;

  KeyProc = PROCEDURE (frame: T; time: VBT.TimeStamp); &lt;* LL = VBT.mu *&gt;

  Mover = FormsVBT.Closure OBJECT
            id : CARDINAL;
            vbt: VBT.T
          OVERRIDES
            apply := MoverApply
          END;

  NamedCondition = Thread.Condition OBJECT name: TEXT END; (* debugging *)

  ParseClosure = Thread.SizedClosure OBJECT
                   frame: T;
                 OVERRIDES
                   apply := ParseClosureApply
                 END;

  ReadMacro = Sx.ReadMacro OBJECT ed: Editor OVERRIDES read := ReadList END;

VAR HighlightOptions: VText.IntervalOptions; (* CONST *)

VAR
  FrameCountLock := NEW (MUTEX);
  FrameCount     := 0;
  formseditPath  := Rsrc.BuildPath (&quot;$formseditPATH&quot;, formseditBundle.Get ());

PROCEDURE <A NAME="Init"><procedure>Init</procedure></A> (frame: T; description: TEXT): T RAISES {FormsVBT.Error} =
  BEGIN
    &lt;* LL = VBT.mu *&gt;
    IF description = NIL THEN description := DummyText END;
    frame.fullPathname := &quot;&quot;;
    frame.shortname := &quot;&quot;;
    frame.ed := NEW (Editor).init (frame);
    FormsVBT.PutText (frame.ed, &quot;openfile&quot;, &quot;&quot;);
    FormsVBT.PutText (frame.ed, &quot;shortname&quot;, &quot;&quot;);
    TextPort.SetText (frame.ed.buffer.tp, description);
    TextPort.SetModified (frame.ed.textport, FALSE);
    SetModified (frame.ed, FALSE);
    frame.path := RefList.List1 (&quot;.&quot;);
    Parse (frame);
    RETURN frame
  END Init;

PROCEDURE <A NAME="InitFromFile"><procedure>InitFromFile</procedure></A> (frame: T; filename: TEXT): T
  RAISES {FormsVBT.Error, Thread.Alerted} =
  &lt;* LL = VBT.mu *&gt;
  BEGIN
    IF Text.Empty (filename) THEN RAISE FormsVBT.Error (&quot;No filename.&quot;) END;
    IF NOT Pathname.Absolute (filename) THEN
      TRY
        filename := Pathname.Join (Process.GetWorkingDirectory (), filename, NIL)
      EXCEPT
      | OSError.E (list) =&gt;
          RAISE FormsVBT.Error (
                  &quot;Can't get current directory: &quot; &amp; RdUtils.FailureText (list))
      END
    END;
    TRY
      frame.fullPathname := FS.GetAbsolutePathname (filename)
    EXCEPT
    | OSError.E (list) =&gt; RAISE FormsVBT.Error (RdUtils.FailureText (list))
    END;
    frame.shortname := Pathname.Last (filename);
    frame.ed := NEW (Editor).init (frame);
    frame.path := NIL;
    Read (frame);
    FormsVBT.PutText (frame.ed, &quot;openfile&quot;, filename);
    FormsVBT.PutText (frame.ed, &quot;shortname&quot;, frame.shortname);
    RETURN frame
  END InitFromFile;

PROCEDURE <A NAME="Read"><procedure>Read</procedure></A> (frame: T) RAISES {FormsVBT.Error, Thread.Alerted} =
  &lt;* LL = VBT.mu *&gt;
  VAR
    ed        := frame.ed;
    rd : Rd.T;
    dir: Pathname.T;
  BEGIN
    ClearError (ed);
    TRY
      rd := FileRd.Open (frame.fullPathname);
      TRY
        dir := Pathname.Prefix (frame.fullPathname);
        IF NOT RefList.Member (frame.path, dir) THEN
          frame.path := RefList.Cons (dir, frame.path)
        END;
        TextPort.SetText (ed.textport, Rd.GetText (rd, Rd.Length (rd)));
        TextPort.SetModified (ed.textport, FALSE);
        SetModified (ed, FALSE);
        Parse (frame);
        frame.decorate ();
        ed.decorate ()
      FINALLY
        Rd.Close (rd)
      END
    EXCEPT
    | OSError.E (list) =&gt; RAISE FormsVBT.Error (RdUtils.FailureText (list))
    | Rd.Failure (f) =&gt;
        RAISE
          FormsVBT.Error (Fmt.F (&quot;Could not read file %s : %s&quot;,
                                 frame.fullPathname, RdUtils.FailureText (f)))
    | TrestleComm.Failure =&gt;
        RAISE
          FormsVBT.Error (
            &quot;TrestleComm.Failure while attempting to change the decoration&quot;)
    END
  END Read;

PROCEDURE <A NAME="EditorRootInit"><procedure>EditorRootInit</procedure></A> (root     : EditorRoot;
                          frame    : T;
                          Xdisplay                := &quot;:0.0&quot;;
                          Xgeometry               := &quot;+50+50&quot;): EditorRoot
  RAISES {TrestleComm.Failure, XParam.Error} =
  BEGIN
    root.firstFrame := frame;
    frame.root := root;
    root.display := Xdisplay;
    root.drec := XParam.ParseDisplay (Xdisplay);
    root.trsl := Trestle.Connect (Xdisplay);
    root.array := Trestle.GetScreens (root.trsl);
    IF root.array = NIL OR NUMBER (root.array^) = 0 THEN
      RAISE TrestleComm.Failure
    END;
    Palette.Init (root.array [0].type);
    Palette.Init (root.array [0].type.bits);
    Install (frame, Xgeometry);
    root.mu := NEW (MUTEX);
    LOCK root.mu DO
      root.frames := NIL;
      root.allClosed := NEW (NamedCondition, name := &quot;all editors closed&quot;)
    END;
    RETURN root
  END EditorRootInit;

PROCEDURE <A NAME="EditorRootApply"><procedure>EditorRootApply</procedure></A> (root: EditorRoot): REFANY =
  VAR frames: RefList.T;
  BEGIN
    root.thread := Thread.Self ();
    root.firstFrame.spawn ();
    TRY
      LOCK root.mu DO
        WHILE root.frames # NIL DO
          Thread.AlertWait (root.mu, root.allClosed)
        END
      END
    EXCEPT
    | Thread.Alerted =&gt;
        Debug (Fmt.F (&quot;EdRoot was alerted. There are %s frames.\n&quot;,
                      Fmt.Int (RefList.Length (root.frames))));
        (* Alert all the frames *)
        LOCK root.mu DO frames := root.frames END;
        WHILE frames # NIL DO AlertFrame (RefListUtils.Pop (frames)) END;
        LOCK root.mu DO
          WHILE root.frames # NIL DO Thread.Wait (root.mu, root.allClosed) END
        END
    END;
    RETURN NIL
  END EditorRootApply;

PROCEDURE <A NAME="Spawn"><procedure>Spawn</procedure></A> (frame: T) =
  VAR fc := NEW (FrameClosure, frame := frame);
  BEGIN
    frame.mu := NEW (MUTEX);
    EVAL Thread.Fork (fc);
    LOCK frame.root.mu DO RefListUtils.Push (frame.root.frames, frame) END
  END Spawn;

PROCEDURE <A NAME="FrameApply"><procedure>FrameApply</procedure></A> (fc: FrameClosure): REFANY =
  &lt;* LL = 0 *&gt;
  BEGIN
    Trestle.AwaitDelete (fc.frame);
    RETURN NIL
  END FrameApply;

PROCEDURE <A NAME="AlertFrame"><procedure>AlertFrame</procedure></A> (frame: T) =
  &lt;* LL = 0 *&gt;
  &lt;* FATAL FormsVBT.Error *&gt;
  VAR ed := frame.ed;
  BEGIN
    Debug (Fmt.F (&quot;Frame %s is being alerted.\n&quot;, Fmt.Int (frame.number)));
    LOCK VBT.mu DO
      IF TextPort.IsModified (ed.textport) THEN
        FormsVBT.MakeDormant (ed, &quot;dontquit&quot;);
        FormsVBT.MakeDormant (ed, &quot;cancelsaveas&quot;);
        FormsVBT.PopUp (ed, &quot;quitConfirmation&quot;)
      ELSE
        frame.delete ()
      END
    END
  END AlertFrame;

PROCEDURE <A NAME="Install"><procedure>Install</procedure></A> (frame: T; editorGeo: TEXT)
  RAISES {TrestleComm.Failure, XParam.Error} =
  &lt;* FATAL FormsVBT.Error *&gt;(* In here, they're all our fault. *)
  VAR
    frameGeo := &quot;+10+10&quot;;        (* NW corner *)
    ed       := frame.ed;
    drec     := frame.root.drec;
    trsl     := frame.root.trsl;
    array    := frame.root.array;
  VAR
    egrec, fgrec: XParam.Geometry;
    name        : TEXT;
  BEGIN
    frame.geometry := editorGeo;
    egrec := XParam.ParseGeometry (editorGeo);
    frame.egrec := egrec;
    fgrec := XParam.ParseGeometry (frameGeo);
    (* Set up Rescreen menu-items. *)
    IF NUMBER (array^) = 1 THEN
      FormsVBT.MakeDormant (ed, &quot;rescreenFilter&quot;)
    ELSE
      FOR i := LAST (array^) TO FIRST (array^) BY -1 DO
        name := &quot;Edit&quot; &amp; Fmt.Int (i);
        EVAL FormsVBT.Insert (
               ed, &quot;rescreenMenu&quot;,
               Fmt.F (&quot;(MButton %%s (Text RightAlign \&quot;%s:%s.%s\&quot;))&quot;, name,
                      drec.hostname, Fmt.Int (drec.display), Fmt.Int (i)), 0);
        FormsVBT.Attach (ed, name, NEW (Mover, id := i, vbt := ed))
      END;
      EVAL FormsVBT.Insert (ed, &quot;rescreenMenu&quot;, &quot;\&quot;Move Editor to\&quot;&quot;, 0);
      EVAL FormsVBT.Insert (ed, &quot;rescreenMenu&quot;, &quot;(Bar 1)&quot;, 0);
      FOR i := LAST (array^) TO FIRST (array^) BY -1 DO
        name := &quot;Frame&quot; &amp; Fmt.Int (i);
        EVAL FormsVBT.Insert (
               ed, &quot;rescreenMenu&quot;,
               Fmt.F (&quot;(MButton %%s (Text RightAlign \&quot;%s:%s.%s\&quot;))&quot;, name,
                      drec.hostname, Fmt.Int (drec.display), Fmt.Int (i)), 0);
        FormsVBT.Attach (ed, name, NEW (Mover, id := i, vbt := frame))
      END;
      EVAL FormsVBT.Insert (ed, &quot;rescreenMenu&quot;, &quot;\&quot;Move Result to\&quot;&quot;, 0);
    END;

    PROCEDURE FixSize (v: VBT.T; VAR g: XParam.Geometry) =
      BEGIN
        VBTClass.Rescreen (v, array [0].type);
        IF g.size = XParam.Missing THEN
          WITH shapes = VBTClass.GetShapes (v) DO
            g.size.h := shapes [Axis.T.Hor].pref;
            g.size.v := shapes [Axis.T.Ver].pref;
          END
        END
      END FixSize;
    BEGIN
      FixSize (ed, egrec);
      FixSize (frame, fgrec)
    END;

    Trestle.Attach(ed, trsl);
    ed.decorate();
    StableVBT.SetShape(ed, egrec.size.h, egrec.size.v);
    Trestle.Overlap(
      ed, drec.screen, XParam.Position(trsl, drec.screen, egrec));

    Trestle.Attach(frame, trsl);
    frame.decorate();
    Trestle.Overlap(frame, drec.screen,
                    XParam.Position(trsl, drec.screen, fgrec))
  END Install;

PROCEDURE <A NAME="DecorateFrame"><procedure>DecorateFrame</procedure></A> (frame: T) RAISES {TrestleComm.Failure} =
  BEGIN
    Trestle.Decorate (frame,
                      windowTitle :=
                        Fmt.F (&quot;FV Result %s: %s&quot;, Fmt.Int (frame.number),
                               Last40 (frame.fullPathname)),
                      iconTitle := Fmt.F (&quot;R %s: %s&quot;, Fmt.Int (frame.number),
                                          frame.shortname),
                      applName := &quot;FormsEdit Result View&quot;, bgColorR := 0.7,
                      bgColorG := 0.7, bgColorB := 1.0)
  END DecorateFrame;

PROCEDURE <A NAME="DecorateEditor"><procedure>DecorateEditor</procedure></A> (ed: Editor) RAISES {TrestleComm.Failure} =
  VAR frame := ed.frame;
  BEGIN
    Trestle.Decorate (ed, windowTitle :=
                            Fmt.F (&quot;FV Editor %s: %s&quot;, Fmt.Int (frame.number),
                                   Last40 (frame.fullPathname)),
                      iconTitle := Fmt.F (&quot;E %s: %s&quot;, Fmt.Int (frame.number),
                                          frame.shortname),
                      applName := &quot;FormsEdit&quot;, bgColorR := 1.0,
                      bgColorG := 0.7, bgColorB := 0.7)
  END DecorateEditor;

PROCEDURE <A NAME="Last40"><procedure>Last40</procedure></A> (t: TEXT): TEXT =
  VAR n := Text.Length (t);
  BEGIN
    IF n &lt;= 40 THEN RETURN t ELSE RETURN &quot;...&quot; &amp; Text.Sub (t, n - 40, n) END
  END Last40;

PROCEDURE <A NAME="GetEditor"><procedure>GetEditor</procedure></A> (frame: T): FormsVBT.T =
  BEGIN
    RETURN frame.ed
  END GetEditor;

PROCEDURE <A NAME="Realize"><procedure>Realize</procedure></A> (ed: Editor; type, name: TEXT): VBT.T
  RAISES {FormsVBT.Error} =
  BEGIN
    IF Text.Equal (name, &quot;openfile&quot;) AND Text.Equal (type, &quot;FileBrowser&quot;) THEN
      RETURN NEW (JustFVfileBrowser, ed := ed)
    END;
    IF Text.Equal (name, &quot;buffer&quot;) AND Text.Equal (type, &quot;TextEdit&quot;) THEN
      RETURN NEW (FVTypes.FVTextEdit, tp := NEW (EPort, ed := ed))
    END;
    IF Text.Length (name) &gt; 6 AND Text.Equal (Text.Sub (name, 0, 6), &quot;Model_&quot;) THEN
      RefListUtils.Push (ed.modelTsplits, name)
    END;
    RETURN FormsVBT.T.realize (ed, type, name)
  END Realize;

PROCEDURE <A NAME="FBinit"><procedure>FBinit</procedure></A> (fb     : JustFVfileBrowser;
                  font   : Font.T              := Font.BuiltIn;
                  colors : PaintOp.ColorQuad   := NIL          ):
  FileBrowserVBT.T =
  BEGIN
    EVAL FVTypes.FVFileBrowser.init (fb, font, colors);
    FileBrowserVBT.SetSuffixes (fb, &quot;fv&quot;);
    RETURN fb
  END FBinit;

PROCEDURE <A NAME="FBerror"><procedure>FBerror</procedure></A> (fb: JustFVfileBrowser; err: FileBrowserVBT.E) =
  &lt;* LL = VBT.mu *&gt;
  BEGIN
    Gripe (fb.ed, &quot;Error in %s: %s&quot;, err.path, err.text)
  END FBerror;

PROCEDURE <A NAME="ChangeSuffixes"><procedure>ChangeSuffixes</procedure></A> (&lt;* UNUSED *&gt; fbcl: FormsVBT.Closure;
                                       fv  : FormsVBT.T;
                                       name: TEXT;
                          &lt;* UNUSED *&gt; time: VBT.TimeStamp  ) =
  VAR fb: FileBrowserVBT.T;
  BEGIN
    TRY
      fb := FormsVBT.GetVBT (fv, &quot;openfile&quot;);
      IF Text.Equal (name, &quot;fvonly&quot;) THEN
        FileBrowserVBT.SetSuffixes (fb, &quot;fv&quot;)
      ELSE
        FileBrowserVBT.SetSuffixes (fb, &quot;&quot;)
      END
    EXCEPT
    | FormsVBT.Error (msg) =&gt; Gripe (fv, msg)
    END
  END ChangeSuffixes;

PROCEDURE <A NAME="EPortNotFound"><procedure>EPortNotFound</procedure></A> (eport: EPort) =
  VAR fv := eport.ed;
  BEGIN
    TRY
      FormsVBT.PopUp (fv, &quot;notfound&quot;);
      EVAL Thread.Fork (NEW (PDNF, fv := fv))
    EXCEPT
    | FormsVBT.Error (msg) =&gt; Gripe (eport.ed, msg)
    END
  END EPortNotFound;

PROCEDURE <A NAME="InitFCL"><procedure>InitFCL</procedure></A> (cl: FinderClosure; fv: FormsVBT.T): FinderClosure =
  BEGIN
    TRY
      FormsVBT.Attach (fv, cl.first, cl);
      FormsVBT.Attach (fv, cl.next, cl);
      FormsVBT.Attach (fv, cl.prev, cl);
      FormsVBT.Attach (fv, cl.typein, cl)
    EXCEPT
    | FormsVBT.Error (msg) =&gt; Gripe (fv, msg)
    END;
    RETURN cl;
  END InitFCL;

PROCEDURE <A NAME="ShowFindWindow"><procedure>ShowFindWindow</procedure></A> (cl  : FinderClosure;
                          fv  : FormsVBT.T;
                          name: TEXT;
                          time: VBT.TimeStamp  ) =
  VAR
    loc : TextPortClass.Loc;
    te  : TextEditVBT.T;
    text: TEXT;
  BEGIN
    IF Text.Equal (name, cl.first) THEN
      loc := TextPortClass.Loc.First
    ELSIF Text.Equal (name, cl.typein) OR Text.Equal (name, cl.next) THEN
      loc := TextPortClass.Loc.Next
    ELSE
      loc := TextPortClass.Loc.Prev
    END;
    TRY
      te := FormsVBT.GetVBT (fv, cl.textedit);
      text := FormsVBT.GetText (fv, cl.typein);
      LOCK te.tp.mu DO
        TextPortClass.FindAndSelect (te.tp, text, time, loc)
      END;
      IF Text.Equal (name, cl.typein) THEN
        FormsVBT.MakeEvent (fv, cl.close, time)
      END
    EXCEPT
    | FormsVBT.Error (msg) =&gt; Gripe (fv, msg)
    END
  END ShowFindWindow;

TYPE
  PDNF = Thread.Closure OBJECT
           fv: FormsVBT.T
         OVERRIDES
           apply := PopDownNotFound
         END;

PROCEDURE <A NAME="PopDownNotFound"><procedure>PopDownNotFound</procedure></A> (cl: PDNF): REFANY =
  BEGIN
    Thread.Pause (2.0D0);
    LOCK VBT.mu DO
      TRY
        FormsVBT.PopDown (cl.fv, &quot;notfound&quot;)
      EXCEPT
      | FormsVBT.Error (msg) =&gt; Gripe (cl.fv, msg)
      END
    END;
    RETURN NIL
  END PopDownNotFound;

TYPE
  ER = Manpage.ErrorReporter OBJECT
         ed: Editor
       OVERRIDES
         apply := CallGripe
       END;

PROCEDURE <A NAME="CallGripe"><procedure>CallGripe</procedure></A> (er: ER; msg: TEXT) =
  &lt;* LL = VBT.mu *&gt;
  BEGIN
    Gripe (er.ed, msg)
  END CallGripe;

PROCEDURE <A NAME="UpdateKeybindingLabels"><procedure>UpdateKeybindingLabels</procedure></A> (ed: Editor) RAISES {FormsVBT.Error} =
  VAR
    index   := ORD (ed.textport.getModel()) - 1;
    tsplits := ed.modelTsplits;
  BEGIN
    WHILE tsplits # NIL DO
      FormsVBT.PutInteger (ed, RefListUtils.Pop (tsplits), index)
    END
  END UpdateKeybindingLabels;

VAR
  qcl   := NEW (FormsVBT.Closure, apply := DoQuit);
  ccl   := NEW (FormsVBT.Closure, apply := DoClose);
  fbcl  := NEW (FormsVBT.Closure, apply := ChangeSuffixes);
  scl   := NEW (FormsVBT.Closure, apply := SaveAs);
  ppcl  := NEW (FormsVBT.Closure, apply := ChangePPW);

PROCEDURE <A NAME="EditorInit"><procedure>EditorInit</procedure></A> (ed: Editor; frame: T): Editor RAISES {FormsVBT.Error} =
  &lt;* LL = VBT.mu *&gt;
  &lt;* FATAL Rsrc.NotFound *&gt;
  PROCEDURE attach (name: TEXT; proc: KeyProc) RAISES {FormsVBT.Error} =
    BEGIN
      FormsVBT.Attach (
        ed, name, NEW (Attachment, frame := frame, proc := proc))
    END attach;
  BEGIN
    ed.frame := frame;
    LOCK FrameCountLock DO INC (FrameCount); frame.number := FrameCount END;
    EVAL Filter.T.init (frame, NIL);
    TRY
      EVAL ed.initFromRsrc (&quot;formseditvbt.fv&quot;, formseditPath);
      Manpage.Init (ed, HelpFile, NEW (ER, ed := ed), helpcase := NIL,
                    path := formseditPath);
      ed.buffer := FormsVBT.GetVBT (ed, &quot;buffer&quot;);
      ed.stderr := FormsVBT.GetVBT (ed, &quot;stderr&quot;);
      ed.errorPopup := FormsVBT.GetVBT (ed, &quot;errorPopup&quot;);
      ed.textport := ed.buffer.tp;
      ed.vtext := TextPort.GetVText (ed.textport);
      ed.mtext := ed.vtext.mtext;
      ed.rd := NEW (MTextRd.T).init (ed.mtext);
      ed.rangeTable := NEW (IntRefTbl.Default).init ();
      ed.syntax := Sx.CopySyntax (FVRuntime.FVSyntax);
      Sx.SetReadMacro (ed.syntax, '(', NEW (ReadMacro, ed := ed));

      VBT.SetCursor (ed.textport, Cursor.TextPointer);
      FormsVBT.AttachEditOps (
        ed, &quot;buffer&quot;, &quot;cut&quot;, &quot;copy&quot;, &quot;paste&quot;, &quot;clear&quot;, &quot;selectAll&quot;, &quot;undo&quot;,
        &quot;redo&quot;, NIL, &quot;findNext&quot;, &quot;findPrev&quot;);
      FormsVBT.AttachEditOps (
        ed, &quot;manpagetext&quot;, copy := &quot;mpcopy&quot;, selectAll := &quot;mpselectAll&quot;,
        findFirst := &quot;helpfindfirst&quot;, findNext := &quot;helpfindnext&quot;,
        findPrev := &quot;helpfindprev&quot;);
      EVAL NEW (FinderClosure, first := &quot;bhelpfindfirst&quot;,
                next := &quot;bhelpfindnext&quot;, prev := &quot;bhelpfindprev&quot;,
                typein := &quot;bhelpfindtext&quot;, textedit := &quot;buffer&quot;,
                close := &quot;bhelpfindclose&quot;).init (ed);
      EVAL
        NEW (FinderClosure, first := &quot;helpfindfirst&quot;, next := &quot;helpfindnext&quot;,
             prev := &quot;helpfindprev&quot;, typein := &quot;helpfindtext&quot;,
             textedit := &quot;manpagetext&quot;, close := &quot;helpfindclose&quot;).init (ed);
      FormsVBT.Attach (ed, &quot;close&quot;, ccl);
      FormsVBT.Attach (ed, &quot;closeAnyway&quot;, ccl);
      attach (&quot;errorPopup&quot;, Reset);
      attach (&quot;dumpTable&quot;, DumpTheTable);
      FormsVBT.Attach (ed, &quot;fvonly&quot;, fbcl);
      UpdateKeybindingLabels (ed);
      attach (&quot;new&quot;, New);
      FormsVBT.Attach (ed, &quot;notfvonly&quot;, fbcl);
      attach (&quot;open&quot;, DoOpen);   (* the Open button in the dialog *)
      attach (&quot;openfile&quot;, DoOpen); (* typing Return in the helper *)
      attach (&quot;openMButton&quot;, OpenDialog); (* the Open...  menu item *)
      FormsVBT.Attach (ed, &quot;overwrite&quot;, scl); (* the Yes button in the
                                                 overwrite confirmation *)
      attach (&quot;parse&quot;, Parse);
      attach (&quot;PPrint&quot;, PrettyPrint);
      FormsVBT.Attach (ed, &quot;ppwidth&quot;, ppcl);
      FormsVBT.Attach (ed, &quot;ppwidthPopMButton&quot;, ppcl);
      FormsVBT.Attach (ed, &quot;ppwRevert&quot;, ppcl);
      FormsVBT.Attach (ed, &quot;ppwApply&quot;, ppcl);
      FormsVBT.Attach (ed, &quot;ppwOK&quot;, ppcl);
      FormsVBT.Attach (ed, &quot;quit&quot;, qcl);
      FormsVBT.Attach (ed, &quot;quit2&quot;, qcl);
      FormsVBT.Attach (ed, &quot;quitAnyway&quot;, qcl);
      attach (&quot;revert&quot;, Revert);
      attach (&quot;save&quot;, Save);
      FormsVBT.Attach (ed, &quot;saveandclose&quot;, ccl);
      FormsVBT.Attach (ed, &quot;saveandquit&quot;, qcl);
      attach (&quot;saveandswitch&quot;, SaveAndSwitch);
      FormsVBT.Attach (ed, &quot;saveas&quot;, scl); (* the Save button in the dialog *)
      FormsVBT.Attach (ed, &quot;saveasfile&quot;, scl); (* typing Return in the
                                                  helper *)
      attach (&quot;snapshot&quot;, Snapshot);
      attach (&quot;switchAnyway&quot;, SwitchAnyway);
      ed.highlighter :=
        VText.CreateInterval (ed.vtext, 0, 0, HighlightOptions)
    EXCEPT
    | VTDef.Error (code) =&gt; RAISE FormsVBT.Error (VTDef.ErrorCodeTexts [code])
    | Rd.Failure (ref) =&gt; RAISE FormsVBT.Error (RdUtils.FailureText (ref))
    | Thread.Alerted =&gt; RAISE FormsVBT.Error (&quot;Alerted&quot;)
    END;
    RETURN ed
  END EditorInit;

PROCEDURE <A NAME="AttachmentApply"><procedure>AttachmentApply</procedure></A> (             cl  : Attachment;
                           &lt;* UNUSED *&gt; v   : FormsVBT.T;
                           &lt;* UNUSED *&gt; name: TEXT;
                                        time: VBT.TimeStamp) =
  BEGIN
    cl.proc (cl.frame, time)
  END AttachmentApply;

PROCEDURE <A NAME="EPortFilter"><procedure>EPortFilter</procedure></A> (eport: EPort; cd: VBT.KeyRec) =
  &lt;* LL = VBT.mu *&gt;
  VAR
    frame := eport.ed.frame;
    time  := cd.time;
    handled := TRUE;             (* Did we recognize this
                                    key? *)
  BEGIN
    TRY
      IF cd.whatChanged = KeyboardKey.Menu (* &quot;Do&quot; key *)
           OR cd.whatChanged = KeyboardKey.KP_Enter THEN
        Parse (frame, time)
      ELSIF cd.whatChanged = KeyboardKey.Help THEN
        Help (frame, time)
      ELSIF VBT.Modifier.Option IN cd.modifiers
              OR VBT.Modifier.Control IN cd.modifiers
                   AND eport.getModel () = TextPort.Model.Mac THEN
        CASE KeyTrans.Latin1 (cd.whatChanged) OF
        | 'a' =&gt; SelectAll (frame, time)
        | 'f' =&gt;
            IF eport.getModel () # TextPort.Model.Emacs THEN
              FormsVBT.MakeEvent (
                eport.ed, &quot;findMButton&quot;, time)
            ELSE
              handled := FALSE
            END
        | 'h' =&gt; Help (frame, time)
        | 'n' =&gt; New (frame, time)
        | 'o' =&gt; OpenDialog (frame, time)
        | 'p' =&gt; PrettyPrint (frame, time)
        | 'q' =&gt; FormsVBT.MakeEvent (eport.ed, &quot;quit&quot;, time)
        | 's' =&gt; Save (frame, time)
        ELSE
          handled := FALSE
        END
      ELSE
        handled := FALSE
      END;
      IF NOT handled THEN FVTypes.Port.filter (eport, cd) END
    EXCEPT
    | FormsVBT.Error (msg) =&gt; Gripe (frame.ed, msg)
    END
  END EPortFilter;
</PRE>********************** Editing Commands *********************************

<P><PRE>PROCEDURE <A NAME="SelectAll"><procedure>SelectAll</procedure></A> (frame: T; time: VBT.TimeStamp) =
  &lt;* LL = VBT.mu *&gt;
  BEGIN
    TextPort.Select (
      frame.ed.textport, time, 0, LAST (CARDINAL), replaceMode := TRUE)
  END SelectAll;
</PRE>********************** Control Commands *********************************

<P><PRE>PROCEDURE <A NAME="DoQuit"><procedure>DoQuit</procedure></A> (&lt;* UNUSED *&gt; cl  : FormsVBT.Closure;
                               fv  : FormsVBT.T;
                               name: TEXT;
                               time: VBT.TimeStamp     ) =
  &lt;* LL = VBT.mu *&gt;
  VAR
    ed   : Editor := fv;
    frame         := ed.frame;
  BEGIN
    TRY
      IF Text.Equal (name, &quot;quit&quot;) OR Text.Equal (name, &quot;quit2&quot;) THEN
        IF NOT TextPort.IsModified (ed.textport) THEN
          frame.delete ();
          Thread.Alert (frame.root.thread) (* Alert the EdRoot *)
        ELSE
          FormsVBT.PopUp (ed, &quot;quitConfirmation&quot;)
        END
      ELSIF Text.Equal (name, &quot;quitAnyway&quot;) THEN
        frame.delete ();
        Thread.Alert (frame.root.thread)
      ELSIF NOT Text.Equal (name, &quot;saveandquit&quot;) THEN (* skip *)
      ELSIF NOT Text.Empty (frame.fullPathname) THEN
        Save (frame, time);
        frame.delete ();
        Thread.Alert (frame.root.thread)
      ELSE
        FormsVBT.PopUp (ed, &quot;SaveAsDialog&quot;);
        FormsVBT.PopDown (ed, &quot;quitConfirmation&quot;)
      END
    EXCEPT
    | FormsVBT.Error (msg) =&gt; Gripe (ed, msg)
    END;
  END DoQuit;

PROCEDURE <A NAME="DoClose"><procedure>DoClose</procedure></A> (&lt;* UNUSED *&gt; cl  : FormsVBT.Closure;
                                fv  : FormsVBT.T;
                                name: TEXT;
                                time: VBT.TimeStamp     ) =
  &lt;* LL = VBT.mu *&gt;
  VAR
    ed   : Editor := fv;
    frame         := ed.frame;
  BEGIN
    TRY
      IF Text.Equal (name, &quot;close&quot;) THEN
        IF NOT TextPort.IsModified (ed.textport) THEN
          frame.delete ()
        ELSE
          FormsVBT.PopUp (ed, &quot;closeConfirmation&quot;)
        END
      ELSIF Text.Equal (name, &quot;closeAnyway&quot;) THEN
        frame.delete ()
      ELSIF NOT Text.Equal (name, &quot;saveandclose&quot;) THEN (* skip *)
      ELSIF Text.Empty (frame.fullPathname) THEN
        FormsVBT.PopUp (frame.ed, &quot;SaveAsDialog&quot;);
        FormsVBT.PopDown (ed, &quot;closeConfirmation&quot;)
      ELSE
        Save (frame, time);
        frame.delete ()
      END
    EXCEPT
    | FormsVBT.Error (msg) =&gt; Gripe (ed, msg)
    END
  END DoClose;

PROCEDURE <A NAME="DeleteFrame"><procedure>DeleteFrame</procedure></A> (frame: T) =
  &lt;* LL = VBT.mu *&gt;
  VAR root := frame.root;
  BEGIN
    LOCK frame.mu DO
      Trestle.Delete (frame);
      Trestle.Delete (frame.ed);
      LOCK root.mu DO
        RefListUtils.DeleteQ (root.frames, frame);
        IF root.frames = NIL THEN Thread.Signal (root.allClosed) END
      END
    END
  END DeleteFrame;

PROCEDURE <A NAME="New"><procedure>New</procedure></A> (frame: T; &lt;* UNUSED *&gt; time: VBT.TimeStamp) =
  &lt;* LL = VBT.mu *&gt;
  VAR newframe: T;
  BEGIN
    TRY
      newframe := NEW (T, root := frame.root).init ();
      Install (newframe, MoveGeometry (frame));
      newframe.spawn ()
    EXCEPT
    | TrestleComm.Failure, XParam.Error, FormsVBT.Error =&gt;
        Gripe (frame.ed, &quot;Couldn't install new window&quot;)
    END
  END New;

PROCEDURE <A NAME="MoveGeometry"><procedure>MoveGeometry</procedure></A> (frame: T): TEXT =
  &lt;* LL = VBT.mu *&gt;
  CONST
    Displacement = ARRAY Rect.Vertex OF
                     Point.T {Point.T {50, 50}, Point.T {-50, 50},
                              Point.T {50, -50}, Point.T {-50, -50}};
  VAR g := frame.egrec; d := VBT.Domain (frame.ed);
  BEGIN
    g.dp := Point.Add (g.dp, Displacement [g.vertex]);
    g.size := Point.T {Rect.HorSize (d), Rect.VerSize (d)};
    RETURN XParam.UnparseGeometry (g)
  END MoveGeometry;
</PRE>********************** Help Command *********************************

<P><PRE>PROCEDURE <A NAME="Help"><procedure>Help</procedure></A> (frame: T; &lt;* UNUSED *&gt; time: VBT.TimeStamp)
  RAISES {FormsVBT.Error} =
  &lt;* LL = VBT.mu *&gt;
  BEGIN
    FormsVBT.PopUp (frame.ed, &quot;manpage&quot;)
  END Help;

PROCEDURE <A NAME="Revert"><procedure>Revert</procedure></A> (frame: T; &lt;* UNUSED *&gt; time: VBT.TimeStamp) =
  &lt;* LL = VBT.mu *&gt;
  BEGIN
    TRY
      Read (frame);
      FormsVBT.PopDown (frame.ed, &quot;RevertDialog&quot;)
    EXCEPT
    | FormsVBT.Error (msg) =&gt; Gripe (frame.ed, msg)
    | Thread.Alerted =&gt;
    END
  END Revert;
</PRE>***************** Snapshot/Restore Command ****************************

<P><PRE>PROCEDURE <A NAME="Snapshot"><procedure>Snapshot</procedure></A> (frame: T; &lt;* UNUSED *&gt; time: VBT.TimeStamp) =
  &lt;* LL = VBT.mu *&gt;
  &lt;* FATAL Wr.Failure, Thread.Alerted *&gt;(* Can't happen with TextWr *)
  BEGIN
    WITH ed = frame.ed,
         ch = NARROW (Filter.Child (frame), FormsVBT.T),
         wr = TextWr.New ()                              DO
      TRY
        TRY
          FormsVBT.PutText (ed, &quot;SnapshotText&quot;, &quot;&quot;);
          ch.snapshot (wr);
          FormsVBT.PutText (ed, &quot;SnapshotText&quot;, TextWr.ToText (wr));
        EXCEPT
        | FormsVBT.Error (msg) =&gt; Gripe (ed, msg)
        END
      FINALLY
        Wr.Close (wr)
      END;
    END
  END Snapshot;
</PRE>********************** Open Command *********************************

<P><PRE>PROCEDURE <A NAME="OpenDialog"><procedure>OpenDialog</procedure></A> (&lt;* UNUSED *&gt; frame: T;
                      &lt;* UNUSED *&gt; time : VBT.TimeStamp) =
  &lt;* LL = VBT.mu *&gt;
  BEGIN
    (* do nothing; keep the popup just as it was
       the last time it was displayed *)
  END OpenDialog;

PROCEDURE <A NAME="DoOpen"><procedure>DoOpen</procedure></A> (frame: T; &lt;* UNUSED *&gt; time: VBT.TimeStamp) =
  &lt;* LL = VBT.mu *&gt;
  VAR
    ed         := frame.ed;
    file: TEXT;
  BEGIN
    TRY
      file := FormsVBT.GetText (ed, &quot;openfile&quot;);
      IF Text.Empty (file) THEN
        Gripe (ed, &quot;No such file&quot;);
        RETURN
      ELSIF NOT FormsVBT.GetBoolean (ed, &quot;reuse&quot;) THEN
        OpenNewWindow (frame, file)
      ELSIF TextPort.IsModified (ed.textport) THEN
        FormsVBT.PopUp (ed, &quot;switchConfirmation&quot;)
      ELSE
        OpenInCurrentWindow (frame, file)
      END;
      FormsVBT.PopDown (ed, &quot;OpenDialog&quot;)
    EXCEPT
    | FormsVBT.Error (text) =&gt; Gripe (ed, text)
    END
  END DoOpen;

PROCEDURE <A NAME="OpenNewWindow"><procedure>OpenNewWindow</procedure></A> (frame: T; filename: TEXT) =
  BEGIN
    TRY
      WITH newframe = NEW (T, root := frame.root).initFromFile (filename) DO
        Install (newframe, MoveGeometry (frame));
        newframe.spawn ()
      END
    EXCEPT
    | TrestleComm.Failure, XParam.Error =&gt;
        Gripe (frame.ed, &quot;Couldn't install new window&quot;)
    | FormsVBT.Error (text) =&gt; Gripe (frame.ed, text)
    | Thread.Alerted =&gt;
    END
  END OpenNewWindow;

PROCEDURE <A NAME="SwitchAnyway"><procedure>SwitchAnyway</procedure></A> (frame: T; &lt;* UNUSED *&gt; time: VBT.TimeStamp) =
  &lt;* LL = VBT.mu *&gt;
  VAR ed := frame.ed;
  BEGIN
    TRY
      ClearError (ed);
      FormsVBT.PopDown (ed, &quot;switchConfirmation&quot;);
      OpenInCurrentWindow (frame, FormsVBT.GetText (ed, &quot;openfile&quot;))
    EXCEPT
    | FormsVBT.Error (text) =&gt; Gripe (ed, text)
    END
  END SwitchAnyway;

PROCEDURE <A NAME="OpenInCurrentWindow"><procedure>OpenInCurrentWindow</procedure></A> (frame: T; filename: TEXT) =
  &lt;* LL = VBT.mu *&gt;
  BEGIN
    TRY
      frame.fullPathname := filename;
      frame.shortname := Pathname.Last (filename);
      FormsVBT.PutText (frame.ed, &quot;shortname&quot;, frame.shortname);
      Read (frame)
    EXCEPT
    | FormsVBT.Error (text) =&gt; Gripe (frame.ed, text)
    | Thread.Alerted =&gt;
    END
  END OpenInCurrentWindow;

PROCEDURE <A NAME="SaveAndSwitch"><procedure>SaveAndSwitch</procedure></A> (frame: T; time: VBT.TimeStamp) =
  &lt;* LL = VBT.mu *&gt;
  VAR ed := frame.ed;
  BEGIN
    TRY
      ClearError (ed);
      Save (frame, time);
      OpenInCurrentWindow (frame, FormsVBT.GetText (ed, &quot;openfile&quot;));
      FormsVBT.PopDown (ed, &quot;switchConfirmation&quot;)
    EXCEPT
    | FormsVBT.Error (text) =&gt; Gripe (ed, text)
    END
  END SaveAndSwitch;
</PRE>********************** Error-handling *********************************

<P><PRE>TYPE
  Edown = Thread.SizedClosure OBJECT
            ed: Editor
          OVERRIDES
            apply := RemoveErrorWindow
          END;

PROCEDURE <A NAME="EPortError"><procedure>EPortError</procedure></A> (&lt;* UNUSED *&gt; p  : EPort;
                      &lt;* UNUSED *&gt; msg: TEXT   ) =
  &lt;* LL = VBT.mu *&gt;
  BEGIN
    (* most of the errors are about grabbing focus, so we won't
       bother the user -- mhb 9/22/93: Gripe (p.ed, msg) *)
  END EPortError;

PROCEDURE <A NAME="Gripe"><procedure>Gripe</procedure></A> (ed: Editor; fmt: TEXT; a, b, c, d, e: TEXT := NIL) =
  &lt;* LL = VBT.mu *&gt;
  BEGIN
    IF a # NIL THEN fmt := Fmt.F (fmt, a, b, c, d, e) END;
    TextPort.SetText (ed.stderr.tp, fmt);
    ZChildVBT.Pop (ed.errorPopup);
    EVAL Thread.Fork (NEW (Edown, stackSize := 3000, ed := ed))
  END Gripe;

PROCEDURE <A NAME="RemoveErrorWindow"><procedure>RemoveErrorWindow</procedure></A> (cl: Edown): REFANY =
  &lt;* LL = {} *&gt;
  &lt;* FATAL FormsVBT.Error *&gt;(* &quot;errorPopup&quot; exists. *)
  BEGIN
    Thread.Pause (5.0D0);
    LOCK VBT.mu DO FormsVBT.PopDown (cl.ed, &quot;errorPopup&quot;) END;
    RETURN NIL
  END RemoveErrorWindow;

PROCEDURE <A NAME="LockNGripe"><procedure>LockNGripe</procedure></A> (ed: Editor; fmt: TEXT; a, b, c, d, e: TEXT := NIL) =
  &lt;* LL = 0 *&gt;
  BEGIN
    LOCK VBT.mu DO Gripe (ed, fmt, a, b, c, d, e) END
  END LockNGripe;

PROCEDURE <A NAME="ClearError"><procedure>ClearError</procedure></A> (ed: Editor) =
  &lt;* LL = VBT.mu *&gt;
  &lt;* FATAL FormsVBT.Error *&gt;(* &quot;errorPopup&quot; exists. *)
  BEGIN
    FormsVBT.PopDown (ed, &quot;errorPopup&quot;);
    TextPort.SetText (ed.stderr.tp, &quot;&quot;)
  END ClearError;

PROCEDURE <A NAME="NoteModification"><procedure>NoteModification</procedure></A> (eport: EPort) =
  &lt;* LL = VBT.mu *&gt;
  BEGIN
    SetModified (eport.ed, TRUE)
  END NoteModification;

PROCEDURE <A NAME="SetModified"><procedure>SetModified</procedure></A> (ed: Editor; value: BOOLEAN) =
  &lt;* LL = VBT.mu *&gt;
  &lt;* FATAL FormsVBT.Error *&gt;
  BEGIN
    FormsVBT.PutInteger (ed, &quot;modified&quot;, ORD (value))
  END SetModified;

PROCEDURE <A NAME="Reset"><procedure>Reset</procedure></A> (frame: T; &lt;* UNUSED *&gt; time: VBT.TimeStamp := 0) =
  &lt;* LL = VBT.mu *&gt;
  VAR ed := frame.ed;
  BEGIN
    ClearError (ed);
    ed.rangeTable  := NEW (IntRefTbl.Default).init ();
    TRY
      VText.SwitchInterval (ed.highlighter, VText.OnOffState.Off);
      VBT.Mark (ed.textport)
    EXCEPT
    | VTDef.Error (code) =&gt; Gripe (ed, VTDef.ErrorCodeTexts [code])
    END
  END Reset;
</PRE>********************** PPrint Command *********************************

<P><PRE>PROCEDURE <A NAME="ChangePPW"><procedure>ChangePPW</procedure></A> (&lt;* UNUSED *&gt; ppcl: FormsVBT.Closure;
                                  fv  : FormsVBT.T;
                                  name: TEXT;
                                  time: VBT.TimeStamp     ) =
  &lt;* LL = VBT.mu *&gt;
  &lt;* FATAL FormsVBT.Unimplemented *&gt;
  VAR
    ed   : Editor := fv;
    frame         := ed.frame;
  BEGIN
    TRY
      IF Text.Equal (name, &quot;ppwidth&quot;) THEN (* the Numeric *)
        frame.prettyprintWidth := FormsVBT.GetInteger (frame.ed, &quot;ppwidth&quot;);
        TYPECASE FormsVBT.GetTheEvent (frame.ed) OF
        | AnyEvent.Key =&gt;        (* User typed Return *)
            frame.revertWidth := frame.prettyprintWidth;
            FormsVBT.PopDown (frame.ed, &quot;PPwidthNumeric&quot;);
            PrettyPrint (frame, time)
        | AnyEvent.Mouse =&gt;      (* User clicked +/- button *)
        ELSE                     &lt;* ASSERT FALSE *&gt;
        END
      ELSIF Text.Equal (name, &quot;ppwRevert&quot;) THEN
        FormsVBT.PutInteger (fv, &quot;ppwidth&quot;, frame.revertWidth);
        frame.prettyprintWidth := frame.revertWidth;
        PrettyPrint (frame, time)
      ELSIF Text.Equal (name, &quot;ppwApply&quot;) THEN
        frame.prettyprintWidth := FormsVBT.GetInteger (frame.ed, &quot;ppwidth&quot;);
        PrettyPrint (frame, time)
      ELSIF Text.Equal (name, &quot;ppwOK&quot;) THEN
        frame.prettyprintWidth := FormsVBT.GetInteger (frame.ed, &quot;ppwidth&quot;);
        frame.revertWidth := frame.prettyprintWidth;
        FormsVBT.PopDown (frame.ed, &quot;PPwidthNumeric&quot;);
        PrettyPrint (frame, time)
      ELSIF Text.Equal (name, &quot;ppwidthPopMButton&quot;) THEN
        FormsVBT.PutInteger (fv, &quot;ppwidth&quot;, frame.revertWidth);
        frame.prettyprintWidth := frame.revertWidth
      END
    EXCEPT
    | FormsVBT.Error (msg) =&gt; Gripe (frame.ed, msg)
    END
  END ChangePPW;

PROCEDURE <A NAME="PrettyPrint"><procedure>PrettyPrint</procedure></A> (frame: T; &lt;* UNUSED *&gt; time: VBT.TimeStamp) =
  &lt;* LL = VBT.mu *&gt;
  &lt;* FATAL Thread.Alerted *&gt;
  (* This is fast enough that we can do it in event-time. *)
  VAR ed := frame.ed;
  BEGIN
    VBT.SetCursor (frame.ed, Cursor.NotReady);
    TRY
      Reset (frame);
      TRY
        WITH oldtext     = TextPort.GetText (ed.textport),
             oldlength   = Text.Length (oldtext),
             oldposition = TextPort.Index (ed.textport),
             rd          = TextRd.New (oldtext),
             s           = Sx.Read (rd, syntax := FVRuntime.FVSyntax),
             wr          = TextWr.New (),
             fmt         = Formatter.New (wr, frame.prettyprintWidth)          DO
          PPrint (fmt, s);
          Formatter.Close (fmt);
          WITH newtext     = TextWr.ToText (wr),
               newlength   = Text.Length (newtext),
               newposition = (oldposition * newlength) DIV oldlength DO
            TextPort.SetText (ed.textport, newtext);
            TextPort.Normalize (ed.textport, newposition);
          END
        END
      EXCEPT
      | Sx.ReadError (msg) =&gt; Gripe (ed, &quot;S-expression error: %s&quot;, msg)
      | Sx.PrintError (ref) =&gt; Gripe (ed, SxPrintErrorText (ref))
      | Rd.EndOfFile =&gt; Gripe (ed, &quot;Premature end of file&quot;)
      | Wr.Failure (ref) =&gt; Gripe (ed, RdUtils.FailureText (ref))
      END
    FINALLY
      VBT.SetCursor (frame.ed, Cursor.TextPointer)
    END
  END PrettyPrint;

PROCEDURE <A NAME="PPrint"><procedure>PPrint</procedure></A> (fmt: Formatter.T; s: Sx.T) RAISES {Wr.Failure, Sx.PrintError} =
  VAR
    wr              := TextWr.New ();
    car, cadr: Sx.T;
  PROCEDURE default (x: RefList.T) RAISES {Wr.Failure, Sx.PrintError} =
    BEGIN
      Formatter.Begin (fmt, 2);
      Formatter.PutChar (fmt, '(');
      LOOP
        pprint (x.head);
        x := x.tail;
        IF x = NIL THEN EXIT END;
        Formatter.PutChar (fmt, ' ');
        Formatter.UnitedBreak (fmt, 0)
      END;
      Formatter.PutChar (fmt, ')');
      Formatter.End (fmt)
    END default;
  PROCEDURE pprint (s: Sx.T) RAISES {Wr.Failure, Sx.PrintError} =
    BEGIN
      TYPECASE s OF
      | NULL =&gt; Formatter.PutText (fmt, &quot;()&quot;, TRUE)
      | RefList.T (x) =&gt;
          IF RefList.Length (x) # 2 THEN
            default (x)
          ELSE
            car := x.head;
            cadr := x.tail.head;
            IF car = FVRuntime.qName THEN
              Formatter.PutChar (fmt, '%');
              pprint (cadr);
            ELSIF car = FVRuntime.qValue THEN
              Formatter.PutChar (fmt, '=');
              pprint (cadr)
            ELSIF car = FVRuntime.qQuote THEN
              Formatter.PutChar (fmt, '\'');
              pprint (cadr)
            ELSIF car = FVRuntime.qBackquote THEN
              Formatter.PutChar (fmt, '`');
              pprint (cadr)
            ELSIF car = FVRuntime.qComma THEN
              Formatter.PutChar (fmt, ',');
              pprint (cadr)
            ELSIF car = FVRuntime.qCommaAtsign THEN
              Formatter.PutText (fmt, &quot;,@&quot;, TRUE);
              pprint (cadr)
            ELSE
              default (x)
            END
          END
      ELSE
        TRY Sx.Print (wr, s) EXCEPT Thread.Alerted =&gt; &lt;* ASSERT FALSE *&gt; END;
        Formatter.PutText (fmt, TextWr.ToText (wr))
      END
    END pprint;
  BEGIN
    pprint (s)
  END PPrint;

PROCEDURE <A NAME="SxPrintErrorText"><procedure>SxPrintErrorText</procedure></A> (ref: REFANY): TEXT =
  BEGIN
    TYPECASE ref OF
    | TEXT (msg) =&gt; RETURN &quot;S-expression print error: &quot; &amp; msg
    ELSE
      RETURN &quot;Unknown Sx.PrintError&quot;
    END
  END SxPrintErrorText;
</PRE>****************** Parse (<CODE>Do It</CODE>) Command *****************************

<P><PRE>PROCEDURE <A NAME="Parse"><procedure>Parse</procedure></A> (frame: T; &lt;* UNUSED *&gt; time: VBT.TimeStamp := 0) =
  &lt;* LL = VBT.mu *&gt;
  &lt;* FATAL FormsVBT.Error *&gt;
  BEGIN
    Reset (frame);
    FormsVBT.MakePassive (frame.ed, &quot;top&quot;);
    EVAL Thread.Fork (NEW (ParseClosure, stackSize := STACKSIZE,
                           frame := frame))
  END Parse;

PROCEDURE <A NAME="ParseClosureApply"><procedure>ParseClosureApply</procedure></A> (cl: ParseClosure): REFANY =
  &lt;* LL = 0 *&gt;
  VAR
    frame         := cl.frame;
    ed            := frame.ed;
    new           := NEW (FormsVBT.T);
    old  : VBT.T;
    form : REFANY;
  BEGIN
    TRY                          (* EXCEPT *)
      TRY                        (* FINALLY *)
        form := Sx.Read (ed.rd.init (), syntax := ed.syntax);
        (* Now check for extra characters: *)
        TRY
          EVAL Sx.Read (ed.rd, syntax := ed.syntax);
          RAISE Sx.ReadError (&quot;Extra characters on input&quot;)
        EXCEPT
        | Rd.EndOfFile =&gt;
        END;
        (* As it reads, start/end intervals will be added to the table. *)
        LOCK VBT.mu DO
          EVAL new.initFromSx (form, path := frame.path);
          StableVBT.Disable (frame);
          old := Filter.Replace (frame, new);
          IF old # NIL THEN
            FVRuntime.SetAttachments (new, FVRuntime.GetAttachments (old));
            VBT.Discard (old)
          END;
          ClearError (ed)
        END
      FINALLY
        LOCK VBT.mu DO FormsVBT.MakeActive (ed, &quot;top&quot;) END;
      END
    EXCEPT
    | FormsVBT.Error (msg) =&gt;
        LOCK VBT.mu DO Gripe (ed, msg); HighlightError (new, frame) END
    | Sx.ReadError (msg) =&gt; LOCK VBT.mu DO Gripe (ed, msg) END
    | Rd.EndOfFile =&gt; LockNGripe (ed, &quot;Premature end of file &quot;)
    | Rd.Failure (ref) =&gt; LockNGripe (ed, RdUtils.FailureText (ref))
    | Thread.Alerted =&gt;
    END;
    RETURN NIL
  END ParseClosureApply;

PROCEDURE <A NAME="ReadList"><procedure>ReadList</procedure></A> (rm: ReadMacro; rd: Rd.T; s: Sx.Syntax): RefList.T
  RAISES {Sx.ReadError, Thread.Alerted} =
  (* Record the starting and ending positions of every list we read, so that
     we can highlight the list if there's an error. *)
  VAR
    start := Rd.Index (rd) - 1;
    form  := Sx.ReadDelimitedList (rd, ')', s);
    end   := Rd.Index (rd);
  BEGIN
    EVAL rm.ed.rangeTable.put (
           start, NEW (Range, start := start, end := end, form := form));
    RETURN RefList.List1 (form)
  END ReadList;

TYPE Range = REF RECORD start, end: INTEGER; form: Sx.T END;

PROCEDURE <A NAME="FindRange"><procedure>FindRange</procedure></A> (t: IntRefTbl.T; form: Sx.T): Range =
  VAR
    iter           := t.iterate ();
    start: INTEGER;
    ref  : REFANY;
    r    : Range;
  BEGIN
    WHILE iter.next (start, ref) DO
      r := ref;
      IF r.form = form THEN RETURN r END
    END;
    RETURN NIL
  END FindRange;

PROCEDURE <A NAME="HighlightError"><procedure>HighlightError</procedure></A> (new: FormsVBT.T; frame: T) =
  &lt;* LL = VBT.mu *&gt;
  VAR
    ed           := frame.ed;
    stack        := new.formstack;
    r    : Range;
  BEGIN
    WHILE stack # NIL DO
      r := FindRange (ed.rangeTable, RefListUtils.Pop (stack));
      IF r # NIL THEN
        TRY
          TextPort.Normalize (ed.textport, r.start);
          VText.MoveInterval (ed.highlighter, r.start, r.end);
          VText.SwitchInterval (ed.highlighter, VText.OnOffState.On);
          VBT.Mark (ed.textport)
        EXCEPT
        | VTDef.Error =&gt;         (* ignore *)
        END;
        RETURN
      END                        (* IF *)
    END                          (* WHILE *)
  END HighlightError;
</PRE>****************** Save and SaveAs Commands *****************************

<P><PRE>PROCEDURE <A NAME="Save"><procedure>Save</procedure></A> (frame: T; &lt;* UNUSED *&gt; time: VBT.TimeStamp) =
  &lt;* LL = VBT.mu *&gt;
  VAR
    ed             := frame.ed;
    filename       := frame.fullPathname;
    wr      : Wr.T;
  BEGIN
    ClearError (ed);
    TRY
      IF Text.Empty (filename) THEN
        FormsVBT.PopUp (ed, &quot;SaveAsDialog&quot;);
        RETURN
      END;
      wr := FileWr.Open (filename);
      TRY
        Wr.PutText (wr, TextPort.GetText (ed.textport))
      FINALLY
        Wr.Close (wr)
      END;
      TextPort.SetModified (ed.textport, FALSE);
      SetModified (ed, FALSE)
    EXCEPT
    | OSError.E (list) =&gt; Gripe (ed, RdUtils.FailureText (list))
    | FormsVBT.Error (msg) =&gt; Gripe (ed, msg)
    | Wr.Failure (refany) =&gt;
        Gripe (
          ed, &quot;Couldn't write %s: %s&quot;, filename, RdUtils.FailureText (refany))
    | Thread.Alerted =&gt;
    END
  END Save;

PROCEDURE <A NAME="SaveAs"><procedure>SaveAs</procedure></A> (&lt;* UNUSED *&gt; cl  : FormsVBT.Closure;
                               fv  : FormsVBT.T;
                               name: TEXT;
                  &lt;* UNUSED *&gt; time: VBT.TimeStamp     ) =
  &lt;* LL = VBT.mu *&gt;
  VAR
    ed      : Editor := fv;
    frame            := ed.frame;
    filename: TEXT;
    wr      : Wr.T;
  BEGIN
    ClearError (ed);
    TRY
      filename := FormsVBT.GetText (ed, &quot;saveasfile&quot;);
      IF Text.Empty (filename) THEN Gripe (ed, &quot;No filename.&quot;); RETURN END;
      IF Text.Equal (name, &quot;overwrite&quot;) THEN (* Don't ask *)
        FormsVBT.PopDown (ed, &quot;overwriteConfirmation&quot;)
      ELSIF ProbeFile (filename) THEN
        FormsVBT.PopUp (ed, &quot;overwriteConfirmation&quot;);
        FormsVBT.PopDown (ed, &quot;SaveAsDialog&quot;);
        RETURN
      END;
      wr := FileWr.Open (filename);
      TRY
        Wr.PutText (wr, TextPort.GetText (ed.buffer.tp));
      FINALLY
        Wr.Close (wr)
      END;
      frame.fullPathname := FS.GetAbsolutePathname (filename);
      frame.shortname := Pathname.Prefix (filename);
      FormsVBT.PutText (ed, &quot;shortname&quot;, frame.shortname);
      TextPort.SetModified (ed.textport, FALSE);
      SetModified (ed, FALSE);
      FormsVBT.PopDown (ed, &quot;SaveAsDialog&quot;);
      frame.decorate ();
      ed.decorate ()
    EXCEPT
    | OSError.E (list) =&gt; Gripe (ed, RdUtils.FailureText (list))
    | FormsVBT.Error (msg) =&gt; Gripe (ed, msg)
    | Wr.Failure (refany) =&gt;
        Gripe (
          ed, &quot;Couldn't write %s: %s&quot;, filename, RdUtils.FailureText (refany))
    | Thread.Alerted =&gt;
    | TrestleComm.Failure =&gt; Gripe (ed, &quot;Couldn't change window labels&quot;)
    END
  END SaveAs;

PROCEDURE <A NAME="ProbeFile"><procedure>ProbeFile</procedure></A> (pn: Pathname.T): BOOLEAN =
  BEGIN
    TRY
      Rd.Close (FileRd.Open (pn));
      RETURN TRUE
    EXCEPT
    | OSError.E, Rd.Failure, Thread.Alerted =&gt; RETURN FALSE
    END
  END ProbeFile;

PROCEDURE <A NAME="DumpTheTable"><procedure>DumpTheTable</procedure></A> (frame: T; &lt;* UNUSED *&gt; time: VBT.TimeStamp) =
  &lt;* LL = VBT.mu *&gt;
  &lt;* FATAL Wr.Failure, Thread.Alerted *&gt;(* all in-memory *)
  BEGIN
    VAR
      ed          := frame.ed;
      ch          := Filter.Child (frame);
      alist       := FVRuntime.NamedVBTs (ch);
      alist2      := alist;
      attachments := FVRuntime.GetAttachments (ch);
      maxlen      := 0;
    VAR
      value: REFANY;
      key  : TEXT;
      pair : RefList.T;
      vbt  : VBT.T;
      sr   : VBT.SizeRange;
      size : CARDINAL;
    BEGIN
      WHILE alist2 # NIL DO
        pair := RefListUtils.Pop (alist2);
        maxlen := MAX (maxlen, Text.Length (pair.head))
      END;
      WITH wr = TextWr.New () DO
        TRY
          Wr.PutText (
            wr,
            Fmt.Pad (&quot;name&quot;, maxlen)
              &amp; &quot; : type  H: [lo, pref, hi] = size. V: [lo, pref, hi] = size.\n\n&quot;);
          WHILE alist # NIL DO
            pair := RefListUtils.Pop (alist);
            key := RefListUtils.Pop (pair);
            value := pair.head;
            Wr.PutText (wr, Fmt.F (&quot;%s : %s&quot;, Fmt.Pad (key, maxlen),
                                   RTTypeSRC.TypeName (value)));
            IF RefListUtils.Assoc (attachments, key) # NIL THEN
              Wr.PutChar (wr, '*')
            END;
            vbt := value;
            WITH a = VBTClass.GetShapes (vbt, clearNewShape := FALSE),
                 d = VBT.Domain (vbt)                                  DO
              FOR ax := FIRST (Axis.T) TO LAST (Axis.T) DO
                sr := a [ax];
                IF ax = Axis.T.Hor THEN
                  size := Rect.HorSize (d)
                ELSE
                  size := Rect.VerSize (d)
                END;
                Wr.PutText (wr, Fmt.F (&quot; %s: [%s, %s, %s] = %s.&quot;,
                                       ARRAY Axis.T OF TEXT {&quot;H&quot;, &quot;V&quot;} [ax],
                                       Fmt.Int (sr.lo), Fmt.Int (sr.pref),
                                       Fmt.Int (sr.hi), Fmt.Int (size)))
              END
            END;
            Wr.PutChar (wr, '\n')
          END;
          TRY
            FormsVBT.PutText (ed, &quot;VBTtable&quot;, TextWr.ToText (wr))
          EXCEPT
          | FormsVBT.Error (msg) =&gt; Gripe (ed, msg)
          END
        FINALLY
          Wr.Close (wr)
        END
      END
    END
  END DumpTheTable;

PROCEDURE <A NAME="MoverApply"><procedure>MoverApply</procedure></A> (             m         : Mover;
                                   ed        : FormsVBT.T;
                      &lt;* UNUSED *&gt; buttonName: TEXT;
                      &lt;* UNUSED *&gt; time      : VBT.TimeStamp) =
  &lt;* LL = VBT.mu *&gt;
  BEGIN
    TRY
      WITH nw  = Rect.NorthWest (VBT.Domain (m.vbt)),
           rec = Trestle.ScreenOf (m.vbt, nw)         DO
        Trestle.Overlap (m.vbt, m.id, rec.q)
      END
    EXCEPT
    | TrestleComm.Failure =&gt; Gripe (ed, &quot;Can't move. Trestle.Overlap failed.&quot;)
    END
  END MoverApply;

VAR doDebug := FALSE;

PROCEDURE <A NAME="Debug"><procedure>Debug</procedure></A> (t: TEXT) =
  BEGIN
    IF doDebug THEN IO.Put (t) END
  END Debug;

BEGIN
  HighlightOptions :=
    VText.MakeIntervalOptions (
      VText.IntervalStyle.BoxStyle, PaintOp.bgFg, PaintOp.bgFg, PaintOp.Bg)
END FormsEditVBT.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
