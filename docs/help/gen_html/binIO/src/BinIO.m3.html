<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: binIO/src/BinIO.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>binIO/src/BinIO.m3</H2></A><HR>
<inModule>
<PRE>MODULE <module><implements><A HREF="BinIO.i3.html">BinIO</A></implements></module> ;

IMPORT <A HREF="../../libm3/src/rw/Rd.i3.html">Rd</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="FastBinIO.i3.html">FastBinIO</A>, <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../libm3/src/rw/UnsafeRd.i3.html">UnsafeRd</A>, <A HREF="../../libm3/src/rw/UnsafeWr.i3.html">UnsafeWr</A> ;
</PRE><BLOCKQUOTE><EM> UnsafeRd and UnsafeWr are simply to know that Readers and Writers
   can be locked
</EM></BLOCKQUOTE><PRE>

&lt;* FATAL Rd.Failure, Wr.Failure, Thread.Alerted, Rd.EndOfFile *&gt;

PROCEDURE <A NAME="PutInt32"><procedure>PutInt32</procedure></A>(i: Int32; wr: Wr.T; endian: Endian := Endian.Native) =
  BEGIN
    LOCK wr DO
      FastBinIO.PutInt32(i, wr, endian) ;
    END ;
    Wr.Flush(wr) ;
  END PutInt32;

PROCEDURE <A NAME="PutUInt32"><procedure>PutUInt32</procedure></A>(i: UInt32; wr: Wr.T; endian: Endian := Endian.Native) =
  BEGIN
    LOCK wr DO
      FastBinIO.PutUInt32(i, wr, endian) ;
    END ;
    Wr.Flush(wr) ;
  END PutUInt32;

PROCEDURE <A NAME="PutInt16"><procedure>PutInt16</procedure></A>(i: Int16; wr: Wr.T; endian: Endian := Endian.Native) =
  BEGIN
    LOCK wr DO
      FastBinIO.PutInt16(i, wr, endian) ;
    END ;
    Wr.Flush(wr) ;
  END PutInt16;

PROCEDURE <A NAME="PutUInt16"><procedure>PutUInt16</procedure></A>(i: UInt16; wr: Wr.T; endian: Endian := Endian.Native) =
  BEGIN
    LOCK wr DO
      FastBinIO.PutUInt16(i, wr, endian) ;
    END ;
    Wr.Flush(wr) ;
  END PutUInt16;

PROCEDURE <A NAME="PutByte"><procedure>PutByte</procedure></A>(i: Byte; wr: Wr.T; endian: Endian := Endian.Native) =
  BEGIN
    LOCK wr DO
      FastBinIO.PutByte(i, wr, endian) ;
    END ;
    Wr.Flush(wr) ;
  END PutByte;

PROCEDURE <A NAME="PutUByte"><procedure>PutUByte</procedure></A>(i: UByte; wr: Wr.T; endian: Endian := Endian.Native) =
  BEGIN
    LOCK wr DO
      FastBinIO.PutUByte(i, wr, endian) ;
    END ;
    Wr.Flush(wr) ;
  END PutUByte;

PROCEDURE <A NAME="GetInt32"><procedure>GetInt32</procedure></A>(rd: Rd.T; endian: Endian := Endian.Native) : Int32 =
  BEGIN
    LOCK rd DO
      RETURN FastBinIO.GetInt32(rd, endian) ;
    END ;
  END GetInt32;

PROCEDURE <A NAME="GetUInt32"><procedure>GetUInt32</procedure></A>(rd: Rd.T; endian: Endian := Endian.Native) : UInt32 =
  BEGIN
    LOCK rd DO
      RETURN FastBinIO.GetUInt32(rd, endian) ;
    END ;
  END GetUInt32;

PROCEDURE <A NAME="GetInt16"><procedure>GetInt16</procedure></A>(rd: Rd.T; endian: Endian := Endian.Native) : Int16 =
  BEGIN
    LOCK rd DO
      RETURN FastBinIO.GetInt16(rd, endian) ;
    END ;
  END GetInt16;

PROCEDURE <A NAME="GetUInt16"><procedure>GetUInt16</procedure></A>(rd: Rd.T; endian: Endian := Endian.Native) : UInt16 =
  BEGIN
    LOCK rd DO
      RETURN FastBinIO.GetUInt16(rd, endian) ;
    END ;
  END GetUInt16;

PROCEDURE <A NAME="GetByte"><procedure>GetByte</procedure></A>(rd: Rd.T; endian: Endian := Endian.Native) : Byte =
  BEGIN
    LOCK rd DO
      RETURN FastBinIO.GetByte(rd, endian) ;
    END ;
  END GetByte;

PROCEDURE <A NAME="GetUByte"><procedure>GetUByte</procedure></A>(rd: Rd.T; endian: Endian := Endian.Native) : UByte =
  BEGIN
    LOCK rd DO
      RETURN FastBinIO.GetUByte(rd, endian) ;
    END ;
  END GetUByte;

BEGIN
END BinIO.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
