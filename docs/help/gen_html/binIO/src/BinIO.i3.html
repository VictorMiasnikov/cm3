<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: binIO/src/BinIO.i3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>binIO/src/BinIO.i3</H2></A><HR>
<inInterface>
<PRE>INTERFACE <interface><A HREF="BinIO.m3.html">BinIO</A></interface> ;

IMPORT <A HREF="../../libm3/src/rw/Rd.i3.html">Rd</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="FastBinIO.i3.html">FastBinIO</A> ;
</PRE><P>
  This interface is almost equivalent to FastBinIO, but no exceptions
  are thrown, the locking and unlocking of readers and writers
  (Rd.T and Wr.T) is automatic, and writer buffers are flushed after
  every operation.
<P>
  For many cases this is sufficient, but the FastBinIO interface
  exists for those instances where speed is of the utmost importance,
  or the handling of Rd, Wr, and/or Thread exceptions are necessary.


<P>
  These types are actually defined in FastBinIO, but have been included
  here in their full form to make it easier to understand the lower
  level details.
<P>
  Int32  = BITS 32 FOR [-16_7FFFFFFF-1 .. 16_7FFFFFFF] ;
  UInt32 = Word.T ;    [0              .. 16_FFFFFFFF] ;
  Int16  = BITS 16 FOR [-16_7FFF-1     .. 16_7FFF] ;
  UInt16 = BITS 16 FOR [0              .. 16_FFFF] ;
  Byte   = BITS 8  FOR [-16_7F         .. 16_7F] ;
  UByte  = BITS 8  FOR [0              .. 16_FF] ;
<P>
  Endian = {Native, Big, Little} ;
<P>
  Native =&gt; Read/Write data using native Endianess
  Big    =&gt; Read/Write data converting from/to Big    Endian if necessary
  Little =&gt; Read/Write data converting from/to Little Endian if necessary


<P><PRE>TYPE
  Int32  = FastBinIO.Int32 ;
  UInt32 = FastBinIO.UInt32 ;
  Int16  = FastBinIO.Int16 ;
  UInt16 = FastBinIO.UInt16 ;
  Byte   = FastBinIO.Byte ;
  UByte  = FastBinIO.UByte ;

  Endian = FastBinIO.Endian ;

PROCEDURE <A HREF="BinIO.m3.html#PutInt32">PutInt32</A>(i: Int32; wr: Wr.T; endian: Endian := Endian.Native) ;

PROCEDURE <A HREF="BinIO.m3.html#PutUInt32">PutUInt32</A>(i: UInt32; wr: Wr.T; endian: Endian := Endian.Native) ;

PROCEDURE <A HREF="BinIO.m3.html#PutInt16">PutInt16</A>(i: Int16; wr: Wr.T; endian: Endian := Endian.Native) ;

PROCEDURE <A HREF="BinIO.m3.html#PutUInt16">PutUInt16</A>(i: UInt16; wr: Wr.T; endian: Endian := Endian.Native) ;

PROCEDURE <A HREF="BinIO.m3.html#PutByte">PutByte</A>(i: Byte; wr: Wr.T; endian: Endian := Endian.Native) ;

PROCEDURE <A HREF="BinIO.m3.html#PutUByte">PutUByte</A>(i: UByte; wr: Wr.T; endian: Endian := Endian.Native) ;

PROCEDURE <A HREF="BinIO.m3.html#GetInt32">GetInt32</A>(rd: Rd.T; endian: Endian := Endian.Native) : Int32 ;

PROCEDURE <A HREF="BinIO.m3.html#GetUInt32">GetUInt32</A>(rd: Rd.T; endian: Endian := Endian.Native) : UInt32 ;

PROCEDURE <A HREF="BinIO.m3.html#GetInt16">GetInt16</A>(rd: Rd.T; endian: Endian := Endian.Native) : Int16 ;

PROCEDURE <A HREF="BinIO.m3.html#GetUInt16">GetUInt16</A>(rd: Rd.T; endian: Endian := Endian.Native) : UInt16 ;

PROCEDURE <A HREF="BinIO.m3.html#GetByte">GetByte</A>(rd: Rd.T; endian: Endian := Endian.Native) : Byte ;

PROCEDURE <A HREF="BinIO.m3.html#GetUByte">GetUByte</A>(rd: Rd.T; endian: Endian := Endian.Native) : UByte ;

END BinIO.
</PRE>
</inInterface>
<PRE>























</PRE>
</BODY>
</HTML>
