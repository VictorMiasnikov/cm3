<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: cube/src/R4.i3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>cube/src/R4.i3</H2></A><HR>
<inInterface>
<PRE></PRE> Copyright (C) 1992, Digital Equipment Corporation                         
 All rights reserved.                                                      
 See the file COPYRIGHT for a full description.                            
                                                                           
 Created on Sep 15 1988 by Jorge Stolfi                      
 Last modified on Wed Dec 22 17:07:37 PST 1993 by mhb        
      modified on Tue Jun 16 18:29:59 PDT 1992 by muller     
      modified on Fri Jan 12  9:36:04 PST 1990 by stolfi     

<P><PRE>INTERFACE <interface><A HREF="R4.m3.html">R4</A></interface>;
</PRE> Real quadruples.
<P>
   This interface implements the 4-dimensional vector space R^4. 
   It defines the basic linear operations on real quadruples (arrays 
   with 4 REAL components).  See R4x4.i3 and R4IO.i3 for 
   additional operations.  
   <P>
   Index: vectors; reals, vectors of; 
   points; geometry; linear algebra; numerical routines
   <P>


<P>******************************************************************
                                                                  
 WARNING: DO NOT EDIT THIS FILE.  IT WAS GENERATED MECHANICALLY.  
 See the  Makefile for more details.                              
                                                                  
******************************************************************

<P><PRE>TYPE
  INT = INTEGER;
  NAT = CARDINAL;
  BOOL = BOOLEAN;

TYPE
  Axis = [0..3];           (* Coordinate selectors *)
  Point = ARRAY Axis OF REAL;  (* A point of R4 *)
  T = Point;

VAR (* CONST *)
  Origin: T; (* The point (0 0 0 0) *)
  Ones: T;   (* The point (1 1 1 1) *)

PROCEDURE <A HREF="R4.m3.html#FromCoords">FromCoords</A>(x0, x1, x2, x3: REAL): T;
  (* The quadruple with given coordinates. *)

PROCEDURE <A HREF="R4.m3.html#Unit">Unit</A>(i: Axis): T;
  (* The unit vector on the i-th axis. *)

PROCEDURE <A HREF="R4.m3.html#Equal">Equal</A>(READONLY x, y: T): BOOL;
  (* Equality *)

PROCEDURE <A HREF="R4.m3.html#IsZero">IsZero</A>(READONLY x: T): BOOL;
  (* TRUE if x = (0 0 0 0) *)

PROCEDURE <A HREF="R4.m3.html#Sum">Sum</A> (READONLY x: T): REAL;
  (* Sum of the coordinates x[i]. *)

PROCEDURE <A HREF="R4.m3.html#Max">Max</A>(READONLY x: T): REAL;
  (* Maximum of the x[i]. *)

PROCEDURE <A HREF="R4.m3.html#Min">Min</A>(READONLY x: T): REAL;
  (* Minimum of the x[i]. *)

PROCEDURE <A HREF="R4.m3.html#SumSq">SumSq</A>(READONLY x: T): REAL;
  (* Sum of x[i]**2. *)

PROCEDURE <A HREF="R4.m3.html#L1Norm">L1Norm</A>(READONLY x: T): REAL;
  (* Sum of ABS(x[i]). *)

PROCEDURE <A HREF="R4.m3.html#Length">Length</A>(READONLY x: T): REAL;
PROCEDURE <A HREF="R4.m3.html#L2Norm">L2Norm</A>(READONLY x: T): REAL;
  (* Euclidean length (sqrt of sum of x[i]**2). *)

PROCEDURE <A HREF="R4.m3.html#LInfNorm">LInfNorm</A>(READONLY x: T): REAL;
  (* Maximum of ABS(READONLY x[i]). *)

PROCEDURE <A HREF="R4.m3.html#L1Dist">L1Dist</A>(READONLY x, y: T): REAL;
  (* L1Norm(Sub(x,y)). *)

PROCEDURE <A HREF="R4.m3.html#Dist">Dist</A>(READONLY x, y: T): REAL;
PROCEDURE <A HREF="R4.m3.html#L2Dist">L2Dist</A>(READONLY x, y: T): REAL;
  (* L2Norm(Sub(x,y)). *)

PROCEDURE <A HREF="R4.m3.html#L2DistSq">L2DistSq</A>(READONLY x, y: T): REAL;
  (* SumSq(Sub(x,y)). *)

PROCEDURE <A HREF="R4.m3.html#LInfDist">LInfDist</A>(READONLY x, y: T): REAL;
  (* LInfNorm(Sub(x,y)). *)

PROCEDURE <A HREF="R4.m3.html#RelDist">RelDist</A>(READONLY x, y: T; eps: REAL := 1.0e-37): REAL;
  (* Relative distance between two points, useful in convergence tests.
  The /eps/ parameter specifies the magnitude of the (additive) noise
  in each coordinate.
  The value of RelDist is defined as   max_i rdist(x[i], y[i])  where
|
|    rdist(u,v) =  max(|u-v|-eps, 0) / max(|u|, |v|, eps)
|
  The result is between 0.0 and 2.0. A result below 2.0e-7 means the vectors
  differ only at the roundoff error level. *)

PROCEDURE <A HREF="R4.m3.html#Dot">Dot</A> (READONLY x, y: T): REAL;
  (* Dot product of vectors x and y. *)

PROCEDURE <A HREF="R4.m3.html#Cos">Cos</A> (READONLY x, y: T): REAL;
  (* Co-sine of the angle between x and y. *)

PROCEDURE <A HREF="R4.m3.html#Det">Det</A>(READONLY p0, p1, p2, p3: T): REAL;
  (* Determinant of the matrix with given points as rows *)

PROCEDURE <A HREF="R4.m3.html#Add">Add</A>(READONLY x, y: T): T;
  (* Vector sum x + y. *)

PROCEDURE <A HREF="R4.m3.html#Sub">Sub</A>(READONLY x, y: T): T;
  (* Vector difference x - y. *)

PROCEDURE <A HREF="R4.m3.html#Minus">Minus</A>(READONLY x: T): T;
  (* Negation of all coordinates. *)

PROCEDURE <A HREF="R4.m3.html#Scale">Scale</A>(alpha: REAL; READONLY x: T): T;
  (* Scalar multiplication alpha * x.  *)

PROCEDURE <A HREF="R4.m3.html#Shift">Shift</A>(READONLY x: T; delta: REAL): T;
  (* Adds delta to every coordinate of x. *)

PROCEDURE <A HREF="R4.m3.html#Mix">Mix</A> (READONLY x: T; alpha: REAL; READONLY y: T; beta: REAL): T;
  (* Linear combination x * alpha + y * beta. *)

PROCEDURE <A HREF="R4.m3.html#Weigh">Weigh</A> (READONLY x, y: T): T;
  (* Returns z such that z[i] = x[i] * y[i]. *)

TYPE Function = PROCEDURE (x: REAL): REAL;

PROCEDURE <A HREF="R4.m3.html#FMap">FMap</A> (READONLY x: T; F: Function): T;
  (* Returns z such that z[i] = F(x[i]). *)

PROCEDURE <A HREF="R4.m3.html#Direction">Direction</A>(READONLY x: T): T;
  (* Divides x by Length(x). An error if x = (0 0 0 0). *)

PROCEDURE <A HREF="R4.m3.html#Cross">Cross</A>(READONLY p1, p2, p3: T): T;
  (* Cross product: Det(p, q, r, ...) = Dot(p, Cross(q, r, ...))  *)

END R4.
</PRE>
</inInterface>
<PRE>























</PRE>
</BODY>
</HTML>
