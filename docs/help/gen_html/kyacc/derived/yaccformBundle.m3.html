<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: kyacc/derived/yaccformBundle.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>kyacc/derived/yaccformBundle.m3</H2></A><HR>
<inModule>
<PRE>MODULE <module><implements><A HREF="yaccformBundle.i3.html">yaccformBundle</A></implements></module>;
</PRE><BLOCKQUOTE><EM> Generated by m3bundle; see its manpage. </EM></BLOCKQUOTE><PRE>

IMPORT <A HREF="../../libm3/src/bundleintf/Bundle.i3.html">Bundle</A>, <A HREF="../../libm3/src/bundleintf/BundleRep.i3.html">BundleRep</A>, <A HREF="../../m3core/src/text/Text.i3.html">Text</A>;
IMPORT <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="../../libm3/src/rw/TextWr.i3.html">TextWr</A>;

TYPE T = Bundle.T OBJECT OVERRIDES
           get      := LookUp;
           getNames := GetNames;
         END;

TYPE Texts = REF ARRAY OF TEXT;

VAR
  bundle: T     := NIL;
  names : Texts := NIL;

PROCEDURE <A NAME="Get"><procedure>Get</procedure></A>(): Bundle.T =
  BEGIN
    IF (bundle = NIL) THEN bundle := NEW (T) END;
    RETURN bundle;
  END Get;

PROCEDURE <A NAME="GetNames"><procedure>GetNames</procedure></A> (&lt;*UNUSED*&gt; self: T): Texts =
  BEGIN
    IF names = NIL THEN
      names := NEW (Texts, NUMBER (Names));
      names^ := Names;
    END;
    RETURN names;
  END GetNames;

PROCEDURE <A NAME="LookUp"><procedure>LookUp</procedure></A> (&lt;*UNUSED*&gt; self: T;  element: TEXT): TEXT =
  BEGIN
    FOR i := 0 TO LAST (Names)-1 DO
      IF Text.Equal (Names[i], element) THEN
        IF Elements[i] = NIL THEN Elements[i] := GetElt (i) END;
        RETURN Elements[i];
      END;
    END;
    RETURN NIL;
  END LookUp;

CONST Names = ARRAY [0..8] OF TEXT {
  &quot;yaccform.i3&quot;,
  &quot;yaccform.type.m3&quot;,
  &quot;yaccform.proc.m3&quot;,
  &quot;yaccform.typecase.m3&quot;,
  &quot;yaccform.rule.m3&quot;,
  &quot;yaccform.m3&quot;,
  &quot;yaccform.orig.m3&quot;,
  &quot;yaccform.reduce.m3&quot;,
  NIL
};

VAR Elements := ARRAY [0..8] OF TEXT {
  E0,
  E1,
  E2,
  E3,
  E4,
  NIL (* E5 .. E5_2 *),
  E6,
  E7,
  NIL
};

PROCEDURE <A NAME="GetElt"><procedure>GetElt</procedure></A> (n: INTEGER): TEXT =
  &lt;*FATAL Thread.Alerted, Wr.Failure *&gt;
  VAR wr := TextWr.New ();
  BEGIN
    CASE n OF
    | 5 =&gt;
        Wr.PutText (wr, E5);
        Wr.PutText (wr, E5_0);
        Wr.PutText (wr, E5_1);
        Wr.PutText (wr, E5_2);
    ELSE (*skip*)
    END;
    RETURN TextWr.ToText (wr);
  END GetElt;

CONST E0 =
   &quot;INTERFACE %yacc;\n%gen\n(* original parser definition *)\nIMPORT %tok;\n&quot;
 &amp; &quot;TYPE\n  (* additional parse types *)\n  StartType = %tok.ParseType BRAN&quot;
 &amp; &quot;DED \&quot;%yacc.StartType\&quot; OBJECT END;\n  OtherType = %tok.ParseType;\n%ty&quot;
 &amp; &quot;pe\\\n\n  (* import tokens *)\n  ConstToken = %tok.ConstToken;\n%gettok&quot;
 &amp; &quot;\\\n\n  (* the parser *)\n  T &lt;: Public;\n  Public = OBJECT\n  METHODS\n&quot;
 &amp; &quot;    setLex(lex: %tok.Lexer): T;\n    parse(exhaustInput: BOOLEAN := TRU&quot;
 &amp; &quot;E): StartType;\n\n    (* rules *)\n%prot\\\n\n    purge(): INTEGER;\n  &quot;
 &amp; &quot;  (* Allow any internally allocated ParseTypes to be garbage collected,&quot;
 &amp; &quot;\n       even if the parser itself remains in scope. Return number of P&quot;
 &amp; &quot;arseType\n       objects allocated but not discarded (not the number of&quot;
 &amp; &quot; purged objects).\n       Can be called at any time by the thread calli&quot;
 &amp; &quot;ng get. *)\n  END;\n\n  (* And now, for a hack to allow compatible meth&quot;
 &amp; &quot;ods *)\n  (* ... without importing the original parser *)\n  Original_P&quot;
 &amp; &quot;arser = T;\n%orig\\\n  (* ... and without importing the original token &quot;
 &amp; &quot;*)\n%tokOrig\\\n\nEND %yacc.\n&quot;;

CONST E1 =
   &quot;  %name = %sup BRANDED \&quot;%yacc.%name\&quot; OBJECT END;\n&quot;;

CONST E2 =
   &quot;PROCEDURE %name(self: T;\n VAR result: %return%uparams) = BEGIN\n IF re&quot;
 &amp; &quot;sult=NIL THEN\n   result:=NewPT(self.allocate_%return,TYPECODE(%return)&quot;
 &amp; &quot;);\n END;END %name;\n\n&quot;;

CONST E3 =
   &quot;          | %name =&gt; symCode := %code;\n&quot;;

CONST E4 =
   &quot;    R{%length, %codeReturn, %debug}\\,\n&quot;;

CONST E5 =
   &quot;MODULE %yacc;\n%gen\nIMPORT %tok;\nIMPORT IntIntTbl, IntTextTbl;\nIMPOR&quot;
 &amp; &quot;T RTType;\nIMPORT Env, Thread, Wr, Fmt, Rd;\nFROM Stdio IMPORT stdout;\n&quot;
 &amp; &quot;FROM %tok IMPORT NewPT;\n&lt;* FATAL Wr.Failure, Thread.Alerted *&gt;\n\nTYPE&quot;
 &amp; &quot;\n  TypedSymbol = RECORD\n    code: INTEGER;\n    value: %tok.ParseType&quot;
 &amp; &quot;;\n  END;\nCONST\n  EOFSymbol = TypedSymbol{code := 0, value := NIL};\n&quot;
 &amp; &quot;  NoToken = TypedSymbol{code := -1, value := NIL};\n  NotASymbol = Type&quot;
 &amp; &quot;dSymbol{code := -1000, value := NIL};\n\nTYPE\n  StackElem = RECORD\n  &quot;
 &amp; &quot;  state: INTEGER;\n    value: TypedSymbol;\n  END;\n  StackElemArray = &quot;
 &amp; &quot;REF ARRAY OF StackElem;\n\n  Stack = RECORD\n    a: StackElemArray;\n  &quot;
 &amp; &quot;  ptr: INTEGER;\n  END;\n\nREVEAL\n  T = Public BRANDED \&quot;%yacc\&quot; OBJEC&quot;
 &amp; &quot;T\n    lex: %tok.Lexer;\n    tokenLookup: IntIntTbl.T := NIL; (* M3 typ&quot;
 &amp; &quot;e code -&gt; SymCode *)\n    symbols: IntTextTbl.T;           (* SymCode -&quot;
 &amp; &quot;&gt; name *)\n%alloc\\\n  OVERRIDES\n    setLex := SetLex;\n    parse := P&quot;
 &amp; &quot;arse;\n    purge := Purge;\n%ovr\\\n  END;\n\nTYPE\n  SymCode = BITS %s&quot;
 &amp; &quot;ymCodeBits FOR [0..%symCodeLast];\n  (* symbol code:  0 .. %symCodePenu&quot;
 &amp; &quot;lt\n     set default:  %symCodeLast *)\n\n  Action = BITS %actionBits F&quot;
 &amp; &quot;OR [0..%actionLast];\n  (* error:        -1   (not stored in table)\n  &quot;
 &amp; &quot;   shift:        1 .. %lastShift0\n     accept:       %lastShift1\n    &quot;
 &amp; &quot; reduce:       %lastShift2 .. %lastReduce0\n     shift&amp;accept: %lastRed&quot;
 &amp; &quot;uce1\n     shift&amp;reduce: %lastReduce2 .. %actionLast  *)\n\n  StateRef &quot;
 &amp; &quot;= BITS %stateBits FOR [0..%stateLast];\n  (* no more:      0\n     next&quot;
 &amp; &quot; state:   1..%stateLast *)\n\n  S = RECORD\n    key: SymCode;\n    acti&quot;
 &amp; &quot;on: Action;\n    next: StateRef;\n  END;\n\n  R = RECORD\n    length: I&quot;
 &amp; &quot;NTEGER;\n    returnCode: INTEGER;\n    name: TEXT;\n  END;\n\n  Y = REC&quot;
 &amp; &quot;ORD\n    code: INTEGER;\n    name: TEXT;\n  END;\n\nCONST\n  States = A&quot;
 &amp; &quot;RRAY [1..%stateLast] OF S {\n%States};\n\n  Rules = ARRAY [%lastShift2.&quot;
 &amp; &quot;.%lastReduce0] OF R {\n%Rules};\n\n  Symbols = ARRAY [1..%numSym] OF Y &quot;
 &amp; &quot;{\n%Symbols};\n\nVAR\n  Debug := Env.Get(\&quot;%yaccDEBUG\&quot;) # NIL;\n\nPROC&quot;
 &amp; &quot;EDURE SetLex(self: T; lex: %tok.Lexer): T =\n  BEGIN self.lex := lex; R&quot;
 &amp; &quot;ETURN self; END SetLex;\n\nPROCEDURE Init&quot;;

CONST E5_0 =
   &quot;(self: T) =\n  BEGIN (* called on first parse *)\n    self.tokenLookup &quot;
 &amp; &quot;:= NEW(IntIntTbl.Default).init(%numSym);\n    IF Debug THEN\n      self&quot;
 &amp; &quot;.symbols := NEW(IntTextTbl.Default).init(%numSym);\n      FOR i := 1 TO&quot;
 &amp; &quot; %numSym DO\n        EVAL self.symbols.put(Symbols[i].code, Symbols[i].&quot;
 &amp; &quot;name);\n      END;\n    END;\n  END Init;\n\nPROCEDURE NextToken(self: &quot;
 &amp; &quot;T): TypedSymbol =\n  VAR\n    symCode, m3code: INTEGER;\n    token: %to&quot;
 &amp; &quot;k.Token;\n    found := FALSE;\n  BEGIN\n    TRY\n      token := self.le&quot;
 &amp; &quot;x.get();\n    EXCEPT\n      Rd.EndOfFile =&gt; RETURN EOFSymbol;\n    END;&quot;
 &amp; &quot;\n    m3code := TYPECODE(token);\n    IF NOT self.tokenLookup.get(m3cod&quot;
 &amp; &quot;e, symCode) THEN\n      REPEAT\n        m3code := RTType.Supertype(m3co&quot;
 &amp; &quot;de);\n        IF m3code = RTType.NoSuchType THEN\n          TYPECASE to&quot;
 &amp; &quot;ken OF\n          | ConstToken =&gt; symCode := -1;\n%case\\\n          EL&quot;
 &amp; &quot;SE\n            &lt;* ASSERT FALSE *&gt;\n          END;\n          found := &quot;
 &amp; &quot;TRUE;\n        ELSE\n          found := self.tokenLookup.get(m3code, sy&quot;
 &amp; &quot;mCode);\n        END;\n      UNTIL found;\n      EVAL self.tokenLookup.&quot;
 &amp; &quot;put(TYPECODE(token), symCode);\n    END;\n    IF symCode = -1 THEN\n   &quot;
 &amp; &quot;   symCode := NARROW(token, ConstToken).val;\n    END;\n    RETURN Type&quot;
 &amp; &quot;dSymbol{code := symCode, value := token};\n  END NextToken;\n\nPROCEDUR&quot;
 &amp; &quot;E AllocStack(): Stack =\n  VAR\n    a :=NEW(StackElemArray, 16);\n  BEG&quot;
 &amp; &quot;IN\n    a[0] := StackElem{state := 1, value := EOFSymbol};\n    RETURN &quot;
 &amp; &quot;Stack{a := a, ptr := 0};\n  END AllocStack;\n\nPROCEDURE Push(VAR stack&quot;
 &amp; &quot;: Stack; elem: StackElem) =\n  VAR\n    new: StackElemArray;\n  BEGIN\n&quot;
 &amp; &quot;    INC(stack.ptr);\n    IF stack.ptr &gt; LAST(stack.a^) THEN\n      new &quot;
 &amp; &quot;:= NEW(StackElemArray, NUMBER(stack.a^) * 2);\n      SUBARRAY(new^, 0, &quot;
 &amp; &quot;NUMBER(stack.a^)) := stack.a^;\n      stack.a := new;\n    END;\n    st&quot;
 &amp; &quot;ack.a[stack.ptr] := elem;\n  END Push;\n\nPROCEDURE ActionLookup(curSta&quot;
 &amp; &quot;te: INTEGER; symbol: TypedSymbol): INTEGER =\n  VAR\n    cur := curStat&quot;
 &amp; &quot;e;\n    state: S;\n    default := -1;\n  BEGIN\n    REPEAT\n      state&quot;
 &amp; &quot; := States[cur];\n      IF state.key = %symCodeLast THEN\n        defau&quot;
 &amp; &quot;lt := state.action&quot;;

CONST E5_1 =
   &quot;;\n      ELSIF state.key = symbol.code THEN\n        RETURN state.actio&quot;
 &amp; &quot;n;\n      END;\n      cur := state.next;\n    UNTIL cur = 0;\n    RETUR&quot;
 &amp; &quot;N default;\n  END ActionLookup;\n\nPROCEDURE Parse(self: T; exhaustInpu&quot;
 &amp; &quot;t: BOOLEAN := TRUE): StartType =\n  VAR\n    curState: INTEGER := 1;\n &quot;
 &amp; &quot;   stack := AllocStack();\n    action: INTEGER;\n    symbol, preservedT&quot;
 &amp; &quot;oken: TypedSymbol;\n    skipTokenGets: INTEGER := 0;\n\n  PROCEDURE Deb&quot;
 &amp; &quot;ugPrint(message: TEXT) = BEGIN\n    IF Debug THEN Wr.PutText(stdout,\&quot;%&quot;
 &amp; &quot;yaccDEBUG: \&quot;&amp;message&amp;\&quot;\\n\&quot;);\n     Wr.Flush(stdout);END;END DebugPri&quot;
 &amp; &quot;nt;\n  PROCEDURE DebugSymbol(message: TEXT) = VAR name: TEXT; BEGIN\n  &quot;
 &amp; &quot; IF Debug THEN EVAL self.symbols.get(symbol.code, name);\n    DebugPrin&quot;
 &amp; &quot;t(message &amp; \&quot; \&quot; &amp; name &amp; \&quot;(\&quot; &amp;\n      Fmt.Int(symbol.code) &amp; \&quot;)\&quot;)&quot;
 &amp; &quot;; END; END DebugSymbol;\n  PROCEDURE DebugState(message: TEXT) = BEGIN &quot;
 &amp; &quot;IF Debug THEN\n    DebugPrint(message &amp; \&quot; \&quot; &amp; Fmt.Int(curState));END;&quot;
 &amp; &quot;END DebugState;\n  PROCEDURE DebugRule(message: TEXT) = BEGIN IF Debug &quot;
 &amp; &quot;THEN\n    DebugPrint(message&amp;\&quot; \&quot;&amp;Rules[action].name);END;END DebugRul&quot;
 &amp; &quot;e;\n\n  BEGIN\n    IF self.tokenLookup = NIL THEN Init(self); END;\n   &quot;
 &amp; &quot; stack.a[0] := StackElem{state := curState, value := NotASymbol};\n    &quot;
 &amp; &quot;DebugState(\&quot;starting in state\&quot;);\n    LOOP\n      IF skipTokenGets = &quot;
 &amp; &quot;2 THEN\n        skipTokenGets := 1;\n        DebugSymbol(\&quot;scanning red&quot;
 &amp; &quot;uced symbol\&quot;);\n      ELSIF skipTokenGets = 1 AND preservedToken # NoT&quot;
 &amp; &quot;oken THEN\n        skipTokenGets := 0;\n        symbol := preservedToke&quot;
 &amp; &quot;n;\n        DebugSymbol(\&quot;re-scanning input token\&quot;);\n      ELSE\n    &quot;
 &amp; &quot;    skipTokenGets := 0;\n        symbol := NextToken(self);\n        pr&quot;
 &amp; &quot;eservedToken := symbol;\n        DebugSymbol(\&quot;input token\&quot;);\n      E&quot;
 &amp; &quot;ND;\n      action := ActionLookup(curState, symbol);\n      IF action &gt;&quot;
 &amp; &quot;= %lastReduce1 THEN\n        DebugPrint(\&quot;shifting anonymously\&quot;);\n   &quot;
 &amp; &quot;     Push(stack, StackElem{state := 0, value := symbol});\n        DEC(&quot;
 &amp; &quot;action, %DECaction);\n        IF skipTokenGets = 0 THEN\n          pres&quot;
 &amp; &quot;ervedToken := NoToken;\n        END;\n      END;\n      IF action = -1 &quot;
 &amp; &quot;THEN\n        DebugPrin&quot;;

CONST E5_2 =
   &quot;t(\&quot;syntax error\&quot;);\n        self.lex.error(\&quot;%yacc: syntax error\&quot;);R&quot;
 &amp; &quot;ETURN NIL;\n      ELSIF action &lt;= %lastShift0 THEN\n        curState :=&quot;
 &amp; &quot; action;\n        DebugState(\&quot;shifting to state\&quot;);\n        Push(stac&quot;
 &amp; &quot;k, StackElem{state := curState, value := symbol});\n      ELSIF action &quot;
 &amp; &quot;= %lastShift1 THEN\n        DebugPrint(\&quot;parsing stopped with singleton&quot;
 &amp; &quot; start symbol on stack\&quot;);\n        &lt;* ASSERT stack.ptr = 1 *&gt;\n       &quot;
 &amp; &quot; IF exhaustInput AND preservedToken = NoToken THEN\n          symbol :=&quot;
 &amp; &quot; NextToken(self);\n          DebugPrint(\&quot;getting token to check that i&quot;
 &amp; &quot;t\'s an EOF\&quot;);\n        END;\n        IF symbol.code # 0 THEN\n       &quot;
 &amp; &quot;   IF exhaustInput THEN\n            DebugPrint(\&quot;Error: last token was&quot;
 &amp; &quot; not EOF\&quot;);\n            self.lex.unget();\n            self.lex.error&quot;
 &amp; &quot;(\&quot;%yacc: syntax error (parsing stopped before EOF)\&quot;);\n            RE&quot;
 &amp; &quot;TURN NIL;\n          END;\n          IF preservedToken # NoToken THEN\n&quot;
 &amp; &quot;            self.lex.unget();\n            DebugPrint(\&quot;ungetting last &quot;
 &amp; &quot;token\&quot;);\n          END;\n        END;\n        symbol := stack.a[1].v&quot;
 &amp; &quot;alue;\n        DebugSymbol(\&quot;returning symbol\&quot;);\n        RETURN symbo&quot;
 &amp; &quot;l.value;\n      ELSE\n        DebugRule(\&quot;reducing by rule\&quot;);\n       &quot;
 &amp; &quot; WITH p=stack.ptr, a=stack.a, v=symbol.value, l=Rules[action].length DO&quot;
 &amp; &quot;\n          CASE action OF\n%reduce\\\n          ELSE\n            &lt;* A&quot;
 &amp; &quot;SSERT FALSE *&gt;\n          END;\n          FOR i := p - l + 1 TO p DO a[&quot;
 &amp; &quot;i].value.value.discard(); END;\n          DEC(p, l);\n          curStat&quot;
 &amp; &quot;e := a[p].state;\n        END;\n        DebugState(\&quot;popping to state\&quot;&quot;
 &amp; &quot;);\n        symbol.code := Rules[action].returnCode;\n        skipToken&quot;
 &amp; &quot;Gets := 2;\n      END;\n    END;\n  END Parse; \n\nPROCEDURE Purge(self&quot;
 &amp; &quot;: T): INTEGER =\n  BEGIN\n    RETURN 0%purge;\n  END Purge;\n\n(* defau&quot;
 &amp; &quot;lt methods *)\n%defimpl\\\nBEGIN\nEND %yacc.\n&quot;;

CONST E6 =
   &quot;  Original_%name = %name;\n&quot;;

CONST E7 =
   &quot;          | %number =&gt; VAR w: %return := NIL;\\\n%fromStack\n          &quot;
 &amp; &quot;  BEGIN self.%name(w%cparams); v:=w; END;\n&quot;;

BEGIN
END yaccformBundle.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
