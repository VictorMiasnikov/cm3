<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: cminstall/src/Main.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>cminstall/src/Main.m3</H2></A><HR>
<inModule>
<PRE>MODULE <module><implements><A HREF="../../m3core/src/main/Main.i3.html">Main</A></implements></module>;

IMPORT <A HREF="../../libm3/src/bundleintf/Bundle.i3.html">Bundle</A>, (* CMKey, CMCurrent, *) <A HREF="../../m3core/derived/Compiler.i3.html">Compiler</A>, <A HREF="../../libm3/src/params/Env.i3.html">Env</A>, <A HREF="../../libm3/src/os/Common/File.i3.html">File</A>, <A HREF="../../libm3/src/fmtlex/Fmt.i3.html">Fmt</A>, <A HREF="../../libm3/src/os/Common/FS.i3.html">FS</A>, <A HREF="#x1">Glob</A>;
IMPORT <A HREF="#x2">M3ID</A>, <A HREF="#x3">Msg</A>, <A HREF="#x4">OS</A>, <A HREF="../../libm3/src/os/Common/OSError.i3.html">OSError</A>, <A HREF="../../libm3/src/params/Params.i3.html">Params</A>, <A HREF="../../libm3/src/os/Common/Pathname.i3.html">Pathname</A>, <A HREF="../../libm3/src/os/Common/Pipe.i3.html">Pipe</A>, <A HREF="../../libm3/src/os/Common/Process.i3.html">Process</A>;
IMPORT <A HREF="../../m3quake/src/Quake.i3.html">Quake</A>, <A HREF="../../m3quake/src/QScanner.i3.html">QScanner</A>, <A HREF="../../m3quake/src/QToken.i3.html">QToken</A>, <A HREF="#x5">RegEx</A>, <A HREF="Registry.i3.html">Registry</A>, <A HREF="../../libm3/src/os/Common/RegularFile.i3.html">RegularFile</A>, <A HREF="../derived/Setup.i3.html">Setup</A>;
IMPORT <A HREF="../../m3core/src/text/Text.i3.html">Text</A>, <A HREF="#x6">Text2</A>, <A HREF="../../libm3/derived/TextSeq.i3.html">TextSeq</A>, <A HREF="../../libm3/src/rw/TextWr.i3.html">TextWr</A>, <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>;
IMPORT <A HREF="../derived/InstallTarget.i3.html">InstallTarget</A>, <A HREF="#x7">TextUtils</A>;
FROM <A HREF="#x3">Msg</A> IMPORT Out, OutS, Ask, AskBool, AskChoice;

CONST
  OnUnix = (Compiler.ThisOS = Compiler.OS.POSIX);

  DefaultInstallDir = ARRAY BOOLEAN OF TEXT
    { &quot;c:\\cm3&quot;, &quot;/usr/local/cm3&quot; } [OnUnix];

  MinDiskSpace = 250; (* megabytes *)

  (* until we get the permission...
  REACTOR_EXE = ARRAY BOOLEAN OF TEXT &lt;*NOWARN*&gt;
    { &quot;reactor.exe&quot;, &quot;reactor&quot; } [OnUnix];
  *)

  CM3_EXE = ARRAY BOOLEAN OF TEXT
    { &quot;cm3.exe&quot;, &quot;cm3&quot; } [OnUnix];

  GZIP_EXE = ARRAY BOOLEAN OF TEXT
    { &quot;gzip.exe&quot;, &quot;gzip&quot; } [OnUnix];

  TAR_EXE = ARRAY BOOLEAN OF TEXT
    { &quot;tar.exe&quot;, &quot;tar&quot; } [OnUnix];

  FIXUP_EXE = ARRAY BOOLEAN OF TEXT
    { &quot;fixup.bat&quot;, &quot;fixup&quot; } [OnUnix];

  ARCHIVES = ARRAY [0..3] OF TEXT
    {
      &quot;cm3-doc*&quot;,
      &quot;cm3-misc*&quot;,
      &quot;cm3-specials*&quot;,
      &quot;cm3-fixes*&quot;
    };

VAR
  install_passwd    : TEXT;
  install_root      : TEXT;
  install_log       : TEXT;
  disk_space        : INTEGER;
  initial_cfg       : TEXT;
  cm3_cfg           : TEXT;
  cminstall_root    : TEXT := NIL;
  gzip              : TEXT (* = OS.MakePath (cminstall_root, GZIP_EXE) *);
  tar               : TEXT (* = OS.MakePath (cminstall_root, TAR_EXE) *);
  interactive       : BOOLEAN := FALSE;
  dumpConfig        : BOOLEAN := FALSE;
  oldConfig         : BOOLEAN := FALSE;

PROCEDURE <A NAME="DoIt"><procedure>DoIt</procedure></A> () =
  BEGIN
    ParseParams ();

    IF NOT UtilsFound() THEN
      RETURN;
    END;

    Out ();
    Out (&quot;Thank you for using Critical Mass CM3.  This program&quot;);
    Out (&quot;will configure and install the system.&quot;);
    Out ();
    Out (&quot;cminstall_root is set to &quot;, cminstall_root);
    Out (&quot;If this is not correct, please restart the installer with&quot;);
    Out (&quot;-root &lt;directory-of-installer-and-system-archive&gt;&quot;);
    Out ();
    Out (&quot;If the installer runs interactively, it will ask you some questions&quot;);
    Out (&quot;about the locations of programs and libraries.&quot;);
    Out (&quot;Usually it will display a default inside [], which can be&quot;);
    Out (&quot;accepted with &lt;Enter&gt;.&quot;);
    Out (&quot;If the installer has found several choices, you may cycle through&quot;,
         &quot; them&quot;);
    Out (&quot;with `+' or `.' for the next and `-' for the previous one.&quot;);
    Out (&quot;You may of course also enter a completely different value.&quot;);
    Out ();

    (* disabled
    (* verify license *)
    Out (&quot;The use of this software is subject to the license agreement&quot;);
    Out (&quot;in the file COPYRIGHT-CMASS.  Please read it now.&quot;);
    Out ();
    IF NOT AskBool (&quot;Do you agree to the terms of the license?&quot;, &quot;Y&quot;) THEN
      RETURN;
    END;
    *)

    (* get the install key *)
    (* disabled
    LOOP
      Out ();
      install_passwd := Ask (&quot;Please enter your installation key: &quot;, NIL);
      IF KeyCheck (install_passwd) THEN EXIT; END;
      Out ();
      Out (&quot;Sorry, that is an invalid installation key, please reenter it.&quot;);
    END;
    *)

    (* get the install directory *)
    LOOP
      Out ();
      IF interactive THEN
        install_root := Ask (&quot;Where would you like the system installed?&quot;,
                              DefaultInstallDir);
      END;
      install_root := OS.CleanDirName (install_root);
      Msg.Debug (&quot;install_root =&gt; &quot;, install_root);

      (* make sure the install directory exists *)
      IF NOT OS.MakeDir (install_root) THEN
        Out (&quot;Unable to create directory: &quot;, install_root);
      ELSE
        install_root := OS.GetAbsolutePath (install_root);
        Msg.Debug (&quot;install_root =&gt; &quot;, install_root);

        (* verify the disk space *)
        disk_space := OS.GetDiskSpace (install_root);
        Msg.Debug (&quot;available disk space: &quot;, Fmt.Int (disk_space), &quot; megabytes&quot;);
        IF disk_space &gt;= MinDiskSpace THEN EXIT; END;
        Out (&quot;It appears that there is only about &quot;, Fmt.Int (disk_space),
             &quot; megabytes of space&quot;);
        Out (&quot;in that directory.  CM3 requires about &quot;,
             Fmt.Int (MinDiskSpace), &quot;MB of disk space.&quot;);
        IF interactive AND
          AskBool (&quot;Do you want to use this directory anyway?&quot;, &quot;N&quot;) THEN
          EXIT;
        END;
      END;
    END;

    (* set the various paths that we'll be using *)
    cm3_cfg     := OS.MakePath (install_root, &quot;bin&quot;, &quot;cm3.cfg&quot;);
    install_log := OS.MakePath (install_root, &quot;Install.log&quot;);
    Msg.AttachDrain (install_log);

    (* process the cfg prototype *)
    IF oldConfig THEN
      Msg.Debug (&quot;processsing config script&quot;);
      initial_cfg := GenConfig ();
    ELSE
      initial_cfg := &quot;&quot;;
    END;

    VAR
      line1 := &quot;INSTALL_ROOT = \&quot;&quot; &amp; install_root &amp; &quot;\&quot;&quot;;
      line2 := &quot;include(\&quot;&quot; &amp; InstallTarget.Target &amp; &quot;\&quot;)&quot;;
    BEGIN
      IF NOT TextUtils.Contains (initial_cfg, &quot;INSTALL_ROOT&quot;) THEN
        initial_cfg := initial_cfg &amp; &quot;\n&quot; &amp; line1 &amp; &quot;\n&quot;;
      END;
      IF NOT TextUtils.Contains (initial_cfg, &quot;m3_backend&quot;) AND
        NOT TextUtils.Contains (initial_cfg, line2) THEN
        initial_cfg := initial_cfg &amp; &quot;\n&quot; &amp; line2 &amp; &quot;\n\n&quot;;
      END;
    END;
    IF dumpConfig THEN
      Msg.Quiet := FALSE;
      Out (initial_cfg);
      Process.Exit(0);
    END;

    (* install the new cm3.cfg file before unpacking in case it chokes *)
    EVAL OS.MakeDir (Pathname.Prefix (cm3_cfg));
    OS.WriteFile (cm3_cfg, initial_cfg);

    (* uncompress and copy the bits *)
    Out ();
    Out (&quot;Installing CM3 in: &quot;, install_root);
    Out (&quot;This may take a few minutes...&quot;);
    Unpack (&quot;system&quot;);
    VAR
      iter: FS.Iterator;
      fn: TEXT;
      stat: File.Status;
      archive_name, archive_path1: TEXT;
    BEGIN
      TRY
        iter := FS.Iterate(&quot;.&quot;);
        FOR i := FIRST(ARCHIVES) TO LAST(ARCHIVES) DO
          archive_name := ARCHIVES[i];
          Msg.Debug (&quot;looking for archive: &quot;, archive_name);
          WHILE iter.nextWithStatus(fn, stat) DO
            Msg.Debug (&quot;  file &quot;, fn);
            IF stat.type = RegularFile.FileType AND
              Glob.Match(archive_name, fn) THEN
              Msg.Debug (&quot;    matching regular file&quot;);
              archive_path1 := OS.MakePath(cminstall_root, fn);
              IF OS.IsExecutable(archive_path1) THEN
                Unpack(fn);
              ELSE
                Msg.Debug (&quot;not found: &quot;, archive_name);
              END;
            END;
          END;
        END;
      EXCEPT
        OSError.E(e) =&gt; Msg.Error(e, &quot;cannot list current directory&quot;);
      | RegEx.Error =&gt; Msg.Error(NIL, &quot;invalid regular expression&quot;);
      END;
    END;
    (* Unpack (OS.MakePath (&quot;..&quot;, &quot;DOCS&quot;)); *)

    (* reinstall the new cm3.cfg file to make sure we've got the right one *)
    OS.WriteFile (cm3_cfg, initial_cfg);
</PRE>******
    (* check out networking 
    <PRE>Out ();
    Out (&quot;CM3 uses TCP/IP to communicate between a World-Wide Web browser&quot;);
    Out (&quot;and the server.  I'll test that networking is installed, now.  This&quot;);
    Out (&quot;test may take up to 20 seconds, please wait.&quot;);
    TestTCP ();
********)

    (* see if there are any last minute patches... *)
    RunFixups ();

    (* reminders *)
    Out ();
    Out (&quot;CM3 is now installed.&quot;);
    Out ();
    Out (&quot;Before you begin, here's a few reminders:&quot;);
    Out ();
    Out (&quot;  1) The CM3 compiler executable is in:&quot;);
    Out (&quot;        &quot;, OS.MakePath (install_root, &quot;bin&quot;, CM3_EXE));
    Out (&quot;     You may need to modify your PATH environment variable to find it.&quot;);
  IF OnUnix THEN
    Out (&quot;     And on Unix, you may need to type \&quot;rehash\&quot; to your shell.&quot;);
  END;
    Out ();
  IF OnUnix THEN
    Out (&quot;  2) CM3's shared libraries and any you create and ship are in:&quot;);
    Out (&quot;        &quot;, OS.MakePath (install_root, &quot;lib&quot;));
    Out (&quot;     On most Unix systems you need to set the LD_LIBRARY_PATH&quot;);
    Out (&quot;     (on Darwin / MacOS X it's called DYLD_LIBRARY_PATH)&quot;);
    Out (&quot;     environment variable before running programs that use&quot;);
    Out (&quot;     these shared libraries.&quot;);
  ELSE
    Out (&quot;  2) CM3's shared libraries and any you create and ship are in:&quot;);
    Out (&quot;        &quot;, OS.MakePath (install_root, &quot;bin&quot;));
    Out (&quot;     As long as that directory is on your PATH, Windows will be able&quot;);
    Out (&quot;     to find and use these libraries.&quot;);
  END;
    Out ();
    Out (&quot;  3) Your system configuration file is:&quot;);
    Out (&quot;        &quot;, cm3_cfg);
    Out (&quot;     At any point in time, you may edit it to modify or update your&quot;);
    Out (&quot;     installation.&quot;);
    Out ();
    (* disabled
    Out (&quot;  4) CM3 will keep your personal configuration information&quot;);
    Out (&quot;     and private packages in \&quot;HOME/proj\&quot;.  Be sure to set your&quot;);
    Out (&quot;     HOME environment variable before running CM3.&quot;);
    Out ();
    *)
    Out (&quot;  4) A copy of this installation dialogue is in:&quot;);
    Out (&quot;        &quot;, install_log);
    Out ();
    Out (&quot;  5) If you had trouble with this installation or need more assistance,&quot;);
    Out (&quot;     please send us a transcript of this installation via e-mail at&quot;);
    Out (&quot;     \&quot;m3-support@elego.de\&quot;.&quot;);
    Out ();
    Out (&quot;Thank you.&quot;);

    (* finally, flush the log file *)
    Msg.FinishLog (install_log);
  END DoIt;

PROCEDURE <A NAME="ParseParams"><procedure>ParseParams</procedure></A> () =
  VAR i := 1;  arg: TEXT;
  BEGIN
    WHILE (i &lt; Params.Count) DO
      arg := Params.Get (i);  INC (i);
      IF Text.Equal (arg, &quot;-debug&quot;) OR
         Text.Equal (arg, &quot;-d&quot;) THEN
        Msg.Debugging := TRUE;
      ELSIF Text.Equal (arg, &quot;-root&quot;) THEN
        IF (i &gt;= Params.Count) THEN
          Msg.Error (NIL, &quot;Missing directory for \&quot;-root &lt;dir&gt;\&quot; option&quot;);
        END;
        cminstall_root := Params.Get (i);  INC (i);
      ELSIF Text.Equal (arg, &quot;-interactive&quot;) OR
            Text.Equal (arg, &quot;-i&quot;) THEN
        interactive := TRUE;
      ELSIF Text.Equal (arg, &quot;-help&quot;) OR
            Text.Equal (arg, &quot;-h&quot;) THEN
        Out(&quot;&quot;);
        Out(&quot;cminstall [&lt;opts&gt;] [-root &lt;installfrom&gt;] [installroot]&quot;);
        Out(&quot;&quot;);
        Out(&quot;  &lt;opts&gt; ::= -debug       | -d&quot;);
        Out(&quot;          |  -quiet       | -q&quot;);
        Out(&quot;          |  -interactive | -i&quot;);
        Out(&quot;          |  -dumpcfg     | -c&quot;);
        Out(&quot;          |  -oldcfg      | -o&quot;);
        Out(&quot;          |  -help        | -h&quot;);
        Out(&quot;&quot;);
        Out(&quot;  will try to install CM3 from the given &lt;installfrom&gt;, if any.&quot;);
        Out(&quot;  The default installation location is &quot;, DefaultInstallDir, &quot;.&quot;);
        Out(&quot;&quot;);
        Out(&quot;  -interactive or -i will make the installer ask several questions.&quot;);
        Out(&quot;&quot;);
        Out(&quot;  -debug will output some debugging information during the installation.&quot;);
        Out(&quot;    This should rarely be of interest to the end user.&quot;);
        Out(&quot;&quot;);
        Out(&quot;  -quiet or -q will suppress output except for warnings and errors.&quot;);
        Out(&quot;&quot;);
        Out(&quot;  -dumpcfg or -c will print the resulting config file to stdout.&quot;);
        Out(&quot;&quot;);
        Out(&quot;Contact m3-support@elegosoft.com or m3devel@elegosoft.com in case of problems.&quot;);
        Out(&quot;&quot;);
        Process.Exit(0);
      ELSIF Text.Equal (arg, &quot;-quiet&quot;) OR
            Text.Equal (arg, &quot;-q&quot;) THEN
        Msg.Quiet := TRUE;
        interactive := FALSE;
      ELSIF Text.Equal (arg, &quot;-dumpcfg&quot;) OR
            Text.Equal (arg, &quot;-c&quot;) THEN
        dumpConfig := TRUE;
        Msg.Quiet := TRUE;
        interactive := FALSE;
      ELSIF Text.Equal (arg, &quot;-oldcfg&quot;) OR
            Text.Equal (arg, &quot;-o&quot;) THEN
        oldConfig := TRUE;
      ELSIF Text.GetChar (arg, 0) = '-'THEN
        Msg.Error (NIL, &quot;Unrecognized option: &quot;, arg);
      ELSE
        IF install_root = NIL THEN
          install_root := arg;
        ELSE
          Msg.Error (NIL, &quot;Unrecognized argument: &quot;, arg);
        END;
      END;
    END;

    IF install_root = NIL THEN
      install_root := DefaultInstallDir;
    END;
    IF (cminstall_root = NIL) THEN
      (* use the directory containing this executable *)
      cminstall_root := Pathname.Prefix (Params.Get (0));
    END;
    cminstall_root := OS.GetAbsolutePath (cminstall_root);
  END ParseParams;
</PRE>-------------------------------------------- initial cm3.cfg generation ---

<P><PRE>TYPE
  TK = QToken.T;
  LibFile = REF RECORD file: TEXT;  next: LibFile; END;

PROCEDURE <A NAME="LibFilesToText"><procedure>LibFilesToText</procedure></A>(l : LibFile) : TEXT =
  VAR res : TEXT;
  BEGIN
    IF l = NIL THEN RETURN &quot;(none)&quot; END;
    res := l.file;
    l := l.next;
    WHILE l # NIL DO
      res := res &amp; &quot; &quot; &amp; l.file;
      l := l.next;
    END;
    RETURN res;
  END LibFilesToText;

PROCEDURE <A NAME="OutResult"><procedure>OutResult</procedure></A> (res : TEXT) =
  BEGIN
    IF res = NIL THEN
      Out (&quot; not found&quot;);
    ELSE
      Out (&quot; found &quot;);
    END;
  END OutResult;

PROCEDURE <A NAME="GenConfig"><procedure>GenConfig</procedure></A> (): TEXT =
  &lt;*FATAL Wr.Failure, Thread.Alerted*&gt;
  TYPE
    Kind = { Any, Dir, Exe, LibPath };
  VAR
    config     := Bundle.Get (Setup.Get (), &quot;config&quot;);
    wr         := TextWr.New ();
    scan       := NewScan (config);
    done       := 0;
    len        := Text.Length (config);
    begin_cfg  := Txt2ID (&quot;BEGIN_CONFIG&quot;);
    end_cfg    := Txt2ID (&quot;END_CONFIG&quot;);
    result     : TEXT;
    title      : TEXT;
    v0, v1, v2 : TEXT;
    confirm    : BOOLEAN;
    rule       : INTEGER;
    kind       : Kind;
    lib_files  : LibFile;
    lib_dirs   : TextSeq.T := NEW(TextSeq.T);
    choices    : TextSeq.T := NEW(TextSeq.T);
  BEGIN
    scan.next (); (* prime the token stream *)

    WHILE (done &lt; len) DO

      (* scan up to the next config section *)
      WHILE (scan.token # TK.EOF)
        AND ((scan.token # TK.Name) OR (scan.string # begin_cfg)) DO
        scan.next ();
      END;
      IF (scan.start &gt; done) THEN
        (* copy what we skipped, verbatim *)
        Wr.PutText (wr, Text.Sub (config, done, scan.start - done));
        done := scan.start;
      END;
      scan.next (); (* BEGIN_CONFIG *)

      IF (done &gt;= len) THEN EXIT; END;
      EVAL choices.init();
      EVAL lib_dirs.init();

      (* get the config item's title *)
      IF (scan.token # TK.String) THEN
        ConfigErr (scan, &quot;missing title&quot;);
      END;
      title := ID2Txt (scan.string);
      scan.next ();

      Out (title);

      kind := Kind.Any;  lib_files := NIL;
      WHILE (scan.token = TK.Cardinal) DO
        confirm := interactive;
        result := NIL;

        rule := scan.cardinal;
        Msg.Debug (&quot; =&gt; &quot;, Fmt.Int (rule));
        scan.next ();  (* rule # *)

        CASE rule OF
        | 0 =&gt; (* exe-name *)
            v0 := GetTxt (scan);
            OutS (&quot;checking for executable &quot; &amp; v0 &amp; &quot;...&quot;);
            result := OS.FindExecutable (v0);
            kind := Kind.Exe;
            OutResult (result);

        | 1 =&gt; (* file-extension *)
            v0 := GetTxt (scan);
            OutS (&quot;registry lookup by extension for &quot; &amp; v0 &amp; &quot;...&quot;);
            result := Registry.LookupByExtension (v0);
            IF result # NIL THEN choices.addhi(result) END;
            kind := Kind.Exe;
            OutResult (result);

        | 2, 3 =&gt; (* file-extension, dir-name *)
            v0 := GetTxt (scan);
            v1 := GetTxt (scan);
            v2  := Registry.LookupByExtension (v0);
            OutS (&quot;registry lookup by extension: file &quot; &amp; v0 &amp; &quot; dir: &quot; &amp;
              v1 &amp; &quot;...&quot;);
            IF v2 # NIL THEN
              v2 := OS.GetAbsolutePath (Pathname.Prefix (v2), v1);
              IF (v2 # NIL) AND OS.IsDirectory (v2) THEN
                result := v2;
              END;
            END;
            kind := Kind.Dir;
            OutResult (result);

        | 4 =&gt;  (* env-variable, exe-name *)
            v0 := GetTxt (scan);
            v1 := GetTxt (scan);
            OutS (&quot;checking for &quot; &amp; v1 &amp; &quot; at value of environment variable &quot; &amp;
              v0 &amp; &quot;...&quot;);
            v2 := Env.Get (v0);
            IF v2 # NIL THEN
              result := OS.FindExecutable (OS.MakePath (v2, v1));
            END;
            kind := Kind.Exe;
            OutResult (result);

        | 5 =&gt; (* exe-name, dir-name *)
            v0 := GetTxt (scan);
            v1 := GetTxt (scan);
            OutS (&quot;checking for directory &quot; &amp; v1 &amp; &quot; with executable &quot; &amp;
              v0 &amp; &quot;...&quot;);
            v2 := OS.FindExecutable (v0);
            IF (v2 # NIL) THEN
              v2 := OS.GetAbsolutePath (Pathname.Prefix (v2), v1);
              IF (v2 # NIL) AND OS.IsDirectory (v2) THEN
                result := v2;
              END;
            END;
            kind := Kind.Dir;
            OutResult (result);

        | 6 =&gt; (* dir-name, exe-name *)
            v0 := GetTxt (scan);
            v1 := GetTxt (scan);
            OutS (&quot;checking for executable &quot; &amp; v1 &amp; &quot; in directory &quot; &amp;
              v0 &amp; &quot;...&quot;);
            result := OS.FindExecutable (OS.MakePath (v0, v1));
            kind := Kind.Exe;
            OutResult (result);

        | 7 =&gt; (* install root *)
            result := OS.FilenameWithoutSpaces (install_root);
            kind := Kind.Dir;
            confirm := FALSE;
            Out (&quot;setting INSTALL_ROOT to &quot; &amp; result);

        | 8 =&gt; (* dir-name *)
            v0 := GetTxt (scan);
            OutS (&quot;checking for directory &quot; &amp; v0 &amp; &quot;...&quot;);
            IF OS.IsDirectory (v0) THEN
              result := v0;
            END;
            kind := Kind.Dir;
            OutResult (result);

        | 9 =&gt;  (* env-variable, dir-name *)
            v0 := GetTxt (scan);
            v1 := GetTxt (scan);
            v2 := Env.Get (v0);
            OutS (&quot;checking for directory &quot; &amp; v1 &amp;
              &quot; with environment variable &quot; &amp; v0 &amp; &quot;...&quot;);
            IF v2 # NIL THEN
              v2 := OS.GetAbsolutePath (v2, v1);
              IF (v2 # NIL) AND OS.IsDirectory (v2) THEN
                result := v2;
              END;
            END;
            kind := Kind.Dir;
            OutResult (result);

        | 10 =&gt; (* env-variable *)
            v0 := GetTxt (scan);
            v1 := Env.Get (v0);
            OutS (&quot;checking for executable &quot; &amp;
              &quot; with environment variable &quot; &amp; v0 &amp; &quot;...&quot;);
            IF (v1 # NIL) THEN
              result := OS.FindExecutable (v1);
            END;
            kind := Kind.Exe;
            OutResult (result);

        | 11 =&gt; (* file-name *)
            lib_files := NEW (LibFile, next := lib_files,
                              file := GetTxt (scan));
            Out (&quot;looking for library file(s): &quot; &amp; LibFilesToText(lib_files));

        | 12 =&gt; (* dir-name *)
            v0 := GetTxt (scan);
            IF v0 # NIL THEN
              OutS (&quot;checking for library files in directory &quot; &amp; v0 &amp; &quot;...&quot;);
              lib_dirs.addhi(v0);
            END;
            IF (v0 # NIL) AND OS.IsDirectory (v0)
              AND FilesPresent (v0, lib_files) THEN
              result := v0;
            END;
            kind := Kind.LibPath;
            OutResult (result);

        | 13 =&gt; (* dir-name *)
            v0 := GetTxt (scan);
            OutS (&quot;checking for directory &quot; &amp; v0 &amp; &quot;...&quot;);
            IF OS.IsDirectory (v0) THEN
              result := v0;
              lib_dirs.addhi(result);
            END;
            kind := Kind.LibPath;
            OutResult (result);

        | 14 =&gt; (* install key *)
            result := install_passwd;
            kind := Kind.Any;
            confirm := FALSE;

        ELSE
            ConfigErr (scan, &quot;unknown key: &quot; &amp; Fmt.Int (scan.cardinal));
        END; (* CASE *)
        IF result # NIL AND NOT MemberOfTextSeq(choices, result) THEN
          choices.addhi(result)
        END;
      END; (* WHILE *)

      (* confirm with the user and stick it into the config file *)
      IF confirm THEN
        LOOP
          Out ();
          v0 := AskChoice (title, choices);
          CASE kind OF
          | Kind.Any =&gt;
              EXIT;
          | Kind.Exe =&gt;
              IF OS.IsExecutable (v0) THEN EXIT; END;
              v0 := OS.FilenameWithoutSpaces (v0);
              Out ();
              Out (&quot;Please enter the name of an executable program.&quot;);
          | Kind.Dir =&gt;
              v0 := OS.CleanDirName (v0);
              v0 := OS.FilenameWithoutSpaces (v0);
              IF OS.IsDirectory (v0) THEN EXIT; END;
              Out ();
              Out (&quot;Please enter the name of a directory.&quot;);
          | Kind.LibPath =&gt;
              v0 := OS.CleanDirName (v0);
              IF v0 = NIL THEN v0 := &quot;&quot; END;
              IF OS.IsDirectory (v0) THEN
                v0 := OS.FilenameWithoutSpaces (v0);
                IF FilesPresent (v0, lib_files) THEN
                  v0 := &quot;-L&quot; &amp; v0;
                  EXIT;
                ELSE
                  Out (&quot;The libraries &quot; &amp; LibFilesToText(lib_files) &amp;
                    &quot; are not present in the chosen directory.&quot;);
                  IF AskBool(&quot;Would you like to change the library names?&quot;,
                             &quot;yes&quot;) THEN
                    Out (&quot;Warning: Changing the required library names is &quot;,
                         &quot;currently only partially&quot;);
                    Out (&quot;supported by the installer. You will have to edit &quot;,
                         OS.MakePath(install_root, &quot;bin&quot;, &quot;cm3.cfg&quot;));
                    Out (&quot;manually after the installation and adapt the &quot;,
                         &quot;-l suffixes in the SYSTEM_LIBS&quot;);
                    Out (&quot;array.&quot;);
                    Out (&quot;Sorry for the inconvenience.&quot;);
                    lib_files := NIL;
                    v0 := Ask(&quot;enter library file (or ENTER to &quot; &amp;
                              &quot;continue): &quot;, NIL);
                    WHILE v0 # NIL AND NOT Text.Empty(v0) DO
                      lib_files := NEW (LibFile, next := lib_files,
                                        file := v0);
                      v0 := Ask(&quot;enter library file (or ENTER to &quot; &amp;
                                &quot;continue): &quot;, NIL);
                    END;
                    IF AskBool(&quot;Would you like to add library search paths?&quot;,
                               &quot;yes&quot;) THEN
                      v0 := Ask(&quot;enter library directory (or ENTER to &quot; &amp;
                                &quot;continue): &quot;, NIL);
                      WHILE v0 # NIL AND NOT Text.Empty(v0) DO
                        lib_dirs.addhi(v0);
                        v0 := Ask(&quot;enter library directory (or ENTER to &quot; &amp;
                                  &quot;continue): &quot;, NIL);
                      END;
                    END;
                    Out (&quot;looking for library file(s): &quot; &amp;
                      LibFilesToText(lib_files));
                    EVAL choices.init();
                    FOR i := 0 TO lib_dirs.size() - 1 DO
                      WITH dir = lib_dirs.get(i) DO
                        OutS (&quot;checking in directory &quot;, dir, &quot;...&quot;);
                        IF OS.IsDirectory (dir) AND lib_files # NIL AND
                          FilesPresent (dir, lib_files) THEN
                          OutResult (dir);
                          IF NOT MemberOfTextSeq(choices, dir) THEN
                            choices.addhi(dir);
                          END;
                        ELSE
                          OutResult (NIL);
                        END;
                      END;
                    END;
                  ELSE
                    IF AskBool(&quot;Would you like to continue nonetheless?&quot;,
                               &quot;yes&quot;) THEN
                      v0 := &quot;-L&quot; &amp; v0;
                      EXIT;
                    END;
                    Out ();
                    Out (&quot;Please enter the name of a directory.&quot;);
                  END;
                END;
              ELSE
                Out ();
                Out (&quot;Please enter the name of a directory.&quot;);
              END;
          END; (* CASE *)
        END; (* LOOP *)
        Out ();
        result := v0;
      ELSIF NOT interactive THEN
        IF choices.size() &gt; 0 THEN
          result := choices.get(0);
          IF kind = Kind.LibPath THEN
            result := &quot;-L&quot; &amp; result;
          END;
        END;
      END;
      Out(&quot;  --&gt; &quot;, Text2.EscapeString (result));
      Wr.PutText (wr, Text2.EscapeString (result));

      (* skip to the end of the config section *)
      WHILE (scan.token # TK.EOF)
        AND ((scan.token # TK.Name) OR (scan.string # end_cfg)) DO
        scan.next ();
      END;
      done := scan.start + scan.length;
      scan.next (); (* END_CONFIG *)
    END;

    RETURN TextWr.ToText (wr);
  END GenConfig;

PROCEDURE <A NAME="FilesPresent"><procedure>FilesPresent</procedure></A> (dir: TEXT;   files: LibFile): BOOLEAN =
  BEGIN
    WHILE (files # NIL) DO
      IF NOT OS.IsExecutable (OS.MakePath (dir, files.file)) THEN
        RETURN FALSE;
      END;
      files := files.next;
    END;
    RETURN TRUE;
  END FilesPresent;

PROCEDURE <A NAME="MemberOfTextSeq"><procedure>MemberOfTextSeq</procedure></A>(tl : TextSeq.T; elem : TEXT) : BOOLEAN =
  BEGIN
    FOR i := 0 TO tl.size() - 1 DO
      WITH act = tl.get(i) DO
        IF Text.Equal(act, elem) THEN
          RETURN TRUE;
        END;
      END;
    END;
    RETURN FALSE;
  END MemberOfTextSeq;
</PRE>--------------------------------------------- low-level quake support ---- 

<P><PRE>VAR
  quake_id_map := Quake.NewIDMap (Str2ID, Txt2ID, ID2Txt);

PROCEDURE <A NAME="NewScan"><procedure>NewScan</procedure></A> (file: TEXT): QScanner.T =
  BEGIN
    RETURN NEW (QScanner.T).initText (file, quake_id_map);
  END NewScan;

PROCEDURE <A NAME="GetTxt"><procedure>GetTxt</procedure></A> (scan: QScanner.T): TEXT =
  VAR txt: TEXT;
  BEGIN
    IF scan.token # TK.String THEN
      ConfigErr (scan, &quot;missing string&quot;);
    END;
    txt := ID2Txt (scan.string);
    scan.next ();
    RETURN txt;
  END GetTxt;

PROCEDURE <A NAME="ConfigErr"><procedure>ConfigErr</procedure></A> (scan: QScanner.T;  msg: TEXT) =
  BEGIN
    Msg.Error (NIL, &quot;Bad config file! --- &quot;, msg, &quot; --- token = &quot;,
               QToken.Name [scan.token]);
  END ConfigErr;

PROCEDURE <A NAME="Str2ID"><procedure>Str2ID</procedure></A> (READONLY x: ARRAY OF CHAR): Quake.ID =
  BEGIN
    RETURN M3ID.FromStr (x);
  END Str2ID;

PROCEDURE <A NAME="Txt2ID"><procedure>Txt2ID</procedure></A> (t: TEXT): Quake.ID =
  BEGIN
    RETURN M3ID.Add (t);
  END Txt2ID;

PROCEDURE <A NAME="ID2Txt"><procedure>ID2Txt</procedure></A> (i: Quake.ID): TEXT =
  BEGIN
    RETURN M3ID.ToText (i);
  END ID2Txt;
</PRE>------------------------------------------- decompression and unpacking ---
<PRE>PROCEDURE <A NAME="UtilsFound"><procedure>UtilsFound</procedure></A>() : BOOLEAN =
  BEGIN
    gzip := OS.MakePath (cminstall_root, GZIP_EXE);
    tar  := OS.MakePath (cminstall_root, TAR_EXE);
    IF NOT OS.IsExecutable(gzip) THEN
      gzip := OS.FindExecutable(GZIP_EXE);
      IF gzip = NIL THEN
        Msg.Out(&quot;Cannot find gzip.&quot;);
        Msg.Out(&quot;A workable gzip (de)compression program must be installed&quot;,
                &quot;and found via PATH.&quot;);
        RETURN FALSE;
      END;
    END;
    Msg.Debug (&quot;GZIP_EXE = &quot;, gzip);
    IF NOT OS.IsExecutable(tar) THEN
      tar := OS.FindExecutable(TAR_EXE);
      IF tar = NIL THEN
        Msg.Out(&quot;Cannot find tar.&quot;);
        Msg.Out(&quot;A workable tar archiving program must be installed&quot;,
                &quot;and found via PATH.&quot;);
        RETURN FALSE;
      END;
    END;
    Msg.Debug (&quot;TAR_EXE = &quot;, tar);
    RETURN TRUE;
  END UtilsFound;

CONST
  GZipArgs = ARRAY [0..0] OF TEXT { &quot;-dc&quot; };
  TarArgs  = ARRAY [0..1] OF TEXT { &quot;-xf&quot;, &quot;-&quot; };

PROCEDURE <A NAME="Unpack"><procedure>Unpack</procedure></A> (archive: TEXT) =
  VAR data: TEXT := OS.MakePath (cminstall_root, archive);
  BEGIN
    IF OS.IsExecutable (data) THEN
      TRY
        IF Glob.Match(&quot;*.tar&quot;, data) THEN
          UnpackTAR (data);
        ELSIF Glob.Match(&quot;*.tar.gz&quot;, data) THEN
          UnpackTGZ (data);
        ELSIF Glob.Match(&quot;*.tgz&quot;, data) THEN
          UnpackTGZ (data);
        ELSE
          Msg.Error(NIL, &quot;unknown archive type: &quot;, data);
        END;
      EXCEPT ELSE END; (* cannot happen :-) *)
    ELSE
      IF OS.IsExecutable (data &amp; &quot;.tar&quot;) THEN
        UnpackTAR (data &amp; &quot;.tar&quot;);
      ELSE
        UnpackTGZ (data &amp; &quot;.tgz&quot;);
      END;
    END;
  END Unpack;

PROCEDURE <A NAME="UnpackTAR"><procedure>UnpackTAR</procedure></A> (data: TEXT) =
  VAR
    tar_process    : Process.T;
    input, stdin   : File.T;
    stdout, stderr : File.T;
  BEGIN
    Msg.Debug (&quot;unpacking:  archive = &quot;, data);

    (* get the default file handles *)
    Process.GetStandardFileHandles (stdin, stdout, stderr);

    (* open the tar file *)
    TRY
      input := FS.OpenFileReadonly (data);
    EXCEPT OSError.E (ec) =&gt;
      Msg.Error (ec, &quot;Unable to open archive: &quot;, data);
    END;

    (* create the tar process *)
    TRY
      tar_process := Process.Create (tar, TarArgs, stdin := input,
                                      stdout := stdout, stderr := stderr,
                                      wd := install_root);
    EXCEPT OSError.E (ec) =&gt;
      Msg.Error (ec, &quot;Unable to create unpacking process: &quot;, tar);
    END;

    (* close our copy of the input file *)
    TRY
      input.close ();
    EXCEPT OSError.E (ec) =&gt;
      Msg.Error (ec, &quot;Trouble closing archive: &quot;, data);
    END;

    (* wait for everybody to finish *)
    Msg.Debug (&quot;waiting for process completion...&quot;);
    EVAL Process.Wait (tar_process);
    Msg.Debug (&quot;unpacking done.&quot;);
  END UnpackTAR;

&lt;*UNUSED*&gt; PROCEDURE <A NAME="UnpackTGZWin32"><procedure>UnpackTGZWin32</procedure></A> (data: TEXT) =
  CONST
    TarArgs  = ARRAY [0..1] OF TEXT { &quot;-zxmf&quot;, &quot;-&quot; };
  VAR
    tar_process    : Process.T;
    input, stdin   : File.T;
    stdout, stderr : File.T;
  BEGIN
    Msg.Debug (&quot;unpacking:  archive = &quot;, data);

    (* get the default file handles *)
    Process.GetStandardFileHandles (stdin, stdout, stderr);

    (* open the tar file *)
    TRY
      input := FS.OpenFileReadonly (data);
    EXCEPT OSError.E (ec) =&gt;
      Msg.Error (ec, &quot;Unable to open archive: &quot;, data);
    END;

    (* create the tar process *)
    TRY
      tar_process := Process.Create (tar, TarArgs, stdin := input,
                                      stdout := stdout, stderr := stderr,
                                      wd := install_root);
    EXCEPT OSError.E (ec) =&gt;
      Msg.Error (ec, &quot;Unable to create unpacking process: &quot;, tar);
    END;

    (* close our copy of the input file *)
    TRY
      input.close ();
    EXCEPT OSError.E (ec) =&gt;
      Msg.Error (ec, &quot;Trouble closing archive: &quot;, data);
    END;

    (* wait for everybody to finish *)
    Msg.Debug (&quot;waiting for process completion...&quot;);
    EVAL Process.Wait (tar_process);
    Msg.Debug (&quot;unpacking done.&quot;);
  END UnpackTGZWin32;

PROCEDURE <A NAME="UnpackTGZ"><procedure>UnpackTGZ</procedure></A> (data: TEXT) =
  VAR
    gzip_process   : Process.T;
    tar_process    : Process.T;
    p_in, p_out    : Pipe.T;
    input, stdin   : File.T;
    stdout, stderr : File.T;
  BEGIN
    Msg.Debug (&quot;unpacking:  archive = &quot;, data);

    (* get the default file handles *)
    Process.GetStandardFileHandles (stdin, stdout, stderr);

    (* open the compressed tar file *)
    TRY
      input := FS.OpenFileReadonly (data);
    EXCEPT OSError.E (ec) =&gt;
      Msg.Error (ec, &quot;Unable to open compressed archive: &quot;, data);
    END;

    (* create a pipe for the gzip-&gt;tar connection *)
    TRY
      Pipe.Open (hr := p_out, hw := p_in);
    EXCEPT OSError.E (ec) =&gt;
      Msg.Error (ec, &quot;Unable to open a pipe for the decompressor&quot;);
    END;

    (* create the gzip process reading from the tar file *)
    TRY
      gzip_process := Process.Create (gzip, GZipArgs, stdin := input,
                                      stdout := p_in, stderr := stderr);
      Msg.Debug (gzip, &quot; &quot;, GZipArgs[0]);
    EXCEPT OSError.E (ec) =&gt;
      Msg.Error (ec, &quot;Unable to create decompression process: &quot;, gzip);
    END;

    (* create the tar process *)
    TRY
      tar_process := Process.Create (tar, TarArgs, stdin := p_out,
                                      stdout := stdout, stderr := stderr,
                                      wd := install_root);
      Msg.Debug (tar, &quot; &quot; &amp; TarArgs[0] &amp; &quot; &quot; &amp; TarArgs[1] &amp; &quot; wd = &quot;,
                 install_root);
    EXCEPT OSError.E (ec) =&gt;
      Msg.Error (ec, &quot;Unable to create unpacking process: &quot;, tar);
    END;

    (* close our copies of the pipe ends *)
    TRY
      p_in.close ();   p_out.close ();
    EXCEPT OSError.E (ec) =&gt;
      Msg.Error (ec, &quot;Trouble closing decompression pipe&quot;);
    END;

    (* close our copy of the input file *)
    TRY
      input.close ();
    EXCEPT OSError.E (ec) =&gt;
      Msg.Error (ec, &quot;Trouble closing compressed archive: &quot;, data);
    END;

    (* wait for everybody to finish *)
    Msg.Debug (&quot;waiting for process completion...&quot;);
    EVAL Process.Wait (gzip_process);
    EVAL Process.Wait (tar_process);
    Msg.Debug (&quot;unpacking done.&quot;);
  END UnpackTGZ;
</PRE>---------------------------------------------------- last minute fixups ---

<P><PRE>PROCEDURE <A NAME="RunFixups"><procedure>RunFixups</procedure></A> () =
  VAR
    fixup          : TEXT := OS.MakePath (cminstall_root, FIXUP_EXE);
    stdin          : File.T;
    stdout, stderr : File.T;
    fixup_process  : Process.T;
    fixup_args     : ARRAY [0..0] OF TEXT;
  BEGIN
    TRY
      EVAL FS.Status (fixup);
    EXCEPT OSError.E =&gt;
      RETURN; (* no fixup file *)
    END;

    Msg.Debug (&quot;starting fixup: &quot;, fixup, &quot;...&quot;);

    (* get the default file handles *)
    Process.GetStandardFileHandles (stdin, stdout, stderr);

    (* create the fixup process *)
    TRY
      fixup_args[0] := install_root;
      fixup_process := Process.Create (fixup, fixup_args, stdin := stdin,
                                       stdout := stdout, stderr := stderr,
                                       wd := install_root);
    EXCEPT OSError.E (ec) =&gt;
      Msg.Error (ec, &quot;Unable to create fixup process: &quot;, fixup);
    END;

    (* wait for it to finish *)
    Msg.Debug (&quot;waiting for process completion...&quot;);
    EVAL Process.Wait (fixup_process);
    Msg.Debug (&quot;fixup done.&quot;);
  END RunFixups;
</PRE>------------------------------------------------------------ decryption ---
 disabled
PROCEDURE KeyCheck (passwd: TEXT): BOOLEAN =
  CONST Day = 24.0d0 * 3600.0d0;
  CONST FirstWarning = 7.0d0 * Day;
  VAR key := CMKey.Decode (passwd);  expire: Time.T;
  BEGIN
    IF (key.usage = CMKey.Usage.Invalid)
    OR (key.version # CMCurrent.Version)
    OR (key.platform # CMCurrent.Platform) THEN
      RETURN FALSE;
    END;
<P>
    Out (<CODE>CM3 Installation: </CODE>, key.banner);
<P>
    IF (key.usage = CMKey.Usage.Demo) THEN
      expire := key.expiration - Time.Now ();
      IF (expire &gt; FirstWarning) THEN
        (* ok 
      <PRE>ELSIF (expire &lt;= 0.0d0) THEN
        Out (&quot;---&quot;);
        Out (&quot;--- This preview copy of CM3 has already expired.&quot;);
        BuyIt ();
        Process.Exit (1);
      ELSE
        Out (&quot;---&quot;);
        Out (&quot;--- Warning: this preview copy of CM3 will expire in &quot;,
                    Fmt.Int (ROUND (expire / Day)), &quot; days.&quot;);
        BuyIt ();
      END;
    END;

    RETURN TRUE;
  END KeyCheck;

CONST
  BuyMsg = ARRAY OF TEXT {
    &quot;To purchase a non-expiring copy of CM3, please contact:&quot;,
    &quot;&quot;,
    &quot;    Critical Mass, Inc.&quot;,
    &quot;    1770 Massachusetts Ave.&quot;,
    &quot;    Cambridge, MA 02140 USA&quot;,
    &quot;&quot;,
    &quot;    Telephone:  1 617 354 MASS    E-mail:  info@cmass.com&quot;,
    &quot;    Fax:        1 617 354 5027    Web:     www.cmass.com&quot;,
    &quot;&quot;
  };

PROCEDURE BuyIt () =
  BEGIN
    FOR i := FIRST (BuyMsg) TO LAST (BuyMsg) DO
      Out (&quot;--- &quot;, BuyMsg[i]);
    END;
  END BuyIt;
*)
</PRE>---------------------------------------------------------- network test ---

<P><PRE>&lt;* UNUSED *&gt; PROCEDURE <A NAME="TestTCP"><procedure>TestTCP</procedure></A> () =
  BEGIN
    Msg.Debug (&quot;Testing network connections&quot;);
    Msg.Debug (&quot;Network test done.&quot;);
  END TestTCP;

BEGIN
  DoIt ();
END Main.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface Glob is in:
</A><UL>
<LI><A HREF="../../patternmatching/src/Glob.i3.html#0TOP0">patternmatching/src/Glob.i3</A>
<LI><A HREF="../../suplib/src/Glob.i3.html#0TOP0">suplib/src/Glob.i3</A>
</UL>
<P>
<HR>
<A NAME="x2">interface M3ID is in:
</A><UL>
<LI><A HREF="../../m3middle/src/M3ID.i3.html#0TOP0">m3middle/src/M3ID.i3</A>
<LI><A HREF="../../m3scan/src/M3ID.i3.html#0TOP0">m3scan/src/M3ID.i3</A>
</UL>
<P>
<HR>
<A NAME="x3">interface Msg is in:
</A><UL>
<LI><A HREF="../../cm3/src/Msg.i3.html#0TOP0">cm3/src/Msg.i3</A>
<LI><A HREF="Msg.i3.html#0TOP0">cminstall/src/Msg.i3</A>
<LI><A HREF="../../m3tohtml/src/Msg.i3.html#0TOP0">m3tohtml/src/Msg.i3</A>
</UL>
<P>
<HR>
<A NAME="x4">interface OS is in:
</A><UL>
<LI><A HREF="../../cm3ide/src/utils/OS.i3.html#0TOP0">cm3ide/src/utils/OS.i3</A>
<LI><A HREF="OS.i3.html#0TOP0">cminstall/src/OS.i3</A>
<LI><A HREF="../../m3browser/src/OS.i3.html#0TOP0">m3browser/src/OS.i3</A>
</UL>
<P>
<HR>
<A NAME="x5">interface RegEx is in:
</A><UL>
<LI><A HREF="../../patternmatching/src/RegEx.i3.html#0TOP0">patternmatching/src/RegEx.i3</A>
<LI><A HREF="../../suplib/src/RegEx.i3.html#0TOP0">suplib/src/RegEx.i3</A>
</UL>
<P>
<HR>
<A NAME="x6">interface Text2 is in:
</A><UL>
<LI><A HREF="../../cm3ide/src/utils/Text2.i3.html#0TOP0">cm3ide/src/utils/Text2.i3</A>
<LI><A HREF="Text2.i3.html#0TOP0">cminstall/src/Text2.i3</A>
</UL>
<P>
<HR>
<A NAME="x7">interface TextUtils is in:
</A><UL>
<LI><A HREF="../../cit_util/src/TextUtils.i3.html#0TOP0">cit_util/src/TextUtils.i3</A>
<LI><A HREF="../../sysutils/src/TextUtils.i3.html#0TOP0">sysutils/src/TextUtils.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
