<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: cm3/src/M3Build.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>cm3/src/M3Build.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright 1996-2000 Critical Mass, Inc. All rights reserved.    
 See file COPYRIGHT-CMASS for details. 

<P><PRE>MODULE <module><implements><A HREF="M3Build.i3.html">M3Build</A></implements></module>;

IMPORT <A HREF="../../libm3/src/params/Env.i3.html">Env</A>, <A HREF="../../libm3/derived/IntArraySort.i3.html">IntArraySort</A>, <A HREF="../../libm3/derived/IntRefTbl.i3.html">IntRefTbl</A>, <A HREF="#x1">M3ID</A>, <A HREF="../../libm3/src/os/Common/Pathname.i3.html">Pathname</A>, <A HREF="../../m3core/src/text/Text.i3.html">Text</A>, <A HREF="../../libm3/derived/TextList.i3.html">TextList</A>, <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>;
IMPORT <A HREF="../../m3quake/src/Quake.i3.html">Quake</A>, <A HREF="../../m3quake/src/QValue.i3.html">QValue</A>, <A HREF="../../m3quake/src/QCode.i3.html">QCode</A>, <A HREF="../../m3quake/src/QMachine.i3.html">QMachine</A>, <A HREF="../../m3quake/src/QVal.i3.html">QVal</A>, <A HREF="../../m3quake/derived/QVSeq.i3.html">QVSeq</A>, <A HREF="../../m3quake/derived/QVTbl.i3.html">QVTbl</A>, <A HREF="../../m3middle/src/M3Timers.i3.html">M3Timers</A>;
IMPORT <A HREF="Arg.i3.html">Arg</A>, <A HREF="#x2">Builder</A>, <A HREF="M3Loc.i3.html">M3Loc</A>, <A HREF="M3Options.i3.html">M3Options</A>, <A HREF="#x3">M3Path</A>, <A HREF="M3Unit.i3.html">M3Unit</A>, <A HREF="#x4">Msg</A>, <A HREF="Utils.i3.html">Utils</A>;
FROM <A HREF="../../m3quake/src/QMachine.i3.html">QMachine</A> IMPORT PushText, PopText, PopID, PopBool;
IMPORT <A HREF="../../m3quake/src/MxConfig.i3.html">MxConfig</A>;
IMPORT <A HREF="../../libm3/src/os/Common/OSError.i3.html">OSError</A>, <A HREF="../../libm3/src/os/Common/Process.i3.html">Process</A>, <A HREF="Dirs.i3.html">Dirs</A>, <A HREF="#x5">TextUtils</A>;

TYPE
  UK = M3Unit.Kind;
  MM = M3Options.Mode;

REVEAL
  <A NAME="T">T</A> = Quake.Machine BRANDED &quot;M3Build.T&quot; OBJECT
    (* READONLY state that is fixed for the build *)
    build_pkg         : M3ID.T; (* the name of the package we're building *)
    build_pkg_dir     : M3ID.T; (* full path to the package we're building *)
    build_dir         : M3ID.T; (* name of the derived directory *)
    text_build_dir    : TEXT;   (* &quot; *)

    (* READONLY state that is fixed by the configuration file *)
    install_root      : TEXT;     (* Root directory *)
    pkg_use           : TEXT;     (* Root directory for public packages *)
    pkg_install       : TEXT;     (* Root directory for public packages *)
    bin_install       : TEXT;     (* Directory to install binaries *)
    lib_install       : TEXT;     (* Directory to install libraries *)
    emacs_install     : TEXT;     (* Directory to install emacs e-lisp code *)
    doc_install       : TEXT;     (* Directory to install documents *)
    man_install       : TEXT;     (* Directory to install man pages *)
    html_install      : TEXT;     (* Directory to install HTML files *)
    have_pkgtools     : BOOLEAN;  (* Using the SRC package tools ? *)
    at_SRC            : BOOLEAN;  (* include SRC-only packages ? *)
    system_libs       : QVTbl.T;  (* Available system libraries *)
    system_liborder   : QVSeq.T;  (* link order for the system libraries *)

    (* major mode, fixed at the beginning of the run *)
    mode              : MM;

    (* per processed package state *)
    cur_pkg           : M3ID.T; (* the name of the package we're processing *)
    cur_pkg_dir       : M3ID.T; (* full path of the package we're processing *)

    (* cache of package name -&gt; directory *)
    pkg_cache         : IntRefTbl.T; (* pkg name -&gt; current path to package *)
    pkg_overrides     : IntRefTbl.T; (* pkg name -&gt; override path *)
    already_warned    : BOOLEAN;     (* warned about overriding build pkg? *)

    (* cache for PathOf() and PkgSubdir() *)
    path_of_path      : TEXT; (* records result of last path() call in PathOf *)
    path_of_base      : TEXT; (* records result of normalize in PathOf *)
    pkg_subdir_path   : TEXT; (* result of last path() call in PkgSubdir *)
    pkg_subdir_base   : TEXT; (* result of last normalize in PkgSubdir *)

    (* maps of imported packages *)
    imports           : IntRefTbl.T;  (* imported package names -&gt; versions *)

    (* various sources *)
    units             : M3Unit.Set;   (* source units *)
    tfile_args        : TxtList;
    derived           : IntRefTbl.T;  (* derived files *)
    sys_libs          : IntRefTbl.T;  (* imported system libraries *)
    ship_units        : M3Unit.Set;   (* explicitly shipped units *)

    (* ship &amp; install cache *)
    listing_width     : INTEGER;
    last_src_dir      : TEXT;
    last_install_dir  : TEXT;
    last_ship_dir     : TEXT;
    all_ship_dirs     : IntRefTbl.T;

    (* current compiler options *)
    current_options   : CompilerOptions;
    build_shared      : BOOLEAN;
  END;

TYPE
  CompilerOptions = REF RECORD
    debug, optimize : BOOLEAN;
    next : CompilerOptions;
  END;

CONST
  M3Exports   = &quot;.M3EXPORTS&quot;;   (* file of exported quake commands *)
  M3Ship      = &quot;.M3SHIP&quot;;      (* ship commands *)
  M3Overrides = &quot;.M3OVERRIDES&quot;; (* marker to indicate override use *)
  M3Web       = &quot;.M3WEB&quot;;       (* compiler support for browser *)
  M3TFile     = &quot;.M3IMPTAB&quot;;    (* import table for external compilers *)
  ModeGroupR  = &quot;0644&quot;;
  ModeGroupW  = &quot;0664&quot;;
  ModeXGroupR = &quot;0755&quot;;
  ModeXGroupW = &quot;0775&quot;;
  RPCR  = &quot;)&quot; &amp; Wr.EOL;   (* right paren, carriage return *)
  QRPCR = &quot;\&quot;)&quot; &amp; Wr.EOL; (* quote, right paren, carriage return *)
  C     = &quot;, &quot;;           (* comma *)
  CQ    = &quot;, \&quot;&quot;;         (* comma, quote *)
  QC    = &quot;\&quot;, &quot;;         (* quote, comma *)
  QCQ   = &quot;\&quot;, \&quot;&quot;;       (* quote, comma, quote *)

VAR
  ModeF := ModeGroupR;
  ModeX := ModeXGroupR;

TYPE
  TxtList = RECORD
    head, tail: TextList.T;
  END;

CONST
  IntfExtensions = ARRAY OF TEXT { &quot;.ic&quot;, &quot;.is&quot;, &quot;.io&quot;, &quot;_i.o&quot; };
  ImplExtensions = ARRAY OF TEXT { &quot;.mc&quot;, &quot;.ms&quot;, &quot;.mo&quot;, &quot;_m.o&quot; };
  CExtensions    = ARRAY OF TEXT { &quot;.s&quot;, &quot;.o&quot;, &quot;.obj&quot; };
  SExtensions    = ARRAY OF TEXT { &quot;.o&quot;, &quot;.obj&quot; };
  NoExtension    = ARRAY OF TEXT { &quot;&quot; };
</PRE>-------------------------------------------------- external entry points --

<P><PRE>PROCEDURE <A NAME="NewMachine"><procedure>NewMachine</procedure></A> (): T =
  VAR
    map := Quake.NewIDMap (Str2ID, Txt2ID, ID2Txt);
    t := NEW (T).init (map);
  BEGIN
    InitBuiltins (t);
    RETURN t;
  END NewMachine;

PROCEDURE <A NAME="SetUp"><procedure>SetUp</procedure></A> (t: T;  pkg, to_pkg, build_dir: TEXT)
  RAISES {Quake.Error} =
  BEGIN
    (* some more config dependent backward compatibility hacks... *)
    Quake.Define (t, &quot;M3SEARCH_TABLES&quot;, &quot;-T&quot; &amp; M3TFile);
    Quake.Define (t, &quot;DEFAULT_BUILD_DIR&quot;, GetConfig (t, &quot;BUILD_DIR&quot;));
    Quake.Define (t, &quot;M3&quot;, M3Path.New (GetConfig (t, &quot;BIN_USE&quot;), &quot;cm3&quot;));
    Quake.Define (t, &quot;PACKAGE_DIR&quot;, pkg);

    t.build_pkg       := M3ID.Add (Pathname.Last (pkg));
    t.build_pkg_dir   := M3ID.Add (pkg);
    t.build_dir       := M3ID.Add (build_dir);
    t.text_build_dir  := build_dir;

    (* M3Path.New is used to canonicalize the paths -- to remove dots *)

    t.pkg_use         := M3Path.New (GetConfig (t, &quot;PKG_USE&quot;));
</PRE><BLOCKQUOTE><EM> not in Quake.Machine
    t.bin_use         := M3Path.New (GetConfig (t, <CODE>BIN_USE</CODE>));
    t.lib_use         := M3Path.New (GetConfig (t, <CODE>LIB_USE</CODE>));
</EM></BLOCKQUOTE><PRE>
    t.pkg_install     := M3Path.New (GetConfig (t, &quot;PKG_INSTALL&quot;));
    t.install_root    := M3Path.New (GetConfig (t, &quot;INSTALL_ROOT&quot;));
    t.bin_install     := M3Path.New (GetConfig (t, &quot;BIN_INSTALL&quot;));
    t.lib_install     := M3Path.New (GetConfig (t, &quot;LIB_INSTALL&quot;));
    t.emacs_install   := M3Path.New (GetConfig (t, &quot;EMACS_INSTALL&quot;));
    t.doc_install     := M3Path.New (GetConfig (t, &quot;DOC_INSTALL&quot;));
    t.man_install     := M3Path.New (GetConfig (t, &quot;MAN_INSTALL&quot;));
    t.html_install    := M3Path.New (GetConfig (t, &quot;HTML_INSTALL&quot;));
    t.have_pkgtools   := GetConfigBool (t, &quot;HAVE_PKGTOOLS&quot;);
    t.at_SRC          := GetConfigBool (t, &quot;AT_SRC&quot;);
    t.system_liborder := QVal.ToArray (t, ConfigDefn (t, &quot;SYSTEM_LIBORDER&quot;).value);
    t.system_libs     := QVal.ToTable (t, ConfigDefn (t, &quot;SYSTEM_LIBS&quot;).value);

    t.cur_pkg         := t.build_pkg;
    t.cur_pkg_dir     := t.build_pkg_dir;

    t.pkg_cache       := NewMap ();
    t.pkg_overrides   := NewMap ();
    t.already_warned  := FALSE;
    EVAL t.pkg_cache.put (t.build_pkg, to_pkg);

    t.path_of_path    := &quot;&quot;;
    t.path_of_base    := &quot;&quot;;
    t.pkg_subdir_path := &quot;&quot;;
    t.pkg_subdir_base := &quot;&quot;;

    t.listing_width   := 0;
    t.last_src_dir    := &quot;&quot;;
    t.last_install_dir:= &quot;&quot;;
    t.last_ship_dir   := &quot;&quot;;
    t.all_ship_dirs   := NewMap ();

    t.current_options := NEW (CompilerOptions);

    InitGlobals (t);
  END SetUp;

PROCEDURE <A NAME="Run"><procedure>Run</procedure></A> (t: T;  makefile: TEXT)
  RAISES {Quake.Error, Thread.Alerted} =
  BEGIN
    IF groupWritable THEN
      ModeF := ModeGroupW;
      ModeX := ModeXGroupW;
    END;
    t.mode := M3Options.major_mode;

    IF (t.mode = MM.Build) THEN
      (* let m3ship know that we've built at least once... *)
      Utils.Remove (M3Ship);
      Utils.Remove (M3Overrides);
      TouchFile (M3Ship);
    END;
    DeleteDeriveds (t, M3Ship, NoExtension);
    DeleteDeriveds (t, M3Overrides, NoExtension);

    Quake.Run (t, makefile);
    MakeRoom (t, 999999);  (* finish any partial listings *)
  END Run;

PROCEDURE <A NAME="RealClean"><procedure>RealClean</procedure></A> () =
  VAR
    targetdir, base, parent: Pathname.T;
  BEGIN
    (* We are already in the TARGET build directory *)
    TRY
      targetdir := Process.GetWorkingDirectory ();
    EXCEPT OSError.E(ec) =&gt;
      Msg.FatalError (ec, &quot;unable to get full directory path: &quot;, targetdir);
    END;
    base   := Pathname.Last (targetdir);
    parent := Pathname.Prefix (targetdir);
    TRY
      Process.SetWorkingDirectory (parent);
    EXCEPT OSError.E(ec) =&gt;
      Msg.FatalError (ec, &quot;unable to move to directory: &quot;, parent);
    END;
    Dirs.RemoveRecursively(base);
  END RealClean;

PROCEDURE <A NAME="NewMap"><procedure>NewMap</procedure></A> (): IntRefTbl.T =
  BEGIN
    RETURN NEW (IntRefTbl.Default).init ();
  END NewMap;
</PRE>-------------------------------------------- <CODE>global</CODE> var initialization --

<P><PRE>PROCEDURE <A NAME="InitGlobals"><procedure>InitGlobals</procedure></A> (t: T) =
  (* initializes the global state for a new build.  That is, forget
     everything we know about source files and imports... *)
  BEGIN
    t.imports := NewMap ();
    M3Unit.InitSet (t.units);
    InitTxtList (t.tfile_args);
    t.derived := NewMap ();
    t.sys_libs := NewMap ();
    M3Unit.InitSet (t.ship_units);
    EVAL t.sys_libs.put (M3ID.Add (&quot;LIBC&quot;), NIL);
    t.current_options.debug := FALSE;
    t.current_options.optimize := FALSE;
    t.build_shared := TRUE;
  END InitGlobals;
</PRE>------------------------------------------------------------------ units --

<P><PRE>PROCEDURE <A NAME="AddSource"><procedure>AddSource</procedure></A> (t: T;  nm: M3ID.T;  kind: UK;  hidden: BOOLEAN)
  RAISES {Quake.Error} =
  VAR
    name := M3ID.ToText (nm);
    dir  := M3Path.New (PkgSubdir (t), Pathname.Prefix (name));
    base := M3ID.Add (Pathname.Last (name));
    loc  := Location (t, t.cur_pkg, M3ID.Add (dir));
    unit := M3Unit.New (base, kind, loc, hidden := hidden, imported := FALSE);
  BEGIN
    unit.debug := t.current_options.debug;
    unit.optimize := t.current_options.optimize;
    M3Unit.Add (t.units, unit);
    DeleteObjects (t, base, kind);
  END AddSource;

PROCEDURE <A NAME="AddDerived"><procedure>AddDerived</procedure></A> (t: T;  name: M3ID.T;  kind: UK;  hidden: BOOLEAN) =
  VAR
    loc  := Location (t, t.build_pkg, t.build_dir);
    unit := M3Unit.New (name, kind, loc, hidden := hidden, imported := FALSE);
    file := M3Unit.FileName (unit);
  BEGIN
    unit.debug := t.current_options.debug;
    unit.optimize := t.current_options.optimize;
    EVAL t.derived.put (M3ID.Add (file), NIL);
    M3Unit.Add (t.units, unit);
    DeleteDeriveds (t, file, NoExtension);
    DeleteObjects (t, name, kind);
  END AddDerived;

PROCEDURE <A NAME="DeleteObjects"><procedure>DeleteObjects</procedure></A> (t: T;  nm: M3ID.T;  kind: UK) =
  VAR name := M3ID.ToText (nm);
  BEGIN
    CASE kind OF
    | UK.I3 =&gt; DeleteDeriveds (t, name, IntfExtensions);
    | UK.M3 =&gt; DeleteDeriveds (t, name, ImplExtensions);
    | UK.C  =&gt; DeleteDeriveds (t, name, CExtensions);
    | UK.S  =&gt; DeleteDeriveds (t, name, SExtensions);
    ELSE (* skip *)
    END;
  END DeleteObjects;
</PRE>------------------------------------------------------------- text lists --

<P><PRE>PROCEDURE <A NAME="InitTxtList"><procedure>InitTxtList</procedure></A> (VAR x: TxtList) =
  BEGIN
    x.head := NIL;  x.tail := NIL;
  END InitTxtList;

PROCEDURE <A NAME="AddText"><procedure>AddText</procedure></A> (VAR x: TxtList;  txt: TEXT) =
  VAR z := NEW (TextList.T, head := txt, tail := NIL);
  BEGIN
    IF (x.head = NIL)
      THEN x.head      := z;
      ELSE x.tail.tail := z;
    END;
    x.tail := z;
  END AddText;

PROCEDURE <A NAME="AddTexts"><procedure>AddTexts</procedure></A> (VAR x: TxtList;  a, b, c: TEXT := NIL) =
  BEGIN
    IF (a # NIL) THEN AddText (x, a); END;
    IF (b # NIL) THEN AddText (x, b); END;
    IF (c # NIL) THEN AddText (x, c); END;
  END AddTexts;
</PRE>------------------------------------------------------ builtin functions --

<P><PRE>TYPE
  Builtin = RECORD
    name   : TEXT;
    proc   : QCode.BuiltinProc;
    n_args : INTEGER;
    isFunc : BOOLEAN;
  END;

CONST
  Builtins = ARRAY OF Builtin {
    (* packages &amp; locations *)
    Builtin {&quot;Pkg&quot;,                           DoPkg,             1, TRUE},
    Builtin {&quot;override&quot;,                      DoOverride,        2, FALSE},
    Builtin {&quot;path_of&quot;,                       DoPathOf,          1, TRUE},
    Builtin {&quot;pkg_subdir&quot;,                    DoPkgSubdir,       0, TRUE},

    (* names *)
    Builtin {&quot;program_name&quot;,                  DoProgramName,     1, TRUE},
    Builtin {&quot;library_name&quot;,                  DoLibraryName,     1, TRUE},

    (* calls in the generated .M3EXPORT files *)
    Builtin {&quot;_define_lib&quot;,                   DoDefineLib,       1, FALSE},
    Builtin {&quot;_define_pgm&quot;,                   DoDefinePgm,       1, FALSE},
    Builtin {&quot;_import_template&quot;,              DoImportTmpl,      3, FALSE},
    Builtin {&quot;_import_m3lib&quot;,                 DoImportM3Lib,     3, FALSE},
    Builtin {&quot;_import_otherlib&quot;,              DoImportOLib,      3, FALSE},
    Builtin {&quot;_map_add_interface&quot;,            DoMapInterface,    4, FALSE},
    Builtin {&quot;_map_add_generic_interface&quot;,    DoMapGenIntf,      4, FALSE},
    Builtin {&quot;_map_add_module&quot;,               DoMapModule,       4, FALSE},
    Builtin {&quot;_map_add_generic_module&quot;,       DoMapGenImpl,      4, FALSE},
    Builtin {&quot;_map_add_c&quot;,                    DoMapCSource,      4, FALSE},
    Builtin {&quot;_map_add_h&quot;,                    DoMapHSource,      4, FALSE},
    Builtin {&quot;_map_add_s&quot;,                    DoMapSSource,      4, FALSE},

    (* compiler options *)
    Builtin {&quot;m3_debug&quot;,                      DoDebug,           1, FALSE},
    Builtin {&quot;m3_optimize&quot;,                   DoOptimize,        1, FALSE},
    Builtin {&quot;build_shared&quot;,                  DoShared,          0, FALSE},
    Builtin {&quot;build_standalone&quot;,              DoStandalone,      0, FALSE},

    (* derived files *)
    Builtin {&quot;m3_compile_only&quot;,               DoCompileOnly,     0, FALSE},
    Builtin {&quot;m3_finish_up&quot;,                  DoFinishUp,        0, FALSE},

    (* predefined system libraries *)
    Builtin {&quot;import_sys_lib&quot;,                DoImportSysLib,    1, FALSE},

    (* options *)
    Builtin {&quot;m3_option&quot;,                     DoM3Option,        1, FALSE},
    Builtin {&quot;remove_m3_option&quot;,              DoRemoveM3Option,  1, FALSE},

    (* deleting *)
    Builtin {&quot;deriveds&quot;,                      DoDeriveds,        2, FALSE},

    (* imports *)
    Builtin {&quot;include_dir&quot;,                   DoIncludeDir,      1, FALSE},
    Builtin {&quot;include_pkg&quot;,                   DoIncludePkg,      1, FALSE},
    Builtin {&quot;import&quot;,                        DoImport,          1, FALSE},
    Builtin {&quot;import_version&quot;,                DoImportVersion,   2, FALSE},
    Builtin {&quot;import_obj&quot;,                    DoImportObj,       1, FALSE},
    Builtin {&quot;import_lib&quot;,                    DoImportLib,       2, FALSE},

    (* objects *)
    Builtin {&quot;pgm_object&quot;,                    DoPgmObject,       2, FALSE},

    (* sources *)
    Builtin {&quot;source&quot;,                        DoSource,          1, FALSE},
    Builtin {&quot;pgm_source&quot;,                    DoPgmSource,       1, FALSE},
    Builtin {&quot;interface&quot;,                     DoIntf,            1, FALSE},
    Builtin {&quot;Interface&quot;,                     DoIntfX,           1, FALSE},
    Builtin {&quot;implementation&quot;,                DoImpl,            1, FALSE},
    Builtin {&quot;module&quot;,                        DoModule,          1, FALSE},
    Builtin {&quot;Module&quot;,                        DoModuleX,         1, FALSE},
    Builtin {&quot;h_source&quot;,                      DoHSource,         1, FALSE},
    Builtin {&quot;c_source&quot;,                      DoCSource,         1, FALSE},
    Builtin {&quot;s_source&quot;,                      DoSSource,         1, FALSE},
    Builtin {&quot;ship_source&quot;,                   DoShipSource,      1, FALSE},

    (* generics *)
    Builtin {&quot;generic_interface&quot;,             DoGenIntf,         1, FALSE},
    Builtin {&quot;Generic_interface&quot;,             DoGenIntfX,        1, FALSE},
    Builtin {&quot;generic_implementation&quot;,        DoGenImpl,         1, FALSE},
    Builtin {&quot;Generic_implementation&quot;,        DoGenImplX,        1, FALSE},
    Builtin {&quot;generic_module&quot;,                DoGenModule,       1, FALSE},
    Builtin {&quot;Generic_module&quot;,                DoGenModuleX,      1, FALSE},
    Builtin {&quot;build_generic_intf&quot;,            DoBuildGenIntf,    4, FALSE},
    Builtin {&quot;build_generic_impl&quot;,            DoBuildGenImpl,    3, FALSE},

    (* derived sources *)
    Builtin {&quot;derived_interface&quot;,             DoDerivedIntf,     2, FALSE},
    Builtin {&quot;derived_implementation&quot;,        DoDerivedImpl,     1, FALSE},
    Builtin {&quot;derived_c&quot;,                     DoDerivedC,        1, FALSE},
    Builtin {&quot;derived_h&quot;,                     DoDerivedH,        1, FALSE},

    (* hiding/exporting *)
    Builtin {&quot;hide_interface&quot;,                DoHideIntf,        1, FALSE},
    Builtin {&quot;hide_generic_interface&quot;,        DoHideGenIntf,     1, FALSE},
    Builtin {&quot;hide_generic_implementation&quot;,   DoHideGenImpl,     1, FALSE},
    Builtin {&quot;export_interface&quot;,              DoExportIntf,      1, FALSE},
    Builtin {&quot;export_generic_interface&quot;,      DoExportGenIntf,   1, FALSE},
    Builtin {&quot;export_generic_implementation&quot;, DoExportGenImpl,   1, FALSE},

    (* templates *)
    Builtin {&quot;template&quot;,                      DoTemplate,        1, FALSE},

    (* library building *)
    Builtin {&quot;library&quot;,                       DoLibrary,         1, FALSE},
    Builtin {&quot;Library&quot;,                       DoLibrary,         1, FALSE},

    (* program building *)
    Builtin {&quot;program&quot;,                       DoProgram,         1, FALSE},
    Builtin {&quot;Program&quot;,                       DoProgramX,        1, FALSE},
    Builtin {&quot;c_program&quot;,                     DoCProgram,        1, FALSE},
    Builtin {&quot;C_program&quot;,                     DoCProgramX,       1, FALSE},

    (* man pages *)
    Builtin {&quot;manPage&quot;,                       DoManPage,         2, FALSE},
    Builtin {&quot;ManPage&quot;,                       DoManPageX,        2, FALSE},

    (* emacs *)
    Builtin {&quot;Gnuemacs&quot;,                      DoGnuEmacs,        1, FALSE},
    Builtin {&quot;CompiledGnuemacs&quot;,              DoCompiledEmacs,   1, FALSE},

    (* &quot;-find&quot; support *)
    Builtin {&quot;find_unit&quot;,                     DoFindUnit,        2, FALSE},
    Builtin {&quot;enum_units&quot;,                    DoEnumUnits,       1, FALSE},

    (* export functions *)
    Builtin {&quot;install_sources&quot;,               DoInstallSources,  0, FALSE},
    Builtin {&quot;install_derived&quot;,               DoInstallDerived,  1, FALSE},
    Builtin {&quot;install_derived_link&quot;,          DoInstallDerivedSymbolicLink,   2, FALSE},
    Builtin {&quot;install_derived_symbolic_link&quot;, DoInstallDerivedSymbolicLink,   2, FALSE},
    Builtin {&quot;install_derived_hard_link&quot;,     DoInstallDerivedHardLink,   2, FALSE},
    Builtin {&quot;install_link_to_derived&quot;,       DoInstallSymbolLinkToDerived, 2, FALSE},
    Builtin {&quot;install_symbolic_link_to_derived&quot;, DoInstallSymbolLinkToDerived, 2, FALSE},
    Builtin {&quot;install_hard_link_to_derived&quot;,  DoInstallHardLinkToDerived, 2, FALSE},
    Builtin {&quot;install_symbolic_link&quot;,         DoInstallSymbolLink, 2, FALSE},
    Builtin {&quot;install_file&quot;,                  DoInstallFile,     3, FALSE},

    (* installation functions *)
    Builtin {&quot;BindExport&quot;,                    DoBindExport,      1, FALSE},
    Builtin {&quot;BinExport&quot;,                     DoBinExport,       1, FALSE},
    Builtin {&quot;LibdExport&quot;,                    DoLibdExport,      1, FALSE},
    Builtin {&quot;LibExport&quot;,                     DoLibExport,       1, FALSE},
    Builtin {&quot;EmacsdExport&quot;,                  DoEmacsdExport,    1, FALSE},
    Builtin {&quot;EmacsExport&quot;,                   DoEmacsExport,     1, FALSE},
    Builtin {&quot;DocdExport&quot;,                    DoDocdExport,      1, FALSE},
    Builtin {&quot;DocExport&quot;,                     DoDocExport,       1, FALSE},
    Builtin {&quot;MandExport&quot;,                    DoMandExport,      2, FALSE},
    Builtin {&quot;ManExport&quot;,                     DoManExport,       2, FALSE},
    Builtin {&quot;HtmlExport&quot;,                    DoHtmlExport,      1, FALSE},
    Builtin {&quot;RootExport&quot;,                    DoRootExport,      2, FALSE},
    Builtin {&quot;RootdExport&quot;,                   DoRootdExport,     2, FALSE},

    (* misc *)
    Builtin {&quot;gen_m3exports&quot;,                 DoGenM3Exports,    1, FALSE},
    Builtin {&quot;generate_tfile&quot;,                DoGenTFile,        0, FALSE},
    Builtin {&quot;delete_file&quot;,                   DoDeleteFile,      1, FALSE},
    Builtin {&quot;link_file&quot;,                     DoSymbolicLinkFile, 2, FALSE},
    Builtin {&quot;symbolic_link_file&quot;,            DoSymbolicLinkFile, 2, FALSE},
    Builtin {&quot;hard_link_file&quot;,                DoHardLinkFile,    2, FALSE}
  };

PROCEDURE <A NAME="InitBuiltins"><procedure>InitBuiltins</procedure></A> (t: T) =
  VAR v: QValue.T;  info: QCode.ProcInfo;  bind: QValue.Binding;
  BEGIN
    TRY
      FOR i := FIRST (Builtins) TO LAST (Builtins) DO
        WITH z = Builtins[i] DO
          info         := NEW (QCode.ProcInfo);
          info.name    := M3ID.Add (z.name);
          info.n_args  := z.n_args;
          info.builtin := TRUE;
          info.isFunc  := z.isFunc;
          info.handler := z.proc;

          v.kind := QValue.Kind.Proc;
          v.ref  := NEW (QValue.Proc, info := info, env := NIL);
          v.int  := 0;
          t.put (info.name, v);

          (* make the definition &quot;readonly&quot; *)
          bind := t.lookup (info.name);
          bind.readonly := TRUE;
        END;
      END;

      (* defined for backward compatibility *)
      Quake.Define (t, &quot;LOCAL&quot;,    &quot;local&quot;);
      Quake.Define (t, &quot;IMPORTED&quot;, &quot;&quot;);
      Quake.Define (t, &quot;HIDDEN&quot;,   &quot;hidden&quot;);
      Quake.Define (t, &quot;VISIBLE&quot;,  &quot;&quot;);
      Quake.Define (t, &quot;CR&quot;,       Wr.EOL);
      Quake.Define (t, &quot;SL&quot;,       M3Path.SlashText);

      DefineArray (t, &quot;intf_extensions&quot;, IntfExtensions);
      DefineArray (t, &quot;impl_extensions&quot;, ImplExtensions);
      DefineArray (t, &quot;c_extensions&quot;,    CExtensions);
      DefineArray (t, &quot;s_extensions&quot;,    SExtensions);
      DefineArray (t, &quot;no_extension&quot;,    NoExtension);

    EXCEPT Quake.Error (msg) =&gt;
      Msg.FatalError (NIL, &quot;unable to define M3/quake builtins: &quot;, msg);
    END;
  END InitBuiltins;

PROCEDURE <A NAME="DefineArray"><procedure>DefineArray</procedure></A> (t: T;  nm: TEXT;  READONLY arr: ARRAY OF TEXT)
  RAISES {Quake.Error} =
  VAR v: QValue.T;  seq := NEW (QVSeq.T).init (NUMBER (arr));
  BEGIN
    FOR i := FIRST (arr) TO LAST (arr) DO
      v.kind := QValue.Kind.String;
      v.int  := M3ID.Add (arr[i]);
      v.ref  := NIL;
      seq.addhi (v);
    END;
    v.kind := QValue.Kind.Array;
    v.int  := 0;
    v.ref  := seq;
    t.put (M3ID.Add (nm), v);
  END DefineArray;
</PRE>------------------------------------------------------ package locations --

<P><PRE>PROCEDURE <A NAME="DoPkg"><procedure>DoPkg</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);
  BEGIN
    PushText (t, Pkg (t, PopID (t)));
  END DoPkg;

PROCEDURE <A NAME="Pkg"><procedure>Pkg</procedure></A> (t: T;  nm: M3ID.T): TEXT =
  (* returns the path currently used to reach package 'x' *)
  VAR ref: REFANY;  dir: TEXT;
  BEGIN
    IF    t.pkg_cache.get (nm, ref)     THEN  RETURN NARROW (ref, TEXT);
    ELSIF t.pkg_overrides.get (nm, ref) THEN  dir := NARROW (ref, TEXT);
    ELSE                                      dir := t.pkg_use;
    END;
    dir := M3Path.New (dir, M3ID.ToText (nm));
    EVAL t.pkg_cache.put (nm, dir);
    RETURN dir;
  END Pkg;

PROCEDURE <A NAME="DoOverride"><procedure>DoOverride</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  pkg: M3ID.T;  dir: TEXT;
  BEGIN
    dir := PopText (t);
    pkg := PopID (t);
    Override (t, pkg, dir);
  END DoOverride;
</PRE> Host and Target paths sometimes get confused, leading to many warnings such
   as: package <CODE>libm3</CODE> is already overridden to C:\dev2\cm3.2/m3-libs,
   ignoring new override to C:/dev2/cm3.2/m3-libs. PathEqual is defined as
   Text.Equal or Text.Equal(replacing backward slashes with forward slashes).
   It would also be reasonable to be case insensitive if the path contains any
   backward slashes, or if they both contain colon as the second character. 
<PRE>PROCEDURE <A NAME="OverrideEqual"><procedure>OverrideEqual</procedure></A>(a: TEXT; b: TEXT): BOOLEAN =
  VAR
    a_Length: CARDINAL;
    b_Length: CARDINAL;
    a_BackwardSlash: INTEGER;
    b_BackwardSlash: INTEGER;
  BEGIN
    IF Text.Equal(a, b) THEN
      RETURN TRUE;
    END;
    a_Length := Text.Length(a);
    b_Length := Text.Length(b);
    IF a_Length # b_Length THEN
      RETURN FALSE;
    END;
    a_BackwardSlash := Text.FindChar(a, '\\');
    b_BackwardSlash := Text.FindChar(b, '\\');
    IF (a_BackwardSlash = -1) AND (b_BackwardSlash = -1) THEN
      RETURN FALSE;
    END;
    a := TextUtils.SubstChar(a, '\\', '/');
    b := TextUtils.SubstChar(b, '\\', '/');
    RETURN Text.Equal(a, b);
  END OverrideEqual;

PROCEDURE <A NAME="Override"><procedure>Override</procedure></A> (t: T;  pkg: M3ID.T;  dir: TEXT) =
  (* establish an override for the location of package &quot;pkg&quot; *)
  VAR  ref: REFANY;  pkg_txt := M3ID.ToText (pkg);
  BEGIN
    IF t.build_pkg = pkg THEN
      IF t.already_warned THEN RETURN; END;
      IF M3Options.major_mode = MM.Depend THEN
        Msg.Verbose (&quot;ignoring override(\&quot;&quot;, pkg_txt, QCQ, dir, QRPCR);
      ELSE
        Msg.Info (&quot;ignoring override(\&quot;&quot;, pkg_txt, QCQ, dir, QRPCR);
      END;
      t.already_warned := TRUE;
    ELSIF t.pkg_overrides.get (pkg, ref) THEN
      IF NOT OverrideEqual (dir, ref) THEN
        IF M3Options.major_mode = MM.Depend THEN
          Msg.Verbose (&quot;package \&quot;&quot;, pkg_txt, &quot;\&quot; is already overridden to &quot;,
                       ref, &quot;, ignoring new override to &quot; &amp; dir &amp; Wr.EOL);
        ELSE
          Msg.Info (&quot;package \&quot;&quot;, pkg_txt, &quot;\&quot; is already overridden to &quot;,
                    ref, &quot;, ignoring new override to &quot;, dir &amp; Wr.EOL);
        END;
      END;
    ELSE
      EVAL t.pkg_overrides.put (pkg, dir);
      EVAL t.pkg_cache.put (pkg, M3Path.New (dir, pkg_txt));
    END;
  END Override;

PROCEDURE <A NAME="Include"><procedure>Include</procedure></A> (t: T;  file: TEXT)
  RAISES {Quake.Error, Thread.Alerted} =
  BEGIN
    (* We cannot be sure that _any_ packages are there when we compute
       the package dependencies. If an appropriate .M3EXPORTS file cannot
       be found, we simply create a dummy unit representing the package
       import. *)
    IF t.mode # MM.Depend OR Utils.IsFile(file) THEN
      t.include (file);
    ELSE
      Msg.Debug (&quot;simulating inclusion of &quot;, file, Wr.EOL);
      VAR
        lib, pkg, subdir, last: TEXT;
        pkg_id, subdir_id, lib_id: M3ID.T;
        loc: M3Loc.T;
      BEGIN
        IF file # NIL THEN
          last := Pathname.Last(file);
          IF last # NIL AND Text.Equal(last, &quot;.M3EXPORTS&quot;) THEN
            file := Pathname.Prefix(file);
            subdir := Pathname.Last(file);
            file := Pathname.Prefix(file);
            pkg := Pathname.Last(file);
            pkg_id := M3ID.Add(pkg);
            subdir_id := M3ID.Add(subdir);
            lib := pkg &amp; &quot;_unknown&quot;;
            lib_id := M3ID.Add(lib);
            loc := Location (t, pkg_id, subdir_id);
            M3Unit.AddNew (t.units, lib_id, UK.M3LIB, loc, hidden := TRUE,
                           imported := TRUE);
          END;
        END;
      END;
    END;
  END Include;
</PRE>------------------------------------------------------ general locations --

<P><PRE>PROCEDURE <A NAME="Location"><procedure>Location</procedure></A> (t: T;  pkg, subdir: M3ID.T): M3Loc.T =
  (* Return the full path that identifies the given subdirectory
     within the package. *)
  VAR pkg_dir: TEXT;
  BEGIN
    IF (pkg = M3Loc.noPkg)
      THEN pkg_dir := NIL;
      ELSE pkg_dir := Pkg (t, pkg);
    END;
    RETURN M3Loc.New (pkg, subdir, pkg_dir);
  END Location;
</PRE>--------------------------------------------------------- relative paths --

<P><PRE>PROCEDURE <A NAME="DoPathOf"><procedure>DoPathOf</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);
  BEGIN
    PushText (t, PathOf (t, PopText (t)));
  END DoPathOf;

PROCEDURE <A NAME="PathOf"><procedure>PathOf</procedure></A> (t: T;  x: TEXT): TEXT
  (* Returns the path needed to reach 'x' from the build directory *)
  RAISES {Quake.Error} =
  VAR ref: REFANY;  p: TEXT;
  BEGIN
    IF t.derived.get (M3ID.Add (x), ref) THEN
      (* This initial lookup in derived_sources allows packages (such as
      ** netobj) that were written without derived sources in mind to work
      ** without modification.
      *)
      RETURN x;
    END;

    p := t.cur_path ();
    IF NOT Text.Equal (p, t.path_of_path) THEN
      t.path_of_path := p;
      t.path_of_base := M3Path.New (Pkg (t, t.cur_pkg), PkgSubdir (t));
    END;
    RETURN M3Path.New (t.path_of_base, x);
  END PathOf;

PROCEDURE <A NAME="DoPkgSubdir"><procedure>DoPkgSubdir</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);
  BEGIN
    PushText (t, PkgSubdir (t));
  END DoPkgSubdir;

PROCEDURE <A NAME="PkgSubdir"><procedure>PkgSubdir</procedure></A> (t: T): TEXT
  (* returns the path needed to reach the current directory from
     the current package *)
  RAISES {Quake.Error} =
  VAR p := t.cur_path ();
  BEGIN
    IF NOT Text.Equal (p, t.pkg_subdir_path) THEN
      t.pkg_subdir_path := p;
      t.pkg_subdir_base := t.normalize (M3ID.ToText (t.cur_pkg_dir),
                                        t.pkg_subdir_path);
    END;
    RETURN t.pkg_subdir_base;
  END PkgSubdir;
</PRE>------------------------------------------------------------------ names --

<P><PRE>PROCEDURE <A NAME="DoProgramName"><procedure>DoProgramName</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);
  BEGIN
    PushText (t, M3Path.ProgramName (PopText (t)));
  END DoProgramName;

PROCEDURE <A NAME="DoLibraryName"><procedure>DoLibraryName</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);
  BEGIN
    PushText (t, M3Path.LibraryName (PopText (t)));
  END DoLibraryName;
</PRE>------------------------------------- calls used in generated files only --

<P><PRE>PROCEDURE <A NAME="DoDefineLib"><procedure>DoDefineLib</procedure></A> (&lt;*UNUSED*&gt; m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER) =
  BEGIN
  END DoDefineLib;

PROCEDURE <A NAME="DoDefinePgm"><procedure>DoDefinePgm</procedure></A> (&lt;*UNUSED*&gt; m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER) =
  BEGIN
  END DoDefinePgm;

PROCEDURE <A NAME="DoImportTmpl"><procedure>DoImportTmpl</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error, Thread.Alerted} =
  VAR t := Self (m);  pkg: M3ID.T;  file, subdir: TEXT;
  BEGIN
    subdir := PopText (t);
    pkg    := PopID (t);
    file   := PopText (t);
    Include (t, M3Path.New (Pkg (t, pkg), subdir, file));
  END DoImportTmpl;

PROCEDURE <A NAME="DoImportM3Lib"><procedure>DoImportM3Lib</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  lib, pkg, subdir: M3ID.T;  loc: M3Loc.T;
  BEGIN
    subdir := PopID (t);
    pkg    := PopID (t);
    lib    := PopID (t);
    loc    := Location (t, pkg, subdir);
    M3Unit.AddNew (t.units, lib, UK.M3LIB, loc, hidden := TRUE, imported := TRUE);
  END DoImportM3Lib;

PROCEDURE <A NAME="DoImportOLib"><procedure>DoImportOLib</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  lib, path: M3ID.T;  imported: BOOLEAN;
  BEGIN
    imported := PopBool (t);
    path     := PopID (t);
    lib      := PopID (t);
    ImportOtherLib (t, lib, path, imported);
  END DoImportOLib;

PROCEDURE <A NAME="ImportOtherLib"><procedure>ImportOtherLib</procedure></A> (t: T;  lib, path: M3ID.T;  imported: BOOLEAN) =
  VAR loc := Location (t, M3Loc.noPkg, path);
  BEGIN
    M3Unit.AddNew (t.units, lib, UK.LIB, loc,
                   hidden := FALSE, imported := imported);
  END ImportOtherLib;

PROCEDURE <A NAME="DoMapInterface"><procedure>DoMapInterface</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  BEGIN
    MapSource (Self (m), UK.I3);
  END DoMapInterface;

PROCEDURE <A NAME="DoMapGenIntf"><procedure>DoMapGenIntf</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  BEGIN
    MapSource (Self (m), UK.IG);
  END DoMapGenIntf;

PROCEDURE <A NAME="DoMapModule"><procedure>DoMapModule</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  BEGIN
    MapSource (Self (m), UK.M3);
  END DoMapModule;

PROCEDURE <A NAME="DoMapGenImpl"><procedure>DoMapGenImpl</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  BEGIN
    MapSource (Self (m), UK.MG);
  END DoMapGenImpl;

PROCEDURE <A NAME="DoMapCSource"><procedure>DoMapCSource</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  BEGIN
    MapSource (Self (m), UK.C);
  END DoMapCSource;

PROCEDURE <A NAME="DoMapHSource"><procedure>DoMapHSource</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  BEGIN
    MapSource (Self (m), UK.H);
  END DoMapHSource;

PROCEDURE <A NAME="DoMapSSource"><procedure>DoMapSSource</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  BEGIN
    MapSource (Self (m), UK.S);
  END DoMapSSource;

PROCEDURE <A NAME="MapSource"><procedure>MapSource</procedure></A> (t: T;  kind: UK)
  RAISES {Quake.Error} =
  VAR name, pkg, subdir: M3ID.T;  vis: BOOLEAN;  loc: M3Loc.T;  zz: M3Path.T;
  BEGIN
    vis    := PopBool (t);
    subdir := PopID (t);
    pkg    := PopID (t);
    name   := PopID (t);
    loc    := Location (t, pkg, subdir);
    zz     := M3Path.Parse (M3ID.ToText (name));
    IF (zz.kind # kind) THEN
      Msg.FatalError (NIL, &quot;imported file extension doesn't match expected type: &quot;,
                      M3ID.ToText (name));
    END;
    M3Unit.AddNew (t.units, M3ID.Add (zz.base), kind, loc,
                   hidden := vis, imported := TRUE);
  END MapSource;
</PRE>------------------------------------------------------------------ misc ---

<P><PRE>PROCEDURE <A NAME="DoDebug"><procedure>DoDebug</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);
  BEGIN
    t.current_options.debug := PopBool (t);
  END DoDebug;

PROCEDURE <A NAME="DoOptimize"><procedure>DoOptimize</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);
  BEGIN
    t.current_options.optimize := PopBool (t);
  END DoOptimize;

PROCEDURE <A NAME="DoShared"><procedure>DoShared</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER) =
  VAR t := Self (m);
  BEGIN
    t.build_shared := TRUE;
  END DoShared;

PROCEDURE <A NAME="DoStandalone"><procedure>DoStandalone</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER) =
  VAR t := Self (m);
  BEGIN
    t.build_shared := FALSE;
  END DoStandalone;

PROCEDURE <A NAME="DoCompileOnly"><procedure>DoCompileOnly</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);
  BEGIN
    GenM3Exports (t, &quot;%% compile only&quot;);
    IF (t.mode = MM.Build) THEN
      Builder.JustCompile (t.units, SysLibs (t), t);
      InstallDerived (t, M3Web);
      InstallSources (t);
    END;
    DeleteDeriveds (t, M3Web, NoExtension);
    InitGlobals (t);  (* forget about the accumulated sources... *)
  END DoCompileOnly;

PROCEDURE <A NAME="DoFinishUp"><procedure>DoFinishUp</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);
  BEGIN
    IF (t.units.head # NIL) THEN
      GenM3Exports (t, &quot;%% finish up&quot;);
      IF (t.mode = MM.Build) THEN
        Builder.JustCompile (t.units, SysLibs (t), t);
        InstallDerived (t, M3Web);
        InstallSources (t);
      END;
      DeleteDeriveds (t, M3Web, NoExtension);
      InitGlobals (t);  (* forget about the accumulated sources... *)
    END;
  END DoFinishUp;
</PRE>-------------------------------------------- predefined system libraries --

<P><PRE>PROCEDURE <A NAME="DoImportSysLib"><procedure>DoImportSysLib</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  nm := PopID (t);  val: QValue.T;
  BEGIN
    IF NOT t.system_libs.get (nm, val) THEN
      ConfigErr (t, &quot;SYSTEM_LIBS&quot;, &quot;does not define a value for \&quot;&quot;
                   &amp; M3ID.ToText (nm) &amp; &quot;\&quot;&quot;);
    END;
    IF NOT t.sys_libs.put (nm, NIL) THEN
      AddTexts (t.tfile_args, &quot;import_sys_lib(\&quot;&quot;, M3ID.ToText (nm), QRPCR);
    END;
  END DoImportSysLib;

PROCEDURE <A NAME="SysLibs"><procedure>SysLibs</procedure></A> (t: T): Arg.List
  RAISES {Quake.Error} =
  VAR
    libs := Arg.NewList ();
    ref  : REFANY;
    val  : QValue.T;
    args : QVSeq.T;
    nm   : M3ID.T;
  BEGIN
    FOR i := 0 TO t.system_liborder.size() - 1 DO
      nm := M3ID.Add (QVal.ToText (t, t.system_liborder.get (i)));
      IF t.sys_libs.get (nm, ref) AND t.system_libs.get (nm, val) THEN
        args := QVal.ToArray (t, val);
        FOR i := 0 TO args.size() - 1 DO
          Arg.Append (libs, QVal.ToText (t, args.get (i)));
        END;
      END;
    END;
    RETURN libs;
  END SysLibs;
</PRE>---------------------------------------------------------------- options --
 These are hacks to provide some backward compatibility with the old m3build 

<P><PRE>PROCEDURE <A NAME="DoM3Option"><procedure>DoM3Option</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  arg: TEXT;
  BEGIN
    arg := PopText (t);
    IF    Text.Equal (arg, &quot;-silent&quot;)   THEN  Msg.SetLevel (Msg.Level.Silent);
    ELSIF Text.Equal (arg, &quot;-why&quot;)      THEN  Msg.SetLevel (Msg.Level.Explain);
    ELSIF Text.Equal (arg, &quot;-explain&quot;)  THEN  Msg.SetLevel (Msg.Level.Explain);
    ELSIF Text.Equal (arg, &quot;-commands&quot;) THEN  Msg.SetLevel (Msg.Level.Commands);
    ELSIF Text.Equal (arg, &quot;-verbose&quot;)  THEN  Msg.SetLevel (Msg.Level.Verbose);
    ELSIF Text.Equal (arg, &quot;-debug&quot;)    THEN  Msg.SetLevel (Msg.Level.Debug);
    ELSIF Text.Equal (arg, &quot;-times&quot;)     THEN
      M3Timers.Start ();
    ELSIF Text.Equal (arg, &quot;-keep&quot;)     THEN
      Quake.Define (t, &quot;M3_KEEP_FILES&quot;, &quot;TRUE&quot;);
    ELSIF Text.Equal (arg, &quot;-gui&quot;)     THEN
      Quake.Define (t, &quot;M3_WINDOWS_GUI&quot;, &quot;TRUE&quot;);
    ELSIF Text.Equal (arg, &quot;-windows&quot;)     THEN
      Quake.Define (t, &quot;M3_WINDOWS_GUI&quot;, &quot;TRUE&quot;);
    ELSE  Msg.Error (NIL, &quot;unsupported m3_option value: \&quot;&quot;, arg, &quot;\&quot;&quot;);
    END;
  END DoM3Option;

PROCEDURE <A NAME="DoRemoveM3Option"><procedure>DoRemoveM3Option</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  arg: TEXT;
  BEGIN
    arg := PopText (t);
    Msg.Info (&quot;remove_m3_option (\&quot;&quot;, arg, &quot;\&quot;) is being ignored.&quot;, Wr.EOL)
  END DoRemoveM3Option;
</PRE>--------------------------------------------------------------- deleting --
 We don't support <CODE>-clean</CODE>.... 

<P><PRE>PROCEDURE <A NAME="DoDeriveds"><procedure>DoDeriveds</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);   base: TEXT;  exts: QVSeq.T;
  BEGIN
    exts := PopArray (t);
    base := PopText (t);
    IF (t.mode = MM.Clean) THEN
      DeleteDeriveds (t, base, SeqToTexts (t, exts)^);
    END;
  END DoDeriveds;

PROCEDURE <A NAME="DeleteDeriveds"><procedure>DeleteDeriveds</procedure></A> (t: T;  base: TEXT;   READONLY exts: ARRAY OF TEXT) =
  BEGIN
    IF (t.mode = MM.Clean) THEN
      FOR i := FIRST (exts) TO LAST (exts) DO
        Utils.Remove (base &amp; exts[i]);
      END;
    END;
  END DeleteDeriveds;
</PRE>---------------------------------------------------------------- imports --

<P><PRE>PROCEDURE <A NAME="DoIncludeDir"><procedure>DoIncludeDir</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error, Thread.Alerted} =
  VAR t := Self (m);  dir: TEXT;
  BEGIN
    dir := PopText (t);
    Include (t, M3Path.New (t.cur_path(), dir, &quot;m3makefile&quot;));
  END DoIncludeDir;

PROCEDURE <A NAME="DoIncludePkg"><procedure>DoIncludePkg</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error, Thread.Alerted} =
  VAR t := Self (m);  pkg, save_pkg, save_dir: M3ID.T;
  BEGIN
    pkg := PopID (t);

    save_pkg := t.cur_pkg;
    save_dir := t.cur_pkg_dir;
    t.cur_pkg     := pkg;
    t.cur_pkg_dir := M3ID.Add (Pkg (t, pkg));
    TRY
      Include (t, M3Path.New (M3ID.ToText (t.cur_pkg_dir), &quot;src&quot;, &quot;m3makefile&quot;));
    FINALLY
      t.cur_pkg     := save_pkg;
      t.cur_pkg_dir := save_dir;
    END;
  END DoIncludePkg;

PROCEDURE <A NAME="DoImport"><procedure>DoImport</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error, Thread.Alerted} =
  VAR t := Self (m);
  BEGIN
    ImportVersion (t, PopID (t), t.build_dir);
  END DoImport;

PROCEDURE <A NAME="DoImportVersion"><procedure>DoImportVersion</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error, Thread.Alerted} =
  VAR t := Self (m);  pkg, vers: M3ID.T;
  BEGIN
    vers := PopID (t);
    pkg  := PopID (t);
    ImportVersion (t, pkg, vers);
  END DoImportVersion;

PROCEDURE <A NAME="ImportVersion"><procedure>ImportVersion</procedure></A> (t: T;  pkg, vers: M3ID.T)
  RAISES {Quake.Error, Thread.Alerted} =
  VAR ref: REFANY;  vers_txt := M3ID.ToText (vers);
  BEGIN
    IF (pkg = t.build_pkg) THEN
      t.error (&quot;cannot import package \&quot;&quot; &amp; M3ID.ToText (pkg) &amp; &quot;\&quot; into itself.&quot;);
    END;
    IF NOT t.imports.get (pkg, ref) THEN
      EVAL t.imports.put (pkg, vers_txt);
      Include (t, M3Path.New (Pkg (t, pkg), vers_txt, M3Exports));
    END;
  END ImportVersion;

PROCEDURE <A NAME="DoImportObj"><procedure>DoImportObj</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR
    t := Self (m);
    file := PathOf (t, PopText (t));
    dir  := M3Path.New (PkgSubdir (t), Pathname.Prefix (file));
    base := M3ID.Add (Pathname.Last (file));
    loc  := Location (t, t.cur_pkg, M3ID.Add (dir));
    unit := M3Unit.New (base, UK.O, loc, hidden := FALSE, imported := FALSE);
    fn   := M3Unit.FileName(unit);
    pn   := Pathname.Join(loc.path, fn, NIL);
  BEGIN
    M3Unit.AddNew (t.units, base, UK.O, loc,
                   imported := FALSE, hidden := TRUE);
    M3Unit.Add (t.units, unit);
    Utils.SymbolicLinkFile (pn, fn);
  END DoImportObj;

PROCEDURE <A NAME="DoImportLib"><procedure>DoImportLib</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  lib, path: M3ID.T;
  BEGIN
    path := PopID (t);
    lib  := PopID (t);
    ImportOtherLib (t, lib, path, imported := FALSE);
  END DoImportLib;
</PRE>---------------------------------------------------------------- objects --

<P><PRE>PROCEDURE <A NAME="DoPgmObject"><procedure>DoPgmObject</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  v: QValue.T;
  BEGIN
    t.pop (v);  (* extension *)
    t.pop (v);  (* filename base *)
  END DoPgmObject;
</PRE>---------------------------------------------------------------- sources --

<P><PRE>PROCEDURE <A NAME="DoSource"><procedure>DoSource</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  v: QValue.T;
  BEGIN
    t.pop (v); (* source file name, ignored *)
  END DoSource;

PROCEDURE <A NAME="DoPgmSource"><procedure>DoPgmSource</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR
    t    := Self (m);
    nm   := PopID (t);
    name := M3ID.ToText (nm);
    dir  := M3Path.New (PkgSubdir (t), Pathname.Prefix (name));
    zz   := M3Path.Parse (Pathname.Last (name));
    base := M3ID.Add (zz.base);
    loc  := Location (t, t.cur_pkg, M3ID.Add (dir));
    unit := M3Unit.New (base, zz.kind, loc, hidden := TRUE, imported := FALSE);
  BEGIN
    M3Unit.Add (t.units, unit);
  END DoPgmSource;

PROCEDURE <A NAME="DoIntf"><procedure>DoIntf</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  nm := PopID (t);
  BEGIN
    AddSource (t, nm, UK.I3, hidden := TRUE);
  END DoIntf;

PROCEDURE <A NAME="DoIntfX"><procedure>DoIntfX</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  nm := PopID (t);
  BEGIN
    AddSource (t, nm, UK.I3, hidden := FALSE);
  END DoIntfX;

PROCEDURE <A NAME="DoImpl"><procedure>DoImpl</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  nm := PopID (t);
  BEGIN
    AddSource (t, nm, UK.M3, hidden := TRUE);
  END DoImpl;

PROCEDURE <A NAME="DoModule"><procedure>DoModule</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  nm := PopID (t);
  BEGIN
    AddSource (t, nm, UK.I3, hidden := TRUE);
    AddSource (t, nm, UK.M3, hidden := TRUE);
  END DoModule;

PROCEDURE <A NAME="DoModuleX"><procedure>DoModuleX</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  nm := PopID (t);
  BEGIN
    AddSource (t, nm, UK.I3, hidden := FALSE);
    AddSource (t, nm, UK.M3, hidden := TRUE);
  END DoModuleX;

PROCEDURE <A NAME="DoHSource"><procedure>DoHSource</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);
  BEGIN
    AddSource (t, PopID (t), UK.H, hidden := FALSE);
  END DoHSource;

PROCEDURE <A NAME="DoCSource"><procedure>DoCSource</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  nm := PopID (t);
  BEGIN
    AddSource (t, nm, UK.C, hidden := TRUE);
  END DoCSource;

PROCEDURE <A NAME="DoSSource"><procedure>DoSSource</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  nm := PopID (t);
  BEGIN
    AddSource (t, nm, UK.S, hidden := TRUE);
  END DoSSource;

PROCEDURE <A NAME="DoShipSource"><procedure>DoShipSource</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR
    t    := Self (m);
    nm   := PopID (t);
    name := M3ID.ToText (nm);
    dir  := M3Path.New (PkgSubdir (t), Pathname.Prefix (name));
    base := M3ID.Add (Pathname.Last (name));
    loc  := Location (t, t.cur_pkg, M3ID.Add (dir));
    unit := M3Unit.New (base, UK.Unknown, loc, hidden := TRUE, imported := FALSE);
  BEGIN
    M3Unit.Add (t.ship_units, unit);
  END DoShipSource;
</PRE>--------------------------------------------------------------- generics --

<P><PRE>PROCEDURE <A NAME="DoGenIntf"><procedure>DoGenIntf</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);
  BEGIN
    AddSource (t, PopID (t), UK.IG, hidden := TRUE);
  END DoGenIntf;

PROCEDURE <A NAME="DoGenIntfX"><procedure>DoGenIntfX</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);
  BEGIN
    AddSource (t, PopID (t), UK.IG, hidden := FALSE);
  END DoGenIntfX;

PROCEDURE <A NAME="DoGenImpl"><procedure>DoGenImpl</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);
  BEGIN
    AddSource (t, PopID (t), UK.MG, hidden := TRUE);
  END DoGenImpl;

PROCEDURE <A NAME="DoGenImplX"><procedure>DoGenImplX</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);
  BEGIN
    AddSource (t, PopID (t), UK.MG, hidden := FALSE);
  END DoGenImplX;

PROCEDURE <A NAME="DoGenModule"><procedure>DoGenModule</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  nm := PopID (t);
  BEGIN
    AddSource (t, nm, UK.IG, hidden := TRUE);
    AddSource (t, nm, UK.MG, hidden := TRUE);
  END DoGenModule;

PROCEDURE <A NAME="DoGenModuleX"><procedure>DoGenModuleX</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  nm := PopID (t);
  BEGIN
    AddSource (t, nm, UK.IG, hidden := FALSE);
    AddSource (t, nm, UK.MG, hidden := FALSE);
  END DoGenModuleX;

PROCEDURE <A NAME="DoBuildGenIntf"><procedure>DoBuildGenIntf</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR
    t := Self (m);
    nm: M3ID.T;
    name, generic: TEXT;
    args: QVSeq.T;
    vis: BOOLEAN;
  BEGIN
    vis     := PopBool (t);
    args    := PopArray (t);
    generic := PopText (t);
    nm      := PopID (t);
    name    := M3ID.ToText (nm);
    BuildGeneric (t, &quot;INTERFACE &quot;, name &amp; &quot;.i3&quot;, name, generic, args);
    AddDerived (t, nm, UK.I3, hidden := vis);
  END DoBuildGenIntf;

PROCEDURE <A NAME="DoBuildGenImpl"><procedure>DoBuildGenImpl</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);   nm: M3ID.T;  name, generic: TEXT;  args: QVSeq.T;
  BEGIN
    args    := PopArray (t);
    generic := PopText (t);
    nm      := PopID (t);
    name    := M3ID.ToText (nm);
    BuildGeneric (t, &quot;MODULE &quot;, name &amp; &quot;.m3&quot;, name, generic, args);
    AddDerived (t, nm, UK.M3, hidden := TRUE);
  END DoBuildGenImpl;

PROCEDURE <A NAME="BuildGeneric"><procedure>BuildGeneric</procedure></A> (t: T;  kind, file, name, generic: TEXT;  args: QVSeq.T)
  RAISES {Quake.Error} =
  CONST tmp = &quot;.generic.tmp&quot;;
  VAR txts: TextVector;

  PROCEDURE Emit (wr: Wr.T) RAISES {Wr.Failure, Thread.Alerted} =
    VAR comma: TEXT := NIL;
    BEGIN
      Out (wr, &quot;(*generated by m3build*)&quot;, Wr.EOL, Wr.EOL);
      Out (wr, kind, &quot; &quot;, name, &quot; = &quot;);
      Out (wr, generic, &quot; (&quot;);
      FOR i := 0 TO LAST (txts^) DO
        Out (wr, comma, txts[i]);
        comma := &quot;, &quot;;
      END;
      Out (wr, &quot;) END &quot;, name, &quot;.&quot;, Wr.EOL);
    END Emit;

  BEGIN
    IF (t.mode = MM.Build) THEN
      txts := SeqToTexts (t, args);
      Utils.WriteFile (tmp, Emit, append := FALSE);
      t.cp_if (tmp, file);
      Utils.Remove (tmp);
    END;
  END BuildGeneric;
</PRE>-------------------------------------------------------- derived sources --

<P><PRE>PROCEDURE <A NAME="DoDerivedIntf"><procedure>DoDerivedIntf</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  file: M3ID.T;  vis: BOOLEAN;
  BEGIN
    vis  := PopBool (t);
    file := PopID (t);
    AddDerived (t, file, UK.I3, hidden := vis);
    DeleteDeriveds (t, M3ID.ToText (file), IntfExtensions);
  END DoDerivedIntf;

PROCEDURE <A NAME="DoDerivedImpl"><procedure>DoDerivedImpl</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  file := PopID (t);
  BEGIN
    AddDerived (t, file, UK.M3, hidden := TRUE);
    DeleteDeriveds (t, M3ID.ToText (file), ImplExtensions);
  END DoDerivedImpl;

PROCEDURE <A NAME="DoDerivedC"><procedure>DoDerivedC</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  file := PopID (t);
  BEGIN
    AddDerived (t, file, UK.C, hidden := TRUE);
    DeleteDeriveds (t, M3ID.ToText (file), CExtensions);
  END DoDerivedC;

PROCEDURE <A NAME="DoDerivedH"><procedure>DoDerivedH</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);
  BEGIN
    AddDerived (t, PopID (t), UK.H, hidden := FALSE);
  END DoDerivedH;
</PRE>------------------------------------------------------- hiding/exporting --
 These are forwarded in the exports file 

<P><PRE>PROCEDURE <A NAME="SetVis"><procedure>SetVis</procedure></A> (t: T;  nm: M3ID.T;  kind: UK;  hidden: BOOLEAN) =
  VAR u := M3Unit.Get (t.units, nm, kind);
  BEGIN
    IF (u # NIL) THEN
      u.hidden := hidden;
    ELSE
      Msg.FatalError (NIL, &quot;set_visibility of unknown unit: &quot;,
                      M3Path.Join (NIL, M3ID.ToText (nm), kind));
    END;
  END SetVis;

PROCEDURE <A NAME="DoHideIntf"><procedure>DoHideIntf</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  nm := PopID (t);
  BEGIN
    SetVis (t, nm, UK.I3, hidden := TRUE);
    AddTexts (t.tfile_args, &quot;hide_interface(\&quot;&quot;,
              M3ID.ToText (nm), QRPCR);
  END DoHideIntf;

PROCEDURE <A NAME="DoHideGenIntf"><procedure>DoHideGenIntf</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  nm := PopID (t);
  BEGIN
    SetVis (t, nm, UK.IG, hidden := TRUE);
    AddTexts (t.tfile_args, &quot;hide_generic_interface(\&quot;&quot;,
              M3ID.ToText (nm), QRPCR);
  END DoHideGenIntf;

PROCEDURE <A NAME="DoHideGenImpl"><procedure>DoHideGenImpl</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  nm := PopID (t);
  BEGIN
    SetVis (t, nm, UK.MG, hidden := TRUE);
    AddTexts (t.tfile_args, &quot;hide_generic_implementation(\&quot;&quot;,
              M3ID.ToText (nm), QRPCR);
  END DoHideGenImpl;

PROCEDURE <A NAME="DoExportIntf"><procedure>DoExportIntf</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  nm := PopID (t);
  BEGIN
    SetVis (t, nm, UK.I3, hidden := FALSE);
    AddTexts (t.tfile_args, &quot;export_interface(\&quot;&quot;,
              M3ID.ToText (nm), QRPCR);
  END DoExportIntf;

PROCEDURE <A NAME="DoExportGenIntf"><procedure>DoExportGenIntf</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  nm := PopID (t);
  BEGIN
    SetVis (t, nm, UK.IG, hidden := FALSE);
    AddTexts (t.tfile_args, &quot;export_generic_interface(\&quot;&quot;,
              M3ID.ToText (nm), QRPCR);
  END DoExportGenIntf;

PROCEDURE <A NAME="DoExportGenImpl"><procedure>DoExportGenImpl</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  nm := PopID (t);
  BEGIN
    SetVis (t, nm, UK.MG, hidden := FALSE);
    AddTexts (t.tfile_args, &quot;export_generic_implementation(\&quot;&quot;,
              M3ID.ToText (nm), QRPCR);
  END DoExportGenImpl;
</PRE>-------------------------------------------------------------- templates --

<P><PRE>PROCEDURE <A NAME="DoTemplate"><procedure>DoTemplate</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error, Thread.Alerted} =
  VAR t := Self (m);  nm := PopID (t);
  BEGIN
    AddSource (t, nm, UK.TMPL, hidden := FALSE);
    Include (t, M3Path.Join (NIL, M3ID.ToText (nm), UK.TMPL));
  END DoTemplate;
</PRE>------------------------------------------------------- library building --

<P><PRE>PROCEDURE <A NAME="DoLibrary"><procedure>DoLibrary</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  nm: M3ID.T;  name, lib_a, lib_m3x: TEXT;
  BEGIN
    nm := PopID (t);  name := M3ID.ToText (nm);
    AddDerived (t, nm, UK.M3LIB, hidden := TRUE);
    GenM3Exports (t, &quot;_define_lib(\&quot;&quot; &amp; name &amp; QRPCR);
    lib_a   := M3Path.Join (NIL, name, UK.M3LIB);
    lib_m3x := M3Path.Join (NIL, name, UK.LIBX);
    IF (t.mode = MM.Build) THEN
      Builder.BuildLib (name, t.units, SysLibs (t), t.build_shared, t);
      InstallDerived (t, lib_a);
      InstallDerived (t, lib_m3x);
      InstallDerived (t, M3Web);
      InstallSources (t);
    END;
    IF (t.mode = MM.Find) THEN FindUnits (t); END;
    IF (t.mode = MM.Depend) THEN
      Msg.Out (M3ID.ToText(t.build_pkg), &quot;:&quot;);
      Builder.EmitPkgImports (t.units);
      done := TRUE;
    END;
    DeleteDeriveds (t, &quot;&quot;, ARRAY OF TEXT {lib_a, lib_m3x, M3Web, M3TFile, &quot;_m3responsefile0.txt&quot;, &quot;_m3responsefile1.txt&quot;});
    DeleteDeriveds (t, name, ARRAY OF TEXT {&quot;.lst&quot;, &quot;.def&quot;, &quot;.dll&quot;, &quot;.exp&quot;, &quot;.lib.sa&quot;, &quot;.pdb&quot;});
    InitGlobals (t);  (* forget about the accumulated sources... *)
  END DoLibrary;
</PRE>------------------------------------------------------- program building --

<P><PRE>PROCEDURE <A NAME="DoProgram"><procedure>DoProgram</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR
    t    := Self (m);
    nm   := PopID (t);
    prog := M3Path.ProgramName (M3ID.ToText (nm));
  BEGIN
    BuildProgram (t, nm);
    IF (t.mode = MM.Build) THEN  InstallDerived (t, prog);  END;
  END DoProgram;

PROCEDURE <A NAME="DoProgramX"><procedure>DoProgramX</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR
    t    := Self (m);
    nm   := PopID (t);
    prog := M3Path.ProgramName (M3ID.ToText (nm));
  BEGIN
    BuildProgram (t, nm);
    BindExport (t, prog);
  END DoProgramX;

PROCEDURE <A NAME="BuildProgram"><procedure>BuildProgram</procedure></A> (t: T;  nm: M3ID.T)
  RAISES {Quake.Error} =
  CONST Extras = ARRAY OF TEXT { &quot;_m3main.c&quot;,&quot;_m3main.o&quot;,&quot;_m3main.obj&quot;, &quot;_m3responsefile0.txt&quot;, M3Web, M3TFile };
  CONST Junk = ARRAY OF TEXT { &quot;.map&quot;, &quot;.lst&quot;, &quot;.pdb&quot; };
  VAR name := M3ID.ToText (nm);
  BEGIN
    (*** AddDerived (t, nm, UK.EXE, hidden := TRUE);  -- not needed ***)
    GenM3Exports (t, &quot;_define_pgm(\&quot;&quot; &amp; name &amp; QRPCR);
    IF (t.mode = MM.Build) THEN
      Builder.BuildPgm (name, t.units, SysLibs (t), t.build_shared, t);
      InstallDerived (t, M3Web);
      InstallSources (t);
    END;
    IF (t.mode = MM.Find) THEN FindUnits (t); END;
    IF (t.mode = MM.Depend) THEN
      Msg.Out (M3ID.ToText(t.build_pkg), &quot;:&quot;);
      Builder.EmitPkgImports (t.units);
      done := TRUE;
    END;
    DeleteDeriveds (t, M3Path.ProgramName (name), NoExtension);
    DeleteDeriveds (t, M3Path.Join (NIL, name, UK.PGMX), NoExtension);
    DeleteDeriveds (t, name, Junk);
    DeleteDeriveds (t, &quot;&quot;, Extras);
    InitGlobals (t);  (* forget about the accumulated sources... *)
  END BuildProgram;

PROCEDURE <A NAME="DoCProgram"><procedure>DoCProgram</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  name := PopText (t);
  BEGIN
    IF (t.mode = MM.Build) THEN
      Builder.BuildCPgm (name, t.units, SysLibs (t), t.build_shared, t);
    END;
    IF (t.mode = MM.Find) THEN FindUnits (t); END;
    IF (t.mode = MM.Depend) THEN
      Msg.Out (M3ID.ToText(t.build_pkg), &quot;:&quot;);
      Builder.EmitPkgImports (t.units);
      done := TRUE;
    END;
    DeleteDeriveds (t, M3Path.ProgramName (name), NoExtension);
    InitGlobals (t);  (* forget about the accumulated sources... *)
  END DoCProgram;

PROCEDURE <A NAME="DoCProgramX"><procedure>DoCProgramX</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  name := PopText (t);  prog: TEXT;
  BEGIN
    IF (t.mode = MM.Build) THEN
      Builder.BuildCPgm (name, t.units, SysLibs (t), t.build_shared, t);
    END;
    IF (t.mode = MM.Find) THEN FindUnits (t); END;
    IF (t.mode = MM.Depend) THEN
      Msg.Out (M3ID.ToText(t.build_pkg), &quot;:&quot;);
      Builder.EmitPkgImports (t.units);
      done := TRUE;
    END;
    prog := M3Path.ProgramName (name);
    BindExport (t, prog);
    DeleteDeriveds (t, prog, NoExtension);
    InitGlobals (t);  (* forget about the accumulated sources... *)
  END DoCProgramX;
</PRE>-------------------------------------------------------------- man pages --

<P><PRE>PROCEDURE <A NAME="DoManPage"><procedure>DoManPage</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  nm, sec: TEXT;
  BEGIN
    sec := PopText (t);
    nm  := PopText (t);
    BuildManPage (t, nm, sec);
  END DoManPage;

PROCEDURE <A NAME="DoManPageX"><procedure>DoManPageX</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  nm, sec: TEXT;
  BEGIN
    sec := PopText (t);
    nm  := PopText (t);
    BuildManPage (t, nm, sec);
    InstallMan (t, nm, sec, derived := TRUE);
  END DoManPageX;

PROCEDURE <A NAME="BuildManPage"><procedure>BuildManPage</procedure></A> (t: T;  nm, sec: TEXT)
  RAISES {Quake.Error} =
  VAR
    dest := nm &amp; &quot;.&quot; &amp; sec;
    src  := PathOf (t, dest);
  BEGIN
    IF (t.mode = MM.Build) THEN
      IF IsStale (dest, src) THEN
        Utils.CopyText (src, dest);
      END;
    END;
    DeleteDeriveds (t, dest, NoExtension);
  END BuildManPage;
</PRE>------------------------------------------------------------------ emacs --

<P><PRE>PROCEDURE <A NAME="DoGnuEmacs"><procedure>DoGnuEmacs</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  nm := PopText (t);
  BEGIN
    EmacsExport (t, PathOf (t, nm &amp; &quot;.el&quot;));
  END DoGnuEmacs;

PROCEDURE <A NAME="DoCompiledEmacs"><procedure>DoCompiledEmacs</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error, Thread.Alerted} =
  VAR t := Self (m);  nm := PopText (t);  src, el, elc: TEXT;
  BEGIN
    IF t.lookup (M3ID.Add (&quot;emacs_compile&quot;)) # NIL THEN
      el  := nm &amp; &quot;.el&quot;;
      elc := nm &amp; &quot;.elc&quot;;
      src := PathOf (t, el);
      IF (t.mode = MM.Build) THEN
        t.cp_if (src, el);
        IF IsStale (elc, el) THEN
          VAR b := t.lookup (M3ID.Add (&quot;emacs_compile&quot;)); BEGIN
             IF (b # NIL) THEN
               t.start_call (b.value);
               PushText (t, el);
               t.call_proc (1, FALSE);
             END;
          END;
        END;
      END;
      EmacsdExport (t, el);
      EmacsdExport (t, elc);
      DeleteDeriveds (t, el, NoExtension);
      DeleteDeriveds (t, elc, NoExtension);
    ELSE
      EmacsExport (t, PathOf (t, nm &amp; &quot;.el&quot;));
    END;
  END DoCompiledEmacs;
</PRE>-------------------------------------------------------- m3where support --

<P><PRE>PROCEDURE <A NAME="DoFindUnit"><procedure>DoFindUnit</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  unit: TEXT;  any_unit: BOOLEAN;
  BEGIN
    any_unit := PopBool (t);
    unit     := PopText (t);
    FindUnit (t, unit, any_unit);
  END DoFindUnit;

PROCEDURE <A NAME="FindUnits"><procedure>FindUnits</procedure></A> (t: T)
  RAISES {Quake.Error} =
  VAR bind := t.lookup (M3ID.Add (&quot;M3_FIND_UNITS&quot;));  txts: TextVector;
  BEGIN
    IF (bind = NIL) THEN RETURN END;
    txts := SeqToTexts (t, QVal.ToArray (t, bind.value));
    FOR i := FIRST (txts^) TO LAST (txts^) DO
      FindUnit (t, txts[i], any_unit := TRUE);
    END;
  END FindUnits;

PROCEDURE <A NAME="FindUnit"><procedure>FindUnit</procedure></A> (t: T;  unit: TEXT;  any_unit: BOOLEAN) =
  VAR
    u: M3Unit.T;
    found := FALSE;
    unm  := M3ID.Add (unit);
    name : M3Path.T;
    base : M3ID.T;
  BEGIN
    name := M3Path.Parse (unit);
    base := M3ID.Add (name.base);

    u := t.units.head;
    WHILE (u # NIL) DO
      IF ((u.name = unm) OR (u.name = base AND u.kind = name.kind))
        AND (any_unit OR NOT u.hidden) THEN
        Msg.Out (M3Unit.FullPath (u), Wr.EOL);
        found := TRUE;
      END;
      u := u.next;
    END;

    IF NOT found THEN
      Msg.Out (&quot;\&quot;&quot;, unit, &quot;\&quot; not found.&quot;, Wr.EOL);
    END;
  END FindUnit;

PROCEDURE <A NAME="DoEnumUnits"><procedure>DoEnumUnits</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  any_unit := PopBool (t);  u: M3Unit.T;
  BEGIN
    u := t.units.head;
    WHILE (u # NIL) DO
      IF any_unit OR NOT u.hidden THEN
        Msg.Out (M3Unit.FullPath (u), Wr.EOL);
      END;
      u := u.next;
    END;
  END DoEnumUnits;
</PRE>------------------------------------------------------- export functions --

<P><PRE>PROCEDURE <A NAME="DoInstallSources"><procedure>DoInstallSources</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER) =
  BEGIN
    InstallSources (Self (m));
  END DoInstallSources;

PROCEDURE <A NAME="InstallSources"><procedure>InstallSources</procedure></A> (t: T) =
  CONST
    IsSource = ARRAY UK OF BOOLEAN {
      FALSE, TRUE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE,
      TRUE, TRUE, TRUE, TRUE, TRUE, FALSE,
      FALSE, FALSE, FALSE, FALSE, FALSE, TRUE };

  VAR
    n_local := 0;
    u : M3Unit.T;
    srcs: REF ARRAY OF M3Unit.T;
    map : REF ARRAY OF INTEGER;

  PROCEDURE CmpUnit (ax, bx: INTEGER): [-1 .. +1] =
    VAR a := srcs[ax];  b := srcs[bx];
    BEGIN
      IF a.loc.pkg &lt; b.loc.pkg THEN RETURN -1; END;
      IF a.loc.pkg &gt; b.loc.pkg THEN RETURN +1; END;
      IF a.loc.subdir &lt; b.loc.subdir THEN RETURN -1; END;
      IF a.loc.subdir &gt; b.loc.subdir THEN RETURN + 1; END;
      IF a.name &lt; b.name THEN RETURN -1; END;
      IF a.name &gt; b.name THEN RETURN +1; END;
      RETURN 0;
    END CmpUnit;

  PROCEDURE Emit (wr: Wr.T) RAISES {Wr.Failure, Thread.Alerted} =
    VAR uu: M3Unit.T;  last_loc : M3Loc.T := NIL;  src, dest: TEXT;
    BEGIN
      FOR i := 0 TO LAST (map^) DO
        uu := srcs [map[i]];
        IF (uu.loc # last_loc) THEN
          dest := M3Path.New (t.pkg_install, M3ID.ToText (uu.loc.pkg),
                              M3ID.ToText (uu.loc.subdir));
          InstallDir (t, dest, wr);
          last_loc := uu.loc;
        END;
        src := M3Unit.FullPath (uu);
        Out (wr, &quot;install_file(\&quot;&quot;, M3Path.Convert (src), QC);
        Out (wr, Unresolve (t, M3Path.Convert (dest)), CQ, ModeF, QRPCR);
      END;
    END Emit;

  BEGIN
    IF t.have_pkgtools THEN RETURN; END;

    (* count the local sources *)
    u := t.units.head;
    WHILE (u # NIL) DO
      IF NOT u.imported AND IsSource [u.kind] THEN
        INC (n_local);
      END;
      u := u.next;
    END;
    u := t.ship_units.head;
    WHILE (u # NIL) DO
      INC (n_local);
      u := u.next;
    END;

    (* collect up the sources in an array *)
    srcs := NEW (REF ARRAY OF M3Unit.T, n_local);
    map  := NEW (REF ARRAY OF INTEGER,  n_local);
    n_local := 0;
    u := t.units.head;
    WHILE (u # NIL) DO
      IF NOT u.imported AND IsSource [u.kind] THEN
        srcs [n_local] := u;
        map  [n_local] := n_local;
        INC (n_local);
      END;
      u := u.next;
    END;
    u := t.ship_units.head;
    WHILE (u # NIL) DO
      srcs [n_local] := u;
      map  [n_local] := n_local;
      INC (n_local);
      u := u.next;
    END;

    (* sort the local sources by directory *)
    IntArraySort.Sort (map^, CmpUnit);

    (* finally, dump the file *)
    Utils.WriteFile (M3Ship, Emit, append := TRUE);
  END InstallSources;

PROCEDURE <A NAME="DoInstallDerived"><procedure>DoInstallDerived</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);
  BEGIN
    InstallDerived (t, PopText (t));
  END DoInstallDerived;

PROCEDURE <A NAME="DoInstallDerivedSymbolicLink"><procedure>DoInstallDerivedSymbolicLink</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);
      to   := PopText (t);
      from := PopText (t);
  BEGIN
    InstallDerivedLink (t, from, to, &quot;symbolic_link_file&quot;);
  END DoInstallDerivedSymbolicLink;

PROCEDURE <A NAME="DoInstallDerivedHardLink"><procedure>DoInstallDerivedHardLink</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);
      to   := PopText (t);
      from := PopText (t);
  BEGIN
    InstallDerivedLink (t, from, to, &quot;hard_link_file&quot;);
  END DoInstallDerivedHardLink;

PROCEDURE <A NAME="DoInstallSymbolLinkToDerived"><procedure>DoInstallSymbolLinkToDerived</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);
      dest := PopText (t);
      src  := PopText (t);
  BEGIN
    InstallLinkToDerived (t, src, dest, &quot;symbolic_link_file&quot;);
  END DoInstallSymbolLinkToDerived;

PROCEDURE <A NAME="DoInstallHardLinkToDerived"><procedure>DoInstallHardLinkToDerived</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);
      dest := PopText (t);
      src  := PopText (t);
  BEGIN
    InstallLinkToDerived (t, src, dest, &quot;hard_link_file&quot;);
  END DoInstallHardLinkToDerived;

PROCEDURE <A NAME="DoInstallSymbolLink"><procedure>DoInstallSymbolLink</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);
      dest := PopText (t);
      src  := PopText (t);
  BEGIN
    InstallLink (t, src, dest, &quot;symbolic_link_file&quot;);
  END DoInstallSymbolLink;

PROCEDURE <A NAME="DoInstallFile"><procedure>DoInstallFile</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  CONST Pad = ARRAY [0..16] OF TEXT { &quot;                &quot;, &quot;               &quot;,
    &quot;              &quot;, &quot;             &quot;, &quot;            &quot;, &quot;           &quot;,
    &quot;          &quot;, &quot;         &quot;, &quot;        &quot;, &quot;       &quot;, &quot;      &quot;, &quot;     &quot;,
    &quot;    &quot;, &quot;   &quot;, &quot;  &quot;, &quot; &quot;, &quot;&quot; };
  VAR t := Self (m);  src, dest, mode, src_dir, src_file, prefix: TEXT;
  BEGIN
    mode := PopText (t);  (* ignored *)
    dest := PopText (t);
    src  := PopText (t);

    IF (Msg.level &gt;= Msg.Level.Explain) THEN
      src_dir := Pathname.Prefix (src);
      src_file := Pathname.Last (src);
      IF (src_dir = NIL) OR Text.Equal (src_dir, &quot;&quot;) THEN src_dir := &quot;.&quot;; END;

      IF NOT Text.Equal (dest, t.last_install_dir)
        OR NOT Text.Equal (src_dir, t.last_src_dir) THEN
        MakeRoom (t, 99999);
        Msg.Explain (src_dir, &quot; =&gt; &quot;, M3Path.New(dest));
        t.last_install_dir := dest;
        t.last_src_dir := src_dir;
        t.listing_width := 0;
      END;

      MakeRoom (t, 2 + MAX (Text.Length (src_file), LAST (Pad)));
      Msg.Out (&quot;  &quot;, src_file, Pad [MIN (Text.Length (src_file), LAST (Pad))]);
    END;

    prefix := Env.Get(&quot;CM3_INSTALL_PREFIX&quot;);
    IF prefix # NIL THEN
      dest := prefix &amp; dest;
    END;

    t.cp_if (src, dest);
  END DoInstallFile;

PROCEDURE <A NAME="MakeRoom"><procedure>MakeRoom</procedure></A> (t: T;  space: INTEGER) =
  BEGIN
    INC (t.listing_width, space);
    IF (t.listing_width &gt; 75) THEN
      (* this line will be too long... *)
      IF (t.listing_width &gt; space) THEN
        (* the existing line is non-empty *)
        Msg.Explain ();  (* force a new-line *)
      END;
      t.listing_width := space;
    END;
  END MakeRoom;
</PRE>---------------------------------------------- internal export utilities --

<P><PRE>PROCEDURE <A NAME="DoUnresolve"><procedure>DoUnresolve</procedure></A> (t: T;  res: TEXT): TEXT =
  BEGIN
    res := TextUtils.Substitute(res, &quot;/&quot;, M3Path.SlashText);
    res := TextUtils.Substitute(res, t.bin_install, &quot;\&quot; &amp; BIN_INSTALL &amp; \&quot;&quot;);
    res := TextUtils.Substitute(res, t.lib_install, &quot;\&quot; &amp; LIB_INSTALL &amp; \&quot;&quot;);
    res := TextUtils.Substitute(res, t.doc_install, &quot;\&quot; &amp; DOC_INSTALL &amp; \&quot;&quot;);
    res := TextUtils.Substitute(res, t.man_install, &quot;\&quot; &amp; MAN_INSTALL &amp; \&quot;&quot;);
    res := TextUtils.Substitute(res, t.html_install, &quot;\&quot; &amp; HTML_INSTALL &amp; \&quot;&quot;);
    res := TextUtils.Substitute(res, t.emacs_install, &quot;\&quot; &amp; EMACS_INSTALL &amp; \&quot;&quot;);
    res := TextUtils.Substitute(res, t.pkg_install, &quot;\&quot; &amp; PKG_INSTALL &amp; \&quot;&quot;);
    res := TextUtils.Substitute(res, t.pkg_use, &quot;\&quot; &amp; PKG_USE &amp; \&quot;&quot;);
    res := TextUtils.Substitute(res, t.text_build_dir, &quot;\&quot; &amp; TARGET &amp; \&quot;&quot;);
    res := TextUtils.Substitute(res, t.install_root, &quot;\&quot; &amp; INSTALL_ROOT &amp; \&quot;&quot;);
    (* res := TextUtils.Substitute(res, M3Path.SlashText, &quot;\&quot; &amp; SL &amp; \&quot;&quot;); *)
    res := TextUtils.Substitute(res, M3Path.SlashText, &quot;/&quot;);
    res := TextUtils.Substitute(res, &quot;\&quot;\&quot; &amp; &quot;, &quot;&quot;);
    res := TextUtils.Substitute(res, &quot; &amp; \&quot;\&quot;&quot;, &quot;&quot;);
    RETURN res;
  END DoUnresolve;

PROCEDURE <A NAME="Unresolve"><procedure>Unresolve</procedure></A> (t: T;  pn: TEXT): TEXT =
  BEGIN
    pn := &quot;\&quot;&quot; &amp; pn &amp; &quot;\&quot;&quot;;
    IF noM3ShipResolution THEN
      pn := DoUnresolve(t, pn);
    END;
    RETURN pn;
  END Unresolve;

PROCEDURE <A NAME="InstallDerived"><procedure>InstallDerived</procedure></A> (t: T;  name: TEXT) =

  PROCEDURE Emit (wr: Wr.T) RAISES {Wr.Failure, Thread.Alerted} =
    VAR dest := InstallDerivedDir (t);
    BEGIN
      InstallDir (t, dest, wr);
      Out (wr, &quot;install_file(\&quot;&quot;, M3Path.Convert (name));
      Out (wr, QC, Unresolve (t, M3Path.Convert (dest)), CQ, ModeF, QRPCR);
    END Emit;

  BEGIN
    IF t.have_pkgtools THEN RETURN; END;
    Utils.WriteFile (M3Ship, Emit, append := TRUE);
  END InstallDerived;

PROCEDURE <A NAME="InstallDerivedLink"><procedure>InstallDerivedLink</procedure></A> (t: T;  from, to: TEXT; ship_function: TEXT) =

  PROCEDURE Emit (wr: Wr.T) RAISES {Wr.Failure, Thread.Alerted} =
    VAR
      dest_dir  := InstallDerivedDir (t);
      to_file   := M3Path.New (dest_dir, to);
      from_file := M3Path.New (UseDerivedDir (t), from);
    BEGIN
      InstallDir (t, dest_dir, wr);
      Out (wr, ship_function, &quot;(&quot;, Unresolve (t, M3Path.Convert (from_file)), C);
      Out (wr, Unresolve (t, M3Path.Convert (to_file)), RPCR);
    END Emit;

  BEGIN
    IF t.have_pkgtools THEN RETURN; END;
    Utils.WriteFile (M3Ship, Emit, append := TRUE);
  END InstallDerivedLink;

PROCEDURE <A NAME="InstallDerivedDir"><procedure>InstallDerivedDir</procedure></A> (t: T): TEXT =
  VAR pkg := M3ID.ToText (t.build_pkg);  dir := M3ID.ToText (t.build_dir);
  BEGIN
    RETURN M3Path.New (t.pkg_install, pkg, dir);
  END InstallDerivedDir;

PROCEDURE <A NAME="UseDerivedDir"><procedure>UseDerivedDir</procedure></A> (t: T): TEXT =
  VAR pkg := M3ID.ToText (t.build_pkg);  dir := M3ID.ToText (t.build_dir);
  BEGIN
    RETURN M3Path.New (t.pkg_use, pkg, dir);
  END UseDerivedDir;

PROCEDURE <A NAME="InstallLink"><procedure>InstallLink</procedure></A> (t: T;   src, dest: TEXT; ship_function: TEXT)
  RAISES {Quake.Error} =

  PROCEDURE Emit (wr: Wr.T) RAISES {Wr.Failure, Thread.Alerted} =
    VAR dest_dir := Pathname.Prefix(dest);
    BEGIN
      InstallDir (t, dest_dir, wr);
      Out (wr, ship_function, &quot;(&quot;, Unresolve (t, M3Path.Convert (src)), C);
      Out (wr, Unresolve (t, M3Path.Convert (dest)), RPCR)
    END Emit;

  BEGIN
    IF t.have_pkgtools THEN (* ? *)
      InstallFile (t, src, dest, ModeX, derived := TRUE);
    ELSE
      Utils.WriteFile (M3Ship, Emit, append := TRUE);
    END;
  END InstallLink;

PROCEDURE <A NAME="InstallLinkToDerived"><procedure>InstallLinkToDerived</procedure></A> (t: T;   src, dest: TEXT; ship_function: TEXT)
  RAISES {Quake.Error} =
  VAR target := M3Path.New (UseDerivedDir (t), src);
      link   := M3Path.New (dest, src);
  BEGIN
    InstallLink(t, target, link, ship_function);
  END InstallLinkToDerived;

PROCEDURE <A NAME="InstallDir"><procedure>InstallDir</procedure></A> (t: T;  dir: TEXT;  wr: Wr.T)
  RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    IF NOT Text.Equal (dir, t.last_ship_dir) THEN
      IF t.have_pkgtools THEN
        Out (wr, &quot;-l &quot;, dir, &quot;\n&quot;);
      ELSIF NOT t.all_ship_dirs.put (M3ID.Add (dir), NIL) THEN
        Out (wr, &quot;make_dir(&quot;, Unresolve (t, M3Path.Convert (dir)), RPCR);
      END;
      t.last_ship_dir := dir;
    END;
  END InstallDir;

PROCEDURE <A NAME="InstallFile"><procedure>InstallFile</procedure></A> (t: T;  src, dest, mode: TEXT;  derived: BOOLEAN)
  RAISES {Quake.Error} =
  VAR src_path: TEXT;

  PROCEDURE Emit (wr: Wr.T) RAISES {Wr.Failure, Thread.Alerted} =
    BEGIN
      (* make sure the install directory is built *)
      InstallDir (t, dest, wr);

      (* generate the code to install the file *)
      IF t.have_pkgtools THEN
        Out (wr, M3ID.ToText (t.build_dir), &quot;/&quot;, src, &quot;\n&quot;);
      ELSE
        Out (wr, &quot;install_file(&quot;, Unresolve (t, M3Path.Convert (src)), C); (* Unresolve needed here? *)
        Out (wr, Unresolve(t, M3Path.Convert (dest)), CQ, mode, QRPCR);
      END;
    END Emit;

  BEGIN
    IF NOT derived THEN
      src_path := PathOf (t, src);
      IF t.have_pkgtools THEN
        (* Since the package tools refuse to export things that are outside
           the current package and in general we don't know where a source
           file resides, we make links to any exported source files. *)
        IF (t.cur_pkg # t.build_pkg) THEN
          IF (t.mode = MM.Build) THEN
            IF IsStale (src, src_path) THEN
              Utils.SymbolicLinkFile (src_path, src);
              src_path := src;
            END;
          END;
          DeleteDeriveds (t, src, NoExtension);
        END;
      END;
      src := src_path;
    END;

    IF NOT (t.mode = MM.Build) THEN RETURN; END;

    IF t.pkg_overrides.size () &gt; 0 THEN
      (* There were overides =&gt; don't create any shipping information *)
      NoteOverrides (t);
      RETURN;
    END;

    Utils.WriteFile (M3Ship, Emit, append := TRUE);
  END InstallFile;

PROCEDURE <A NAME="InstallMan"><procedure>InstallMan</procedure></A> (t: T;  page, sec: TEXT;  derived: BOOLEAN)
  RAISES {Quake.Error} =
  VAR
   src  := page &amp; &quot;.&quot; &amp; sec;
   dest := M3Path.New (t.man_install, &quot;man&quot; &amp; sec);
  BEGIN
    InstallFile (t, src, dest, ModeF, derived);
  END InstallMan;

PROCEDURE <A NAME="InstallSource"><procedure>InstallSource</procedure></A> (t: T;  src, dest, mode: TEXT) =

  PROCEDURE Emit (wr: Wr.T) RAISES {Wr.Failure, Thread.Alerted} =
    BEGIN
      (* make sure the install directory is built *)
      InstallDir (t, dest, wr);
      IF t.have_pkgtools THEN
        Out (wr, src, &quot;\n&quot;);
      ELSE
        Out (wr, &quot;install_file(&quot;, Unresolve (t, M3Path.Convert (src)), C); (* Unresolve needed here? *)
        Out (wr, Unresolve (t, M3Path.Convert (dest)), CQ, mode, QRPCR);
      END;
    END Emit;

  BEGIN
    IF NOT (t.mode = MM.Build) THEN RETURN; END;

    IF t.pkg_overrides.size () &gt; 0 THEN
      (* There were overides =&gt; don't create any shipping information *)
      NoteOverrides (t);
      RETURN;
    END;

    Utils.WriteFile (M3Ship, Emit, append := TRUE);
  END InstallSource;

PROCEDURE <A NAME="IsStale"><procedure>IsStale</procedure></A> (obj, src: TEXT): BOOLEAN =
  BEGIN
    RETURN Utils.ModificationTime (obj) &lt; Utils.ModificationTime (src);
  END IsStale;

PROCEDURE <A NAME="NoteOverrides"><procedure>NoteOverrides</procedure></A> (&lt;*UNUSED*&gt; t: T) =
  BEGIN
    Utils.Remove (M3Ship);
    TouchFile (M3Overrides);
  END NoteOverrides;
</PRE>------------------------------------------ user callable export routines --

<P><PRE>PROCEDURE <A NAME="DoBindExport"><procedure>DoBindExport</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);
  BEGIN
    BindExport (t, PopText (t));
  END DoBindExport;

PROCEDURE <A NAME="BindExport"><procedure>BindExport</procedure></A> (t: T;  file: TEXT)
  RAISES {Quake.Error} =
  BEGIN
    InstallFile (t, file, t.bin_install, ModeX, derived := TRUE);
  END BindExport;

PROCEDURE <A NAME="DoBinExport"><procedure>DoBinExport</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  file := PopText (t);
  BEGIN
    InstallFile (t, file, t.bin_install, ModeX, derived := FALSE);
  END DoBinExport;

PROCEDURE <A NAME="DoLibdExport"><procedure>DoLibdExport</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  file := PopText (t);
  BEGIN
    InstallFile (t, file, t.lib_install, ModeX, derived := TRUE);
  END DoLibdExport;

PROCEDURE <A NAME="DoLibExport"><procedure>DoLibExport</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  file := PopText (t);
  BEGIN
    InstallFile (t, file, t.lib_install, ModeX, derived := FALSE);
  END DoLibExport;

PROCEDURE <A NAME="DoEmacsdExport"><procedure>DoEmacsdExport</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);
  BEGIN
    EmacsdExport (t, PopText (t));
  END DoEmacsdExport;

PROCEDURE <A NAME="EmacsdExport"><procedure>EmacsdExport</procedure></A> (t: T;  file: TEXT)
  RAISES {Quake.Error} =
  BEGIN
    InstallFile (t, file, t.emacs_install, ModeF, derived := TRUE);
  END EmacsdExport;

PROCEDURE <A NAME="DoEmacsExport"><procedure>DoEmacsExport</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);
  BEGIN
    EmacsExport (t, PopText (t));
  END DoEmacsExport;

PROCEDURE <A NAME="EmacsExport"><procedure>EmacsExport</procedure></A> (t: T;  file: TEXT)
  RAISES {Quake.Error} =
  BEGIN
    InstallFile (t, file, t.emacs_install, ModeF, derived := FALSE);
  END EmacsExport;

PROCEDURE <A NAME="DoDocdExport"><procedure>DoDocdExport</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  file := PopText (t);
  BEGIN
    InstallFile (t, file, t.doc_install, ModeF, derived := TRUE);
  END DoDocdExport;

PROCEDURE <A NAME="DoDocExport"><procedure>DoDocExport</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  file := PopText (t);
  BEGIN
    InstallFile (t, file, t.doc_install, ModeF, derived := FALSE);
  END DoDocExport;

PROCEDURE <A NAME="DoMandExport"><procedure>DoMandExport</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  page, sec: TEXT;
  BEGIN
    sec := PopText (t);
    page := PopText (t);
    InstallMan (t, page, sec, derived := TRUE);
  END DoMandExport;

PROCEDURE <A NAME="DoManExport"><procedure>DoManExport</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  page, sec: TEXT;
  BEGIN
    sec := PopText (t);
    page := PopText (t);
    InstallMan (t, page, sec, derived := FALSE);
  END DoManExport;

PROCEDURE <A NAME="DoHtmlExport"><procedure>DoHtmlExport</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  file := PopText (t);
  BEGIN
    InstallSource (t, file, t.html_install, ModeF);
  END DoHtmlExport;

PROCEDURE <A NAME="DoRootExport"><procedure>DoRootExport</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR
    t := Self (m);
    reldir := PopText (t);
    file := PopText (t);
  BEGIN
    IF Pathname.Absolute (reldir) THEN
      RAISE Quake.Error (&quot;can only export relative to INSTALL_ROOT&quot;);
    END;
    WITH dir = Pathname.Join( t.install_root, reldir ) DO
      InstallFile (t, file, dir, ModeF, derived := FALSE);
    END;
  END DoRootExport;

PROCEDURE <A NAME="DoRootdExport"><procedure>DoRootdExport</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR
    t := Self (m);
    reldir := PopText (t);
    file := PopText (t);
  BEGIN
    IF Pathname.Absolute (reldir) THEN
      RAISE Quake.Error (&quot;can only export relative to INSTALL_ROOT&quot;);
    END;
    WITH dir = Pathname.Join( t.install_root, reldir ) DO
      InstallFile (t, file, dir, ModeF, derived := TRUE);
    END;
  END DoRootdExport;
</PRE>------------------------------------------------------------- .M3EXPORTS --

<P><PRE>PROCEDURE <A NAME="DoGenM3Exports"><procedure>DoGenM3Exports</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);
  BEGIN
    EVAL PopID (t);   (* backward compatibility *)
    GenM3Exports (t, NIL);
  END DoGenM3Exports;

PROCEDURE <A NAME="GenM3Exports"><procedure>GenM3Exports</procedure></A> (t: T;  header: TEXT)
  RAISES {Quake.Error} =
  CONST HTag = ARRAY BOOLEAN OF TEXT { &quot;&quot;, &quot;hidden&quot; };
  CONST KindTag = ARRAY UK OF TEXT {
     NIL,
     &quot;_map_add_interface&quot;, NIL, NIL, NIL,
     &quot;_map_add_module&quot;, NIL, NIL, NIL,
     &quot;_map_add_generic_interface&quot;, &quot;_map_add_generic_module&quot;,
     &quot;_map_add_c&quot;, &quot;_map_add_h&quot;, &quot;_map_add_s&quot;, NIL,
     &quot;_import_m3lib&quot;, &quot;_import_otherlib&quot;, NIL, NIL, NIL, &quot;template&quot; } ;

  VAR fail_msg: TEXT := NIL;

  PROCEDURE Emit (wr: Wr.T) RAISES {Wr.Failure, Thread.Alerted} =
    VAR nm: INTEGER;  ref: REFANY;
    BEGIN
      Out (wr, &quot;% exports of &quot;, M3ID.ToText (t.build_pkg), Wr.EOL);
      Out (wr, header);

      (* copy forward overrides *)
      VAR it := t.pkg_overrides.iterate (); BEGIN
        WHILE it.next (nm, ref) DO
          Out (wr, &quot;override(\&quot;&quot;, M3Path.Convert (M3ID.ToText (nm)), QCQ);
          Out (wr, M3Path.Convert (ref), QRPCR);
        END;
      END;

      (* copy forward package imports *)
      VAR x := t.imports.iterate (); BEGIN
        WHILE x.next (nm, ref) DO
          Out (wr, &quot;import_version(\&quot;&quot;, M3Path.Convert (M3ID.ToText (nm)), QCQ);
          Out (wr, M3Path.Convert (ref), QRPCR);
        END;
      END;

      (* output the units *)
      VAR u := t.units.head; BEGIN
        WHILE (u # NIL) DO
          IF (NOT u.imported) THEN
            CASE u.kind OF
            | UK.Unknown, UK.IC, UK.IS, UK.MC, UK.MS, UK.PGM, UK.LIBX,
              UK.PGMX, UK.IO, UK.MO, UK.O =&gt;
                &lt;*ASSERT KindTag[u.kind] = NIL *&gt;
            | UK.I3, UK.M3, UK.IG, UK.MG, UK.C, UK.H, UK.S =&gt;
                &lt;*ASSERT KindTag[u.kind] # NIL *&gt;
                Out (wr, KindTag[u.kind], &quot;(\&quot;&quot;);
                Out (wr, M3Path.Convert (M3Unit.FileName (u)), QCQ);
                Out (wr, M3Path.Convert (M3ID.ToText (u.loc.pkg)), QCQ);
                Out (wr, M3Path.Convert (M3ID.ToText (u.loc.subdir)), QCQ);
                Out (wr, HTag [u.hidden], QRPCR);
            | UK.M3LIB =&gt;
                Out (wr, &quot;_import_m3lib(\&quot;&quot;, M3ID.ToText (u.name), QCQ);
                Out (wr, M3Path.Convert (M3ID.ToText (u.loc.pkg)), QCQ);
                Out (wr, M3Path.Convert (M3ID.ToText (u.loc.subdir)), QRPCR);
            | UK.LIB =&gt;
                Out (wr, &quot;_import_otherlib(\&quot;&quot;, M3ID.ToText (u.name), QCQ);
                Out (wr, M3Path.Convert (u.loc.path), &quot;\&quot;, IMPORTED)&quot;, Wr.EOL);
            | UK.TMPL =&gt;
                Out (wr, &quot;_import_template(\&quot;&quot;, M3Unit.FileName (u), QCQ);
                Out (wr, M3Path.Convert (M3ID.ToText (u.loc.pkg)), QCQ);
                Out (wr, M3Path.Convert (M3ID.ToText (u.loc.subdir)), QRPCR);
            END;
          END;
          u := u.next;
        END;
      END;

      (* dump the rest, including the explicit hide/export calls *)
      VAR x := t.tfile_args.head; BEGIN
        WHILE (x # NIL) DO
          Out (wr, x.head);
          x := x.tail;
        END;
      END;

      (* dump any 'custom' calls; these must come after any _import_template()
         calls, which may introduce the definitions of the custom calls  *)
      VAR b := t.lookup (M3ID.Add (&quot;gen_map_hooks&quot;)); BEGIN
        IF (b # NIL) THEN
          TRY
            VAR sav := t.cur_wr (); BEGIN
              t.set_wr (wr);
              t.start_call (b.value);
              t.call_proc (0, FALSE);
              t.set_wr (sav);
            END;
          EXCEPT Quake.Error (msg) =&gt;
            fail_msg := msg;
          END;
        END;
      END;
    END Emit;

  BEGIN
    Utils.WriteFile (M3Exports, Emit, append := FALSE);
    IF (fail_msg # NIL) THEN RAISE Quake.Error (fail_msg); END;
    IF (t.mode = MM.Build) THEN InstallDerived (t, M3Exports);  END;
    DeleteDeriveds (t, M3Exports, NoExtension);
  END GenM3Exports;
</PRE>------------------------------------------------------------- <CODE>-T</CODE> files --
 We don't need -T files any more.  This function is just here
   for backward compatibility with m3tk tools like stablegen... 

<P><PRE>PROCEDURE <A NAME="DoGenTFile"><procedure>DoGenTFile</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {} =
  CONST
    IsImportable = ARRAY UK OF BOOLEAN {
      FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
      TRUE, TRUE, FALSE, FALSE, FALSE, FALSE,
      FALSE, FALSE, FALSE, FALSE, FALSE, FALSE };

  VAR
    t := Self (m);
    n_visible := 0;
    u : M3Unit.T;
    srcs: REF ARRAY OF M3Unit.T;
    map : REF ARRAY OF INTEGER;

  PROCEDURE CmpUnit (ax, bx: INTEGER): [-1 .. +1] =
    VAR a := srcs[ax];  b := srcs[bx];
    BEGIN
      IF a.loc.pkg &lt; b.loc.pkg THEN RETURN -1; END;
      IF a.loc.pkg &gt; b.loc.pkg THEN RETURN +1; END;
      IF a.loc.subdir &lt; b.loc.subdir THEN RETURN -1; END;
      IF a.loc.subdir &gt; b.loc.subdir THEN RETURN + 1; END;
      IF a.name &lt; b.name THEN RETURN -1; END;
      IF a.name &gt; b.name THEN RETURN +1; END;
      RETURN 0;
    END CmpUnit;

  PROCEDURE Emit (wr: Wr.T) RAISES {Wr.Failure, Thread.Alerted} =
    VAR uu: M3Unit.T;  last_loc : M3Loc.T := NIL;
    BEGIN
      FOR i := 0 TO LAST (map^) DO
        uu := srcs [map[i]];
        IF (uu.loc # last_loc) THEN
          Out (wr, &quot;@&quot;, uu.loc.path, &quot;\n&quot;);
          last_loc := uu.loc;
        END;
        Out (wr, M3Unit.FileName (uu), &quot;\n&quot;);
      END;
    END Emit;

  BEGIN
    (* count the local sources *)
    u := t.units.head;
    WHILE (u # NIL) DO
      IF IsImportable [u.kind] AND NOT (u.hidden AND u.imported) THEN
        INC (n_visible);
      END;
      u := u.next;
    END;

    (* collect up the sources in an array *)
    srcs := NEW (REF ARRAY OF M3Unit.T, n_visible);
    map  := NEW (REF ARRAY OF INTEGER,  n_visible);
    n_visible := 0;
    u := t.units.head;
    WHILE (u # NIL) DO
      IF IsImportable [u.kind] AND NOT (u.hidden AND u.imported) THEN
        srcs [n_visible] := u;
        map  [n_visible] := n_visible;
        INC (n_visible);
      END;
      u := u.next;
    END;

    (* sort the local sources by directory *)
    IntArraySort.Sort (map^, CmpUnit);

    (* finally, dump the file *)
    Utils.WriteFile (M3TFile, Emit, append := FALSE);
    IF (t.mode = MM.Build) THEN InstallDerived (t, M3TFile); END;
    DeleteDeriveds (t, M3TFile, NoExtension);
  END DoGenTFile;

PROCEDURE <A NAME="DoDeleteFile"><procedure>DoDeleteFile</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  VAR t := Self (m);  file := PopText (t);
  BEGIN
    Utils.Remove (file);
  END DoDeleteFile;

PROCEDURE <A NAME="DoSymbolicOrHardLinkFile"><procedure>DoSymbolicOrHardLinkFile</procedure></A> (link: PROCEDURE(from, to: TEXT); m: QMachine.T)
  RAISES {Quake.Error} =
  VAR t := Self (m);  src, dest, prefix: TEXT;
  BEGIN
    dest := PopText (t);
    src  := PopText (t);

    prefix := Env.Get(&quot;CM3_INSTALL_PREFIX&quot;);
    IF prefix # NIL AND Pathname.Absolute(src) THEN
      src := prefix &amp; src;
      dest := prefix &amp; dest;
    END;

    link (src, dest);
  END DoSymbolicOrHardLinkFile;

PROCEDURE <A NAME="DoSymbolicLinkFile"><procedure>DoSymbolicLinkFile</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  BEGIN
    DoSymbolicOrHardLinkFile(Utils.SymbolicLinkFile, m);
  END DoSymbolicLinkFile;

PROCEDURE <A NAME="DoHardLinkFile"><procedure>DoHardLinkFile</procedure></A> (m: QMachine.T;  &lt;*UNUSED*&gt; n_args: INTEGER)
  RAISES {Quake.Error} =
  BEGIN
    DoSymbolicOrHardLinkFile(Utils.HardLinkFile, m);
  END DoHardLinkFile;
</PRE>----------------------------------------------------------- file writing --

<P><PRE>PROCEDURE <A NAME="Out"><procedure>Out</procedure></A> (wr: Wr.T;  a, b, c, d, e: TEXT := NIL)
  RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    IF (a # NIL) THEN Wr.PutText (wr, a); END;
    IF (b # NIL) THEN Wr.PutText (wr, b); END;
    IF (c # NIL) THEN Wr.PutText (wr, c); END;
    IF (d # NIL) THEN Wr.PutText (wr, d); END;
    IF (e # NIL) THEN Wr.PutText (wr, e); END;
  END Out;

PROCEDURE <A NAME="TouchFile"><procedure>TouchFile</procedure></A> (file: TEXT) =
  (* Create a new empty file *)
  BEGIN
    Utils.CloseWriter (Utils.OpenWriter (file, fatal := TRUE), file);
  END TouchFile;
</PRE>------------------------------------------------------------------- misc --

<P><PRE>PROCEDURE <A NAME="Self"><procedure>Self</procedure></A> (m: QMachine.T): T =
  BEGIN
    RETURN NARROW (m, T);
  END Self;

PROCEDURE <A NAME="ConfigDefn"><procedure>ConfigDefn</procedure></A> (t: T;  sym: TEXT): QValue.Binding
  RAISES {Quake.Error} =
  VAR bind := t.lookup (M3ID.Add (sym));
  BEGIN
    IF (bind = NIL) THEN ConfigErr (t, sym, &quot;not defined&quot;); END;
    RETURN bind;
  END ConfigDefn;

PROCEDURE <A NAME="GetConfig"><procedure>GetConfig</procedure></A> (t: T;  symbol: TEXT): TEXT
  RAISES {Quake.Error} =
  VAR bind := ConfigDefn (t, symbol);
  BEGIN
    TRY
      RETURN QVal.ToText (t, bind.value);
    EXCEPT Quake.Error (msg) =&gt;
      ConfigErr (t, symbol, msg);
      RETURN &quot;&quot;;
    END;
  END GetConfig;

PROCEDURE <A NAME="GetConfigBool"><procedure>GetConfigBool</procedure></A> (t: T;  symbol: TEXT): BOOLEAN
  RAISES {Quake.Error} =
  VAR bind := t.lookup (M3ID.Add (symbol));
  BEGIN
    IF (bind = NIL) THEN RETURN FALSE; END;
    TRY
      RETURN QVal.ToBool (t, bind.value);
    EXCEPT Quake.Error (msg) =&gt;
      ConfigErr (t, symbol, msg);
      RETURN FALSE;
    END;
  END GetConfigBool;

PROCEDURE <A NAME="ConfigErr"><procedure>ConfigErr</procedure></A> (t: T;  symbol, msg: TEXT)
  RAISES {Quake.Error} =
  BEGIN
    t.error (&quot;Unable to use definition of \&quot;&quot; &amp; symbol
             &amp; &quot;\&quot; from configuration file \&quot;&quot; &amp; MxConfig.FindFile ()
             &amp; &quot;\&quot;: &quot; &amp; msg);
  END ConfigErr;

TYPE TextVector = REF ARRAY OF TEXT;

PROCEDURE <A NAME="SeqToTexts"><procedure>SeqToTexts</procedure></A> (t: T;  seq: QVSeq.T): TextVector
  RAISES {Quake.Error} =
  VAR
    n    := seq.size ();
    txts := NEW (TextVector, n);
  BEGIN
    FOR i := 0 TO n - 1 DO
      txts[i] := QVal.ToText (t, seq.get (i));
    END;
    RETURN txts;
  END SeqToTexts;

PROCEDURE <A NAME="PopArray"><procedure>PopArray</procedure></A> (t: T): QVSeq.T
  RAISES {Quake.Error} =
  VAR v: QValue.T;
  BEGIN
    t.pop (v);
    RETURN QVal.ToArray (t, v);
  END PopArray;

PROCEDURE <A NAME="Str2ID"><procedure>Str2ID</procedure></A> (READONLY x: ARRAY OF CHAR): Quake.ID =
  BEGIN
    RETURN M3ID.FromStr (x);
  END Str2ID;

PROCEDURE <A NAME="Txt2ID"><procedure>Txt2ID</procedure></A> (t: TEXT): Quake.ID =
  BEGIN
    RETURN M3ID.Add (t);
  END Txt2ID;

PROCEDURE <A NAME="ID2Txt"><procedure>ID2Txt</procedure></A> (i: Quake.ID): TEXT =
  BEGIN
    RETURN M3ID.ToText (i);
  END ID2Txt;

BEGIN
END M3Build.
</PRE>*******************************
<P>
%----------------------------------------------------------------------- M3 ---
<P>
readonly proc DO_M3(args) is
  before_do_m3_hooks()
  generate_tfile()
<P>
  if defined (<CODE>CAPTURE_M3</CODE>)
    local all_args = arglist (<CODE></CODE>, [M3_CONFIG, <CODE>-make</CODE>, M3OPTIONS, args,
                               M3SEARCH_TABLES, COMPILE_SOURCES,
                               IMPORT_LIBS, OTHER_LIBS_L])
    cp_if (all_args, <CODE>.M3ARGS</CODE>)
  end
<P>
  local sources = arglist(<CODE>-F</CODE>, [M3SEARCH_TABLES, COMPILE_SOURCES,
                                 IMPORT_LIBS, OTHER_LIBS_L])
  <P>
  if not defined (<CODE>_quiet</CODE>)
    write([<CODE>m3</CODE>, M3OPTIONS, args, sources, CR])
    % write([M3, M3_CONFIG, <CODE>-make</CODE>, M3OPTIONS, args, sources, CR])
  end
  exec(<CODE>@-</CODE> &amp; M3, M3_CONFIG, <CODE>-make</CODE>, M3OPTIONS, args, sources)
  install_derived (M3WEB)
<P>
  if not empty(PKG_OVERRIDES)
    % there were overrides =&gt; don't create any shipping information
    NoteOverrides()
  end
end
<P>
readonly proc NoteOverrides() is
  delete_file(M3SHIP_FILE)
  &gt; M3OVERRIDES in  write (CR) end
end
<P>
%-------------------------------------------------------------------- noweb ---
<P>
readonly proc noweb(src_file,root,dest_file) is
  src_file = path_of(src_file &amp; <CODE>.nw</CODE>)
  local tmp_dest = <CODE>.</CODE> &amp; dest_file
  if defined(<CODE>_all</CODE>)
    if stale(tmp_dest, src_file)
      exec(<CODE>notangle -L'&lt;*LINE %L \</CODE>%F\<CODE> *&gt;%N' -R'</CODE> &amp; root &amp; <CODE>'</CODE>, src_file,
           <CODE>&gt;</CODE>, tmp_dest)
    end
    cp_if (tmp_dest, dest_file)
  end
  deriveds(tmp_dest, no_extension)
  deriveds(dest_file, no_extension)
end
<P>
readonly proc noweb_interface(f,r,d) is
  noweb(f,r,d &amp; <CODE>.i3</CODE>)
  derived_interface(d, HIDDEN)
end
<P>
readonly proc Noweb_interface(f,r,d) is
  noweb(f,r,d &amp; <CODE>.i3</CODE>)
  derived_interface(d, VISIBLE)
end
<P>
readonly proc noweb_implementation(f,r,d) is
  noweb(f,r,d &amp; <CODE>.m3</CODE>)
  derived_implementation(d)
end
<P>
%--------------------------------------------------------------------- Zume ---
<P>
proc zume(x) is
  write(<CODE>zume is not implemented</CODE>, CR)
end
<P>
*******************************

</inModule>
<HR>
<A NAME="x1">interface M3ID is in:
</A><UL>
<LI><A HREF="../../m3middle/src/M3ID.i3.html#0TOP0">m3middle/src/M3ID.i3</A>
<LI><A HREF="../../m3scan/src/M3ID.i3.html#0TOP0">m3scan/src/M3ID.i3</A>
</UL>
<P>
<HR>
<A NAME="x2">interface Builder is in:
</A><UL>
<LI><A HREF="Builder.i3.html#0TOP0">cm3/src/Builder.i3</A>
<LI><A HREF="../../cm3ide/src/misc/Builder.i3.html#0TOP0">cm3ide/src/misc/Builder.i3</A>
<LI><A HREF="../../metasyn/src/Builder.i3.html#0TOP0">metasyn/src/Builder.i3</A>
</UL>
<P>
<HR>
<A NAME="x3">interface M3Path is in:
</A><UL>
<LI><A HREF="M3Path.i3.html#0TOP0">cm3/src/M3Path.i3</A>
<LI><A HREF="../../m3quake/src/M3Path.i3.html#0TOP0">m3quake/src/M3Path.i3</A>
</UL>
<P>
<HR>
<A NAME="x4">interface Msg is in:
</A><UL>
<LI><A HREF="Msg.i3.html#0TOP0">cm3/src/Msg.i3</A>
<LI><A HREF="../../m3tohtml/src/Msg.i3.html#0TOP0">m3tohtml/src/Msg.i3</A>
</UL>
<P>
<HR>
<A NAME="x5">interface TextUtils is in:
</A><UL>
<LI><A HREF="../../cit_util/src/TextUtils.i3.html#0TOP0">cit_util/src/TextUtils.i3</A>
<LI><A HREF="../../sysutils/src/TextUtils.i3.html#0TOP0">sysutils/src/TextUtils.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
