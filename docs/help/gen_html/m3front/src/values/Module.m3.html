<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: m3front/src/values/Module.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>m3front/src/values/Module.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright (C) 1992, Digital Equipment Corporation           
 All rights reserved.                                        
 See the file COPYRIGHT for a full description.              

<P> File: Module.m3                                             
 Last modified on Wed Apr 12 08:36:02 PDT 1995 by kalsow     
      modified on Tue May 25 10:53:07 PDT 1993 by muller     

<P><PRE>UNSAFE MODULE <module><implements><A HREF="Module.i3.html">Module</A></implements></module>;

IMPORT <A HREF="../misc/M3.i3.html">M3</A>, <A HREF="#x1">M3ID</A>, <A HREF="../misc/CG.i3.html">CG</A>, <A HREF="#x2">Value</A>, <A HREF="ValueRep.i3.html">ValueRep</A>, <A HREF="../misc/Scope.i3.html">Scope</A>, <A HREF="../stmts/Stmt.i3.html">Stmt</A>, <A HREF="../misc/Error.i3.html">Error</A>, <A HREF="../misc/ESet.i3.html">ESet</A>,  <A HREF="External.i3.html">External</A>;
IMPORT <A HREF="Variable.i3.html">Variable</A>, <A HREF="#x3">Type</A>, <A HREF="Procedure.i3.html">Procedure</A>, <A HREF="Ident.i3.html">Ident</A>, <A HREF="../../../m3middle/src/M3Buf.i3.html">M3Buf</A>, <A HREF="../stmts/BlockStmt.i3.html">BlockStmt</A>, <A HREF="../builtinTypes/Int.i3.html">Int</A>;
IMPORT <A HREF="../misc/Host.i3.html">Host</A>, <A HREF="#x4">Token</A>, <A HREF="Revelation.i3.html">Revelation</A>, <A HREF="../misc/Coverage.i3.html">Coverage</A>, <A HREF="#x5">Decl</A>, <A HREF="../misc/Scanner.i3.html">Scanner</A>, <A HREF="../misc/WebInfo.i3.html">WebInfo</A>;
IMPORT <A HREF="../misc/ProcBody.i3.html">ProcBody</A>, <A HREF="../../../m3middle/src/Target.i3.html">Target</A>, <A HREF="../../../m3middle/src/M3RT.i3.html">M3RT</A>, <A HREF="#x6">Marker</A>, <A HREF="../../../libm3/src/os/Common/File.i3.html">File</A>, <A HREF="../misc/Tracer.i3.html">Tracer</A>;

FROM <A HREF="../misc/Scanner.i3.html">Scanner</A> IMPORT GetToken, Fail, Match, MatchID, cur;

TYPE
  DataSeg = RECORD
    size : INTEGER;
    seg  : CG.Var;
  END;

REVEAL
  <A NAME="T">T</A> = Value.T BRANDED &quot;Module.T&quot; OBJECT
        safe        : BOOLEAN;
        interface   : BOOLEAN;
        external    : BOOLEAN;
        has_errors  : BOOLEAN;
        genericBase : M3ID.T;
        genericFile : TEXT;
        externals   : External.Set;
        importScope : Scope.T;
        localScope  : Scope.T;
        revelations : Revelation.Set;
        block       : Stmt.T;
        body        : InitBody;
        counter     : ARRAY [0..4] OF CHAR;
        fails       : ESet.T;
        body_origin : INTEGER;
        visit_age   : INTEGER;
        compile_age : INTEGER;
        globals     : ARRAY BOOLEAN (*const*) OF DataSeg;
        import_offs : INTEGER;
        last_import : INTEGER;
        data_name   : TEXT;
        trace       : Tracer.T;
        type_info   : Type.ModuleInfo;
        value_info  : Value.T;
        lazyAligned : BOOLEAN;
        containsLazyAlignments: BOOLEAN;
      OVERRIDES
        typeCheck   := TypeCheckMethod;
        set_globals := ValueRep.NoInit;
        load        := ValueRep.NoLoader;
        declare     := ValueRep.Never;
        const_init  := ValueRep.NoInit;
        need_init   := ValueRep.Never;
        lang_init   := ValueRep.NoInit;
        user_init   := ValueRep.NoInit;
        toExpr      := ValueRep.NoExpr;
        toType      := ValueRep.NoType;
        typeOf      := ValueRep.TypeVoid;
        base        := ValueRep.Self;
        add_fp_tag  := AddFPTag;
        fp_type     := FPType;
      END;

TYPE
  InitBody = ProcBody.T OBJECT
    self: T;
    arg: CG.Var := NIL;
  OVERRIDES
    gen_decl := EmitDecl;
    gen_body := EmitBody;
  END;

TYPE
  TK = Token.T;

VAR (* CONST *)
  n_builtins : CARDINAL := 0;
  builtins   : ARRAY [0..3] OF RECORD name: M3ID.T;  t: T;  END;

VAR
  curModule   : T := NIL;
  parseStack  : ARRAY [0..200] OF M3ID.T;
  parseDepth  := 0;
  error_buf   : M3Buf.T  := NIL; (* used to compose error messages *)
  visit_age   : INTEGER  := 0;
  visit_proc  : Visitor  := NIL;
  compile_age := 0;

CONST
  ModuleTypeUID = -1;  (* special CG.TypeUID used for all interface records *)

CONST
  InitialCounter = ARRAY [0..4] OF CHAR { '_', '0', '0', '0', '0' };

CONST
  GlobalDataPrefix = ARRAY (*t.interface*)BOOLEAN OF TEXT { &quot;M_&quot;, &quot;I_&quot;   };
  MainBodySuffix   = ARRAY (*t.interface*)BOOLEAN OF TEXT { &quot;_M3&quot;, &quot;_I3&quot; };

PROCEDURE <A NAME="Reset"><procedure>Reset</procedure></A> () =
  BEGIN
    curModule := NIL;
    parseDepth := 0;
    INC (compile_age);
  END Reset;

PROCEDURE <A NAME="Create"><procedure>Create</procedure></A> (name: M3ID.T): T =
  VAR t: T;
  BEGIN
    t := NEW (T);
    ValueRep.Init (t, name, Value.Class.Module);
    t.readonly    := TRUE;
    t.safe        := TRUE;
    t.interface   := TRUE;
    t.external    := FALSE;
    t.has_errors  := FALSE;
    t.genericBase := M3ID.NoID;
    t.genericFile := NIL;
    t.externals   := External.NewSet ();
    t.importScope := NIL;
    t.localScope  := NIL;
    t.block       := NIL;
    t.body        := NIL;
    t.revelations := Revelation.NewSet (t);
    t.fails       := NIL;
    t.data_name   := NIL;
    t.body_origin := Scanner.offset;
    t.visit_age   := 0;
    t.compile_age := compile_age;
    t.globals[FALSE].size := 0;
    t.globals[FALSE].seg  := NIL;
    t.globals[TRUE].size := 0;
    t.globals[TRUE].seg  := NIL;
    t.import_offs := -1;
    t.last_import := 0;
    t.trace       := NIL;
    t.type_info   := NIL;
    t.value_info  := NIL;
    t.counter     := InitialCounter;
    t.lazyAligned := FALSE;
    t.containsLazyAlignments := FALSE;
    RETURN t;
  END Create;

PROCEDURE <A NAME="Switch"><procedure>Switch</procedure></A> (new: T): T =
  VAR
    old        : T               := curModule;
    old_types  : Type.ModuleInfo := NIL;
    old_values : Value.T         := NIL;
    new_types  : Type.ModuleInfo := NIL;
    new_values : Value.T         := NIL;
  BEGIN
    IF (new # NIL) THEN
      new_types  := new.type_info;
      new_values := new.value_info;
    END;
    old_types  := Type.SetModule  (new_types);
    old_values := Value.SetModule (new_values);
    IF (old # NIL) THEN
      old.type_info  := old_types;
      old.value_info := old_values;
    END;
    curModule := new;
    RETURN old;
  END Switch;

PROCEDURE <A NAME="NewDefn"><procedure>NewDefn</procedure></A> (name: TEXT;  safe: BOOLEAN;  syms: Scope.T): T =
  VAR save, t: T;  zz: Scope.T;  yy: Revelation.Set;
  BEGIN
    t := Create (M3ID.Add (name));
    WITH z = builtins[n_builtins] DO z.name := t.name;  z.t := t; END;
    INC (n_builtins);
    t.safe := safe;
    save := Switch (t);
    yy := Revelation.Push (t.revelations);
    zz := Scope.Push (Scope.Initial);
      t.importScope := Scope.PushNew (TRUE, M3ID.NoID, module := TRUE);
        IF (syms # NIL) THEN
          t.localScope := syms;
        ELSE
          t.localScope := Scope.PushNew (TRUE, t.name, module := TRUE);
          Scope.PopNew ();
        END;
      Scope.PopNew ();
    Scope.Pop (zz);
    Revelation.Pop (yy);
    RecordInterface (t);
    EVAL Switch (save);
    RETURN t;
  END NewDefn;

PROCEDURE <A NAME="Parse"><procedure>Parse</procedure></A> (interfaceOnly : BOOLEAN := FALSE): T =
  VAR
    t, save: T;
    id: M3ID.T;
    n: INTEGER;
    genericReader: File.T;
    yy: Revelation.Set;
    topLevel := NOT interfaceOnly;
    n_errs, n_warns, n_initial_errs: INTEGER;
    cc: CG.CallingConvention;
    got_cc: BOOLEAN;
  BEGIN
    (* ETimer.Push (M3Timers.parse); *)
    Error.Count (n_initial_errs, n_warns);

    t := Create (M3ID.NoID);
    yy := Revelation.Push (t.revelations);
    save := Switch (t);

    IF (cur.token = TK.tEXTERNAL) THEN
      Decl.ParseExternalPragma (id, cc, got_cc);
      IF (id # M3ID.NoID) THEN
        Error.ID (id, &quot;external module name ignored&quot;);
      END;
      t.external := TRUE;
    END;

    IF (cur.token = TK.tUNSAFE) THEN
      t.safe := FALSE;
      GetToken ();
    END;

    t.interface := (cur.token = TK.tINTERFACE);
    IF interfaceOnly THEN
      IF (cur.token = TK.tINTERFACE)
        THEN GetToken ();
        ELSE Fail (&quot;missing INTERFACE keyword&quot;);
      END;
      t.interface := TRUE;
    ELSIF (cur.token = TK.tINTERFACE) OR (cur.token = TK.tMODULE) THEN
      GetToken ();
    ELSE Fail (&quot;missing INTERFACE or MODULE keyword&quot;);
    END;

    IF t.external AND NOT t.interface THEN
      Error.Msg (&quot;Only interfaces can be &lt;*EXTERNAL*&gt;&quot;);
    END;

    id := MatchID ();
    t.name := id;

    IF (t.interface) THEN
      RecordInterface (t);
      IF (topLevel) THEN EVAL PushInterface (id); INC (parseDepth) END;
    END;

    IF (cur.token = TK.tEXPORTS) THEN
      IF (t.interface) THEN
        Error.Msg (&quot;EXPORTS clause not allowed in an interface&quot;);
        t.interface := FALSE;
      END;
      GetToken ();
      n := Ident.ParseList ();
      FOR i := 0 TO n - 1 DO
        External.NoteExport (t.externals, Ident.stack[Ident.top - n + i]);
      END;
      DEC (Ident.top, n);
    ELSIF (NOT t.interface) THEN
      External.NoteExport (t.externals, t.name);
    END;

    IF (cur.token = TK.tSEMI) THEN
      (* this is a simple module/interface, just fall through *)
      GetToken (); (* ; *)
    ELSIF (cur.token = TK.tEQUAL) THEN
      (* this is an instantiation of a generic module/interface *)
      GetToken (); (* = *)
      t.genericBase := PushGeneric (t, genericReader);
    ELSE Fail (&quot;missing \';\' or \'=\', assuming \';\'&quot;);
    END;

    (* parse the imports *)
    External.ParseImports (t.externals, t);

    (* build my scopes and fill them! *)
    t.importScope := Scope.PushNew (TRUE, M3ID.NoID, module := TRUE);
      (* this scope must be created after the imports &amp; exports are
         parsed so that their module scopes aren't nested inside this one. *)

      (* copy the imports and exports into my scope *)
      External.LoadImports (t.externals, t);

      (* open my private, local scope *)
      t.localScope := Scope.PushNew (TRUE, id, module := TRUE);

        WHILE (cur.token IN Token.DeclStart) DO
          Decl.Parse (t.interface, TRUE, t.fails);
        END;

        t.body_origin := Scanner.offset;
        IF (topLevel) THEN
          t.body := NEW (InitBody, self := t,
                         name := BinderName (t.name, t.interface));
          ProcBody.Push (t.body);
        END;
        IF (NOT t.interface) THEN
          Match (TK.tBEGIN);
          t.trace := BlockStmt.ParseTrace ();
          t.block := Stmt.Parse ();
        END;
        IF (topLevel) THEN
          ProcBody.Pop ();
        END;

        IF (t.genericBase # M3ID.NoID) THEN
          ParseFinalEndID (t.genericBase);
          Scanner.Pop ();
        END;
        Host.CloseFile (genericReader);
        ParseFinalEndID (t.name);

      Scope.PopNew (); (* localScope *)

    Scope.PopNew (); (* importScope *)
    Revelation.Pop (yy);
    IF (t.interface) AND (topLevel) THEN DEC (parseDepth) END;
    EVAL Switch (save);

    Error.Count (n_errs, n_warns);
    IF (n_errs &gt; n_initial_errs) THEN t.has_errors := TRUE; END;

    (* ETimer.Pop (); *)
    RETURN t;
  END Parse;

PROCEDURE <A NAME="PushGeneric"><procedure>PushGeneric</procedure></A> (t: T;  VAR rd: File.T): M3ID.T =
</PRE><BLOCKQUOTE><EM> instantiate a call on a generic interface or module </EM></BLOCKQUOTE><PRE>
  VAR
    genericName, id : M3ID.T;
    nActuals, aBase : INTEGER;
    nFormals, fBase : INTEGER;
    formal, actual  : M3ID.T;
    filename: TEXT;
    im: T;
    old_file := Scanner.offset;
    save: INTEGER;
    old_filename: TEXT;
  BEGIN
    Scanner.Here (old_filename, save);

    genericName := MatchID ();
    IF (genericName = M3ID.NoID) THEN RETURN genericName END;

    (* parse the list of actuals *)
    nActuals := ParseGenericArgs ();

    (* open the external file *)
    rd := Host.OpenUnit (genericName, t.interface, TRUE, filename);
    IF (rd = NIL) THEN
      Error.ID (genericName, &quot;unable to find generic&quot;);
      RETURN M3ID.NoID;
    END;

    (* build a synthetic file name &amp; start reading *)
    filename := old_filename &amp; &quot; =&gt; &quot; &amp; filename;
    Scanner.Push (filename, rd, is_main := Scanner.in_main);
    t.genericFile := filename;

    (* make sure we got what we wanted *)
    Match (TK.tGENERIC);
    IF (t.interface)
      THEN Match (TK.tINTERFACE);
      ELSE Match (TK.tMODULE);
    END;

    (* get the generic's name *)
    id := MatchID ();
    IF (id # M3ID.NoID) THEN
      IF (id # genericName) THEN
        Error.ID (id, &quot;imported module has wrong name&quot;);
        genericName := id;
      END;
    END;

    (* parse the list of formals *)
    nFormals := ParseGenericArgs ();
    Match (TK.tSEMI);

    (* finally, generate the rewriting *)
    IF (nActuals # nFormals) THEN
      save := Scanner.offset;
      Scanner.offset := old_file;
      Error.Msg (&quot;number of actuals doesn\'t match number of generic formals&quot;);
      Scanner.offset := save;
    END;
    fBase := Ident.top - nFormals;
    aBase := fBase - nActuals;
    FOR i := 0 TO MAX (nActuals, nFormals)-1 DO
      IF (i &lt; nFormals)
       THEN formal := Ident.stack[fBase + i];
       ELSE formal := Ident.stack[aBase + i]; (* use the actual instead *)
      END;
      IF (i &lt; nActuals)
       THEN actual := Ident.stack[aBase + i];
       ELSE actual := formal; (* use the actual instead *)
      END;
      im := LookUp (actual, internal := FALSE);
      External.NoteImport (t.externals, im, formal);
    END;
    DEC (Ident.top, nActuals + nFormals);

    RETURN genericName;
  END PushGeneric;

PROCEDURE <A NAME="ParseGenericArgs"><procedure>ParseGenericArgs</procedure></A> (): INTEGER =
  VAR n := 0;
  BEGIN
    Match (TK.tLPAREN);
    IF (cur.token = TK.tIDENT) THEN
      n := Ident.ParseList ();
    END;
    Match (TK.tRPAREN);
    RETURN n;
  END ParseGenericArgs;

PROCEDURE <A NAME="ParseFinalEndID"><procedure>ParseFinalEndID</procedure></A> (goal: M3ID.T) =
  VAR id: M3ID.T;
  BEGIN
    Match (TK.tEND);
    id := MatchID ();
    IF (goal # id) THEN
      Error.ID (id, &quot;Initial module name doesn\'t match final name&quot;);
    END;
    Match (TK.tDOT);
    IF (cur.token # TK.tEOF) THEN
      Fail (&quot;extra tokens ignored&quot;);
    END;
  END ParseFinalEndID;

PROCEDURE <A NAME="PushInterface"><procedure>PushInterface</procedure></A> (name: M3ID.T): BOOLEAN =
  VAR i: INTEGER;
  BEGIN
    (* check for a cycle in the active imports *)
    parseStack [parseDepth] := name;
    i := 0;  WHILE (parseStack[i] # name) DO INC (i) END;
    IF (i = parseDepth) THEN RETURN TRUE END;

    IF (error_buf = NIL) THEN error_buf := M3Buf.New (); END;
    M3ID.Put (error_buf, name);
    FOR j := i+1 TO parseDepth DO
      M3Buf.PutText (error_buf, &quot; -&gt; &quot;);
      M3ID.Put      (error_buf, parseStack [j]);
    END;
    Error.Txt (M3Buf.ToText (error_buf), &quot;circular imports&quot;);
    RETURN FALSE;
  END PushInterface;

PROCEDURE <A NAME="LookUp"><procedure>LookUp</procedure></A> (name: M3ID.T;  internal: BOOLEAN): T =
  (* find and return the named interface module *)
  VAR
    t: T;
    save: INTEGER;
    filename: TEXT;
    cs := M3.OuterCheckState;
    rd: File.T;
  BEGIN
    IF NOT internal THEN
      IF NOT PushInterface (name) THEN RETURN NIL END;
    END;

    t := Host.env.find_ast (name);
    IF (t # NIL) THEN
      IF (t.has_errors) THEN
        Error.ID (name, &quot;imported interface contains errors&quot;);
      END;
      MakeCurrent (t);
    ELSE
      (* open the external file &amp; parse the interface*)
      rd := Host.OpenUnit (name, TRUE, FALSE, filename);
      IF (rd = NIL) THEN
        Error.ID (name, &quot;unable to find interface&quot;);
        RETURN NIL;
      END;

      Scanner.Push (filename, rd, is_main := FALSE);
      INC (parseDepth);
      t := Parse (TRUE);
      DEC (parseDepth);
      Scanner.Pop ();
      Host.CloseFile (rd);
      rd := NIL;

      (* make sure we got what we wanted *)
      IF (t = NIL) THEN
        Error.ID (name, &quot;imported object is not an interface&quot;);
        RETURN NIL;
      END;
      IF (t.name # name) THEN
        save := Scanner.offset;
        Scanner.offset := t.origin;
        Error.ID (name, &quot;imported interface has wrong name&quot;);
        Scanner.offset := save;
        RETURN NIL;
      END;
      IF (NOT t.interface) THEN
        save := Scanner.offset;
        Scanner.offset := t.origin;
        Error.ID (name, &quot;imported unit is not an interface&quot;);
        Scanner.offset := save;
        RETURN NIL;
      END;
      RecordInterface (t);
      Value.TypeCheck (t, cs);
    END;
    IF (curModule # NIL) AND (curModule.safe)
      AND (NOT t.safe) AND (NOT internal) THEN
      Error.ID (name, &quot;cannot import an unsafe interface in a safe module&quot;);
    END;
    RETURN t;
  END LookUp;

PROCEDURE <A NAME="MakeCurrent"><procedure>MakeCurrent</procedure></A> (t: T) =
  BEGIN
    IF (t # NIL) AND (t.compile_age &lt; compile_age) THEN
      t.compile_age := compile_age;
      t.globals[FALSE].seg := NIL;
      t.globals[TRUE].seg  := NIL;
      t.import_offs := -1;
      t.last_import := 0;
      t.used        := FALSE;
      t.imported    := TRUE;
      t.exported    := FALSE;
      Value.Reuse (t.value_info);
      Revelation.Reuse (t.revelations);
      External.Visit (t.externals, MakeCurrent);
    END;
  END MakeCurrent;

PROCEDURE <A NAME="RecordInterface"><procedure>RecordInterface</procedure></A> (t: T) =
  (* we must be careful not to overwrite the cached values of
     the builtin interfaces (e.g. Word), because the versions generated
     from source don't have the special procedure methods needed
     for code generation and constant evaluation. *)
  BEGIN
    IF (t = NIL) OR (t.name = M3ID.NoID) THEN RETURN END;
    FOR i := 0 TO n_builtins-1 DO
      WITH z = builtins[i] DO
        IF (z.name = t.name) AND (t # z.t) THEN RETURN END;
      END;
    END;
    Host.env.note_ast (t.name, t);
  END RecordInterface;

PROCEDURE <A NAME="ImportRevelations"><procedure>ImportRevelations</procedure></A> (t: T;  source: Value.T) =
  BEGIN
    Revelation.Inherit (t.revelations, source);
  END ImportRevelations;

PROCEDURE <A NAME="TypeCheckMethod"><procedure>TypeCheckMethod</procedure></A> (t: T;  VAR cs: Value.CheckState) =
  BEGIN
    TypeCheck (t, FALSE, cs);
  END TypeCheckMethod;

PROCEDURE <A NAME="TypeCheck"><procedure>TypeCheck</procedure></A> (t: T;  main: BOOLEAN;  VAR cs: Value.CheckState) =
  VAR
    save: T;
    yy: Revelation.Set;
    z1, z2: Scope.T;
    save_main: BOOLEAN;
    n_errs, n_warns, n_initial_errs: INTEGER;
  BEGIN
    IF (t.checked) THEN RETURN END;
    (* ETimer.Push (M3Timers.check); *)
    Error.Count (n_initial_errs, n_warns);

    save := Switch (t);
    save_main := Scanner.in_main;
    Scanner.in_main := main;
    yy := Revelation.Push (t.revelations);
    SoftPush (t.importScope, z1);
      Scope.TypeCheck (t.importScope, cs);
      SoftPush (t.localScope, z2);
        ESet.TypeCheck (t.fails);
        ESet.Push (cs, NIL, t.fails, stop := TRUE);

          Revelation.TypeCheck (t.revelations);
          Scope.TypeCheck (t.localScope, cs);
          IF (NOT t.interface) THEN
            BlockStmt.CheckTrace (t.trace, cs);
            Stmt.TypeCheck (t.block, cs);
          END;

        ESet.Pop (cs, NIL, t.fails, stop := TRUE);
      SoftPop (t.localScope, z2);
    SoftPop (t.importScope, z1);
    Revelation.Pop (yy);
    CheckDuplicates (t);
    IF (main) THEN
      NoteVisibility (t);
      Scope.WarnUnused (t.importScope);
      Scope.WarnUnused (t.localScope);
    END;

    Error.Count (n_errs, n_warns);
    IF (n_errs &gt; n_initial_errs) THEN t.has_errors := TRUE; END;

    SetGlobals (t);
    Scanner.in_main := save_main;
    EVAL Switch (save);

    Error.Count (n_errs, n_warns);
    IF (n_errs &gt; n_initial_errs) THEN t.has_errors := TRUE; END;
    (* ETimer.Pop (); *)

    (* This is a horrible hack!  Since we want to call Module.TypeCheck
       with &quot;main:=TRUE&quot; directly from M3Compiler.Compile, we bypass
       the normal flag setting done by Value.TypeCheck. *)
    t.checkDepth := 0;
    t.checked := TRUE;
  END TypeCheck;

PROCEDURE <A NAME="SoftPush"><procedure>SoftPush</procedure></A> (s: Scope.T;  VAR tmp: Scope.T) =
  (* the scopes may be NIL when there's illegal cycles in the import graph *)
  BEGIN
    IF (s # NIL) THEN  tmp := Scope.Push (s)  END;
  END SoftPush;

PROCEDURE <A NAME="SoftPop"><procedure>SoftPop</procedure></A> (s: Scope.T;  tmp: Scope.T) =
  BEGIN
    IF (s # NIL) THEN Scope.Pop (tmp)  END;
  END SoftPop;

PROCEDURE <A NAME="SetGlobals"><procedure>SetGlobals</procedure></A> (t: T) =
  (* Interface record offsets are allocated here.  We don't
     allocate them during typechecking, since the order is
     unpredictable.  Here, the offsets are allocated to
     objects in the order that they appear in the source. *)
  VAR v := Scope.ToList (t.localScope);
  BEGIN
    IF (t.has_errors) THEN (*don't bother *) RETURN END;
    IF (Host.verbose) OR (Host.load_map AND Scanner.in_main) THEN
      Out (TRUE, Target.EOL, Target.EOL, &quot; global constants for &quot;);
      Out (TRUE, DataName (t), Target.EOL);
      Out (FALSE, Target.EOL, Target.EOL, &quot; global data allocation for &quot;);
      Out (FALSE, DataName (t), Target.EOL);
    END;
    IF (t.globals[FALSE].size = 0) THEN
      EVAL Allocate (M3RT.MI_SIZE, Target.Address.align, FALSE, &quot;*module info*&quot;);
    END;
    Type.BeginSetGlobals ();
    WHILE (v # NIL) DO
      Type.SetGlobals (v.origin);
      Value.SetGlobals (v);  v := v.next;
    END;
    Type.SetGlobals (LAST (INTEGER));
  END SetGlobals;

PROCEDURE <A NAME="Allocate"><procedure>Allocate</procedure></A> (size, align: INTEGER;  is_const : BOOLEAN;
                    tag: TEXT := NIL;  id: M3ID.T := M3ID.NoID): INTEGER =
  VAR offset: INTEGER;
  BEGIN
    align  := MAX (align, Target.Byte);
    align  := (align + Target.Byte - 1) DIV Target.Byte * Target.Byte;
    size   := (size  + Target.Byte - 1) DIV Target.Byte * Target.Byte;
    offset := (curModule.globals[is_const].size + align - 1) DIV align * align;
    curModule.globals[is_const].size := offset + size;

    IF (Host.verbose) OR (Host.load_map AND Scanner.in_main) THEN
      OutI (offset DIV Target.Byte, 6, is_const);
      OutI (size   DIV Target.Byte, 6, is_const);
      OutI (align  DIV Target.Byte, 3, is_const);
      Out  (is_const, &quot;  &quot;, tag);
      IF (id # M3ID.NoID) THEN M3ID.Put (load_map[is_const], id); END;
      Out  (is_const, Target.EOL);
    END;

    RETURN offset;
  END Allocate;

VAR load_map := ARRAY BOOLEAN (*is_const*) OF M3Buf.T { NIL, NIL };
CONST Pads = ARRAY [0..5] OF TEXT { &quot;&quot;, &quot; &quot;, &quot;  &quot;, &quot;   &quot;, &quot;    &quot;, &quot;     &quot; };

PROCEDURE <A NAME="InitLoadMap"><procedure>InitLoadMap</procedure></A> () =
  BEGIN
    IF (load_map[FALSE] = NIL) THEN
      load_map[FALSE] := M3Buf.New ();
      load_map[TRUE]  := M3Buf.New ();
    END;
  END InitLoadMap;

PROCEDURE <A NAME="OutI"><procedure>OutI</procedure></A> (n, width: INTEGER;  is_const: BOOLEAN) =
  VAR x := 10;  pad := width - 1;
  BEGIN
    IF (load_map[FALSE] = NIL) THEN InitLoadMap (); END;
    WHILE (pad &gt; 0) AND (n &gt;= x) DO DEC (pad); x := 10*x; END;
    IF (pad &gt; 0) THEN M3Buf.PutText (load_map[is_const], Pads[pad]) END;
    M3Buf.PutInt (load_map[is_const], n);
  END OutI;

PROCEDURE <A NAME="Out"><procedure>Out</procedure></A> (is_const: BOOLEAN;  a, b, c, d: TEXT := NIL) =
  BEGIN
    IF (load_map[FALSE] = NIL) THEN InitLoadMap (); END;
    IF (a # NIL) THEN M3Buf.PutText (load_map[is_const], a) END;
    IF (b # NIL) THEN M3Buf.PutText (load_map[is_const], b) END;
    IF (c # NIL) THEN M3Buf.PutText (load_map[is_const], c) END;
    IF (d # NIL) THEN M3Buf.PutText (load_map[is_const], d) END;
  END Out;

PROCEDURE <A NAME="CheckDuplicates"><procedure>CheckDuplicates</procedure></A> (t: T) =
  VAR
    v, v2 : Value.T;
    save  := Scanner.offset;
  BEGIN
    M3ID.AdvanceMarks ();

    (* mark all the imports *)
    v := Scope.ToList (t.importScope);
    WHILE (v # NIL) DO
      EVAL M3ID.SetMark (v.name);
      v := v.next;
    END;

    (* check for anything already marked in the local scope *)
    v := Scope.ToList (t.localScope);
    WHILE (v # NIL) DO
      IF M3ID.SetMark (v.name) THEN
        v2 := Scope.LookUp (t.importScope, v.name, strict := TRUE);
        IF (v2 # NIL) THEN
          (* possible duplicate *)
          IF (NOT External.IsExportable (v2))
            OR (Value.ClassOf (v)  # Value.Class.Procedure)
            OR (Value.ClassOf (v2) # Value.Class.Procedure) THEN
            Scanner.offset := v.origin;
            Error.ID (v.name, &quot;symbol redefined&quot;);
          ELSE
            Procedure.NoteExport (v, v2);
            External.Redirect (v2, v);
          END;
        END;
      END;
      v := v.next;
    END;

    Scanner.offset := save;
  END CheckDuplicates;

PROCEDURE <A NAME="NoteVisibility"><procedure>NoteVisibility</procedure></A> (t: T) =
  VAR v := Scope.ToList (t.localScope);
  BEGIN
    WHILE (v # NIL) DO
      CASE Value.ClassOf (v) OF
      | Value.Class.Module,
        Value.Class.Error =&gt;
          (* no change of import/export status *)
      | Value.Class.Expr,
        Value.Class.Var,
        Value.Class.Type,
        Value.Class.Exception =&gt;
          IF (t.interface) THEN
            &lt;*ASSERT NOT v.imported*&gt;
            v.exported := TRUE;
            v.exportable := TRUE;
          (* ELSE no change of import/export status *)
          END;
      | Value.Class.Procedure =&gt;
          &lt;*ASSERT NOT v.imported*&gt;
          IF (t.interface) THEN
            v.used     := TRUE; (* force a version stamp *)
            v.exported := TRUE;
            v.imported := FALSE;
            (*****
            v.exported := v.external;
            v.imported := NOT v.exported;
            ****)
            v.exportable := TRUE;
          END;
      | Value.Class.Field,
        Value.Class.Method,
        Value.Class.Formal =&gt;
          &lt;* ASSERT FALSE *&gt;
      END;
      v := v.next;
    END;
  END NoteVisibility;

PROCEDURE <A NAME="IsSafe"><procedure>IsSafe</procedure></A> (): BOOLEAN =
  BEGIN
    RETURN (curModule = NIL) OR (curModule.safe);
  END IsSafe;

PROCEDURE <A NAME="IsInterface"><procedure>IsInterface</procedure></A> (): BOOLEAN =
  BEGIN
    RETURN (curModule = NIL) OR (curModule.interface);
  END IsInterface;

PROCEDURE <A NAME="IsExternal"><procedure>IsExternal</procedure></A> (): BOOLEAN =
  BEGIN
    RETURN (curModule # NIL) AND (curModule.external);
  END IsExternal;

PROCEDURE <A NAME="LazyAlignmentOn"><procedure>LazyAlignmentOn</procedure></A> (): BOOLEAN =
  BEGIN
    RETURN curModule # NIL AND curModule.lazyAligned;
  END LazyAlignmentOn;

PROCEDURE <A NAME="SetLazyAlignment"><procedure>SetLazyAlignment</procedure></A> (on: BOOLEAN) =
  BEGIN
    IF curModule # NIL THEN
      curModule.lazyAligned := on;
      IF on THEN
        curModule.containsLazyAlignments := TRUE;
      END;
    END;
  END SetLazyAlignment;

PROCEDURE <A NAME="ExportScope"><procedure>ExportScope</procedure></A> (t: T): Scope.T =
  BEGIN
    IF (t = NIL)
      THEN RETURN NIL;
      ELSE RETURN t.localScope;
    END;
  END ExportScope;

PROCEDURE <A NAME="Compile"><procedure>Compile</procedure></A> (t: T) =
  VAR save: T;  zz: Scope.T;  yy: Revelation.Set;
  BEGIN
    (* ETimer.Push (M3Timers.emit); *)
    Target.Allow_packed_byte_aligned := t.containsLazyAlignments;
    save := Switch (t);
    Scanner.offset := t.origin;
    yy := Revelation.Push (t.revelations);
    zz := Scope.Push (t.localScope);
      WebInfo.Reset ();
      CG.Begin_unit ();
      CG.Gen_location (t.origin);
      Host.env.note_unit (t.name, t.interface);
      DeclareGlobalData (t);
      IF (t.body # NIL) THEN EmitDecl (t.body); END;
      Type.CompileAll ();
      IF (t.interface)
        THEN CompileInterface (t);
        ELSE CompileModule (t);
      END;
      IF (load_map[FALSE] # NIL) THEN
        CG.Comment (-1, FALSE, &quot;load map&quot;, Target.EOL,
                    M3Buf.ToText (load_map[FALSE]),
                    M3Buf.ToText (load_map[TRUE]));
        load_map[FALSE] := NIL;
        load_map[TRUE]  := NIL;
      END;
      CG.End_unit ();
      Host.env.note_webinfo (WebInfo.Finish ());
    Scope.Pop (zz);
    Revelation.Pop (yy);
    EVAL Switch (save);
    (* ETimer.Pop (); *)
  END Compile;

PROCEDURE <A NAME="CompileInterface"><procedure>CompileInterface</procedure></A> (t: T) =
  VAR proc_info, type_map, rev_full, rev_part: INTEGER;
  BEGIN
    (* declare the modules that I import &amp; export *)
    (** EVAL GlobalData (t); **)
    CG.Export_unit (t.name);
    Host.env.note_interface_use (t.name, imported := FALSE);
    IF (t.genericBase # M3ID.NoID) THEN
      Host.env.note_generic_use (t.genericBase);
    END;
    External.GenLinkInfo (t.externals);
    ImportImplementations ();

    (* declare my imports, exports and local variables *)
    External.GenImports (t.externals);
    Scope.Enter (t.importScope);
    Scope.Enter (t.localScope);

    (* declare any visible revelations *)
    Revelation.Declare (t.revelations, rev_full, rev_part);

    (* generate any internal procedures *)
    ProcBody.EmitAll (proc_info);

    type_map := Variable.GenGlobalMap (t.localScope);

    GenLinkerInfo (t, proc_info, type_map, rev_full, rev_part);

  END CompileInterface;

PROCEDURE <A NAME="CompileModule"><procedure>CompileModule</procedure></A> (t: T) =
  VAR proc_info, type_map, rev_full, rev_part: INTEGER;
  BEGIN
    (* declare the modules that I import &amp; export *)
    IF (t.genericBase # M3ID.NoID) THEN
      Host.env.note_generic_use (t.genericBase);
    END;
    External.GenLinkInfo (t.externals);

    (* declare my imports, exports and local variables *)
    (**** moved below **** External.GenImports (t.externals); *)
    Scope.Enter (t.importScope);
    Scope.Enter (t.localScope);

    (* declare any visible revelations *)
    Revelation.Declare (t.revelations, rev_full, rev_part);

    (* generate the tables for coverage *)
    Coverage.GenerateTables ();

    (* generate any internal procedures *)
    ProcBody.EmitAll (proc_info);

    type_map := Variable.GenGlobalMap (t.localScope);

    (* declare my imports *)
    External.GenImports (t.externals);
    (* we deferred the import declarations until all the code
       has been generated to pick up imports that are used
       via &quot;Value.Load&quot;, but not &quot;Scope.LookUp&quot;. *)

    GenLinkerInfo (t, proc_info, type_map, rev_full, rev_part);

  END CompileModule;

PROCEDURE <A NAME="DeclareGlobalData"><procedure>DeclareGlobalData</procedure></A> (t: T) =
  BEGIN
    CG.Comment (-1, FALSE, &quot;module global constants&quot;);
    t.globals[TRUE].seg := CG.Declare_segment (M3ID.NoID,
                                                ModuleTypeUID, is_const := TRUE);
    CG.Comment (-1, FALSE, &quot;module global data&quot;);
    t.globals[FALSE].seg := CG.Declare_segment (M3ID.Add (DataName (t)),
                                                ModuleTypeUID, is_const := FALSE);
  END DeclareGlobalData;

PROCEDURE <A NAME="GlobalData"><procedure>GlobalData</procedure></A> (is_const: BOOLEAN): CG.Var =
  BEGIN
    &lt;*ASSERT curModule.compile_age &gt;= compile_age*&gt;
    RETURN curModule.globals[is_const].seg;
  END GlobalData;

PROCEDURE <A NAME="LoadGlobalAddr"><procedure>LoadGlobalAddr</procedure></A> (t: T;  offset: INTEGER;  is_const: BOOLEAN) =
  BEGIN
    &lt;*ASSERT t.compile_age &gt;= compile_age*&gt;
    IF (t = curModule) THEN
      CG.Load_addr_of (t.globals[is_const].seg, offset, CG.Max_alignment);
    ELSE
      &lt;*ASSERT NOT is_const*&gt;
      ImportInterface (t);
      CG.Load_addr (curModule.globals[FALSE].seg, t.import_offs + M3RT.II_import);
      CG.Boost_alignment (CG.Max_alignment);
      CG.Add_offset (offset);
    END;
  END LoadGlobalAddr;

PROCEDURE <A NAME="ImportInterface"><procedure>ImportInterface</procedure></A> (t: T) =
  BEGIN
    &lt;*ASSERT t.compile_age &gt;= compile_age*&gt;
    IF (t # curModule) AND (t.import_offs &lt; 0) THEN
      (* this is the first reference to the imported interface 't' *)
      t.import_offs := BuildImportLink (t.name, BinderName (t.name, t.interface));
    END;
  END ImportInterface;

PROCEDURE <A NAME="BuildImportLink"><procedure>BuildImportLink</procedure></A> (nm: M3ID.T;  binder: TEXT): INTEGER =
  VAR
    new_proc  : BOOLEAN;
    prev_link : INTEGER;
    offset    := Allocate (M3RT.II_SIZE, Target.Address.align, FALSE,
                           &quot;import &quot;, nm);
    proc      := CG.Import_procedure (M3ID.Add (binder), 0, CG.Type.Addr,
                                       Target.DefaultCall, new_proc);
  BEGIN
    IF (curModule.last_import = 0)
      THEN prev_link := M3RT.MI_imports;
      ELSE prev_link := curModule.last_import + M3RT.II_next;
    END;
    curModule.last_import := offset;
    CG.Init_var (prev_link, curModule.globals[FALSE].seg, offset, FALSE);
    CG.Init_proc (offset + M3RT.II_binder, proc, FALSE);
    RETURN offset;
  END BuildImportLink;

PROCEDURE <A NAME="ImportImplementations"><procedure>ImportImplementations</procedure></A> () =
  (* Generate the import and initialization links that cause the
     importer of an interface to also bind to the implementations
     of that interface. *)
  VAR x := Host.env.get_implementations (curModule.name);
  BEGIN
    WHILE (x # NIL) DO
      EVAL BuildImportLink (x.impl, BinderName (x.impl, interface := FALSE));
      x := x.next;
    END;
  END ImportImplementations;

PROCEDURE <A NAME="EmitDecl"><procedure>EmitDecl</procedure></A> (x: InitBody) =
  VAR t := x.self;
  BEGIN
    IF (x.cg_proc # NIL) THEN RETURN END;
    Scanner.offset := t.body_origin;
    CG.Gen_location (t.body_origin);
    x.cg_proc := CG.Declare_procedure (M3ID.Add (x.name), 1, CG.Type.Addr,
       lev := 0, cc := Target.DefaultCall, exported := TRUE, parent := NIL);
    x.arg := CG.Declare_param (M3ID.Add (&quot;mode&quot;), Target.Integer.size,
                               Target.Integer.align, Target.Integer.cg_type,
                               Type.GlobalUID (Int.T), (*in_memory*) FALSE,
                               (*up_level*) FALSE, (*frequency*) CG.Always);
  END EmitDecl;

PROCEDURE <A NAME="EmitBody"><procedure>EmitBody</procedure></A> (x: InitBody) =
  VAR t := x.self;  zz: Scope.T;   skip := CG.Next_label ();
  BEGIN
    IF (x.cg_proc = NIL) THEN RETURN END;

    (* restore my environment *)
    zz := Scope.Push (t.localScope);

    (* generate my initialization procedure *)
    CG.Comment (-1, FALSE, &quot;module main body &quot;, x.name);
    Scanner.offset := t.body_origin;
    CG.Gen_location (t.body_origin);
    CG.Begin_procedure (x.cg_proc);

    CG.Load_int (Target.Integer.cg_type, x.arg);
    CG.If_false (skip, CG.Never);

    Scope.InitValues (t.importScope);
    Scope.InitValues (t.localScope);

    (* initialize my exported variables *)
    External.InitGlobals (t.externals);

    (* perform the main body *)
    Tracer.Push (t.trace);
    EVAL Stmt.Compile (t.block);
    Tracer.Pop (t.trace);

    CG.Set_label (skip);

    CG.Load_addr_of (t.globals[FALSE].seg, 0, CG.Max_alignment);
    CG.Exit_proc (CG.Type.Addr);
    CG.End_procedure (x.cg_proc);

    Scope.Pop (zz);
  END EmitBody;

PROCEDURE <A NAME="GenLinkerInfo"><procedure>GenLinkerInfo</procedure></A> (t: T;  proc_info, type_map, rev_full, rev_part: INTEGER) =
  VAR
    v  := t.globals[FALSE].seg;
    vc := t.globals[TRUE].seg;
    file: TEXT;
    line, offs: INTEGER;
    type_cells, type_cell_ptrs: INTEGER;
    exception_scopes := Marker.EmitScopeTable ();
  BEGIN
    Scanner.offset := t.origin;
    IF (t.genericFile # NIL) THEN
      offs := CG.EmitText (t.genericFile, is_const := TRUE);
    ELSE
      Scanner.Here (file, line);
      offs := CG.EmitText (file, is_const := TRUE);
    END;
    CG.Init_var (M3RT.MI_file, vc, offs, is_const := FALSE);
    CG.Comment (offs, TRUE, &quot;file name&quot;);

    type_cells := Type.GenCells ();
    type_cell_ptrs := Type.GenCellPtrs ();
    (* note: the type info cannot be generated until *all* types have
       have been declared *)

    IF (type_cells &gt;= 0) THEN
      CG.Init_var (M3RT.MI_type_cells, v, type_cells, FALSE);
    END;
    IF (type_cell_ptrs &gt;= 0) THEN
      CG.Init_var (M3RT.MI_type_cell_ptrs, v, type_cell_ptrs, FALSE);
    END;
    IF (rev_full &gt;= 0) THEN
      CG.Init_var (M3RT.MI_full_rev, vc, rev_full, FALSE);
    END;
    IF (rev_part &gt;= 0) THEN
      CG.Init_var (M3RT.MI_part_rev, vc, rev_part, FALSE);
    END;
    IF (proc_info &gt;= 0) THEN
      CG.Init_var (M3RT.MI_proc_info, vc, proc_info, FALSE);
    END;
    IF (exception_scopes &gt;= 0) THEN
      CG.Init_var (M3RT.MI_try_scopes, vc, exception_scopes, FALSE);
    END;
    IF (type_map &gt;= 0) THEN
      CG.Init_var (M3RT.MI_var_map, vc, type_map, FALSE);
      CG.Init_var (M3RT.MI_gc_map, vc, type_map, FALSE);
    END;
    IF (t.body # NIL) AND (t.body.cg_proc # NIL) THEN
      CG.Init_proc (M3RT.MI_binder, t.body.cg_proc, FALSE);
    END;
    IF (Host.doIncGC) AND (Host.doGenGC) THEN
      CG.Init_intt (M3RT.MI_gc_flags, Target.Integer.size, 3, FALSE);
    ELSIF (Host.doIncGC) THEN
      CG.Init_intt (M3RT.MI_gc_flags, Target.Integer.size, 2, FALSE);
    ELSIF (Host.doGenGC) THEN
      CG.Init_intt (M3RT.MI_gc_flags, Target.Integer.size, 1, FALSE);
    END;

    (* finish up the global data segment allocations *)
    EVAL Allocate (0, Target.Address.align, FALSE, &quot;*TOTAL*&quot;);
    EVAL Allocate (0, Target.Address.align, TRUE, &quot;*TOTAL*&quot;);

    (* generate a debugging type descriptor for the global data *)
    CG.Comment (-1, FALSE, &quot;global constant type descriptor&quot;);
    CG.Emit_global_record (t.globals[TRUE].size, TRUE);
    CG.Comment (-1, FALSE, &quot;global data type descriptor&quot;);
    CG.Emit_global_record (t.globals[FALSE].size, FALSE);

    (* finish the global data initializations *)
    CG.Comment (-1, TRUE, &quot;module global constants&quot;);
    CG.Bind_segment (t.globals[TRUE].seg, t.globals[TRUE].size, CG.Max_alignment,
                     CG.Type.Struct, exported := FALSE, init := TRUE,
                     is_const := TRUE);
    CG.Comment (-1, FALSE, &quot;module global data&quot;);
    CG.Bind_segment (t.globals[FALSE].seg, t.globals[FALSE].size, CG.Max_alignment,
                     CG.Type.Struct, exported := FALSE, init := TRUE,
                     is_const := FALSE);
  END GenLinkerInfo;

PROCEDURE <A NAME="AddFPTag"><procedure>AddFPTag</procedure></A> (t: T;  VAR x: M3.FPInfo): CARDINAL =
  CONST Tags = ARRAY BOOLEAN OF TEXT { &quot;MODULE &quot;, &quot;INTERFACE &quot; };
  BEGIN
    ValueRep.FPStart (t, x, Tags[t.interface], 0, global := FALSE);
    RETURN 0;
  END AddFPTag;

PROCEDURE <A NAME="FPType"><procedure>FPType</procedure></A> (&lt;*UNUSED*&gt; t: T): Type.T =
  BEGIN
    RETURN NIL;
  END FPType;

PROCEDURE <A NAME="Current"><procedure>Current</procedure></A> (): T =
  BEGIN
    RETURN curModule;
  END Current;

PROCEDURE <A NAME="Name"><procedure>Name</procedure></A> (t: T): M3ID.T =
  BEGIN
    IF (t = NIL) THEN t := curModule;   END;
    IF (t = NIL) THEN RETURN M3ID.NoID; END;
    RETURN t.name;
  END Name;

PROCEDURE <A NAME="DataName"><procedure>DataName</procedure></A> (t: T): TEXT =
  BEGIN
    IF (t = NIL) THEN t := curModule; END;
    IF (t = NIL) THEN RETURN &quot;&quot;;      END;
    IF (t.data_name = NIL) THEN
      t.data_name := GlobalDataPrefix [t.interface] &amp; M3ID.ToText (t.name);
    END;
    RETURN t.data_name;
  END DataName;

PROCEDURE <A NAME="BinderName"><procedure>BinderName</procedure></A> (nm: M3ID.T;  interface: BOOLEAN): TEXT =
  BEGIN
    RETURN M3ID.ToText (nm) &amp; MainBodySuffix[interface];
  END BinderName;

PROCEDURE <A NAME="GetNextCounter"><procedure>GetNextCounter</procedure></A> (VAR c: ARRAY [0..4] OF CHAR) =
  BEGIN
    &lt;* ASSERT curModule # NIL *&gt;
    WITH cnt = curModule.counter DO
      c := curModule.counter;

      (* bump the counter *)
      FOR j := LAST (cnt) TO FIRST (cnt) BY -1 DO
        IF (cnt[j] = '9')
           THEN cnt[j] := '0';
           ELSE cnt[j] := VAL (ORD (cnt[j]) + 1, CHAR);  EXIT;
        END;
      END;
    END;
  END GetNextCounter;

PROCEDURE <A NAME="GetTypeInfo"><procedure>GetTypeInfo</procedure></A> (t: T): Type.ModuleInfo =
  BEGIN
    RETURN t.type_info;
  END GetTypeInfo;

PROCEDURE <A NAME="VisitImports"><procedure>VisitImports</procedure></A> (v: Visitor) =
  BEGIN
    &lt;*ASSERT visit_proc = NIL *&gt;
    visit_proc := v;
    INC (visit_age);
    External.Visit (curModule.externals, InnerVisit);
    visit_proc := NIL;
  END VisitImports;

PROCEDURE <A NAME="InnerVisit"><procedure>InnerVisit</procedure></A> (t: T) =
  BEGIN
    IF (t # NIL) AND (t.visit_age &lt; visit_age) THEN
      t.visit_age := visit_age;
      External.Visit (t.externals, InnerVisit);
      visit_proc (t);
    END;
  END InnerVisit;

BEGIN
END Module.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface M3ID is in:
</A><UL>
<LI><A HREF="../../../m3middle/src/M3ID.i3.html#0TOP0">m3middle/src/M3ID.i3</A>
<LI><A HREF="../../../m3scan/src/M3ID.i3.html#0TOP0">m3scan/src/M3ID.i3</A>
</UL>
<P>
<HR>
<A NAME="x2">interface Value is in:
</A><UL>
<LI><A HREF="Value.i3.html#0TOP0">m3front/src/values/Value.i3</A>
<LI><A HREF="../../../sharedobjgen/src/Value.i3.html#0TOP0">sharedobjgen/src/Value.i3</A>
<LI><A HREF="../../../stablegen/src/Value.i3.html#0TOP0">stablegen/src/Value.i3</A>
<LI><A HREF="../../../stubgen/src/Value.i3.html#0TOP0">stubgen/src/Value.i3</A>
</UL>
<P>
<HR>
<A NAME="x3">interface Type is in:
</A><UL>
<LI><A HREF="../../../cm3ide/src/nodes/Type.i3.html#0TOP0">cm3ide/src/nodes/Type.i3</A>
<LI><A HREF="../types/Type.i3.html#0TOP0">m3front/src/types/Type.i3</A>
<LI><A HREF="../../../sharedobjgen/src/Type.i3.html#0TOP0">sharedobjgen/src/Type.i3</A>
<LI><A HREF="../../../stablegen/src/Type.i3.html#0TOP0">stablegen/src/Type.i3</A>
<LI><A HREF="../../../stubgen/src/Type.i3.html#0TOP0">stubgen/src/Type.i3</A>
</UL>
<P>
<HR>
<A NAME="x4">interface Token is in:
</A><UL>
<LI><A HREF="../misc/Token.i3.html#0TOP0">m3front/src/misc/Token.i3</A>
<LI><A HREF="../../../mentor/src/parse/Token.i3.html#0TOP0">mentor/src/parse/Token.i3</A>
</UL>
<P>
<HR>
<A NAME="x5">interface Decl is in:
</A><UL>
<LI><A HREF="../../../cm3ide/src/nodes/Decl.i3.html#0TOP0">cm3ide/src/nodes/Decl.i3</A>
<LI><A HREF="Decl.i3.html#0TOP0">m3front/src/values/Decl.i3</A>
</UL>
<P>
<HR>
<A NAME="x6">interface Marker is in:
</A><UL>
<LI><A HREF="../../../cm3ide/src/markup/Marker.i3.html#0TOP0">cm3ide/src/markup/Marker.i3</A>
<LI><A HREF="../misc/Marker.i3.html#0TOP0">m3front/src/misc/Marker.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
