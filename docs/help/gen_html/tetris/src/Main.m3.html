<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: tetris/src/Main.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>tetris/src/Main.m3</H2></A><HR>
<inModule>
<PRE></PRE> <P>
  Translation to Modula-3:
        Copyright 1990, 1991 Digital Equipment Corporation 
<P>
  Modifications for Xaw widget set, and other improvements,
  designated XTETRIS versions 2.X:
        Copyright 1990, 1991 Daniel R. Greening
<P>
  Modifications for X : Didier Tallot &lt;tallot@bdblues.altair.fr&gt;
        Copyright 1989 Didier Tallot
<P>
  Copyright 1989 Phill Everson &amp; Martyn Shortley
<P>
  This notice and any statement of authorship must be reproduced
  on all copies.  The authors do not make any warranty expressed
  or implied, or assume any liability or responsiblity for the
  use of this software.
<P>
  Any distributor of copies of this software shall grant the
  recipient permission for further redistribution as permitted
  by this notice.  Any distributor must distribute this software
  without any fee or other monetary gains, unless expressed written
  permission is granted by the authors.
<P>
  This software or its use shall not be: sold, rented, leased,
  traded, or otherwise marketed without the expressed written
  permission of the authors.


<P> Last modified on Mon Jan 30 16:00:07 PST 1995 by kalsow       
      modified on Wed Oct 14 13:12:38 PDT 1992 by muller       
      modified on Tue Apr 24 09:07:35 1990 by jerome           

<P><PRE>UNSAFE MODULE <module><implements><A HREF="../../m3core/src/main/Main.i3.html">Main</A></implements></module>;

FROM <A HREF="../../m3core/src/C/Common/M3toC.i3.html">M3toC</A> IMPORT FlatTtoS, StoT, SharedTtoS, FreeSharedS;

IMPORT <A HREF="../../libm3/src/rw/FileRd.i3.html">FileRd</A>, <A HREF="../../libm3/src/rw/FileWr.i3.html">FileWr</A>, <A HREF="../../libm3/src/fmtlex/Fmt.i3.html">Fmt</A>, <A HREF="../../libm3/src/random/Common/Random.i3.html">Random</A>, <A HREF="../../libm3/src/rw/Rd.i3.html">Rd</A>, <A HREF="../../libm3/src/fmtlex/Scan.i3.html">Scan</A>, <A HREF="../../libm3/src/rw/Stdio.i3.html">Stdio</A>, <A HREF="../../m3core/src/text/Text.i3.html">Text</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="../../m3core/src/word/Word.i3.html">Word</A>;
IMPORT <A HREF="../../m3core/src/C/Common/Ctypes.i3.html">Ctypes</A>, <A HREF="../../m3core/src/C/Common/Cstdlib.i3.html">Cstdlib</A>, <A HREF="#x1">Utime</A>, <A HREF="#x2">Uutmp</A>, <A HREF="../../m3core/src/runtime/common/RTLinker.i3.html">RTLinker</A>, <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../libm3/src/os/Common/OSError.i3.html">OSError</A>;
IMPORT <A HREF="../../X11R4/src/Common/X.i3.html">X</A>, <A HREF="../../X11R4/src/Common/Xrm.i3.html">Xrm</A>, <A HREF="../../X11R4/src/Common/Xt.i3.html">Xt</A>, <A HREF="../../X11R4/src/Common/XtN.i3.html">XtN</A>, <A HREF="../../X11R4/src/Common/XtR.i3.html">XtR</A>, <A HREF="../../X11R4/src/Common/Xaw.i3.html">Xaw</A>, <A HREF="../../m3core/src/C/Common/M3toC.i3.html">M3toC</A>, <A HREF="../../libm3/src/params/Params.i3.html">Params</A>;
&lt;*FATAL ANY*&gt;

CONST

  NWIDTH           =  10;               (* canvas width in units *)
  MWIDTH           =  NWIDTH-1;         (* max index *)
  NHEIGHT          =  30;               (* canvas height in units *)
  MHEIGHT          =  NHEIGHT-1;        (* max index *)
  NSHAPE           =  7;                (* number of different shapes *)
  MSHAPE           =  NSHAPE-1;         (* max index *)
  NROT             =  4;                (* number of rotations *)
  MROT             =  NROT-1;           (* max index *)
  NHSCORE          =  20;               (* number of recorded high scores *)
  MHSCORE          =  NHSCORE-1;        (* max index *)

  HIGH_SCORE_FILE  =  &quot;tetris_scores&quot;;

TYPE

  READER           =  Rd.T;
  WRITER           =  Wr.T;
  WORD             =  Word.T;

  resource_res = RECORD
    foreground:   Xt.Pixel;
    background:   Xt.Pixel;
    boxsize:      Xt.Dimension;
    scorefilep:   INTEGER;
    startscore:   INTEGER;
    startrows:    INTEGER;
    startlevel:   INTEGER
  END;

  score_rec = RECORD
    name:  TEXT;
    score: INTEGER;
    rows:  INTEGER;
    level: INTEGER;
    date:  TEXT
  END;

  Int4 = ARRAY [0..MROT] OF INTEGER;

  rotate_rec = RECORD
    unitson:  WORD;         (* an array of 4x4 = 16 bits, indicating the
                               on units in this order:
                                   &lt;3,3&gt; &lt;2,3&gt; &lt;1,3&gt; &lt;0,3&gt; &lt;3,2&gt; ... &lt;0,0&gt; *)
    points:   INTEGER;      (* Points for acceptance in this position. *)
    highesty: Int4;         (* highest non-0 y in unitson, for each x *)
    highestx: Int4;         (* highest non-0 x in unitson, for each y *)
    lowestx:  Int4          (* lowest  non-0 y in unitson, for each y *)
  END;

  shape_rec = RECORD
    forms:        ARRAY [0..MROT] OF rotate_rec;
    foreground:   Xt.Pixel;
    background:   Xt.Pixel;
    gc:           X.GC
  END;

VAR
  rand : Random.T := NEW (Random.Default).init ();

  (* get from resource database *)

  foreground:         Xt.Pixel;
  background:         Xt.Pixel;
  scorefilep:         BOOLEAN;          (* use / don't use score file *)
  bsize:              Xt.Dimension;     (* size of one unit box *)
  startscore:         INTEGER;          (* starting value *)
  startrows:          INTEGER;          (* starting value *)
  startlevel:         INTEGER;          (* starting value *)

  score:              INTEGER;          (* the actual score *)
  rows:               INTEGER;          (* the number of removed rows *)
  level:              INTEGER;          (* the actual level *)

  False: X.Bool       := 0;             (* to de defined in X.i3 ... *)

  user_name:          TEXT;
  running:            BOOLEAN;

  cur_shape:          INTEGER;          (* the current moving shape *)
  cur_xpos:           INTEGER;          (* the current xpos for cur_shape *)
  cur_ypos:           INTEGER;          (* the current ypos for cur_shape *)
  cur_rot:            INTEGER;          (* the current rot for cur_shape *)

  next_shape:         INTEGER;          (* the next moving shape *)
  next_rot:           INTEGER;          (* the current rot for next_shape *)

  context:            Xt.AppContext;

  toplevel:           Xt.Widget;
  frame:              Xt.Widget;
  left_frame:         Xt.Widget;
  right_frame:        Xt.Widget;
  stat_frame:         Xt.Widget;
  stat_shapes:        ARRAY [0..MSHAPE] OF Xt.Widget;
  stat_labels:        ARRAY [0..MSHAPE] OF Xt.Widget;
  score_frame:        Xt.Widget;
  score_panel:        Xt.Widget;
  canvas:             Xt.Widget;
  shadow:             Xt.Widget;
  nextobj:            Xt.Widget;
  stats:              Xt.Widget;
  start_bt:           Xt.Widget;
  pause_bt:           Xt.Widget;
  newgame_bt:         Xt.Widget;
  quit_bt:            Xt.Widget;
  score_item:         Xt.Widget;
  level_item:         Xt.Widget;
  rows_item:          Xt.Widget;
  game_over:          Xt.Widget;

  shadegc:            X.GC;   (* to add a shadow for block unit *)
  erasegc:            X.GC;   (* when a line is removed *)
  movegc:             X.GC;   (* to blit the canvas after removing a line *)

  gcval:=             NEW (UNTRACED REF X.XGCValues);

  grid:               ARRAY [0..MWIDTH], [0..MHEIGHT] OF X.GC;
  shapes:             ARRAY [0..MSHAPE] OF shape_rec;
  stat_totals:        ARRAY [0..MSHAPE] OF INTEGER;
  stat_counts:        ARRAY [0..MSHAPE] OF INTEGER;
  high_scores:        ARRAY [0..MHSCORE] OF score_rec;
  high_score_item:    ARRAY [0..MHSCORE+2] OF Xt.Widget;
  high_score_def      := score_rec {&quot;&quot;, 0, 0, 0,&quot;&quot;};

  shapenames          := ARRAY [0..7] OF TEXT
                            {&quot;Shape&quot;,  &quot;shape0&quot;, &quot;shape1&quot;, &quot;shape2&quot;,
                             &quot;shape3&quot;, &quot;shape4&quot;, &quot;shape5&quot;, &quot;shape6&quot;};

  fallbacklist        := NEW (Xt.FallbackResList);
  options             := NEW (Xrm.OptionDescList);
  resources           := NEW (UNTRACED REF resource_res);
  actions             := NEW (Xt.ActionList);
  reslist             := NEW (Xt.ResourceList);
  args                := NEW (Xt.ArgList);

  count:              INTEGER;

CONST
  fallbacktext  = ARRAY [0..30] OF TEXT {
    &quot;*LeftFrame.Buttons.NewGame.translations: #augment \\n&quot; &amp;
    &quot;        &lt;Btn1Down&gt;,&lt;Btn1Up&gt;: NewGame() notify()&quot;,
    &quot;*LeftFrame.Buttons.Pause.translations: #override \\n&quot; &amp;
    &quot;        &lt;Btn1Down&gt;,&lt;Btn1Up&gt;: Pause()&quot;,
    &quot;*LeftFrame.Buttons.Quit.translations: #augment \\n&quot; &amp;
    &quot;        &lt;Btn1Down&gt;,&lt;Btn1Up&gt;: Quit() notify()&quot;,
    &quot;*LeftFrame.Buttons.Scores.translations: #augment \\n&quot; &amp;
    &quot;        &lt;Btn1Down&gt;,&lt;Btn1Up&gt;: Scores() notify()&quot;,
    &quot;*LeftFrame.Buttons.Start.translations: #override \\n&quot; &amp;
    &quot;        &lt;Btn1Down&gt;,&lt;Btn1Up&gt;: Start()&quot;,
    &quot;*RightFrame.Canvas.translations: &quot; &amp;
    &quot;      &lt;Expose&gt;: Refresh() \\n&quot; &amp;
    &quot;      !Shift&lt;Btn1Down&gt;: RotateCCW() \\n&quot; &amp;
    &quot;      !&lt;Btn1Down&gt;: MoveLeft() \\n&quot; &amp;
    &quot;      !Shift&lt;Btn3Down&gt;: RotateCW() \\n&quot; &amp;
    &quot;      !&lt;Btn3Down&gt;: MoveRight() \\n&quot; &amp;
    &quot;      !Shift&lt;Btn2Down&gt;: Drop()&quot;,
    &quot;*RightFrame.Canvas.accelerators: &quot; &amp;
    &quot;      &lt;Key&gt;space: Drop() \\n&quot; &amp;
    &quot;      &lt;Key&gt;h: MoveLeft() \\n&quot; &amp;
    &quot;      &lt;Key&gt;q: Quit() \\n&quot; &amp;
    &quot;      &lt;Key&gt;p: Pause() \\n&quot; &amp;
    &quot;      &lt;Key&gt;s: Start() \\n&quot; &amp;
    &quot;      &lt;Key&gt;r: NewGame() \\n&quot; &amp;
    &quot;      &lt;Key&gt;Left: MoveLeft() \\n&quot; &amp;
    &quot;      &lt;Key&gt;j: RotateCW() \\n&quot; &amp;
    &quot;      &lt;Key&gt;Down: RotateCW() \\n&quot; &amp;
    &quot;      &lt;Key&gt;k: RotateCCW() \\n&quot; &amp;
    &quot;      &lt;Key&gt;Up: RotateCCW() \\n&quot; &amp;
    &quot;      &lt;Key&gt;l: MoveRight() \\n&quot; &amp;
    &quot;      &lt;Key&gt;Right: MoveRight()&quot;,
    &quot;*LeftFrame.NextObject.translations: &quot; &amp;
    &quot;      &lt;Expose&gt;:Refresh()&quot;,
    &quot;*RightFrame.Shadow.translations: &quot; &amp;
    &quot;      &lt;Expose&gt;:Refresh()&quot;,
    &quot;*StatFrame.Shapes.translations: &quot; &amp;
    &quot;      &lt;Expose&gt;:Refresh()&quot;,
    &quot;*ScoreFrame.ScorePanel.Close.translations: #augment \\n&quot; &amp;
    &quot;         &lt;Btn1Down&gt;,&lt;Btn1Up&gt;:Close()&quot;,
    &quot;*ScorePanel.Close.translations:        #augment \\n&quot; &amp;
    &quot;        &lt;Btn1Down&gt;,&lt;Btn1Up&gt;:Close()&quot;,
    &quot;Tetris*BorderWidth: 1&quot;,
    &quot;Tetris*ShapeStyle: Oval&quot;,
    &quot;Tetris.shape0.foreground:   #ff0000&quot;, (* red1 *)
    &quot;Tetris.shape0.background:   #8b0000&quot;, (* red4 *)
    &quot;Tetris.shape1.foreground:   #ffa500&quot;, (* orange1 *)
    &quot;Tetris.shape1.background:   #8b5a00&quot;, (* orange4 *)
    &quot;Tetris.shape2.foreground:   #ffff00&quot;, (* yellow1 *)
    &quot;Tetris.shape2.background:   #8b8b00&quot;, (* yellow4 *)
    &quot;Tetris.shape3.foreground:   #00ff00&quot;, (* green1 *)
    &quot;Tetris.shape3.background:   #008b00&quot;, (* green4 *)
    &quot;Tetris.shape4.foreground:   #0000ff&quot;, (* blue1 *)
    &quot;Tetris.shape4.background:   #00008b&quot;, (* blue4 *)
    &quot;Tetris.shape5.foreground:   #00ffff&quot;, (* cyan1 *)
    &quot;Tetris.shape5.background:   #008b8b&quot;, (* cyan4 *)
    &quot;Tetris.shape6.foreground:   #9b30ff&quot;, (* purple1 *)
    &quot;Tetris.shape6.background:   #551a8b&quot;, (* purple4 *)
    &quot;Tetris*ScorePanel*Font:     8x13&quot;,
    &quot;Tetris*Font:      -*-helvetica-bold-r-*-*-*-120-*-*-*-*-*-*&quot;,
    &quot;Tetris*Buttons*width:        100&quot;
  };
</PRE>*******************************************************************
<P>
                        X 1 1   U T I L I T I E S
<P>
 *******************************************************************

<P>
<P><PRE>PROCEDURE <A NAME="SetValueText"><procedure>SetValueText</procedure></A> (w: Xt.Widget; name: Xt.String; val: TEXT) =
BEGIN
  WITH string = SharedTtoS(val) DO
    args[0] := Xt.Arg {name, string};
    Xt.SetValues (w, args, 1);
    FreeSharedS(val, string);
  END;
END SetValueText;

PROCEDURE <A NAME="CreateWidget"><procedure>CreateWidget</procedure></A> (name: TEXT; class: Xt.WidgetClass; parent: Xt.Widget;
                      args: Xt.ArgList := NIL; narg: INTEGER := 0): Xt.Widget =
BEGIN
  WITH string = SharedTtoS (name) DO
    TRY
      RETURN (Xt.CreateManagedWidget (string, class, parent, args, narg))
    FINALLY
      FreeSharedS(name, string);
    END
  END
END CreateWidget;

PROCEDURE <A NAME="SetArgI"><procedure>SetArgI</procedure></A> (VAR args: Xt.ArgList; VAR count: INTEGER;
                   name: Xt.String; val: INTEGER) =
BEGIN
  args[count] := Xt.Arg {name, LOOPHOLE (val, ADDRESS)};
  INC (count)
END SetArgI;

PROCEDURE <A NAME="SetArgA"><procedure>SetArgA</procedure></A> (VAR args: Xt.ArgList; VAR count: INTEGER;
                   name: Xt.String; val: ADDRESS) =
BEGIN
  args[count] := Xt.Arg {name, val};
  INC (count)
END SetArgA;

PROCEDURE <A NAME="SetArgT"><procedure>SetArgT</procedure></A> (VAR args: Xt.ArgList; VAR count: INTEGER;
                   name: Xt.String; val: TEXT) =
BEGIN
  args[count] := Xt.Arg {name, FlatTtoS(val)};
  INC (count)
END SetArgT;

PROCEDURE <A NAME="SetOption"><procedure>SetOption</procedure></A> (VAR optlist: Xrm.OptionDescList; VAR count: INTEGER;
                     optionn, specifier: TEXT;
                     argKind: Xrm.OptionKind; val: TEXT) =
BEGIN
  optlist[count] := Xrm.OptionDescRec{ FlatTtoS(optionn), FlatTtoS(specifier),
                                       argKind, FlatTtoS(val) };
  INC (count)
END SetOption;

PROCEDURE <A NAME="SetAction"><procedure>SetAction</procedure></A> (VAR optlist: Xt.ActionList; VAR count: INTEGER;
                     name: TEXT; proc: Xt.ActionProc) =
BEGIN
  optlist[count] :=  Xt.ActionsRec {FlatTtoS(name), proc};
  INC (count)
END SetAction;

PROCEDURE <A NAME="SetResource"><procedure>SetResource</procedure></A> (VAR reslist: Xt.ResourceList; VAR count: INTEGER;
                       name, class: TEXT; type: Xt.String; size, offset: Xt.Cardinal;
                       default_type: Xt.String; default_addr: TEXT) =
BEGIN
  reslist[count] :=  Xt.Resource {FlatTtoS (name), FlatTtoS (class), type,
                                  size, offset, default_type, FlatTtoS (default_addr)};
  INC (count)
END SetResource;

PROCEDURE <A NAME="MapWidget"><procedure>MapWidget</procedure></A> (widget: Xt.Widget) =
BEGIN
  X.XMapWindow (Xt.Display (widget), Xt.XtWindow (widget))
END MapWidget;

PROCEDURE <A NAME="UnmapWidget"><procedure>UnmapWidget</procedure></A> (widget: Xt.Widget) =
BEGIN
  X.XUnmapWindow (Xt.Display (widget), Xt.XtWindow (widget))
END UnmapWidget;
</PRE>*******************************************************************
<P>
                        The High Scores Display
<P>
 *******************************************************************

<P>
<P><PRE>PROCEDURE <A NAME="ReadHighScores"><procedure>ReadHighScores</procedure></A> () =
VAR
   rd: READER;
BEGIN
  IF NOT scorefilep THEN RETURN END;
  (* clear the high_scores structure *)
  FOR i := 0 TO MHSCORE DO
      high_scores[i] := high_score_def
  END;
  TRY rd := FileRd.Open (HIGH_SCORE_FILE);
  EXCEPT
  | OSError.E =&gt;
      scorefilep := FALSE;
      Wr.PutText (Stdio.stderr,
                    &quot;tetris: can\'t read score file: &quot; &amp;
                    HIGH_SCORE_FILE &amp;
                    &quot; Run with \'-noscore\' to avoid this message.\n&quot;);
     RETURN
  END;
  TRY FOR i := 0 TO MHSCORE DO
          high_scores[i].name  := Rd.GetLine (rd);
          high_scores[i].score := Scan.Int (Rd.GetLine (rd));
          high_scores[i].rows  := Scan.Int (Rd.GetLine (rd));
          high_scores[i].level := Scan.Int (Rd.GetLine (rd));
          high_scores[i].date  := Rd.GetLine (rd)
      END
   EXCEPT
      Rd.EndOfFile =&gt;
   END;
   Rd.Close (rd)
END ReadHighScores;

PROCEDURE <A NAME="WriteHighScores"><procedure>WriteHighScores</procedure></A> () =
VAR
  wr: WRITER;
BEGIN
  TRY wr := FileWr.Open (HIGH_SCORE_FILE);
  EXCEPT
  | OSError.E =&gt;
      scorefilep := FALSE;
      Wr.PutText (Stdio.stderr,
                    &quot;tetris: can\'t write score file: &quot; &amp;
                    HIGH_SCORE_FILE &amp;
                    &quot; Run with \'-noscore\' to avoid this message.\n&quot;);
     RETURN
  END;
  FOR i := 0 TO MHSCORE DO
      Wr.PutText (wr, high_scores[i].name &amp; &quot;\n&quot; &amp;
                      Fmt.Int (high_scores[i].score) &amp; &quot;\n&quot; &amp;
                      Fmt.Int (high_scores[i].rows) &amp; &quot;\n&quot; &amp;
                      Fmt.Int (high_scores[i].level) &amp; &quot;\n&quot; &amp;
                      high_scores[i].date &amp; &quot;\n&quot;);
  END;
  Wr.Close (wr)
END WriteHighScores;

PROCEDURE <A NAME="ShowHighScores"><procedure>ShowHighScores</procedure></A>  (&lt;*UNUSED*&gt; w: Xt.Widget;
                           &lt;*UNUSED*&gt;  event: X.XAnyEventStar;
                           &lt;*UNUSED*&gt; pars: Xt.StringStar;
                           &lt;*UNUSED*&gt;  npars: Xt.CardinalStar) =
BEGIN
  IF NOT scorefilep THEN RETURN END;
  (* re-read high-score table in case someone else on the network is
   * playing at the same time *)
  ReadHighScores ();
  SetValueText (high_score_item[0], XtN.string,
                &quot;Pos Name       Score  Rows Level  When                      &quot;);
  SetValueText (high_score_item[1], XtN.string, &quot; &quot;);
  FOR i := 0 TO MHSCORE DO
     SetValueText (high_score_item[i+2], XtN.string, &quot; &quot; &amp;
                     Fmt.Pad (Fmt.Int (i+1), 3, ' ', Fmt.Align.Left) &amp;
                     Fmt.Pad (high_scores[i].name, 10, ' ', Fmt.Align.Left) &amp;
                     Fmt.Pad (Fmt.Int (high_scores[i].score), 6) &amp;
                     Fmt.Pad (Fmt.Int (high_scores[i].rows), 6) &amp;
                      Fmt.Pad (Fmt.Int (high_scores[i].level), 6) &amp; &quot;  &quot; &amp;
                     high_scores[i].date);
  END;
  Xt.Popup (score_frame, Xt.GrabExclusive)
END ShowHighScores;

PROCEDURE <A NAME="UpdateHighScores"><procedure>UpdateHighScores</procedure></A> () =
VAR
  pos: INTEGER;
  strdate: Ctypes.char_star;
  tloc: Ctypes.long;
BEGIN
  IF NOT scorefilep THEN  RETURN END;
  (* re-read high-score table in case someone else on the network is
   * playing at the same time *)
  ReadHighScores ();
  (* Check for previous best score *)
  pos := -1;
  FOR i := 0 TO MHSCORE DO
      IF score &gt;= high_scores[i].score THEN pos := i; EXIT END;
  END;
  IF pos # -1 THEN
     (* Blit the high_score *)
     FOR i := MHSCORE TO pos+1 BY -1 DO
         high_scores[i] := high_scores[i-1]
     END;
     (* Force the new score *)
     high_scores[pos].name  := user_name;
     high_scores[pos].score := score;
     high_scores[pos].rows  := rows;
     high_scores[pos].level := level;
     EVAL Utime.time (ADR (tloc));
     strdate := Utime.ctime (tloc);
     high_scores[pos].date  := Text.Sub (StoT (strdate), 0, 24);
     (* and write back the new score *)
     WriteHighScores()
  END;
END UpdateHighScores;
</PRE>*********************************************************************
<P>
                        T I M E R  +  E V E N T S
<P>
 *********************************************************************

<P>
<P><PRE>VAR
  timer: Xt.IntervalId;

PROCEDURE <A NAME="StartTimer"><procedure>StartTimer</procedure></A> () =
VAR
  interval: Ctypes.unsigned_long;
  pevel: INTEGER;
BEGIN
  pevel := 50 - level;
  IF pevel &lt; 0 THEN pevel := 0 END;
  interval := pevel * 6;
  timer := Xt.AppAddTimeOut (context, interval, MoveBlock, NIL)
END StartTimer;

PROCEDURE <A NAME="MoveBlock"><procedure>MoveBlock</procedure></A> (&lt;*UNUSED*&gt; closure: Xt.Pointer;
                     &lt;*UNUSED*&gt; id: Xt.InputIdStar) =
BEGIN
  StartTimer ();
  IF BlockCanDown (cur_shape, cur_xpos, cur_ypos, cur_rot) THEN
     ShowShape (canvas, cur_shape, cur_xpos, cur_ypos, cur_rot, TRUE);
     cur_ypos := cur_ypos + 1;
  ELSE
     IF cur_ypos &lt; 0 THEN
        EndGame (toplevel, NIL, NIL, NIL)
     ELSE
        score := score + shapes[cur_shape].forms[cur_rot].points;
        UpdateGrid (cur_shape, cur_xpos, cur_ypos, cur_rot);
        RemoveFullLines (cur_ypos);
        CreateShape (TRUE);
        ShowStatLabel (cur_shape);
        ShowScoreProc (toplevel, NIL, NIL, NIL);
        ShowNext ();
        DrawShadow (cur_shape, cur_xpos, cur_ypos, cur_rot)
     END;
  END;
  ShowShape (canvas, cur_shape, cur_xpos, cur_ypos, cur_rot, FALSE)
END MoveBlock;

PROCEDURE <A NAME="StopTimer"><procedure>StopTimer</procedure></A> () =
BEGIN
  IF timer # 0 THEN
     Xt.RemoveTimeOut (timer);
     timer := 0
  END;
END StopTimer;

PROCEDURE <A NAME="SetEvents"><procedure>SetEvents</procedure></A> () =
BEGIN
  running := TRUE;
  UnmapWidget (start_bt);
  MapWidget (pause_bt);
END SetEvents;

PROCEDURE <A NAME="ClearEvents"><procedure>ClearEvents</procedure></A> () =
BEGIN
  running := FALSE;
  UnmapWidget (pause_bt);
  MapWidget (start_bt)
END ClearEvents;
</PRE>**********************************************************************
<P>
                        A C T I O N S
<P>
 **********************************************************************

<P> <CODE>Refresh</CODE> Action 

<P><PRE>PROCEDURE <A NAME="RefreshProc"><procedure>RefreshProc</procedure></A> (w: Xt.Widget; &lt;*UNUSED*&gt; event: X.XAnyEventStar;
                       &lt;*UNUSED*&gt; pars: Xt.StringStar;
                       &lt;*UNUSED*&gt; npars: Xt.CardinalStar) =
BEGIN
  IF w = canvas THEN
     FOR x := 0 TO MWIDTH DO
         FOR y := 0 TO MHEIGHT DO
             IF grid[x, y] # NIL THEN
                ShowRectangle (Xt.Display (w), Xt.XtWindow(w), grid[x, y],
                               x * bsize, y * bsize, bsize, bsize);
             END;
         END;
         ShowShape (canvas, cur_shape, cur_xpos, cur_ypos, cur_rot, FALSE)
     END
  ELSE
     IF w = shadow THEN
        DrawShadow (cur_shape, cur_xpos, cur_ypos, cur_rot);
     ELSE
        IF w = nextobj THEN
           ShowNext ()
        ELSE
           IF w = stats THEN
              FOR i := 0 TO MSHAPE DO
                  ShowShape (stat_shapes[i], i, 0, 0, 1, FALSE);
              END
           ELSE
           Wr.PutText (Stdio.stderr,
                       &quot;Hmm. I got a Refresh() for an unrecognized window!\n&quot;)
           END;
        END;
     END;
  END;
END RefreshProc;
</PRE> <CODE>ShowScore</CODE> Action 

<P><PRE>PROCEDURE <A NAME="ShowScoreProc"><procedure>ShowScoreProc</procedure></A> (&lt;*UNUSED*&gt; w: Xt.Widget;
                         &lt;*UNUSED*&gt; event: X.XAnyEventStar;
                         &lt;*UNUSED*&gt; pars: Xt.StringStar;
                         &lt;*UNUSED*&gt;  npars: Xt.CardinalStar) =
BEGIN
  SetValueText (score_item, XtN.string, &quot;Score: &quot; &amp; Fmt.Int (score));
  SetValueText (level_item, XtN.string, &quot;Level: &quot; &amp; Fmt.Int (level));
  SetValueText (rows_item,  XtN.string, &quot;Rows:  &quot; &amp; Fmt.Int (rows));
END ShowScoreProc;
</PRE> <CODE>Quit</CODE> Action 

<P><PRE>PROCEDURE <A NAME="QuitProc"><procedure>QuitProc</procedure></A> (&lt;*UNUSED*&gt; w: Xt.Widget;
                    &lt;*UNUSED*&gt; event: X.XAnyEventStar;
                    &lt;*UNUSED*&gt; pars: Xt.StringStar;
                    &lt;*UNUSED*&gt;  npars: Xt.CardinalStar) =
BEGIN
  ClearEvents ();
  StopTimer ();
  Xt.DestroyWidget (toplevel);
  Cstdlib.exit (0)
END QuitProc;
</PRE> <CODE>Close</CODE> Action 

<P><PRE>PROCEDURE <A NAME="CloseProc"><procedure>CloseProc</procedure></A> (&lt;*UNUSED*&gt; w: Xt.Widget;
                     &lt;*UNUSED*&gt;  event: X.XAnyEventStar;
                     &lt;*UNUSED*&gt; pars: Xt.StringStar;
                     &lt;*UNUSED*&gt;  npars: Xt.CardinalStar) =
BEGIN
  Xt.Popdown (score_frame);
END CloseProc;
</PRE> <CODE>EndGame</CODE> Action 

<P><PRE>PROCEDURE <A NAME="EndGame"><procedure>EndGame</procedure></A>  (w: Xt.Widget;
                    &lt;*UNUSED*&gt; event: X.XAnyEventStar;
                    &lt;*UNUSED*&gt; pars: Xt.StringStar;
                    &lt;*UNUSED*&gt;  npars: Xt.CardinalStar) =
BEGIN
  ClearEvents ();
  StopTimer ();
  UnmapWidget (start_bt);
  UnmapWidget (pause_bt);
  SetValueText (game_over, XtN.string, &quot;Game Over&quot;);
  UpdateHighScores ();
  ShowHighScores (w, NIL, NIL, NIL)
END EndGame;
</PRE> <CODE>Restart</CODE> Action 

<P><PRE>PROCEDURE <A NAME="RestartProc"><procedure>RestartProc</procedure></A> (&lt;*UNUSED*&gt; w: Xt.Widget;
                       &lt;*UNUSED*&gt; event: X.XAnyEventStar;
                       &lt;*UNUSED*&gt; pars: Xt.StringStar;
                       &lt;*UNUSED*&gt;  npars: Xt.CardinalStar) =
BEGIN
  ClearEvents ();
  StopTimer ();
  ClearGame ()
END RestartProc;
</PRE> <CODE>Start</CODE> Action 

<P><PRE>PROCEDURE <A NAME="StartProc"><procedure>StartProc</procedure></A> (&lt;*UNUSED*&gt; w: Xt.Widget;
                     &lt;*UNUSED*&gt;  event: X.XAnyEventStar;
                     &lt;*UNUSED*&gt; pars: Xt.StringStar;
                     &lt;*UNUSED*&gt;  npars: Xt.CardinalStar) =
BEGIN
  IF running THEN RETURN END;
  SetEvents ();
  StartTimer ()
END StartProc;
</PRE> <CODE>Pause</CODE> Action 

<P><PRE>PROCEDURE <A NAME="PauseProc"><procedure>PauseProc</procedure></A> (&lt;*UNUSED*&gt; w: Xt.Widget;
                     &lt;*UNUSED*&gt;  event: X.XAnyEventStar;
                     &lt;*UNUSED*&gt; pars: Xt.StringStar;
                     &lt;*UNUSED*&gt;  npars: Xt.CardinalStar) =
BEGIN
  IF NOT running THEN RETURN END;
  ClearEvents();
  StopTimer();
END PauseProc;
</PRE> Moving Actions 

<P><PRE>PROCEDURE <A NAME="LeftProc"><procedure>LeftProc</procedure></A> (&lt;*UNUSED*&gt; w: Xt.Widget;
                    &lt;*UNUSED*&gt;  event: X.XAnyEventStar;
                    &lt;*UNUSED*&gt; pars: Xt.StringStar;
                    &lt;*UNUSED*&gt;  npars: Xt.CardinalStar) =
BEGIN
  IF NOT running THEN RETURN END;
  IF BlockCanLeft (cur_shape, cur_xpos, cur_ypos, cur_rot) THEN
     ShowShape (canvas, cur_shape, cur_xpos, cur_ypos, cur_rot, TRUE);
     cur_xpos := cur_xpos - 1;
     ShowShape (canvas, cur_shape, cur_xpos, cur_ypos, cur_rot, FALSE);
     DrawShadow (cur_shape, cur_xpos, cur_ypos, cur_rot)
  END;
END LeftProc;

PROCEDURE <A NAME="RightProc"><procedure>RightProc</procedure></A> (&lt;*UNUSED*&gt; w: Xt.Widget;
                     &lt;*UNUSED*&gt; event: X.XAnyEventStar;
                     &lt;*UNUSED*&gt; pars: Xt.StringStar;
                     &lt;*UNUSED*&gt; npars: Xt.CardinalStar) =
BEGIN
  IF NOT running THEN RETURN END;
  IF BlockCanRight (cur_shape, cur_xpos, cur_ypos, cur_rot) THEN
     ShowShape (canvas, cur_shape, cur_xpos, cur_ypos, cur_rot, TRUE);
     cur_xpos := cur_xpos + 1;
     ShowShape (canvas, cur_shape, cur_xpos, cur_ypos, cur_rot, FALSE);
     DrawShadow (cur_shape, cur_xpos, cur_ypos, cur_rot)
  END;
END RightProc;

PROCEDURE <A NAME="AntiProc"><procedure>AntiProc</procedure></A> (&lt;*UNUSED*&gt; w: Xt.Widget;
                    &lt;*UNUSED*&gt; event: X.XAnyEventStar;
                    &lt;*UNUSED*&gt; pars: Xt.StringStar;
                    &lt;*UNUSED*&gt; npars: Xt.CardinalStar) =
VAR
  rot: INTEGER;
BEGIN
  IF NOT running THEN RETURN END;
  rot := (cur_rot + 3) MOD 4;
  IF BlockCanRot (cur_shape, cur_xpos, cur_ypos, rot) THEN
     ShowShape (canvas, cur_shape, cur_xpos, cur_ypos, cur_rot, TRUE);
     cur_rot := rot;
     ShowShape (canvas, cur_shape, cur_xpos, cur_ypos, cur_rot, FALSE);
     DrawShadow (cur_shape, cur_xpos, cur_ypos, cur_rot)
  END;
END AntiProc;

PROCEDURE <A NAME="ClockProc"><procedure>ClockProc</procedure></A> (&lt;*UNUSED*&gt; w: Xt.Widget;
                     &lt;*UNUSED*&gt; event: X.XAnyEventStar;
                     &lt;*UNUSED*&gt; pars: Xt.StringStar;
                     &lt;*UNUSED*&gt;  npars: Xt.CardinalStar) =
VAR
  rot: INTEGER;
BEGIN
  IF NOT running THEN RETURN END;
  rot := (cur_rot + 1) MOD 4;
  IF BlockCanRot (cur_shape, cur_xpos, cur_ypos, rot) THEN
     ShowShape (canvas, cur_shape, cur_xpos, cur_ypos, cur_rot, TRUE);
     cur_rot := rot;
     ShowShape (canvas, cur_shape, cur_xpos, cur_ypos, cur_rot, FALSE);
     DrawShadow (cur_shape, cur_xpos, cur_ypos, cur_rot)
  END;
END ClockProc;
</PRE> <CODE>Fast</CODE> Action 

<P><PRE>PROCEDURE <A NAME="DropProc"><procedure>DropProc</procedure></A> (&lt;*UNUSED*&gt; w: Xt.Widget;
                    &lt;*UNUSED*&gt;  event: X.XAnyEventStar;
                    &lt;*UNUSED*&gt; pars: Xt.StringStar;
                    &lt;*UNUSED*&gt;  npars: Xt.CardinalStar) =
BEGIN
  IF NOT running THEN RETURN END;
  WHILE BlockCanDown (cur_shape, cur_xpos, cur_ypos, cur_rot) DO
    ShowShape (canvas, cur_shape, cur_xpos, cur_ypos, cur_rot, TRUE);
    cur_ypos := cur_ypos + 1;
    ShowShape (canvas, cur_shape, cur_xpos, cur_ypos, cur_rot, FALSE)
  END;
END DropProc;
</PRE>**************************************************************
<P>
                        Actions Utilities
<P>
 **************************************************************

<P>
<P><PRE>PROCEDURE <A NAME="BlockCanDown"><procedure>BlockCanDown</procedure></A> (shape, xpos, ypos, rot: INTEGER): BOOLEAN =
VAR
  y, c: INTEGER;
BEGIN
  (* Find highest non-zero y coordinate for each x *)
  FOR x := 0 TO MROT DO
      c := shapes[shape].forms[rot].highesty[x];
      y := ypos + c;
      IF c # 0 AND y &gt;= 0 THEN
         IF y &gt; MHEIGHT OR grid[xpos+x, y] # NIL THEN
            RETURN (FALSE)
         END;
      END;
  END;
  RETURN (TRUE)
END BlockCanDown;

PROCEDURE <A NAME="BlockCanLeft"><procedure>BlockCanLeft</procedure></A> (shape, xpos, ypos, rot: INTEGER): BOOLEAN =
VAR
  x, yg, c: INTEGER;
BEGIN
  (* get the lowest x value for y, in (3-c) *)
  yg := ypos;
  FOR y := 0 TO MROT DO
      c := shapes[shape].forms[rot].lowestx[y];
      x := xpos + c;
      IF c # -2 THEN
         IF  x &lt; 0 OR (yg &gt;= 0 AND grid[x, yg] # NIL) THEN
             RETURN (FALSE)
         END;
      END;
      yg := yg + 1;
  END;
  RETURN (TRUE)
END BlockCanLeft;

PROCEDURE <A NAME="BlockCanRight"><procedure>BlockCanRight</procedure></A> (shape, xpos, ypos, rot: INTEGER): BOOLEAN =
VAR
  x, yg, c: INTEGER;
BEGIN
  (* get the lowest x value for y, in (3-c) *)
  yg := ypos;
  FOR y := 0 TO MROT DO
      c := shapes[shape].forms[rot].highestx[y];
      x := xpos + c;
      IF c # 0 AND x &gt;= 0 THEN
         IF x = NWIDTH OR (yg &gt;= 0 AND grid[x, yg] # NIL) THEN
            RETURN (FALSE)
         END;
      END;
      yg := yg + 1;
  END;
  RETURN (TRUE)
END BlockCanRight;

PROCEDURE <A NAME="BlockCanRot"><procedure>BlockCanRot</procedure></A> (shape, xpos, ypos, rot: INTEGER): BOOLEAN =
VAR
  unitson: WORD;
BEGIN
  unitson := shapes[shape].forms[rot].unitson;
  FOR y := ypos+MROT TO ypos BY -1 DO
      IF y &gt;= 0 THEN
         IF y &gt; MHEIGHT AND Word.And (16_0000000F, unitson) # 0 THEN
            RETURN (FALSE)
         END;
         FOR x := xpos + MROT TO xpos BY -1 DO
             IF Word.And (unitson, 1) # 0 AND (x &lt; 0 OR
                                               x &gt; MWIDTH OR
                                               grid[x, y] # NIL) THEN
                RETURN (FALSE)
             END;
             unitson := Word.Shift (unitson, -1);
         END;
      ELSE
         unitson := Word.Shift (unitson, -4);
      END;
  END;
  RETURN (TRUE)
END BlockCanRot;
</PRE>********************************************************************
<P>
                        Drawing Procedures
<P>
 ********************************************************************

<P>
<P><PRE>PROCEDURE <A NAME="RemoveFullLines"><procedure>RemoveFullLines</procedure></A> (starty: INTEGER) =
VAR
  ymax: INTEGER;                             (* y max of search *)
  foundfull: INTEGER;                        (* number of full lines *)
  linefull: ARRAY [0..MHEIGHT] OF BOOLEAN;   (* state of each line *)
BEGIN
  foundfull := 0;
  ymax := MIN (starty + 4, MHEIGHT);
  FOR y := starty TO ymax DO
      linefull[y] := TRUE;
      FOR x := 0 TO MWIDTH DO
          IF grid[x, y] = NIL THEN
             linefull[y] := FALSE;
             EXIT
          END
      END;
      IF linefull[y] THEN
         INC (foundfull);
         X.XFillRectangle (Xt.Display (canvas), Xt.XtWindow (canvas), erasegc,
                            0, y * bsize, bsize * NWIDTH, bsize)
      END;
  END;
  IF (foundfull = 0) THEN RETURN END;

  (* Computes and display the new score *)

  score := score + (10 * foundfull * foundfull);
  rows  := rows + foundfull;
  level := startlevel + rows DIV 10;
  ShowScoreProc (toplevel, NIL, NIL, NIL);

  (* Wait a bit for the user to see it. *)

  X.XFlush (Xt.Display (toplevel));
  Thread.Pause(1.2d+0);

  (* Now change the data. *)

  FOR y := starty TO ymax DO
      IF linefull[y] THEN
         FOR y2 := y TO 1 BY -1 DO
             FOR x := 0 TO MWIDTH DO
                 grid[x, y2] := grid[x, y2 - 1]
             END;
         END;
         FOR x := 0 TO MWIDTH DO
             grid[x, 0] := NIL
         END;
         X.XCopyArea  (Xt.Display (toplevel),
                       Xt.XtWindow (canvas), Xt.XtWindow (canvas), movegc,
                       0,0, bsize * NWIDTH, y * bsize, 0, bsize);
         X.XClearArea (Xt.Display (toplevel), Xt.XtWindow (canvas),
                       0, 0, bsize * NWIDTH, bsize, False);
      END;
  END;
  X.XFlush (Xt.Display (toplevel))
END RemoveFullLines;

PROCEDURE <A NAME="DrawShadow"><procedure>DrawShadow</procedure></A> (shape, xpos: INTEGER; &lt;*UNUSED*&gt; ypos: INTEGER;
                      rot: INTEGER) =
VAR
  unitson: WORD := shapes[shape].forms[rot].unitson;
  xmax: INTEGER;
BEGIN
  X.XClearArea (Xt.Display (shadow), Xt.XtWindow (shadow), 0, 0, 0, 0, False);
  xmax := (xpos+3) * bsize;
  FOR x:= xpos * bsize TO  xmax BY bsize DO
      IF Word.And (unitson, 16_00008888) # 0 THEN
          ShowRectangle (Xt.Display (shadow), Xt.XtWindow (shadow),
                        shapes[shape].gc, x, 0, bsize, bsize);
      END;
      unitson := Word.Shift (unitson, 1);
  END;
  X.XFlush (Xt.Display (toplevel))
END DrawShadow;

PROCEDURE <A NAME="ShowNext"><procedure>ShowNext</procedure></A> () =
BEGIN
  X.XClearArea (Xt.Display (nextobj), Xt.XtWindow (nextobj), 0,0,0,0, False);
  ShowShape (nextobj, next_shape, 0, 0, next_rot, FALSE)
END ShowNext;

PROCEDURE <A NAME="ShowRectangle"><procedure>ShowRectangle</procedure></A> (d: X.DisplayStar; win: X.Drawable;
                         gc: X.GC; x, y: INTEGER; w, h: Xt.Cardinal) =
CONST
  DEEP = 1;
BEGIN
  X.XFillRectangle (d, win, gc, x, y, w, h);
  X.XFillRectangle (d, win, shadegc, x+DEEP, y+DEEP, w-DEEP, h-DEEP)
END ShowRectangle;

PROCEDURE <A NAME="ShowStatLabel"><procedure>ShowStatLabel</procedure></A> (index: INTEGER) =
BEGIN
  SetValueText (stat_labels[index], XtN.string,
                Fmt.Pad (Fmt.Int (stat_totals[index]), 6) &amp;
                Fmt.Pad (Fmt.Int (stat_counts[index]), 6));
END ShowStatLabel;

PROCEDURE <A NAME="ShowShape"><procedure>ShowShape</procedure></A> (w: Xt.Widget; shape, x, y, rot: INTEGER; clear: BOOLEAN) =
VAR
  d: X.DisplayStar;
  win: X.Drawable;
  unitson: WORD;
  xmax, ymax, xmin, ymin: INTEGER;
BEGIN
  d       := Xt.Display (w);
  win     := Xt.XtWindow (w);
  unitson := shapes[shape].forms[rot].unitson;
  xmax    := (x+3) * bsize;
  ymax    := (y+3) * bsize;
  ymin    := y * bsize;
  xmin    := x * bsize;

  (* Fill or clear the rectangles *)

  FOR  ycor := ymax TO ymin BY -bsize DO
       IF (ycor &gt;= 0) AND (Word.And (unitson, 16_0000000F) # 0) THEN
          FOR xcor := xmax TO xmin BY -bsize DO
              IF Word.And (unitson, 16_00000001) # 0  THEN
                  IF clear THEN
                    X.XClearArea (d, win, xcor, ycor, bsize, bsize, False)
                  ELSE
                    ShowRectangle (d, win, shapes[shape].gc, xcor, ycor, bsize, bsize);
                    X.XFlush (d)
                  END;
               END;
               unitson := Word.Shift (unitson, -1);
           END;
      ELSE
        unitson := Word.Shift (unitson, -4);
      END;
  END;
END ShowShape;

PROCEDURE <A NAME="DefineShapes"><procedure>DefineShapes</procedure></A> () =
VAR
  unitson: WORD;

BEGIN

  WITH s = shapes [0] DO
    s.forms[0].unitson := 16_0f00; s.forms[0].points := 5;  (*      *)
    s.forms[1].unitson := 16_4444; s.forms[1].points := 8;  (* #### *)
    s.forms[2].unitson := 16_0f00; s.forms[2].points := 5;  (*      *)
    s.forms[3].unitson := 16_4444; s.forms[3].points := 8;  (*      *) END;

  WITH s = shapes [1] DO
    s.forms[0].unitson := 16_cc00; s.forms[0].points := 6;  (* ##   *)
    s.forms[1].unitson := 16_cc00; s.forms[1].points := 6;  (* ##   *)
    s.forms[2].unitson := 16_cc00; s.forms[2].points := 6;  (*      *)
    s.forms[3].unitson := 16_cc00; s.forms[3].points := 6;  (*      *) END;

  WITH s = shapes [2] DO
    s.forms[0].unitson := 16_4e00; s.forms[0].points := 5;  (*  #   *)
    s.forms[1].unitson := 16_4640; s.forms[1].points := 5;  (* ###  *)
    s.forms[2].unitson := 16_0e40; s.forms[2].points := 6;  (*      *)
    s.forms[3].unitson := 16_4c40; s.forms[3].points := 5;  (*      *) END;

  WITH s = shapes [3] DO
    s.forms[0].unitson := 16_c600; s.forms[0].points := 6;  (* ##   *)
    s.forms[1].unitson := 16_4c80; s.forms[1].points := 7;  (*  ##  *)
    s.forms[2].unitson := 16_c600; s.forms[2].points := 6;  (*      *)
    s.forms[3].unitson := 16_4c80; s.forms[3].points := 7;  (*      *) END;

  WITH s = shapes [4] DO
    s.forms[0].unitson := 16_6c00; s.forms[0].points := 6;  (*  ##  *)
    s.forms[1].unitson := 16_8c40; s.forms[1].points := 7;  (* ##   *)
    s.forms[2].unitson := 16_6c00; s.forms[2].points := 6;  (*      *)
    s.forms[3].unitson := 16_8c40; s.forms[3].points := 7;  (*      *) END;

  WITH s = shapes [5] DO
    s.forms[0].unitson := 16_2e00; s.forms[0].points := 6;  (*   #  *)
    s.forms[1].unitson := 16_88c0; s.forms[1].points := 7;  (* ###  *)
    s.forms[2].unitson := 16_e800; s.forms[2].points := 6;  (*      *)
    s.forms[3].unitson := 16_c440; s.forms[3].points := 7;  (*      *) END;

  WITH s = shapes [6] DO
    s.forms[0].unitson := 16_e200; s.forms[0].points := 6;  (* ###  *)
    s.forms[1].unitson := 16_44c0; s.forms[1].points := 7;  (*   #  *)
    s.forms[2].unitson := 16_8e00; s.forms[2].points := 6;  (*      *)
    s.forms[3].unitson := 16_c880; s.forms[3].points := 7;  (*      *) END;

  (* First set the highesty values (could have specified these statically, but the
     human cost is too high.  This is one-shot anyway). *)

  FOR s := 0 TO MSHAPE DO
      FOR r := 0 TO MROT DO
          (* set the highesty values. *)
          unitson := shapes[s].forms[r].unitson;
          FOR x := 0 TO MROT DO
              shapes[s].forms[r].highesty[x] := 0;
              shapes[s].forms[r].highestx[x] := 0;
              shapes[s].forms[r].lowestx[x]  := -2;
          END;
          FOR y := MROT TO 0 BY -1 DO
              FOR x := MROT TO 0 BY -1 DO
                  IF  Word.And (unitson, 1) # 0 THEN
                      IF shapes[s].forms[r].highesty[x] = 0 THEN
                         shapes[s].forms[r].highesty[x] := y+1
                      END;
                      IF shapes[s].forms[r].highestx[y] = 0 THEN
                         shapes[s].forms[r].highestx[y] := x+1
                      END;
                      shapes[s].forms[r].lowestx[y] := x-1;
                  END;
                  unitson := Word.Shift (unitson, -1);
              END;
          END;

      (* Now allocate the colored graphics context *)

      gcval.foreground := shapes[s].foreground;
      gcval.background := shapes[s].background;
      shapes[s].gc := X.XCreateGC (Xt.Display (canvas), Xt.XtWindow (canvas),
                            X.GCForeground + X.GCBackground, gcval);
      END;
  END;
END DefineShapes;

PROCEDURE <A NAME="UpdateGrid"><procedure>UpdateGrid</procedure></A> (shape, xpos, ypos, rot: INTEGER) =
VAR
  unitson: WORD;
BEGIN
  unitson  := shapes[shape].forms[rot].unitson;
  FOR y := ypos+3 TO ypos BY -1 DO
      FOR x := xpos+3 TO xpos BY -1 DO
          IF x &gt;= 0 AND y &gt;= 0 THEN
             IF Word.And (unitson, 16_00000001) # 0 THEN
                grid[x, y] := shapes[shape].gc
             END;
          END;
          unitson := Word.Shift (unitson, -1);
      END;
  END;
END UpdateGrid;
</PRE> creates a new (randomly chosen) shape and sets the global variables 
<PRE>PROCEDURE <A NAME="CreateShape"><procedure>CreateShape</procedure></A> (countp: BOOLEAN) =
BEGIN
  cur_shape  := next_shape;
  IF countp THEN
     INC (stat_counts[cur_shape]);
     INC (stat_totals[cur_shape])
  END;
  cur_rot    := next_rot;
  next_shape := rand.integer () MOD NSHAPE;
  next_rot   := rand.integer () MOD NROT;
  cur_xpos   := (NWIDTH DIV 2) - 1;
  cur_ypos   := -4
END CreateShape;
</PRE>***********************************************************************
<P>
                        I IN I T I A L I Z A T I O N
<P>
 ***********************************************************************

<P>
<P><PRE>PROCEDURE <A NAME="Initialize"><procedure>Initialize</procedure></A> () =
VAR
  who: Ctypes.char_star;
BEGIN
  DefineShapes ();
  who := Cstdlib.getenv (FlatTtoS (&quot;TETRIS&quot;));
  IF who = NIL THEN who := Cstdlib.getenv (FlatTtoS (&quot;LOGNAME&quot;)) END;
  IF who = NIL THEN who := Cstdlib.getenv (FlatTtoS (&quot;USER&quot;)) END;
  IF who = NIL THEN who := Uutmp.getlogin () END;
  user_name := StoT (who);
  ClearGame ();
  ReadHighScores ();
END Initialize;

PROCEDURE <A NAME="ClearGame"><procedure>ClearGame</procedure></A> () =
BEGIN
  score     := startscore;
  rows      := startrows;
  level     := startlevel;
  cur_xpos  := 0;
  cur_ypos  := 0;
  FOR i := 0 TO MWIDTH DO
      FOR j := 0 TO MHEIGHT DO
          grid[i, j] := NIL
      END;
  END;
  FOR i := 0 TO MSHAPE DO
      stat_counts[i] := 0;
      ShowShape (stat_shapes[i], i, 0, 0, 1, FALSE);
      ShowStatLabel (i);
  END;
  CreateShape (FALSE);         (* Set up 1st shape *)
  CreateShape (TRUE);          (* Set up next shape *)
  X.XClearArea (Xt.Display (canvas), Xt.XtWindow (canvas), 0, 0, 0, 0, False);
  SetValueText (game_over, XtN.string, &quot;         &quot;);
  ShowScoreProc (toplevel, NIL, NIL, NIL);
  ShowNext ();
  ShowStatLabel (cur_shape);
  DrawShadow (cur_shape, cur_xpos, cur_ypos, cur_rot )
END ClearGame;

PROCEDURE <A NAME="MakeFrames"><procedure>MakeFrames</procedure></A> (top: Xt.Widget) =
VAR
  status, buttons, nextlabel,
  tbar, scores_bt: Xt.Widget;
  stbar, statboxl: Xt.Widget;

BEGIN

  (* the global frame: &quot;Frame&quot; *)

  count := 0;
  SetArgI (args, count, XtN.defaultDistance, bsize);
  frame := CreateWidget (&quot;Frame&quot;, Xaw.formWidgetClass, top, args, count);

  (* the left frame: LeftFrame, contains the label, the next object,
     and the buttons *)

  count := 0;
  SetArgA (args, count, XtN.fromHoriz, NIL);
  SetArgI (args, count, XtN.defaultDistance, 2 * bsize);
  left_frame := CreateWidget (&quot;LeftFrame&quot;, Xaw.formWidgetClass, frame, args, count);

  count := 0;
  SetArgA (args, count, XtN.fromVert, NIL);
  SetArgT (args, count, XtN.label, &quot;        TETRIS\nX11R4 + Modula-3\n     entertainment&quot;);
  tbar := CreateWidget (&quot;TitleBar&quot;, Xaw.labelWidgetClass, left_frame, args, count);

  count := 0;
  SetArgA (args, count, XtN.fromVert, tbar);
  SetArgT (args, count, XtN.label, &quot; The Next Shape &quot;);
  nextlabel  := CreateWidget (&quot;NextLabel&quot;, Xaw.labelWidgetClass, left_frame,args, count);
  count := 0;
  SetArgA (args, count, XtN.fromVert, nextlabel);
  SetArgI (args, count, XtN.width, (bsize * 4));
  SetArgI (args, count, XtN.height, (bsize * 4));
  SetArgT (args, count, XtN.resizable, &quot;FALSE&quot;);
  nextobj := CreateWidget (&quot;NextObject&quot;, Xaw.simpleWidgetClass, left_frame, args, count);

  count := 0;
  SetArgA (args, count, XtN.fromVert, nextobj);
  status     := CreateWidget (&quot;Status&quot;, Xaw.boxWidgetClass, left_frame, args, count);
  score_item := CreateWidget (&quot;Score&quot;, Xaw.asciiTextWidgetClass, status);
  level_item := CreateWidget (&quot;Level&quot;, Xaw.asciiTextWidgetClass, status);
  rows_item  := CreateWidget (&quot;Rows&quot;,  Xaw.asciiTextWidgetClass, status);
  game_over  := CreateWidget (&quot;Game&quot;,  Xaw.asciiTextWidgetClass, status);

  count := 0;
  SetArgA (args, count, XtN.fromVert, status);
  buttons    := CreateWidget (&quot;Buttons&quot;, Xaw.boxWidgetClass, left_frame, args, count);
  start_bt   := CreateWidget (&quot;Start&quot;,   Xaw.commandWidgetClass, buttons);
  pause_bt   := CreateWidget (&quot;Pause&quot;,   Xaw.commandWidgetClass, buttons);
  newgame_bt := CreateWidget (&quot;NewGame&quot;, Xaw.commandWidgetClass, buttons);
  IF scorefilep THEN
     scores_bt := CreateWidget (&quot;Scores&quot;, Xaw.commandWidgetClass, buttons);
  END;
  quit_bt    := CreateWidget (&quot;Quit&quot;,    Xaw.commandWidgetClass, buttons);

  (*
   *  the right frame: RightFrame, contains the canvas and the shadow
   *)

  count := 0;
  SetArgA (args, count, XtN.fromHoriz, left_frame);
  SetArgI (args, count, XtN.defaultDistance, bsize);
  right_frame := CreateWidget (&quot;RightFrame&quot;, Xaw.formWidgetClass, frame, args, count);

  count := 0;
  SetArgA (args, count, XtN.fromVert, NIL);
  SetArgI (args, count, XtN.width, (bsize * NWIDTH));
  SetArgI (args, count, XtN.height, (bsize * NHEIGHT));
  SetArgI (args, count, XtN.borderWidth, (bsize DIV 4) + 1);
  SetArgT (args, count, XtN.resizable, &quot;FALSE&quot;);
  canvas := CreateWidget (&quot;Canvas&quot;, Xaw.simpleWidgetClass, right_frame, args, count);

  count := 0;
  SetArgA (args, count, XtN.fromVert, canvas);
  SetArgI (args, count, XtN.width, (bsize * NWIDTH));
  SetArgI (args, count, XtN.height, bsize);
  SetArgI (args, count, XtN.borderWidth, (bsize DIV 4) + 1);
  SetArgT (args, count, XtN.resizable, &quot;FALSE&quot;);
  shadow := CreateWidget (&quot;Shadow&quot;, Xaw.simpleWidgetClass, right_frame, args, count);

  (*
   *  the stats frame: StatFrame, contains the shapes statistics
   *)

  count := 0;
  SetArgA (args, count, XtN.fromHoriz, right_frame);
  SetArgI (args, count, XtN.defaultDistance, bsize);
  stat_frame := CreateWidget (&quot;StatFrame&quot;, Xaw.formWidgetClass, frame, args, count);

  count := 0;
  SetArgA (args, count, XtN.fromVert, NIL);
  SetArgT (args, count, XtN.label, &quot;           Shape Statistics            &quot;);
  stbar := CreateWidget (&quot;&quot;, Xaw.labelWidgetClass, stat_frame, args, count);

  count := 0;
  SetArgA (args, count, XtN.fromVert, stbar);
  SetArgI (args, count, XtN.vSpace, 13);
  statboxl := CreateWidget (&quot; &quot;, Xaw.boxWidgetClass, stat_frame, args, count);
  FOR i := 0 TO MSHAPE DO
      EVAL CreateWidget (&quot;      &quot; &amp; shapenames[i+1] &amp; &quot;      &quot;, Xaw.labelWidgetClass, statboxl);
      stat_labels[i] := CreateWidget (&quot; &quot;, Xaw.asciiTextWidgetClass, statboxl);
  END;

  count := 0;
  SetArgA (args, count, XtN.fromVert, stbar);
  SetArgA (args, count, XtN.fromHoriz, statboxl);
  stats := CreateWidget (&quot;Shapes&quot;, Xaw.boxWidgetClass, stat_frame, args, count);
  FOR i := 0 TO MSHAPE DO
      count := 0;
      SetArgI (args, count, XtN.width, (bsize * 4));
      SetArgI (args, count, XtN.height, (bsize * 4));
      SetArgT (args, count, XtN.resizable, &quot;FALSE&quot;);
      stat_shapes[i] := CreateWidget (&quot; &quot;, Xaw.simpleWidgetClass, stats, args, count);
  END;

  (*
   *  the score frame: contains the results and the Close button
   *)

  IF scorefilep THEN
     score_frame := Xt.CreatePopupShell (FlatTtoS (&quot;ScoreFrame&quot;),
                                         Xaw.transientShellWidgetClass, top);
     score_panel := CreateWidget (&quot;ScorePanel&quot;, Xaw.boxWidgetClass, score_frame);
     FOR j:= 0 TO MHSCORE+2 DO
         count := 0;
         SetArgI (args, count, XtN.width, 500);
         high_score_item[j] := CreateWidget (&quot;&quot;, Xaw.asciiTextWidgetClass,
                                              score_panel, args, count);
     END;
     EVAL CreateWidget (&quot;Close&quot;, Xaw.commandWidgetClass, score_panel);
  END;

  Xt.InstallAllAccelerators (canvas, top);
  Xt.InstallAllAccelerators (shadow, top);
  Xt.InstallAllAccelerators (nextobj, top);
  Xt.InstallAllAccelerators (frame, top);
  Xt.RealizeWidget (top);
  MapWidget (top);

  gcval.foreground := foreground;
  gcval.background := background;
  movegc := X.XCreateGC (Xt.Display (top), Xt.XtWindow(top),
                         X.GCForeground + X.GCBackground, gcval);

  gcval.foreground := background;
  gcval.background := foreground;
  gcval.fill_style := X.FillStippled;
  gcval.stipple    := X.XCreateBitmapFromData (Xt.Display (top), Xt.XtWindow (top),
                                     FlatTtoS(&quot;\252\000&quot;), 2, 2);
  erasegc := X.XCreateGC (Xt.Display (top), Xt.XtWindow (top),
                          X.GCForeground + X.GCBackground +
                             X.GCStipple +  X.GCFillStyle, gcval);

  gcval.foreground := foreground;
  gcval.background := background;
  gcval.fill_style := X.FillStippled;
  gcval.stipple    := X.XCreateBitmapFromData (Xt.Display (top), Xt.XtWindow (top),
                          FlatTtoS(&quot;\223\000&quot;), 2, 2);

  shadegc := X.XCreateGC (Xt.Display (top), Xt.XtWindow(top),
                          X.GCForeground + X.GCBackground +
                             X.GCStipple +  X.GCFillStyle, gcval);
END MakeFrames;

PROCEDURE <A NAME="Syntax"><procedure>Syntax</procedure></A> (cont: Xt.AppContext; call: TEXT) =
BEGIN
    Xt.DestroyApplicationContext (cont);
    Wr.PutText (Stdio.stdout, &quot;Usage: &quot; &amp; call &amp;
                              &quot; [ -noscore] [ -score ] [ -boxsize [&lt;n&gt;]\n&quot;);
    Cstdlib.exit (1);
END Syntax;
</PRE>****************************************************************
<P>
                           M A I N
<P>
 ****************************************************************

<P>
<P><PRE>BEGIN
  FOR i := 0 TO LAST (fallbacktext) DO
      fallbacklist[i] := FlatTtoS (fallbacktext[i])
  END;
  fallbacklist[LAST (fallbacktext)+1] := NIL;

  count := 0;
  SetOption (options, count, &quot;-score&quot;,  &quot;*useScoreFile&quot;,Xrm.optionNoArg, &quot;1&quot;);
  SetOption (options, count, &quot;-noscore&quot;,&quot;*useScoreFile&quot;,Xrm.optionNoArg, &quot;0&quot;);
  SetOption (options, count, &quot;-boxsize&quot;,&quot;*boxSize&quot;,     Xrm.optionSepArg,&quot;16&quot;);
  SetOption (options, count, &quot;-iscore&quot;, &quot;*startScore&quot;,  Xrm.optionSepArg, &quot;0&quot;);
  SetOption (options, count, &quot;-rows&quot;,   &quot;*startRows&quot;,   Xrm.optionSepArg, &quot;0&quot;);
  SetOption (options, count, &quot;-level&quot;,  &quot;*startLevel&quot;,  Xrm.optionSepArg, &quot;0&quot;);

  VAR
    name := FlatTtoS (&quot;Tetris&quot;);
    argc : Xt.Cardinal := RTLinker.argc;
    argv : X.Argv := RTLinker.argv;
  BEGIN
    toplevel := Xt.AppInitialize (context, name, options, count, argc, argv,
                                fallbacklist);
    IF argc # 1 THEN Syntax (context, Params.Get (0)) END;
  END;

  count := 0;
  SetResource (reslist, count, &quot;foreground&quot;, &quot;Foreground&quot;, XtR.Pixel,
               BYTESIZE (resources.foreground),
               ADR (resources.foreground) - ADR (resources^),
               XtR.String, &quot;XtDefaultForeground&quot;);
  SetResource (reslist, count, &quot;background&quot;, &quot;Background&quot;, XtR.Pixel,
               BYTESIZE (resources.background),
               ADR (resources.background) - ADR (resources^),
               XtR.String, &quot;XtDefaultBackground&quot;);
  SetResource (reslist, count, &quot;boxSize&quot;, &quot;BoxSize&quot;, XtR.Dimension,
               BYTESIZE (resources.boxsize),
               ADR (resources.boxsize) - ADR (resources^),
               XtR.String, &quot;16&quot;);
  SetResource (reslist, count, &quot;useScoreFile&quot;, &quot;Boolean&quot;, XtR.Int,
               BYTESIZE (resources.scorefilep),
               ADR (resources.scorefilep) - ADR (resources^),
               XtR.String, &quot;1&quot;);
  SetResource (reslist, count, &quot;startScore&quot;, &quot;StartScore&quot;, XtR.Int,
               BYTESIZE (resources.startscore),
               ADR (resources.startscore) - ADR (resources^),
               XtR.String, &quot;0&quot;);
  SetResource (reslist, count, &quot;startRows&quot;,  &quot;StartRows&quot;,  XtR.Int,
               BYTESIZE (resources.startrows),
               ADR (resources.startrows) - ADR (resources^),
               XtR.String, &quot;0&quot;);
  SetResource (reslist, count, &quot;startLevel&quot;, &quot;StartLevel&quot;, XtR.Int,
               BYTESIZE (resources.startlevel),
               ADR (resources.startlevel) - ADR (resources^),
               XtR.String, &quot;0&quot;);

  Xt.GetApplicationResources (toplevel, LOOPHOLE (resources, Xt.Pointer),
                              reslist, count);
  foreground   := resources.foreground;
  background   := resources.background;
  bsize        := MAX (resources.boxsize, 4);
  startscore   := resources.startscore;
  startrows    := resources.startrows;
  startlevel   := resources.startlevel;
  scorefilep   := (resources.scorefilep # 0);

  count := 0;
  SetAction (actions, count, &quot;Refresh&quot;, RefreshProc);
  SetAction (actions, count, &quot;ShowScore&quot;, ShowScoreProc);
  SetAction (actions, count, &quot;Quit&quot;, QuitProc);
  SetAction (actions, count, &quot;Close&quot;, CloseProc);
  SetAction (actions, count, &quot;EndGame&quot;, EndGame);
  SetAction (actions, count, &quot;NewGame&quot;, RestartProc);
  SetAction (actions, count, &quot;Start&quot;, StartProc);
  SetAction (actions, count, &quot;Pause&quot;, PauseProc);
  SetAction (actions, count, &quot;MoveLeft&quot;, LeftProc);
  SetAction (actions, count, &quot;MoveRight&quot;, RightProc);
  SetAction (actions, count, &quot;RotateCW&quot;, ClockProc);
  SetAction (actions, count, &quot;RotateCCW&quot;, AntiProc);
  SetAction (actions, count, &quot;Drop&quot;, DropProc);
  SetAction (actions, count, &quot;Scores&quot;, ShowHighScores);

  Xt.AppAddActions (context, actions, count);

  count := 0;
  SetResource (reslist, count, &quot;foreground&quot;, &quot;Foreground&quot;, XtR.Pixel,
               BYTESIZE (resources.foreground),
               ADR (resources.foreground) - ADR (resources^),
               XtR.String, &quot;XtDefaultForeground&quot;);
  SetResource (reslist, count, &quot;background&quot;, &quot;Background&quot;, XtR.Pixel,
               BYTESIZE (resources.background),
               ADR (resources.background) - ADR (resources^),
               XtR.String, &quot;XtDefaultBackground&quot;);
  FOR i:= 0 TO MSHAPE
      DO  Xt.GetSubresources (toplevel, LOOPHOLE (resources, Xt.Pointer),
                              FlatTtoS (shapenames[i+1]), FlatTtoS (shapenames[0]),
                              reslist, count, NIL, 0);
          shapes[i].foreground := resources.foreground;
          shapes[i].background := resources.background;
          stat_totals[i] := 0;
      END;

  MakeFrames (toplevel);

  Initialize ();

  Xt.AppMainLoop (context);

END Main.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface Utime is in:
</A><UL>
<LI><A HREF="../../m3core/src/unix/Common/Utime.i3.html#0TOP0">m3core/src/unix/Common/Utime.i3</A>
<LI><A HREF="../../m3core/src/unix/linux-common/Utime.i3.html#0TOP0">m3core/src/unix/linux-common/Utime.i3</A>
</UL>
<P>
<HR>
<A NAME="x2">interface Uutmp is in:
</A><UL>
<LI><A HREF="../../m3core/src/unix/Common/Uutmp.i3.html#0TOP0">m3core/src/unix/Common/Uutmp.i3</A>
<LI><A HREF="../../m3core/src/unix/linux-common/Uutmp.i3.html#0TOP0">m3core/src/unix/linux-common/Uutmp.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
