<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: mentor/derived/SubtypeIE.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>mentor/derived/SubtypeIE.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright (C) 1995, Digital Equipment Corporation.       
 All rights reserved.                                     
 See the file COPYRIGHT for a full description.           
                                                          
 Last modified on Thu Feb  9 08:50:48 PST 1995 by kalsow  
      modified on Sun Jun  5 21:59:57 PDT 1994 by mhb     
      modified on Wed Feb 17 16:46:47 PST 1993 by johnh   

<P>********************************************************************
<PRE>
      *  NOTE: This file is generated automatically from the event
      *        definition file Subtype.evt.
      ********************************************************************


<P><PRE>&lt;* PRAGMA LL *&gt;

MODULE <module><implements><A HREF="SubtypeIE.i3.html">SubtypeIE</A></implements></module>;

&lt;*NOWARN*&gt; IMPORT <A HREF="../../zeus/src/ZeusClass.i3.html">ZeusClass</A>, <A HREF="../../zeus/src/Zeus.i3.html">Zeus</A>, <A HREF="SubtypeViewClass.i3.html">SubtypeViewClass</A>;
&lt;*NOWARN*&gt; IMPORT <A HREF="SubtypeAlgClass.i3.html">SubtypeAlgClass</A>, <A HREF="../../zeus/src/Algorithm.i3.html">Algorithm</A>, <A HREF="../src/subtype/AlgSubtype.i3.html">AlgSubtype</A>, <A HREF="#x1">View</A>;
&lt;*NOWARN*&gt; IMPORT <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../zeus/src/AlgorithmClass.i3.html">AlgorithmClass</A>;

&lt;* FATAL Zeus.Error, Zeus.Locked *&gt;
</PRE><BLOCKQUOTE><EM> If you get either of these errors, contact a Zeus implementor. </EM></BLOCKQUOTE><PRE>

TYPE
  SetupArgs = BRANDED REF RECORD
  END;

  BeginArgs = BRANDED REF RECORD
    lftRoot: INTEGER;
    rhtRoot: INTEGER;
  END;

  NewBotArgs = BRANDED REF RECORD
    index: INTEGER;
  END;

  NewTopArgs = BRANDED REF RECORD
    index: INTEGER;
  END;

  NewFunArgs = BRANDED REF RECORD
    index: INTEGER;
    domEdgeIndex: INTEGER;
    rngEdgeIndex: INTEGER;
  END;

  NewDomRngArgs = BRANDED REF RECORD
    index: INTEGER;
    domIndex: INTEGER;
    rngIndex: INTEGER;
  END;

  NewLoopArgs = BRANDED REF RECORD
    fromIndex: INTEGER;
    toIndex: INTEGER;
  END;

  EnterArgs = BRANDED REF RECORD
    lftIndex: INTEGER;
    rhtIndex: INTEGER;
    lftLeadingEdgeIndex: INTEGER;
    rhtLeadingEdgeIndex: INTEGER;
  END;

  ExitArgs = BRANDED REF RECORD
    lftIndex: INTEGER;
    rhtIndex: INTEGER;
    lftLeadingEdgeIndex: INTEGER;
    rhtLeadingEdgeIndex: INTEGER;
    result: BOOLEAN;
  END;

  SeenOKArgs = BRANDED REF RECORD
    fromIndex: INTEGER;
    toIndex: INTEGER;
  END;

  NoticeArgs = BRANDED REF RECORD
    fromIndex: INTEGER;
    toIndex: INTEGER;
  END;

  BotLessAnyOKArgs = BRANDED REF RECORD
    lftIndex: INTEGER;
    rhtIndex: INTEGER;
    lftLeadingEdgeIndex: INTEGER;
    rhtLeadingEdgeIndex: INTEGER;
  END;

  TopLessTopOKArgs = BRANDED REF RECORD
    lftIndex: INTEGER;
    rhtIndex: INTEGER;
    lftLeadingEdgeIndex: INTEGER;
    rhtLeadingEdgeIndex: INTEGER;
  END;

  TopLessNonTopKOArgs = BRANDED REF RECORD
    lftIndex: INTEGER;
    rhtIndex: INTEGER;
    lftLeadingEdgeIndex: INTEGER;
    rhtLeadingEdgeIndex: INTEGER;
  END;

  FunLessBotKOArgs = BRANDED REF RECORD
    lftIndex: INTEGER;
    rhtIndex: INTEGER;
    lftLeadingEdgeIndex: INTEGER;
    rhtLeadingEdgeIndex: INTEGER;
  END;

  FunLessTopOKArgs = BRANDED REF RECORD
    lftIndex: INTEGER;
    rhtIndex: INTEGER;
    lftLeadingEdgeIndex: INTEGER;
    rhtLeadingEdgeIndex: INTEGER;
  END;

  FunLessFunArgs = BRANDED REF RECORD
    lftIndex: INTEGER;
    rhtIndex: INTEGER;
    lftLeadingEdgeIndex: INTEGER;
    rhtLeadingEdgeIndex: INTEGER;
  END;

  OKArgs = BRANDED REF RECORD
    lftIndex: INTEGER;
    rhtIndex: INTEGER;
    lftLeadingEdgeIndex: INTEGER;
    rhtLeadingEdgeIndex: INTEGER;
  END;

  KOArgs = BRANDED REF RECORD
    lftIndex: INTEGER;
    rhtIndex: INTEGER;
    lftLeadingEdgeIndex: INTEGER;
    rhtLeadingEdgeIndex: INTEGER;
  END;
</PRE>  Zeus calls the following to invoke vbt v's event handler: 

<P><PRE>&lt;*NOWARN*&gt; PROCEDURE <A NAME="OEDispatcher"><procedure>OEDispatcher</procedure></A>(v: ZeusClass.T; evt: REFANY) RAISES {Thread.Alerted} =
  &lt;* LL &lt;= VBT.mu *&gt;
  (* LL = {} if event style is output, LL = VBT.mu if event style is update. *)
  BEGIN
    TYPECASE v OF
    | SubtypeViewClass.T (view) =&gt; &lt;*NOWARN*&gt;
      TYPECASE evt OF
      | SetupArgs(varSetupArgs) =&gt; &lt;*NOWARN*&gt;
          view.oeSetup (
              )
      | BeginArgs(varBeginArgs) =&gt; &lt;*NOWARN*&gt;
          view.oeBegin (
              varBeginArgs.lftRoot
                ,
              varBeginArgs.rhtRoot
              )
      | NewBotArgs(varNewBotArgs) =&gt; &lt;*NOWARN*&gt;
          view.oeNewBot (
              varNewBotArgs.index
              )
      | NewTopArgs(varNewTopArgs) =&gt; &lt;*NOWARN*&gt;
          view.oeNewTop (
              varNewTopArgs.index
              )
      | NewFunArgs(varNewFunArgs) =&gt; &lt;*NOWARN*&gt;
          view.oeNewFun (
              varNewFunArgs.index
                ,
              varNewFunArgs.domEdgeIndex
                ,
              varNewFunArgs.rngEdgeIndex
              )
      | NewDomRngArgs(varNewDomRngArgs) =&gt; &lt;*NOWARN*&gt;
          view.oeNewDomRng (
              varNewDomRngArgs.index
                ,
              varNewDomRngArgs.domIndex
                ,
              varNewDomRngArgs.rngIndex
              )
      | NewLoopArgs(varNewLoopArgs) =&gt; &lt;*NOWARN*&gt;
          view.oeNewLoop (
              varNewLoopArgs.fromIndex
                ,
              varNewLoopArgs.toIndex
              )
      | EnterArgs(varEnterArgs) =&gt; &lt;*NOWARN*&gt;
          view.oeEnter (
              varEnterArgs.lftIndex
                ,
              varEnterArgs.rhtIndex
                ,
              varEnterArgs.lftLeadingEdgeIndex
                ,
              varEnterArgs.rhtLeadingEdgeIndex
              )
      | ExitArgs(varExitArgs) =&gt; &lt;*NOWARN*&gt;
          view.oeExit (
              varExitArgs.lftIndex
                ,
              varExitArgs.rhtIndex
                ,
              varExitArgs.lftLeadingEdgeIndex
                ,
              varExitArgs.rhtLeadingEdgeIndex
                ,
              varExitArgs.result
              )
      | SeenOKArgs(varSeenOKArgs) =&gt; &lt;*NOWARN*&gt;
          view.oeSeenOK (
              varSeenOKArgs.fromIndex
                ,
              varSeenOKArgs.toIndex
              )
      | NoticeArgs(varNoticeArgs) =&gt; &lt;*NOWARN*&gt;
          view.oeNotice (
              varNoticeArgs.fromIndex
                ,
              varNoticeArgs.toIndex
              )
      | BotLessAnyOKArgs(varBotLessAnyOKArgs) =&gt; &lt;*NOWARN*&gt;
          view.oeBotLessAnyOK (
              varBotLessAnyOKArgs.lftIndex
                ,
              varBotLessAnyOKArgs.rhtIndex
                ,
              varBotLessAnyOKArgs.lftLeadingEdgeIndex
                ,
              varBotLessAnyOKArgs.rhtLeadingEdgeIndex
              )
      | TopLessTopOKArgs(varTopLessTopOKArgs) =&gt; &lt;*NOWARN*&gt;
          view.oeTopLessTopOK (
              varTopLessTopOKArgs.lftIndex
                ,
              varTopLessTopOKArgs.rhtIndex
                ,
              varTopLessTopOKArgs.lftLeadingEdgeIndex
                ,
              varTopLessTopOKArgs.rhtLeadingEdgeIndex
              )
      | TopLessNonTopKOArgs(varTopLessNonTopKOArgs) =&gt; &lt;*NOWARN*&gt;
          view.oeTopLessNonTopKO (
              varTopLessNonTopKOArgs.lftIndex
                ,
              varTopLessNonTopKOArgs.rhtIndex
                ,
              varTopLessNonTopKOArgs.lftLeadingEdgeIndex
                ,
              varTopLessNonTopKOArgs.rhtLeadingEdgeIndex
              )
      | FunLessBotKOArgs(varFunLessBotKOArgs) =&gt; &lt;*NOWARN*&gt;
          view.oeFunLessBotKO (
              varFunLessBotKOArgs.lftIndex
                ,
              varFunLessBotKOArgs.rhtIndex
                ,
              varFunLessBotKOArgs.lftLeadingEdgeIndex
                ,
              varFunLessBotKOArgs.rhtLeadingEdgeIndex
              )
      | FunLessTopOKArgs(varFunLessTopOKArgs) =&gt; &lt;*NOWARN*&gt;
          view.oeFunLessTopOK (
              varFunLessTopOKArgs.lftIndex
                ,
              varFunLessTopOKArgs.rhtIndex
                ,
              varFunLessTopOKArgs.lftLeadingEdgeIndex
                ,
              varFunLessTopOKArgs.rhtLeadingEdgeIndex
              )
      | FunLessFunArgs(varFunLessFunArgs) =&gt; &lt;*NOWARN*&gt;
          view.oeFunLessFun (
              varFunLessFunArgs.lftIndex
                ,
              varFunLessFunArgs.rhtIndex
                ,
              varFunLessFunArgs.lftLeadingEdgeIndex
                ,
              varFunLessFunArgs.rhtLeadingEdgeIndex
              )
      | OKArgs(varOKArgs) =&gt; &lt;*NOWARN*&gt;
          view.oeOK (
              varOKArgs.lftIndex
                ,
              varOKArgs.rhtIndex
                ,
              varOKArgs.lftLeadingEdgeIndex
                ,
              varOKArgs.rhtLeadingEdgeIndex
              )
      | KOArgs(varKOArgs) =&gt; &lt;*NOWARN*&gt;
          view.oeKO (
              varKOArgs.lftIndex
                ,
              varKOArgs.rhtIndex
                ,
              varKOArgs.lftLeadingEdgeIndex
                ,
              varKOArgs.rhtLeadingEdgeIndex
              )
      ELSE &lt;* ASSERT FALSE *&gt;
      END;
    ELSE (* this view isn't a SubtypeViewClass, so just ignore *)
    END
  END OEDispatcher;

&lt;*NOWARN*&gt; PROCEDURE <A NAME="FEDispatcher"><procedure>FEDispatcher</procedure></A>(v: ZeusClass.T; evt: REFANY) =
  &lt;* LL = VBT.mu *&gt;
  BEGIN
    TYPECASE v OF
    | SubtypeAlgClass.T (alg) =&gt; &lt;*NOWARN*&gt;
      TYPECASE evt OF
      ELSE &lt;* ASSERT FALSE *&gt;
      END;
    ELSE (* this alg isn't a SubtypeAlgClass, so just ignore *)
    END
  END FEDispatcher;

PROCEDURE <A NAME="Setup"><procedure>Setup</procedure></A> (
      initiator: Algorithm.T;

    ) RAISES {Thread.Alerted} =
  &lt;* LL = {} *&gt;
  VAR zumeArgRec := NEW(SetupArgs
      );
      alg := NARROW(initiator, SubtypeAlgClass.T);
  BEGIN
    LOCK alg.evtMu DO
      INC(alg.eventDataRec.ctOfSetup);
      alg.stopAtEvent := alg.eventDataRec.stopAtSetup;
      alg.waitAtEvent := alg.eventDataRec.waitAtSetup;
      Zeus.Dispatch(initiator, Zeus.EventStyle.Output, 1,
                    &quot;Setup&quot;, OEDispatcher, zumeArgRec);
    END;
  END Setup;

PROCEDURE <A NAME="Begin"><procedure>Begin</procedure></A> (
      initiator: Algorithm.T;
       lftRoot, rhtRoot: INTEGER
    ) RAISES {Thread.Alerted} =
  &lt;* LL = {} *&gt;
  VAR zumeArgRec := NEW(BeginArgs
               , lftRoot := lftRoot
               , rhtRoot := rhtRoot
      );
      alg := NARROW(initiator, SubtypeAlgClass.T);
  BEGIN
    LOCK alg.evtMu DO
      INC(alg.eventDataRec.ctOfBegin);
      alg.stopAtEvent := alg.eventDataRec.stopAtBegin;
      alg.waitAtEvent := alg.eventDataRec.waitAtBegin;
      Zeus.Dispatch(initiator, Zeus.EventStyle.Output, 1,
                    &quot;Begin&quot;, OEDispatcher, zumeArgRec);
    END;
  END Begin;

PROCEDURE <A NAME="NewBot"><procedure>NewBot</procedure></A> (
      initiator: Algorithm.T;
       index: INTEGER
    ) RAISES {Thread.Alerted} =
  &lt;* LL = {} *&gt;
  VAR zumeArgRec := NEW(NewBotArgs
               , index := index
      );
      alg := NARROW(initiator, SubtypeAlgClass.T);
  BEGIN
    LOCK alg.evtMu DO
      INC(alg.eventDataRec.ctOfNewBot);
      alg.stopAtEvent := alg.eventDataRec.stopAtNewBot;
      alg.waitAtEvent := alg.eventDataRec.waitAtNewBot;
      Zeus.Dispatch(initiator, Zeus.EventStyle.Output, 1,
                    &quot;NewBot&quot;, OEDispatcher, zumeArgRec);
    END;
  END NewBot;

PROCEDURE <A NAME="NewTop"><procedure>NewTop</procedure></A> (
      initiator: Algorithm.T;
       index: INTEGER
    ) RAISES {Thread.Alerted} =
  &lt;* LL = {} *&gt;
  VAR zumeArgRec := NEW(NewTopArgs
               , index := index
      );
      alg := NARROW(initiator, SubtypeAlgClass.T);
  BEGIN
    LOCK alg.evtMu DO
      INC(alg.eventDataRec.ctOfNewTop);
      alg.stopAtEvent := alg.eventDataRec.stopAtNewTop;
      alg.waitAtEvent := alg.eventDataRec.waitAtNewTop;
      Zeus.Dispatch(initiator, Zeus.EventStyle.Output, 1,
                    &quot;NewTop&quot;, OEDispatcher, zumeArgRec);
    END;
  END NewTop;

PROCEDURE <A NAME="NewFun"><procedure>NewFun</procedure></A> (
      initiator: Algorithm.T;
       index, domEdgeIndex, rngEdgeIndex: INTEGER
    ) RAISES {Thread.Alerted} =
  &lt;* LL = {} *&gt;
  VAR zumeArgRec := NEW(NewFunArgs
               , index := index
               , domEdgeIndex := domEdgeIndex
               , rngEdgeIndex := rngEdgeIndex
      );
      alg := NARROW(initiator, SubtypeAlgClass.T);
  BEGIN
    LOCK alg.evtMu DO
      INC(alg.eventDataRec.ctOfNewFun);
      alg.stopAtEvent := alg.eventDataRec.stopAtNewFun;
      alg.waitAtEvent := alg.eventDataRec.waitAtNewFun;
      Zeus.Dispatch(initiator, Zeus.EventStyle.Output, 1,
                    &quot;NewFun&quot;, OEDispatcher, zumeArgRec);
    END;
  END NewFun;

PROCEDURE <A NAME="NewDomRng"><procedure>NewDomRng</procedure></A> (
      initiator: Algorithm.T;
       index, domIndex, rngIndex: INTEGER
    ) RAISES {Thread.Alerted} =
  &lt;* LL = {} *&gt;
  VAR zumeArgRec := NEW(NewDomRngArgs
               , index := index
               , domIndex := domIndex
               , rngIndex := rngIndex
      );
      alg := NARROW(initiator, SubtypeAlgClass.T);
  BEGIN
    LOCK alg.evtMu DO
      INC(alg.eventDataRec.ctOfNewDomRng);
      alg.stopAtEvent := alg.eventDataRec.stopAtNewDomRng;
      alg.waitAtEvent := alg.eventDataRec.waitAtNewDomRng;
      Zeus.Dispatch(initiator, Zeus.EventStyle.Output, 1,
                    &quot;NewDomRng&quot;, OEDispatcher, zumeArgRec);
    END;
  END NewDomRng;

PROCEDURE <A NAME="NewLoop"><procedure>NewLoop</procedure></A> (
      initiator: Algorithm.T;
       fromIndex, toIndex: INTEGER
    ) RAISES {Thread.Alerted} =
  &lt;* LL = {} *&gt;
  VAR zumeArgRec := NEW(NewLoopArgs
               , fromIndex := fromIndex
               , toIndex := toIndex
      );
      alg := NARROW(initiator, SubtypeAlgClass.T);
  BEGIN
    LOCK alg.evtMu DO
      INC(alg.eventDataRec.ctOfNewLoop);
      alg.stopAtEvent := alg.eventDataRec.stopAtNewLoop;
      alg.waitAtEvent := alg.eventDataRec.waitAtNewLoop;
      Zeus.Dispatch(initiator, Zeus.EventStyle.Output, 1,
                    &quot;NewLoop&quot;, OEDispatcher, zumeArgRec);
    END;
  END NewLoop;

PROCEDURE <A NAME="Enter"><procedure>Enter</procedure></A> (
      initiator: Algorithm.T;
       lftIndex, rhtIndex, lftLeadingEdgeIndex, rhtLeadingEdgeIndex: INTEGER
    ) RAISES {Thread.Alerted} =
  &lt;* LL = {} *&gt;
  VAR zumeArgRec := NEW(EnterArgs
               , lftIndex := lftIndex
               , rhtIndex := rhtIndex
               , lftLeadingEdgeIndex := lftLeadingEdgeIndex
               , rhtLeadingEdgeIndex := rhtLeadingEdgeIndex
      );
      alg := NARROW(initiator, SubtypeAlgClass.T);
  BEGIN
    LOCK alg.evtMu DO
      INC(alg.eventDataRec.ctOfEnter);
      alg.stopAtEvent := alg.eventDataRec.stopAtEnter;
      alg.waitAtEvent := alg.eventDataRec.waitAtEnter;
      Zeus.Dispatch(initiator, Zeus.EventStyle.Output, 1,
                    &quot;Enter&quot;, OEDispatcher, zumeArgRec);
    END;
  END Enter;

PROCEDURE <A NAME="Exit"><procedure>Exit</procedure></A> (
      initiator: Algorithm.T;
       lftIndex, rhtIndex, lftLeadingEdgeIndex, rhtLeadingEdgeIndex: INTEGER; result: BOOLEAN
    ) RAISES {Thread.Alerted} =
  &lt;* LL = {} *&gt;
  VAR zumeArgRec := NEW(ExitArgs
               , lftIndex := lftIndex
               , rhtIndex := rhtIndex
               , lftLeadingEdgeIndex := lftLeadingEdgeIndex
               , rhtLeadingEdgeIndex := rhtLeadingEdgeIndex
               , result := result
      );
      alg := NARROW(initiator, SubtypeAlgClass.T);
  BEGIN
    LOCK alg.evtMu DO
      INC(alg.eventDataRec.ctOfExit);
      alg.stopAtEvent := alg.eventDataRec.stopAtExit;
      alg.waitAtEvent := alg.eventDataRec.waitAtExit;
      Zeus.Dispatch(initiator, Zeus.EventStyle.Output, 1,
                    &quot;Exit&quot;, OEDispatcher, zumeArgRec);
    END;
  END Exit;

PROCEDURE <A NAME="SeenOK"><procedure>SeenOK</procedure></A> (
      initiator: Algorithm.T;
       fromIndex, toIndex: INTEGER
    ) RAISES {Thread.Alerted} =
  &lt;* LL = {} *&gt;
  VAR zumeArgRec := NEW(SeenOKArgs
               , fromIndex := fromIndex
               , toIndex := toIndex
      );
      alg := NARROW(initiator, SubtypeAlgClass.T);
  BEGIN
    LOCK alg.evtMu DO
      INC(alg.eventDataRec.ctOfSeenOK);
      alg.stopAtEvent := alg.eventDataRec.stopAtSeenOK;
      alg.waitAtEvent := alg.eventDataRec.waitAtSeenOK;
      Zeus.Dispatch(initiator, Zeus.EventStyle.Output, 1,
                    &quot;SeenOK&quot;, OEDispatcher, zumeArgRec);
    END;
  END SeenOK;

PROCEDURE <A NAME="Notice"><procedure>Notice</procedure></A> (
      initiator: Algorithm.T;
       fromIndex, toIndex: INTEGER
    ) RAISES {Thread.Alerted} =
  &lt;* LL = {} *&gt;
  VAR zumeArgRec := NEW(NoticeArgs
               , fromIndex := fromIndex
               , toIndex := toIndex
      );
      alg := NARROW(initiator, SubtypeAlgClass.T);
  BEGIN
    LOCK alg.evtMu DO
      INC(alg.eventDataRec.ctOfNotice);
      alg.stopAtEvent := alg.eventDataRec.stopAtNotice;
      alg.waitAtEvent := alg.eventDataRec.waitAtNotice;
      Zeus.Dispatch(initiator, Zeus.EventStyle.Output, 1,
                    &quot;Notice&quot;, OEDispatcher, zumeArgRec);
    END;
  END Notice;

PROCEDURE <A NAME="BotLessAnyOK"><procedure>BotLessAnyOK</procedure></A> (
      initiator: Algorithm.T;
       lftIndex, rhtIndex, lftLeadingEdgeIndex, rhtLeadingEdgeIndex: INTEGER
    ) RAISES {Thread.Alerted} =
  &lt;* LL = {} *&gt;
  VAR zumeArgRec := NEW(BotLessAnyOKArgs
               , lftIndex := lftIndex
               , rhtIndex := rhtIndex
               , lftLeadingEdgeIndex := lftLeadingEdgeIndex
               , rhtLeadingEdgeIndex := rhtLeadingEdgeIndex
      );
      alg := NARROW(initiator, SubtypeAlgClass.T);
  BEGIN
    LOCK alg.evtMu DO
      INC(alg.eventDataRec.ctOfBotLessAnyOK);
      alg.stopAtEvent := alg.eventDataRec.stopAtBotLessAnyOK;
      alg.waitAtEvent := alg.eventDataRec.waitAtBotLessAnyOK;
      Zeus.Dispatch(initiator, Zeus.EventStyle.Output, 1,
                    &quot;BotLessAnyOK&quot;, OEDispatcher, zumeArgRec);
    END;
  END BotLessAnyOK;

PROCEDURE <A NAME="TopLessTopOK"><procedure>TopLessTopOK</procedure></A> (
      initiator: Algorithm.T;
       lftIndex, rhtIndex, lftLeadingEdgeIndex, rhtLeadingEdgeIndex: INTEGER
    ) RAISES {Thread.Alerted} =
  &lt;* LL = {} *&gt;
  VAR zumeArgRec := NEW(TopLessTopOKArgs
               , lftIndex := lftIndex
               , rhtIndex := rhtIndex
               , lftLeadingEdgeIndex := lftLeadingEdgeIndex
               , rhtLeadingEdgeIndex := rhtLeadingEdgeIndex
      );
      alg := NARROW(initiator, SubtypeAlgClass.T);
  BEGIN
    LOCK alg.evtMu DO
      INC(alg.eventDataRec.ctOfTopLessTopOK);
      alg.stopAtEvent := alg.eventDataRec.stopAtTopLessTopOK;
      alg.waitAtEvent := alg.eventDataRec.waitAtTopLessTopOK;
      Zeus.Dispatch(initiator, Zeus.EventStyle.Output, 1,
                    &quot;TopLessTopOK&quot;, OEDispatcher, zumeArgRec);
    END;
  END TopLessTopOK;

PROCEDURE <A NAME="TopLessNonTopKO"><procedure>TopLessNonTopKO</procedure></A> (
      initiator: Algorithm.T;
       lftIndex, rhtIndex, lftLeadingEdgeIndex, rhtLeadingEdgeIndex: INTEGER
    ) RAISES {Thread.Alerted} =
  &lt;* LL = {} *&gt;
  VAR zumeArgRec := NEW(TopLessNonTopKOArgs
               , lftIndex := lftIndex
               , rhtIndex := rhtIndex
               , lftLeadingEdgeIndex := lftLeadingEdgeIndex
               , rhtLeadingEdgeIndex := rhtLeadingEdgeIndex
      );
      alg := NARROW(initiator, SubtypeAlgClass.T);
  BEGIN
    LOCK alg.evtMu DO
      INC(alg.eventDataRec.ctOfTopLessNonTopKO);
      alg.stopAtEvent := alg.eventDataRec.stopAtTopLessNonTopKO;
      alg.waitAtEvent := alg.eventDataRec.waitAtTopLessNonTopKO;
      Zeus.Dispatch(initiator, Zeus.EventStyle.Output, 1,
                    &quot;TopLessNonTopKO&quot;, OEDispatcher, zumeArgRec);
    END;
  END TopLessNonTopKO;

PROCEDURE <A NAME="FunLessBotKO"><procedure>FunLessBotKO</procedure></A> (
      initiator: Algorithm.T;
       lftIndex, rhtIndex, lftLeadingEdgeIndex, rhtLeadingEdgeIndex: INTEGER
    ) RAISES {Thread.Alerted} =
  &lt;* LL = {} *&gt;
  VAR zumeArgRec := NEW(FunLessBotKOArgs
               , lftIndex := lftIndex
               , rhtIndex := rhtIndex
               , lftLeadingEdgeIndex := lftLeadingEdgeIndex
               , rhtLeadingEdgeIndex := rhtLeadingEdgeIndex
      );
      alg := NARROW(initiator, SubtypeAlgClass.T);
  BEGIN
    LOCK alg.evtMu DO
      INC(alg.eventDataRec.ctOfFunLessBotKO);
      alg.stopAtEvent := alg.eventDataRec.stopAtFunLessBotKO;
      alg.waitAtEvent := alg.eventDataRec.waitAtFunLessBotKO;
      Zeus.Dispatch(initiator, Zeus.EventStyle.Output, 1,
                    &quot;FunLessBotKO&quot;, OEDispatcher, zumeArgRec);
    END;
  END FunLessBotKO;

PROCEDURE <A NAME="FunLessTopOK"><procedure>FunLessTopOK</procedure></A> (
      initiator: Algorithm.T;
       lftIndex, rhtIndex, lftLeadingEdgeIndex, rhtLeadingEdgeIndex: INTEGER
    ) RAISES {Thread.Alerted} =
  &lt;* LL = {} *&gt;
  VAR zumeArgRec := NEW(FunLessTopOKArgs
               , lftIndex := lftIndex
               , rhtIndex := rhtIndex
               , lftLeadingEdgeIndex := lftLeadingEdgeIndex
               , rhtLeadingEdgeIndex := rhtLeadingEdgeIndex
      );
      alg := NARROW(initiator, SubtypeAlgClass.T);
  BEGIN
    LOCK alg.evtMu DO
      INC(alg.eventDataRec.ctOfFunLessTopOK);
      alg.stopAtEvent := alg.eventDataRec.stopAtFunLessTopOK;
      alg.waitAtEvent := alg.eventDataRec.waitAtFunLessTopOK;
      Zeus.Dispatch(initiator, Zeus.EventStyle.Output, 1,
                    &quot;FunLessTopOK&quot;, OEDispatcher, zumeArgRec);
    END;
  END FunLessTopOK;

PROCEDURE <A NAME="FunLessFun"><procedure>FunLessFun</procedure></A> (
      initiator: Algorithm.T;
       lftIndex, rhtIndex, lftLeadingEdgeIndex, rhtLeadingEdgeIndex: INTEGER
    ) RAISES {Thread.Alerted} =
  &lt;* LL = {} *&gt;
  VAR zumeArgRec := NEW(FunLessFunArgs
               , lftIndex := lftIndex
               , rhtIndex := rhtIndex
               , lftLeadingEdgeIndex := lftLeadingEdgeIndex
               , rhtLeadingEdgeIndex := rhtLeadingEdgeIndex
      );
      alg := NARROW(initiator, SubtypeAlgClass.T);
  BEGIN
    LOCK alg.evtMu DO
      INC(alg.eventDataRec.ctOfFunLessFun);
      alg.stopAtEvent := alg.eventDataRec.stopAtFunLessFun;
      alg.waitAtEvent := alg.eventDataRec.waitAtFunLessFun;
      Zeus.Dispatch(initiator, Zeus.EventStyle.Output, 1,
                    &quot;FunLessFun&quot;, OEDispatcher, zumeArgRec);
    END;
  END FunLessFun;

PROCEDURE <A NAME="OK"><procedure>OK</procedure></A> (
      initiator: Algorithm.T;
       lftIndex, rhtIndex, lftLeadingEdgeIndex, rhtLeadingEdgeIndex: INTEGER
    ) RAISES {Thread.Alerted} =
  &lt;* LL = {} *&gt;
  VAR zumeArgRec := NEW(OKArgs
               , lftIndex := lftIndex
               , rhtIndex := rhtIndex
               , lftLeadingEdgeIndex := lftLeadingEdgeIndex
               , rhtLeadingEdgeIndex := rhtLeadingEdgeIndex
      );
      alg := NARROW(initiator, SubtypeAlgClass.T);
  BEGIN
    LOCK alg.evtMu DO
      INC(alg.eventDataRec.ctOfOK);
      alg.stopAtEvent := alg.eventDataRec.stopAtOK;
      alg.waitAtEvent := alg.eventDataRec.waitAtOK;
      Zeus.Dispatch(initiator, Zeus.EventStyle.Output, 1,
                    &quot;OK&quot;, OEDispatcher, zumeArgRec);
    END;
  END OK;

PROCEDURE <A NAME="KO"><procedure>KO</procedure></A> (
      initiator: Algorithm.T;
       lftIndex, rhtIndex, lftLeadingEdgeIndex, rhtLeadingEdgeIndex: INTEGER
    ) RAISES {Thread.Alerted} =
  &lt;* LL = {} *&gt;
  VAR zumeArgRec := NEW(KOArgs
               , lftIndex := lftIndex
               , rhtIndex := rhtIndex
               , lftLeadingEdgeIndex := lftLeadingEdgeIndex
               , rhtLeadingEdgeIndex := rhtLeadingEdgeIndex
      );
      alg := NARROW(initiator, SubtypeAlgClass.T);
  BEGIN
    LOCK alg.evtMu DO
      INC(alg.eventDataRec.ctOfKO);
      alg.stopAtEvent := alg.eventDataRec.stopAtKO;
      alg.waitAtEvent := alg.eventDataRec.waitAtKO;
      Zeus.Dispatch(initiator, Zeus.EventStyle.Output, 1,
                    &quot;KO&quot;, OEDispatcher, zumeArgRec);
    END;
  END KO;

BEGIN
END SubtypeIE.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface View is in:
</A><UL>
<LI><A HREF="../../juno-app/src/View.i3.html#0TOP0">juno-app/src/View.i3</A>
<LI><A HREF="../../zeus/src/View.i3.html#0TOP0">zeus/src/View.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
