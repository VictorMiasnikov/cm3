<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: mentor/derived/MentorBundle.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>mentor/derived/MentorBundle.m3</H2></A><HR>
<inModule>
<PRE>MODULE <module><implements><A HREF="MentorBundle.i3.html">MentorBundle</A></implements></module>;
</PRE><BLOCKQUOTE><EM> Generated by m3bundle; see its manpage. </EM></BLOCKQUOTE><PRE>

IMPORT <A HREF="../../libm3/src/bundleintf/Bundle.i3.html">Bundle</A>, <A HREF="../../libm3/src/bundleintf/BundleRep.i3.html">BundleRep</A>, <A HREF="../../m3core/src/text/Text.i3.html">Text</A>;
IMPORT <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="../../libm3/src/rw/TextWr.i3.html">TextWr</A>;

TYPE T = Bundle.T OBJECT OVERRIDES
           get      := LookUp;
           getNames := GetNames;
         END;

TYPE Texts = REF ARRAY OF TEXT;

VAR
  bundle: T     := NIL;
  names : Texts := NIL;

PROCEDURE <A NAME="Get"><procedure>Get</procedure></A>(): Bundle.T =
  BEGIN
    IF (bundle = NIL) THEN bundle := NEW (T) END;
    RETURN bundle;
  END Get;

PROCEDURE <A NAME="GetNames"><procedure>GetNames</procedure></A> (&lt;*UNUSED*&gt; self: T): Texts =
  BEGIN
    IF names = NIL THEN
      names := NEW (Texts, NUMBER (Names));
      names^ := Names;
    END;
    RETURN names;
  END GetNames;

PROCEDURE <A NAME="LookUp"><procedure>LookUp</procedure></A> (&lt;*UNUSED*&gt; self: T;  element: TEXT): TEXT =
  BEGIN
    FOR i := 0 TO LAST (Names)-1 DO
      IF Text.Equal (Names[i], element) THEN
        IF Elements[i] = NIL THEN Elements[i] := GetElt (i) END;
        RETURN Elements[i];
      END;
    END;
    RETURN NIL;
  END LookUp;

CONST Names = ARRAY [0..126] OF TEXT {
  &quot;hullinput.fv&quot;,
  &quot;ChangeParent.obl&quot;,
  &quot;QueueSizes.obl&quot;,
  &quot;BinpackEventData.fv&quot;,
  &quot;MatchTranscriptView.fv&quot;,
  &quot;Insertion.pas&quot;,
  &quot;CPTranscriptView.fv&quot;,
  &quot;maxflowdata.fv&quot;,
  &quot;CPCode.pasc&quot;,
  &quot;HullTranscriptView.fv&quot;,
  &quot;logoTranscriptView.fv&quot;,
  &quot;DFS.m3.cv&quot;,
  &quot;HashTranscriptView.fv&quot;,
  &quot;logoinput.fv&quot;,
  &quot;SubtypeEventData.fv&quot;,
  &quot;binpackprompt.fv&quot;,
  &quot;hashstats.fv&quot;,
  &quot;PacketMove.obl&quot;,
  &quot;SearchTreeEventData.fv&quot;,
  &quot;subtypeinput.fv&quot;,
  &quot;RedBlack.m3&quot;,
  &quot;ParseEventData.fv&quot;,
  &quot;UnionFindEventData.fv&quot;,
  &quot;MinimaxEventData.fv&quot;,
  &quot;stringsearchinput.fv&quot;,
  &quot;CPVar.fv&quot;,
  &quot;data.big2&quot;,
  &quot;Decompress.pcode&quot;,
  &quot;Decompress.obl&quot;,
  &quot;SortEventData.fv&quot;,
  &quot;DFSVar.fv&quot;,
  &quot;ManyPacketsStep.obl&quot;,
  &quot;BresenhamTranscriptView.fv&quot;,
  &quot;MaxflowTranscriptView.fv&quot;,
  &quot;PQueueEventData.fv&quot;,
  &quot;bresenhaminput.fv&quot;,
  &quot;FindLength.obl&quot;,
  &quot;pqueueAlgs.m3&quot;,
  &quot;ViewColorScale.obl&quot;,
  &quot;PktRouteEventData.fv&quot;,
  &quot;Unbalanced.pseudo&quot;,
  &quot;ShortestPathTranscriptView.fv&quot;,
  &quot;DGraphTranscriptView.fv&quot;,
  &quot;A_RecDescent.code&quot;,
  &quot;ZPaperTranscriptView.fv&quot;,
  &quot;EuclidTranscriptView.fv&quot;,
  &quot;dgraph.data&quot;,
  &quot;zviewframe.fv&quot;,
  &quot;proof&quot;,
  &quot;binpackFFvar.fv&quot;,
  &quot;MatchEventData.fv&quot;,
  &quot;SPGraph.obl&quot;,
  &quot;Insertion.m3&quot;,
  &quot;AverageDepth.obl&quot;,
  &quot;stringsearchautoview.fv&quot;,
  &quot;CPEventData.fv&quot;,
  &quot;PacketStep.obl&quot;,
  &quot;WheelerTranscriptView.fv&quot;,
  &quot;maxflowinput.fv&quot;,
  &quot;CPCode.cc&quot;,
  &quot;data.simple&quot;,
  &quot;HullEventData.fv&quot;,
  &quot;logoEventData.fv&quot;,
  &quot;Warshall.m3.cv&quot;,
  &quot;HashEventData.fv&quot;,
  &quot;binpackinput.fv&quot;,
  &quot;hashinput.fv&quot;,
  &quot;Compress.obl&quot;,
  &quot;RedBlack.pseudo&quot;,
  &quot;ManyPacketsMove.obl&quot;,
  &quot;A_BottomUp.code&quot;,
  &quot;StringSearchTranscriptView.fv&quot;,
  &quot;BigTree.obl&quot;,
  &quot;ViewGameTreeB.obl&quot;,
  &quot;CPinput.fv&quot;,
  &quot;data.big&quot;,
  &quot;WrapAlg.m3.cv&quot;,
  &quot;myview.obl&quot;,
  &quot;BinpackTranscriptView.fv&quot;,
  &quot;WarshallVar.fv&quot;,
  &quot;BresenhamEventData.fv&quot;,
  &quot;InsertionVar.fv&quot;,
  &quot;MaxflowEventData.fv&quot;,
  &quot;AlgGreedy.fv&quot;,
  &quot;maxflowcode.m3&quot;,
  &quot;ShortestPathEventData.fv&quot;,
  &quot;DGraphEventData.fv&quot;,
  &quot;NodeDepth.obl&quot;,
  &quot;Parse.fv&quot;,
  &quot;ZPaperEventData.fv&quot;,
  &quot;PacketRoute.obl&quot;,
  &quot;EuclidEventData.fv&quot;,
  &quot;graph.sx&quot;,
  &quot;DFSTC.m3.cv&quot;,
  &quot;zdata.fv&quot;,
  &quot;SubtypeTranscriptView.fv&quot;,
  &quot;alg.c&quot;,
  &quot;SearchTreeTranscriptView.fv&quot;,
  &quot;alg_m3.code&quot;,
  &quot;SearchTree.fv&quot;,
  &quot;ParseTranscriptView.fv&quot;,
  &quot;UnionFindTranscriptView.fv&quot;,
  &quot;MinimaxTranscriptView.fv&quot;,
  &quot;SortData.fv&quot;,
  &quot;stringsearchtextview.fv&quot;,
  &quot;UnionFind.fv&quot;,
  &quot;MinimaxInput.fv&quot;,
  &quot;WheelerEventData.fv&quot;,
  &quot;CPCode.m3c&quot;,
  &quot;view1.obl&quot;,
  &quot;data.fin&quot;,
  &quot;WheelerInput.fv&quot;,
  &quot;PacketTrace.obl&quot;,
  &quot;SortTranscriptView.fv&quot;,
  &quot;DGraphinput.fv&quot;,
  &quot;Tree.obl&quot;,
  &quot;ViewGameTreeA.obl&quot;,
  &quot;PQueueTranscriptView.fv&quot;,
  &quot;HashVar.fv&quot;,
  &quot;pqueueinput.fv&quot;,
  &quot;PktRouteTranscriptView.fv&quot;,
  &quot;Unbalanced.m3&quot;,
  &quot;WhyDecompressWorks.obl&quot;,
  &quot;A_TopDown.code&quot;,
  &quot;StringSearchEventData.fv&quot;,
  &quot;data.backedge&quot;,
  NIL
};

VAR Elements := ARRAY [0..126] OF TEXT {
  E0,
  NIL (* E1 .. E1_2 *),
  NIL (* E2 .. E2_7 *),
  NIL (* E3 .. E3_1 *),
  E4,
  E5,
  E6,
  E7,
  E8,
  E9,
  E10,
  E11,
  E12,
  E13,
  NIL (* E14 .. E14_5 *),
  E15,
  E16,
  NIL (* E17 .. E17_2 *),
  NIL (* E18 .. E18_3 *),
  E19,
  NIL (* E20 .. E20_1 *),
  NIL (* E21 .. E21_2 *),
  NIL (* E22 .. E22_4 *),
  NIL (* E23 .. E23_2 *),
  E24,
  E25,
  E26,
  E27,
  NIL (* E28 .. E28_6 *),
  NIL (* E29 .. E29_0 *),
  E30,
  NIL (* E31 .. E31_5 *),
  E32,
  E33,
  NIL (* E34 .. E34_2 *),
  E35,
  NIL (* E36 .. E36_2 *),
  E37,
  E38,
  NIL (* E39 .. E39_3 *),
  E40,
  E41,
  E42,
  E43,
  E44,
  E45,
  E46,
  E47,
  NIL (* E48 .. E48_0 *),
  E49,
  NIL (* E50 .. E50_0 *),
  NIL (* E51 .. E51_3 *),
  E52,
  NIL (* E53 .. E53_3 *),
  E54,
  NIL (* E55 .. E55_5 *),
  NIL (* E56 .. E56_3 *),
  E57,
  E58,
  E59,
  E60,
  NIL (* E61 .. E61_4 *),
  NIL (* E62 .. E62_1 *),
  E63,
  NIL (* E64 .. E64_2 *),
  E65,
  NIL (* E66 .. E66_0 *),
  NIL (* E67 .. E67_5 *),
  NIL (* E68 .. E68_0 *),
  NIL (* E69 .. E69_3 *),
  E70,
  E71,
  NIL (* E72 .. E72_7 *),
  NIL (* E73 .. E73_3 *),
  E74,
  E75,
  NIL (* E76 .. E76_2 *),
  E77,
  E78,
  E79,
  NIL (* E80 .. E80_2 *),
  E81,
  NIL (* E82 .. E82_1 *),
  NIL (* E83 .. E83_0 *),
  E84,
  NIL (* E85 .. E85_1 *),
  NIL (* E86 .. E86_2 *),
  NIL (* E87 .. E87_3 *),
  E88,
  NIL (* E89 .. E89_0 *),
  NIL (* E90 .. E90_6 *),
  NIL (* E91 .. E91_3 *),
  E92,
  E93,
  E94,
  E95,
  E96,
  E97,
  E98,
  E99,
  E100,
  E101,
  E102,
  E103,
  E104,
  E105,
  E106,
  NIL (* E107 .. E107_7 *),
  E108,
  NIL (* E109 .. E109_6 *),
  E110,
  E111,
  NIL (* E112 .. E112_6 *),
  E113,
  E114,
  NIL (* E115 .. E115_7 *),
  NIL (* E116 .. E116_3 *),
  E117,
  E118,
  E119,
  E120,
  NIL (* E121 .. E121_0 *),
  NIL (* E122 .. E122_5 *),
  E123,
  NIL (* E124 .. E124_2 *),
  E125,
  NIL
};

PROCEDURE <A NAME="GetElt"><procedure>GetElt</procedure></A> (n: INTEGER): TEXT =
  &lt;*FATAL Thread.Alerted, Wr.Failure *&gt;
  VAR wr := TextWr.New ();
  BEGIN
    CASE n OF
    | 1 =&gt;
        Wr.PutText (wr, E1);
        Wr.PutText (wr, E1_0);
        Wr.PutText (wr, E1_1);
        Wr.PutText (wr, E1_2);
    | 2 =&gt;
        Wr.PutText (wr, E2);
        Wr.PutText (wr, E2_0);
        Wr.PutText (wr, E2_1);
        Wr.PutText (wr, E2_2);
        Wr.PutText (wr, E2_3);
        Wr.PutText (wr, E2_4);
        Wr.PutText (wr, E2_5);
        Wr.PutText (wr, E2_6);
        Wr.PutText (wr, E2_7);
    | 3 =&gt;
        Wr.PutText (wr, E3);
        Wr.PutText (wr, E3_0);
        Wr.PutText (wr, E3_1);
    | 14 =&gt;
        Wr.PutText (wr, E14);
        Wr.PutText (wr, E14_0);
        Wr.PutText (wr, E14_1);
        Wr.PutText (wr, E14_2);
        Wr.PutText (wr, E14_3);
        Wr.PutText (wr, E14_4);
        Wr.PutText (wr, E14_5);
    | 17 =&gt;
        Wr.PutText (wr, E17);
        Wr.PutText (wr, E17_0);
        Wr.PutText (wr, E17_1);
        Wr.PutText (wr, E17_2);
    | 18 =&gt;
        Wr.PutText (wr, E18);
        Wr.PutText (wr, E18_0);
        Wr.PutText (wr, E18_1);
        Wr.PutText (wr, E18_2);
        Wr.PutText (wr, E18_3);
    | 20 =&gt;
        Wr.PutText (wr, E20);
        Wr.PutText (wr, E20_0);
        Wr.PutText (wr, E20_1);
    | 21 =&gt;
        Wr.PutText (wr, E21);
        Wr.PutText (wr, E21_0);
        Wr.PutText (wr, E21_1);
        Wr.PutText (wr, E21_2);
    | 22 =&gt;
        Wr.PutText (wr, E22);
        Wr.PutText (wr, E22_0);
        Wr.PutText (wr, E22_1);
        Wr.PutText (wr, E22_2);
        Wr.PutText (wr, E22_3);
        Wr.PutText (wr, E22_4);
    | 23 =&gt;
        Wr.PutText (wr, E23);
        Wr.PutText (wr, E23_0);
        Wr.PutText (wr, E23_1);
        Wr.PutText (wr, E23_2);
    | 28 =&gt;
        Wr.PutText (wr, E28);
        Wr.PutText (wr, E28_0);
        Wr.PutText (wr, E28_1);
        Wr.PutText (wr, E28_2);
        Wr.PutText (wr, E28_3);
        Wr.PutText (wr, E28_4);
        Wr.PutText (wr, E28_5);
        Wr.PutText (wr, E28_6);
    | 29 =&gt;
        Wr.PutText (wr, E29);
        Wr.PutText (wr, E29_0);
    | 31 =&gt;
        Wr.PutText (wr, E31);
        Wr.PutText (wr, E31_0);
        Wr.PutText (wr, E31_1);
        Wr.PutText (wr, E31_2);
        Wr.PutText (wr, E31_3);
        Wr.PutText (wr, E31_4);
        Wr.PutText (wr, E31_5);
    | 34 =&gt;
        Wr.PutText (wr, E34);
        Wr.PutText (wr, E34_0);
        Wr.PutText (wr, E34_1);
        Wr.PutText (wr, E34_2);
    | 36 =&gt;
        Wr.PutText (wr, E36);
        Wr.PutText (wr, E36_0);
        Wr.PutText (wr, E36_1);
        Wr.PutText (wr, E36_2);
    | 39 =&gt;
        Wr.PutText (wr, E39);
        Wr.PutText (wr, E39_0);
        Wr.PutText (wr, E39_1);
        Wr.PutText (wr, E39_2);
        Wr.PutText (wr, E39_3);
    | 48 =&gt;
        Wr.PutText (wr, E48);
        Wr.PutText (wr, E48_0);
    | 50 =&gt;
        Wr.PutText (wr, E50);
        Wr.PutText (wr, E50_0);
    | 51 =&gt;
        Wr.PutText (wr, E51);
        Wr.PutText (wr, E51_0);
        Wr.PutText (wr, E51_1);
        Wr.PutText (wr, E51_2);
        Wr.PutText (wr, E51_3);
    | 53 =&gt;
        Wr.PutText (wr, E53);
        Wr.PutText (wr, E53_0);
        Wr.PutText (wr, E53_1);
        Wr.PutText (wr, E53_2);
        Wr.PutText (wr, E53_3);
    | 55 =&gt;
        Wr.PutText (wr, E55);
        Wr.PutText (wr, E55_0);
        Wr.PutText (wr, E55_1);
        Wr.PutText (wr, E55_2);
        Wr.PutText (wr, E55_3);
        Wr.PutText (wr, E55_4);
        Wr.PutText (wr, E55_5);
    | 56 =&gt;
        Wr.PutText (wr, E56);
        Wr.PutText (wr, E56_0);
        Wr.PutText (wr, E56_1);
        Wr.PutText (wr, E56_2);
        Wr.PutText (wr, E56_3);
    | 61 =&gt;
        Wr.PutText (wr, E61);
        Wr.PutText (wr, E61_0);
        Wr.PutText (wr, E61_1);
        Wr.PutText (wr, E61_2);
        Wr.PutText (wr, E61_3);
        Wr.PutText (wr, E61_4);
    | 62 =&gt;
        Wr.PutText (wr, E62);
        Wr.PutText (wr, E62_0);
        Wr.PutText (wr, E62_1);
    | 64 =&gt;
        Wr.PutText (wr, E64);
        Wr.PutText (wr, E64_0);
        Wr.PutText (wr, E64_1);
        Wr.PutText (wr, E64_2);
    | 66 =&gt;
        Wr.PutText (wr, E66);
        Wr.PutText (wr, E66_0);
    | 67 =&gt;
        Wr.PutText (wr, E67);
        Wr.PutText (wr, E67_0);
        Wr.PutText (wr, E67_1);
        Wr.PutText (wr, E67_2);
        Wr.PutText (wr, E67_3);
        Wr.PutText (wr, E67_4);
        Wr.PutText (wr, E67_5);
    | 68 =&gt;
        Wr.PutText (wr, E68);
        Wr.PutText (wr, E68_0);
    | 69 =&gt;
        Wr.PutText (wr, E69);
        Wr.PutText (wr, E69_0);
        Wr.PutText (wr, E69_1);
        Wr.PutText (wr, E69_2);
        Wr.PutText (wr, E69_3);
    | 72 =&gt;
        Wr.PutText (wr, E72);
        Wr.PutText (wr, E72_0);
        Wr.PutText (wr, E72_1);
        Wr.PutText (wr, E72_2);
        Wr.PutText (wr, E72_3);
        Wr.PutText (wr, E72_4);
        Wr.PutText (wr, E72_5);
        Wr.PutText (wr, E72_6);
        Wr.PutText (wr, E72_7);
    | 73 =&gt;
        Wr.PutText (wr, E73);
        Wr.PutText (wr, E73_0);
        Wr.PutText (wr, E73_1);
        Wr.PutText (wr, E73_2);
        Wr.PutText (wr, E73_3);
    | 76 =&gt;
        Wr.PutText (wr, E76);
        Wr.PutText (wr, E76_0);
        Wr.PutText (wr, E76_1);
        Wr.PutText (wr, E76_2);
    | 80 =&gt;
        Wr.PutText (wr, E80);
        Wr.PutText (wr, E80_0);
        Wr.PutText (wr, E80_1);
        Wr.PutText (wr, E80_2);
    | 82 =&gt;
        Wr.PutText (wr, E82);
        Wr.PutText (wr, E82_0);
        Wr.PutText (wr, E82_1);
    | 83 =&gt;
        Wr.PutText (wr, E83);
        Wr.PutText (wr, E83_0);
    | 85 =&gt;
        Wr.PutText (wr, E85);
        Wr.PutText (wr, E85_0);
        Wr.PutText (wr, E85_1);
    | 86 =&gt;
        Wr.PutText (wr, E86);
        Wr.PutText (wr, E86_0);
        Wr.PutText (wr, E86_1);
        Wr.PutText (wr, E86_2);
    | 87 =&gt;
        Wr.PutText (wr, E87);
        Wr.PutText (wr, E87_0);
        Wr.PutText (wr, E87_1);
        Wr.PutText (wr, E87_2);
        Wr.PutText (wr, E87_3);
    | 89 =&gt;
        Wr.PutText (wr, E89);
        Wr.PutText (wr, E89_0);
    | 90 =&gt;
        Wr.PutText (wr, E90);
        Wr.PutText (wr, E90_0);
        Wr.PutText (wr, E90_1);
        Wr.PutText (wr, E90_2);
        Wr.PutText (wr, E90_3);
        Wr.PutText (wr, E90_4);
        Wr.PutText (wr, E90_5);
        Wr.PutText (wr, E90_6);
    | 91 =&gt;
        Wr.PutText (wr, E91);
        Wr.PutText (wr, E91_0);
        Wr.PutText (wr, E91_1);
        Wr.PutText (wr, E91_2);
        Wr.PutText (wr, E91_3);
    | 107 =&gt;
        Wr.PutText (wr, E107);
        Wr.PutText (wr, E107_0);
        Wr.PutText (wr, E107_1);
        Wr.PutText (wr, E107_2);
        Wr.PutText (wr, E107_3);
        Wr.PutText (wr, E107_4);
        Wr.PutText (wr, E107_5);
        Wr.PutText (wr, E107_6);
        Wr.PutText (wr, E107_7);
    | 109 =&gt;
        Wr.PutText (wr, E109);
        Wr.PutText (wr, E109_0);
        Wr.PutText (wr, E109_1);
        Wr.PutText (wr, E109_2);
        Wr.PutText (wr, E109_3);
        Wr.PutText (wr, E109_4);
        Wr.PutText (wr, E109_5);
        Wr.PutText (wr, E109_6);
    | 112 =&gt;
        Wr.PutText (wr, E112);
        Wr.PutText (wr, E112_0);
        Wr.PutText (wr, E112_1);
        Wr.PutText (wr, E112_2);
        Wr.PutText (wr, E112_3);
        Wr.PutText (wr, E112_4);
        Wr.PutText (wr, E112_5);
        Wr.PutText (wr, E112_6);
    | 115 =&gt;
        Wr.PutText (wr, E115);
        Wr.PutText (wr, E115_0);
        Wr.PutText (wr, E115_1);
        Wr.PutText (wr, E115_2);
        Wr.PutText (wr, E115_3);
        Wr.PutText (wr, E115_4);
        Wr.PutText (wr, E115_5);
        Wr.PutText (wr, E115_6);
        Wr.PutText (wr, E115_7);
    | 116 =&gt;
        Wr.PutText (wr, E116);
        Wr.PutText (wr, E116_0);
        Wr.PutText (wr, E116_1);
        Wr.PutText (wr, E116_2);
        Wr.PutText (wr, E116_3);
    | 121 =&gt;
        Wr.PutText (wr, E121);
        Wr.PutText (wr, E121_0);
    | 122 =&gt;
        Wr.PutText (wr, E122);
        Wr.PutText (wr, E122_0);
        Wr.PutText (wr, E122_1);
        Wr.PutText (wr, E122_2);
        Wr.PutText (wr, E122_3);
        Wr.PutText (wr, E122_4);
        Wr.PutText (wr, E122_5);
    | 124 =&gt;
        Wr.PutText (wr, E124);
        Wr.PutText (wr, E124_0);
        Wr.PutText (wr, E124_1);
        Wr.PutText (wr, E124_2);
    ELSE (*skip*)
    END;
    RETURN TextWr.ToText (wr);
  END GetElt;

CONST E0 =
   &quot;; Copyright (C) 1992, Digital Equipment Corporation\n; All rights reser&quot;
 &amp; &quot;ved.\n; See the file COPYRIGHT for a full description.\n\n(Rim\n  (Pen &quot;
 &amp; &quot;10)\n  (HBox\n    (Radio\n      %InStyle\n      =Random\n      (VBox\n &quot;
 &amp; &quot;       (HBox\n          (Choice %Random \&quot;Random points:\&quot;)\n          &quot;
 &amp; &quot;(Numeric (Min 3) (Max 99) %N =10)\n          (Glue 10)\n          (Bool&quot;
 &amp; &quot;ean %UsePrev (Value FALSE) \&quot;Prev. seed\&quot;)\n          Fill)\n        (G&quot;
 &amp; &quot;lue 10)\n        (HBox\n          (Choice %File \&quot;From file:\&quot;)\n      &quot;
 &amp; &quot;    (Border\n            (Shape\n              (Width 120 + 200)\n     &quot;
 &amp; &quot;         (Height 60 + 75)\n              (FileBrowser (Suffixes \&quot;pt\&quot; &quot;
 &amp; &quot;\&quot;\&quot;) %Name))))))))\n&quot;;

CONST E1 =
   &quot;(* Copyright (C) 1994, Digital Equipment Corporation                   &quot;
 &amp; &quot;      *)\n(* All rights reserved.                                      &quot;
 &amp; &quot;                *)\n(* See the file COPYRIGHT for a full description.  &quot;
 &amp; &quot;                          *)\n(*                                       &quot;
 &amp; &quot;                                    *)\n(* Last modified on Mon Jan  9 &quot;
 &amp; &quot;12:04:15 PST 1995 by najork                   *)\n(*      modified on F&quot;
 &amp; &quot;ri Aug 19 12:49:52 PDT 1994 by heydon                   *)\n\n(* Change&quot;
 &amp; &quot;Parent.obl -- histogram of grouped \&quot;ChangeParent\&quot; operations. *)\n\nl&quot;
 &amp; &quot;et Margin   = 5.0;           (* in mm *)\nlet InitMaxX = 4;\nlet InitMa&quot;
 &amp; &quot;xY = 4.0;\n\nlet BarColor    = color_named(\&quot;yellow\&quot;);\nlet BorderColo&quot;
 &amp; &quot;r = color_named(\&quot;black\&quot;);\nlet BorderWidth = 0.05;\nlet TextColor   =&quot;
 &amp; &quot; color_named(\&quot;black\&quot;);\nlet FontSz      = 0.6;\nlet Lab1Y       = ~0.&quot;
 &amp; &quot;5;\nlet Lab2Y       = ~1.5;\nlet MinY        = ~2.0;\n\n(* Bar Object =&quot;
 &amp; &quot;============================================================ *)\n\nlet &quot;
 &amp; &quot;Bar = {\n  slot: Int =&gt; ok,\n  count: Int =&gt; 0,\n  v: Vertex =&gt; ok,\n\n&quot;
 &amp; &quot;  barHeight =&gt; meth(self: Bar): Real,\n    math_sqrt(float(self.count))&quot;
 &amp; &quot;\n  end,\n\n  updateVertex =&gt; meth(self): Ok,\n    let ht = self.barHei&quot;
 &amp; &quot;ght();\n    graph_setVertexSize(self.v, 0.9, ht);\n    graph_moveVertex&quot;
 &amp; &quot;(self.v, 0.5 + float(self.slot), ht / 2.0, false);\n    ok\n  end,\n\n &quot;
 &amp; &quot; updateLabel =&gt; meth(self): Ok,\n    graph_setVertexLabel(self.v, fmt_i&quot;
 &amp; &quot;nt(self.count));\n    ok\n  end,\n\n  new =&gt; meth(self: Bar, g: Graph, &quot;
 &amp; &quot;f: Font, slot: Int): Bar,\n    self.slot := slot;\n    self.v := graph_&quot;
 &amp; &quot;newVertex(g);\n    graph_setVertexColor(self.v, BarColor);\n    graph_s&quot;
 &amp; &quot;etVertexBorderColor(self.v, BorderColor);\n    graph_setVertexBorder(se&quot;
 &amp; &quot;lf.v, BorderWidth);\n    graph_setVertexFont(self.v, f);\n    graph_set&quot;
 &amp; &quot;VertexLabelColor(self.v, TextColor);\n    graph_setVertexLabel(self.v, &quot;
 &amp; &quot;\&quot;\&quot;);\n    self.updateVertex();\n    let v = graph_newVertex(g);\n    &quot;
 &amp; &quot;graph_vertexToBack(v);\n    graph_setVertexColor(v, color_named(\&quot;white&quot;
 &amp; &quot;\&quot;));\n    graph_setVertexFont(v, f);\n    graph_setVertexLabelColor(v,&quot;
 &amp; &quot; TextColor);&quot;;

CONST E1_0 =
   &quot;\n    graph_setVertexLabel(v, fmt_int(slot+1));\n    graph_setVertexSiz&quot;
 &amp; &quot;e(v, 1.0, 1.0);\n    graph_moveVertex(v, 0.5 + float(slot), Lab1Y, fals&quot;
 &amp; &quot;e);\n    self\n  end,\n\n  inc =&gt; meth(self: Bar): Ok,\n  (* increment &quot;
 &amp; &quot;the count of the bar \&quot;self\&quot;, and update its vertex\n     to reflect t&quot;
 &amp; &quot;he change. *)\n    self.count := self.count + 1;\n    self.updateVertex&quot;
 &amp; &quot;();\n    self.updateLabel();\n    ok\n  end,\n};\n\n(* View Object ====&quot;
 &amp; &quot;======================================================== *)\n\nlet view&quot;
 &amp; &quot;: View = {\n\n  (* Data members ---------------------------------------&quot;
 &amp; &quot;------------------ *)\n\n  graphvbt =&gt; graph_new(),\n  bar: [Bar] =&gt; ok&quot;
 &amp; &quot;,\n  maxX: Int =&gt; InitMaxX,     (* slots [0..maxX-1] *)\n  maxY: Real =&quot;
 &amp; &quot;&gt; InitMaxY,    (* values [0..maxY] *)\n  currLen: Int =&gt; ok,\n  labelFo&quot;
 &amp; &quot;nt: Font =&gt; ok,\n  total: Int =&gt; 0,\n  count: Int =&gt; 0,\n  totalV: Vert&quot;
 &amp; &quot;ex =&gt; ok,\n\n  setWorld =&gt; meth(self: View): Ok,\n    graph_setWorld(se&quot;
 &amp; &quot;lf.graphvbt,\n      0.0, float(self.maxX), self.maxY + 2.0, MinY);\n   &quot;
 &amp; &quot; ok\n  end,\n\n  updateTotal =&gt; meth(self: View): Ok,\n    let txt = \&quot;&quot;
 &amp; &quot;Total = \&quot; &amp; fmt_int(self.total) &amp; \&quot;  Average = \&quot; &amp;\n      if self.co&quot;
 &amp; &quot;unt is 0 then \&quot;0.00\&quot; else\n        text_replaceAll(\&quot;d\&quot;, \&quot;0\&quot;,\n   &quot;
 &amp; &quot;                     text_sub(fmt_real(float(self.total)/float(self.cou&quot;
 &amp; &quot;nt)),\n                                 0, 4));\n      end;\n    graph_&quot;
 &amp; &quot;setVertexLabel(self.totalV, txt);\n    ok\n  end,\n\n  moveTotalLabel =&quot;
 &amp; &quot;&gt; meth(self: View): Ok,\n    graph_moveVertex(self.totalV, float(self.m&quot;
 &amp; &quot;axX)/2.0, Lab2Y, true);\n    ok\n  end,\n\n  (* Setup -----------------&quot;
 &amp; &quot;----------------------------------------------- *)\n\n  Setup =&gt; meth(s&quot;
 &amp; &quot;elf: View): Ok,\n    self.labelFont := graph_newFont(self.graphvbt, \&quot;H&quot;
 &amp; &quot;elvetica\&quot;, FontSz,\n      \&quot;Roman\&quot;, \&quot;bold\&quot;, \&quot;*\&quot;);\n    graph_setM&quot;
 &amp; &quot;argin(self.graphvbt, Margin);\n    self.setWorld();\n    ok\n  end,\n\n&quot;
 &amp; &quot;  NewSet =&gt; meth(self: View, nm: Text): Ok,\n    ok\n  end,\n\n  Finish&quot;
 &amp; &quot;edSets =&gt; meth(self: View, numSets: Int, usesRanks: Bool): Ok,\n    sel&quot;
 &amp; &quot;f.totalV := graph_newVertex(self.graphvbt);\n    graph_vertexToBack(sel&quot;
 &amp; &quot;f.totalV);\n    graph_setVertexFo&quot;;

CONST E1_1 =
   &quot;nt(self.totalV, self.labelFont);\n    graph_setVertexLabelColor(self.to&quot;
 &amp; &quot;talV, TextColor);\n    graph_setVertexColor(self.totalV, color_named(\&quot;&quot;
 &amp; &quot;white\&quot;));\n    graph_setVertexSize(self.totalV, 200.0, 1.0);\n    self&quot;
 &amp; &quot;.updateTotal(); self.moveTotalLabel();\n\n    self.bar := array_new(sel&quot;
 &amp; &quot;f.maxX, ok);\n    for i = 0 to self.maxX - 1 do\n      self.bar[i] := c&quot;
 &amp; &quot;lone(Bar).new(self.graphvbt, self.labelFont, i)\n    end;\n    zeus_ani&quot;
 &amp; &quot;mate(self.graphvbt, 0.0, 0.0);\n    ok\n  end,\n\n  (* DoFind events --&quot;
 &amp; &quot;------------------------------------------------------ *)\n\n  StartDoF&quot;
 &amp; &quot;ind =&gt; meth(self, id): Ok,\n    ok\n  end,\n\n  StepUp =&gt; meth(self, ch&quot;
 &amp; &quot;ild, parent): Ok,\n    ok\n  end,\n\n  Found =&gt; meth(self, root): Ok,\n&quot;
 &amp; &quot;    ok\n  end,\n\n  StepDown =&gt; meth(self: View, childId, parentId: Int&quot;
 &amp; &quot;): Ok,\n    ok\n  end,\n\n  ChangeParent =&gt; meth(self: View, childId, p&quot;
 &amp; &quot;arentId, rootId: Int): Ok,\n    self.currLen := self.currLen + 1;\n    &quot;
 &amp; &quot;ok\n  end,\n\n  EndDoFind =&gt; meth(self, id): Ok,\n    ok\n  end,\n\n  (&quot;
 &amp; &quot;* Find events ---------------------------------------------------------&quot;
 &amp; &quot;- *)\n\n  StartFind =&gt; meth(self: View, id: Int): Ok,\n    ok\n  end,\n&quot;
 &amp; &quot;\n  EndFind =&gt; meth(self: View, id: Int): Ok,\n    ok\n  end,\n\n  (* U&quot;
 &amp; &quot;nion events --------------------------------------------------------- *&quot;
 &amp; &quot;)\n\n  StartUnion =&gt; meth(self: View, id1, id2: Int, bothRoots: Bool): &quot;
 &amp; &quot;Ok,\n    ok\n  end,\n\n  FoundFirst =&gt; meth(self: View, root1: Int): Ok&quot;
 &amp; &quot;,\n    ok\n  end,\n\n  CompareRanks =&gt; meth(self: View, id1, id2: Int):&quot;
 &amp; &quot; Ok,\n    ok\n  end,\n\n  Unite =&gt; meth(self: View, childId, parentId, &quot;
 &amp; &quot;pRank: Int): Ok,\n    self.currLen := 0;\n    ok\n  end,\n\n  EndUnion &quot;
 &amp; &quot;=&gt; meth(self): Ok,\n    var rescale: Bool = false;\n    if self.currLen&quot;
 &amp; &quot; &gt;= self.maxX then\n      var sz: Int = (self.currLen - self.maxX) + 1;&quot;
 &amp; &quot;\n      var new: [Bar] = array_new(sz, ok);\n      for i = 0 to sz - 1 &quot;
 &amp; &quot;do\n        new[i] := clone(Bar).new(self.graphvbt, self.labelFont, sel&quot;
 &amp; &quot;f.maxX + i)\n      end;\n      self.bar := self.bar @ new;\n      self.&quot;
 &amp; &quot;maxX := self.currLen + 1;\n      self.moveTotalLabel();\n      rescale &quot;
 &amp; &quot;:= true\n    end;\n    if &quot;;

CONST E1_2 =
   &quot;self.bar[self.currLen].barHeight() &gt;= self.maxY then\n      self.maxY :&quot;
 &amp; &quot;= 1.5 * self.maxY;\n      rescale := true\n    end;\n    if rescale the&quot;
 &amp; &quot;n\n      self.setWorld();\n      graph_redisplay(self.graphvbt)\n    en&quot;
 &amp; &quot;d;\n    self.bar[self.currLen].inc();\n    self.total := self.total + s&quot;
 &amp; &quot;elf.currLen + 1;\n    self.count := self.count + 1;\n    self.updateTot&quot;
 &amp; &quot;al();\n    zeus_animate(self.graphvbt, 0.0, 0.0);\n    ok\n  end,\n};\n&quot;
;

CONST E2 =
   &quot;(* Copyright 1993 Digital Equipment Corporation.                       &quot;
 &amp; &quot;      *)\n(* Distributed only by permission.                           &quot;
 &amp; &quot;                *)\n(*                                                 &quot;
 &amp; &quot;                          *)\n(* Last modified on Thu Oct 14 18:45:31 P&quot;
 &amp; &quot;DT 1993 by heydon                   *)\n(*      modified on Tue Aug 10 &quot;
 &amp; &quot;22:14:21 PDT 1993 by rsanchez                 *)\n\n(* View that shows &quot;
 &amp; &quot;each node as a circle whose radius is proportional to the\n   number of&quot;
 &amp; &quot; packets queued up that that node. *)\n\nlet nodeColor = [color_named(\&quot;&quot;
 &amp; &quot;yellow\&quot;), color_named(\&quot;red\&quot;)];\nlet edgeColor = color_named(\&quot;Blue\&quot;&quot;
 &amp; &quot;);\nlet labelColor = color_named(\&quot;Black\&quot;);\nlet borderColor = color_n&quot;
 &amp; &quot;amed(\&quot;Black\&quot;);\nlet backgroundColor = color_named(\&quot;White\&quot;);\n\nlet &quot;
 &amp; &quot;moveEdgeColor = color_named(\&quot;DarkGreen\&quot;);\nlet blockedEdgeColor = col&quot;
 &amp; &quot;or_named(\&quot;Red\&quot;);\n\nlet normal = 0;\nlet congested = 1;\n\nlet edgeWi&quot;
 &amp; &quot;dth = 0.1;\nlet borderWidth = 0.1;\n\nlet angle = proc(p1, p2)\n  var a&quot;
 &amp; &quot;ng = ok;\n  if p1[0] is p2[0] then  \n    if p1[1] &lt; p2[1] then \n     &quot;
 &amp; &quot; ang := 90.0;\n    else\n      ang := 270.0;\n    end;\n  elsif p1[1] i&quot;
 &amp; &quot;s p2[1] then\n    if p1[0] &lt; p2[0] then\n      ang := 0.0;\n    else\n &quot;
 &amp; &quot;     ang := ~180.0;\n    end;\n  else\n    ang := math_atan((p2[1] - p1&quot;
 &amp; &quot;[1])/(p2[0] - p1[0]))/math_degree;\n    if (p2[0] - p1[0]) &lt; 0.0 then\n&quot;
 &amp; &quot;      if (p2[1] - p1[1]) &gt; 0.0 then\n        ang := ang + 180.0;\n     &quot;
 &amp; &quot; else\n        ang := ang - 180.0;\n      end;\n    end;\n  end;\n  ang&quot;
 &amp; &quot;\nend;\n\nlet getStraightEdgeCP = proc(p1,p2,r)\n  var cp = [[ok,ok],[o&quot;
 &amp; &quot;k,ok]];\n  let ang = angle(p1,p2);\n  cp[0][0] := p1[0] + (r * math_cos&quot;
 &amp; &quot;((ang - 90.)*math_degree));\n  cp[0][1] := p1[1] + (r * math_sin((ang -&quot;
 &amp; &quot; 90.)*math_degree));\n  cp[1][0] := p2[0] + (r * math_cos((ang - 90.)*m&quot;
 &amp; &quot;ath_degree));\n  cp[1][1] := p2[1] + (r * math_sin((ang - 90.)*math_deg&quot;
 &amp; &quot;ree));\n  cp\nend;\n\nlet getCurvedEdgeCP = proc(p1,p2,cp1,cp2,r)\n  le&quot;
 &amp; &quot;t avg = proc(a, b)\n    let avgreal = proc(r1, r2) (r1 + r2)/2.0 end;\n&quot;
 &amp; &quot;    [ avgreal(a[0],b[0]), avgreal(a[1], b[1]) ]\n  end;\n  let aux1 = g&quot;
 &amp; &quot;etStraightEdgeCP(p1, c&quot;;

CONST E2_0 =
   &quot;p1, r);\n  let aux2 = getStraightEdgeCP(cp2, p2, r);\n  let aux3 = getS&quot;
 &amp; &quot;traightEdgeCP(cp1, cp2, r);\n  [ aux1[0], avg(aux1[1], aux3[0]), avg(au&quot;
 &amp; &quot;x3[1], aux2[0]), aux2[1] ]\nend;\n\nlet invisibleCP = proc(g, pt)\n  le&quot;
 &amp; &quot;t vtx = graph_newVertex(g);\n  graph_setVertexSize(vtx, 0.0, 0.0);\n  g&quot;
 &amp; &quot;raph_moveVertex(vtx, pt[0], pt[1], false);\n  vtx\nend;      \n\nlet Ha&quot;
 &amp; &quot;shEntry = \n  {\n   key1 =&gt; ok,\n   key2 =&gt; ok,\n   value =&gt; ok,\n   ne&quot;
 &amp; &quot;xt =&gt; ok,\n   };\n\nlet HashTable = \n  {\n    num =&gt; ok,\n    size =&gt; &quot;
 &amp; &quot;ok,\n    table =&gt; ok,\n\n    curindex =&gt; ok,\n    curentry =&gt; ok,\n\n  &quot;
 &amp; &quot;  create =&gt; meth(self, num)\n      self.num := num;\n      self.size :=&quot;
 &amp; &quot; real_round(float(num)*math_log(float(num)));\n      self.table := arra&quot;
 &amp; &quot;y_new(self.size, ok);\n      self;\n    end,\n\n    getfirst =&gt; meth(se&quot;
 &amp; &quot;lf)\n      self.curindex := 0;\n      self.curentry := ok;\n      loop\n&quot;
 &amp; &quot;\tif self.curindex is self.size then\n\t  exit;\n        else\n\t  if s&quot;
 &amp; &quot;elf.table[self.curindex] isnot ok then\n            self.curentry := se&quot;
 &amp; &quot;lf.table[self.curindex];\n\t    exit;\n\t  end;\n\t  self.curindex := s&quot;
 &amp; &quot;elf.curindex + 1;\n        end;\n      end;\n      if self.curentry isn&quot;
 &amp; &quot;ot ok then\n\tself.curentry.value;\n      else\n\tok;\n      end;\n    &quot;
 &amp; &quot;end,\n\n    getnext =&gt; meth(self)\n      if self.curentry isnot ok then&quot;
 &amp; &quot;\n        self.curentry := self.curentry.next;\n        loop\n\t  if se&quot;
 &amp; &quot;lf.curentry isnot ok then\n\t    exit;\n          else\n\t    self.curi&quot;
 &amp; &quot;ndex := self.curindex + 1;\n\t    if self.curindex &lt; self.size then\n\t&quot;
 &amp; &quot;      self.curentry := self.table[self.curindex];\n            else\n\t&quot;
 &amp; &quot;      exit;\n            end;\n          end;\n        end;\n        if&quot;
 &amp; &quot; self.curentry isnot ok then\n\t  self.curentry.value;\n        else\n\t&quot;
 &amp; &quot;  ok;\n        end;\n      else\n\tok;\n      end;\n    end,\n\n    loo&quot;
 &amp; &quot;kup =&gt; meth(self, key1, key2)\n      let index = ((key1 * self.size) + &quot;
 &amp; &quot;key2) % self.num;\n      if self.table[index] isnot ok then\n         v&quot;
 &amp; &quot;ar entry = self.table[index];\n\t loop\n           if (entry is ok) ori&quot;
 &amp; &quot;f\n\t      ((entry.key1 is key1) and (entry.key2 is key2)) then\n\t    &quot;
 &amp; &quot; exit;\n           else\n\t     entry := entry.next;&quot;;

CONST E2_1 =
   &quot;\n           end;\n\t end;\n         if entry isnot ok then\n\t   entry&quot;
 &amp; &quot;.value;\n         else\n\t   ok;\n         end;\n      else\n\tok;\n   &quot;
 &amp; &quot;   end;\n    end,\n\n    insert =&gt; meth(self, key1, key2, value)\n     &quot;
 &amp; &quot; let index = ((key1 * self.size) + key2) % self.num;\n      var newentr&quot;
 &amp; &quot;y = clone(HashEntry);\n      newentry.key1 := key1;\n      newentry.key&quot;
 &amp; &quot;2 := key2;\n      newentry.value := value;\n      newentry.next := ok;\n&quot;
 &amp; &quot;\n      if self.table[index] isnot ok then\n        var entry = self.ta&quot;
 &amp; &quot;ble[index];\n\tloop\n\t  if entry.next is ok then\n            entry.ne&quot;
 &amp; &quot;xt := newentry;\n\t    exit;\n\t  else\n\t    entry := entry.next;\n   &quot;
 &amp; &quot;       end;\n        end;\n      else\n\tself.table[index] := newentry;&quot;
 &amp; &quot;\n      end;\n    end,\n  };\n\nlet StraightEdge =\n  {\n    g =&gt; ok,\n&quot;
 &amp; &quot;    e =&gt; ok,\n    v1 =&gt; ok,\n    v2 =&gt; ok,\n    cEdge12 =&gt; ok,\n    cEd&quot;
 &amp; &quot;ge21 =&gt; ok,\n    tag12 =&gt; false,\n    tag21 =&gt; false,\n    \n    edge =&quot;
 &amp; &quot;&gt; meth(self) self.e end,\n\n    create =&gt; meth (self, t, v1, v2)\n     &quot;
 &amp; &quot; self.g := t.g;\n      self.v1 := v1;\n      self.v2 := v2;\n      self&quot;
 &amp; &quot;.e := graph_newEdge(v1.v, v2.v);\n      graph_moveEdge(self.e, v1.v, v2&quot;
 &amp; &quot;.v, false);\n      graph_setEdgeColor(self.e, edgeColor);\n      self\n&quot;
 &amp; &quot;    end,\n\n    initialWidth =&gt; meth(self, maxSize, size)\n      let ge&quot;
 &amp; &quot;tCondEdge = proc(pt1, pt2)\n        let vp1 = invisibleCP(self.g, pt1);&quot;
 &amp; &quot;\n        let vp2 = invisibleCP(self.g, pt2);\n        let cEdge = grap&quot;
 &amp; &quot;h_newEdge(vp1, vp2);\n        graph_edgeToBack(cEdge);\n        graph_s&quot;
 &amp; &quot;etEdgeColor(cEdge, backgroundColor);\n        graph_setEdgeWidth(cEdge,&quot;
 &amp; &quot; size/1.5);\n        cEdge\n      end;\n      graph_setEdgeWidth(self.e&quot;
 &amp; &quot;dge, size/3.0);\n      let cp12 = getStraightEdgeCP(self.v1.pos, self.v&quot;
 &amp; &quot;2.pos, maxSize/10.0);\n      let cp21 = getStraightEdgeCP(self.v2.pos, &quot;
 &amp; &quot;self.v1.pos, maxSize/10.0);\n      self.cEdge12 := getCondEdge(cp12[0],&quot;
 &amp; &quot; cp12[1]);\n      self.cEdge21 := getCondEdge(cp21[0], cp21[1]); \n    &quot;
 &amp; &quot;end,\n\n    showMoveCondEdge =&gt; meth(self, fromN, toN)\n      if fromN &quot;
 &amp; &quot;is self.v1.id then\n        graph_setEdgeColor(self.cEdge12, moveEdgeCo&quot;
 &amp; &quot;lor);\n        graph_edgeToFro&quot;;

CONST E2_2 =
   &quot;nt(self.cEdge12);\n        self.tag12 := true;\n      else\n        gra&quot;
 &amp; &quot;ph_setEdgeColor(self.cEdge21, moveEdgeColor);\n        graph_edgeToFron&quot;
 &amp; &quot;t(self.cEdge21);\n        self.tag21 := true;\n      end; \n    end,\n\n&quot;
 &amp; &quot;    showBlockedCondEdge =&gt; meth(self, fromN, toN)\n      if fromN is se&quot;
 &amp; &quot;lf.v1.id then\n        graph_setEdgeColor(self.cEdge12, blockedEdgeColo&quot;
 &amp; &quot;r);\n        graph_edgeToFront(self.cEdge12);\n        self.tag12 := tr&quot;
 &amp; &quot;ue;\n      else\n        graph_setEdgeColor(self.cEdge21, blockedEdgeCo&quot;
 &amp; &quot;lor);\n        graph_edgeToFront(self.cEdge21);\n        self.tag21 := &quot;
 &amp; &quot;true; \n      end;\n    end,\n\n    hideCondEdge =&gt; meth(self)\n      i&quot;
 &amp; &quot;f self.tag12 then\n        graph_setEdgeColor(self.cEdge12, backgroundC&quot;
 &amp; &quot;olor);\n        graph_edgeToBack(self.cEdge12);\n        self.tag12 := &quot;
 &amp; &quot;false;\n      end;\n      if self.tag21 then\n        graph_setEdgeColo&quot;
 &amp; &quot;r(self.cEdge21, backgroundColor);\n        graph_edgeToBack(self.cEdge2&quot;
 &amp; &quot;1);\n        self.tag21 := false;\n      end;\n    end,\n\n};\n\n\nlet &quot;
 &amp; &quot;CurvedEdge =\n  {\n    g =&gt; ok,\n    e =&gt; ok,\n    v1 =&gt; ok,\n    v2 =&gt;&quot;
 &amp; &quot; ok,\n    ctls =&gt; ok,\n    cEdge12 =&gt; ok,\n    cEdge21 =&gt; ok,\n    tag1&quot;
 &amp; &quot;2 =&gt; false,\n    tag21 =&gt; false,\n\n    edge =&gt; meth(self) self.e end,\n&quot;
 &amp; &quot;\n    create =&gt; meth (self, t, v1, v2, x1, y1, x2, y2)\n      self.g :=&quot;
 &amp; &quot; t.g;\n      self.v1 := v1;\n      self.v2 := v2;\n      let cpt1 = [x1&quot;
 &amp; &quot;, y1];\n      let cpt2 = [x2, y2];\n      var cpt1v = invisibleCP(self.&quot;
 &amp; &quot;g, cpt1);\n      var cpt2v = invisibleCP(self.g, cpt2);\n      self.ctl&quot;
 &amp; &quot;s := [cpt1, cpt2]; \n      self.e := graph_newEdge(v1.v, v2.v);\n      &quot;
 &amp; &quot;graph_moveEdgeBezier(self.e, v1.v, v2.v, cpt1v, cpt2v, false);\n      g&quot;
 &amp; &quot;raph_setEdgeColor(self.e, edgeColor);\n      graph_setEdgeWidth(self.e,&quot;
 &amp; &quot; edgeWidth);\n      self\n    end,\n\n    initialWidth =&gt; meth(self, ma&quot;
 &amp; &quot;xSize, size)\n      let getCondEdge = proc(pt1, cpt1, cpt2, pt2)\n     &quot;
 &amp; &quot;   let vp1 = invisibleCP(self.g, pt1);\n        let vp2 = invisibleCP(s&quot;
 &amp; &quot;elf.g, pt2);\n        let vcp1 = invisibleCP(self.g, cpt1);\n        le&quot;
 &amp; &quot;t vcp2 = invisibleCP(self.g, cpt2);\n        let cEdge = graph_newEdge(&quot;
 &amp; &quot;vp1, vp2);\n &quot;;

CONST E2_3 =
   &quot;       graph_edgeToBack(cEdge);\n        graph_moveEdgeBezier(cEdge, vp&quot;
 &amp; &quot;1, vp2, vcp1, vcp2, false);\n        graph_setEdgeColor(cEdge, backgrou&quot;
 &amp; &quot;ndColor);\n        graph_setEdgeWidth(cEdge, size/1.5);\n        cEdge &quot;
 &amp; &quot;\n      end;\n      graph_setEdgeWidth(self.edge, size/3.0);\n      let&quot;
 &amp; &quot; cp12 = getCurvedEdgeCP(self.v1.pos, self.v2.pos,\n                    &quot;
 &amp; &quot;             self.ctls[0], self.ctls[1], maxSize/10.0);\n      let cp21&quot;
 &amp; &quot; = getCurvedEdgeCP(self.v2.pos, self.v1.pos,\n                         &quot;
 &amp; &quot;        self.ctls[1], self.ctls[0], maxSize/10.0);\n      self.cEdge12 &quot;
 &amp; &quot;:= getCondEdge(cp12[0], cp12[1], cp12[2], cp12[3]);\n      self.cEdge21&quot;
 &amp; &quot; := getCondEdge(cp21[0], cp21[1], cp21[2], cp21[3]);\n    end,\n\n    s&quot;
 &amp; &quot;howMoveCondEdge =&gt; meth(self, fromN, toN)\n      if fromN is self.v1.id&quot;
 &amp; &quot; then\n        graph_setEdgeColor(self.cEdge12, moveEdgeColor);\n      &quot;
 &amp; &quot;  graph_edgeToFront(self.cEdge12);\n        self.tag12 := true;\n      &quot;
 &amp; &quot;else\n        graph_setEdgeColor(self.cEdge21, moveEdgeColor);\n       &quot;
 &amp; &quot; graph_edgeToFront(self.cEdge21);\n        self.tag21 := true;\n      e&quot;
 &amp; &quot;nd;\n    end,\n\n    showBlockedCondEdge =&gt; meth(self, fromN, toN)\n   &quot;
 &amp; &quot;   if fromN is self.v1.id then\n        graph_setEdgeColor(self.cEdge12&quot;
 &amp; &quot;, blockedEdgeColor);\n        graph_edgeToFront(self.cEdge12);\n       &quot;
 &amp; &quot; self.tag12 := true;\n      else\n        graph_setEdgeColor(self.cEdge&quot;
 &amp; &quot;21, blockedEdgeColor);\n        graph_edgeToFront(self.cEdge21);\n     &quot;
 &amp; &quot;   self.tag21 := true; \n      end;\n    end,\n\n    hideCondEdge =&gt; me&quot;
 &amp; &quot;th(self)\n      if self.tag12 then\n        graph_setEdgeColor(self.cEd&quot;
 &amp; &quot;ge12, backgroundColor);\n        graph_edgeToBack(self.cEdge12);\n     &quot;
 &amp; &quot;   self.tag12 := false;\n      end;\n      if self.tag21 then\n        &quot;
 &amp; &quot;graph_setEdgeColor(self.cEdge21, backgroundColor);\n        graph_edgeT&quot;
 &amp; &quot;oBack(self.cEdge21);\n        self.tag21 := false;\n      end;\n    end&quot;
 &amp; &quot;,\n\n};\n\n\nlet Node =\n  {\n    g =&gt; ok,\n    v =&gt; ok,\n    pos =&gt; ok&quot;
 &amp; &quot;,\n    qs =&gt; 0,\n    id =&gt; ok,\n\n    incQS =&gt; meth(self) self.qs := se&quot;
 &amp; &quot;lf.qs + 1 end,\n\n    create =&gt; meth(self, t, id, x, y)\n      self.g :&quot;
 &amp; &quot;= t.g;\n&quot;;

CONST E2_4 =
   &quot;      self.id := id;\n      self.pos := [x, y];\n      self.v := graph_&quot;
 &amp; &quot;newVertex(self.g);\n      graph_moveVertex(self.v, x, y, false); \n    &quot;
 &amp; &quot;  graph_setVertexShape(self.v, \&quot;ellipse\&quot;);\n      graph_setVertexColo&quot;
 &amp; &quot;r(self.v, nodeColor[normal]); \n      graph_setVertexBorderColor(self.v&quot;
 &amp; &quot;, borderColor);\n      self\n    end,\n\n    initialSize =&gt; meth(self, &quot;
 &amp; &quot;size)\n      graph_setVertexSize(self.v, size, size);\n      graph_setV&quot;
 &amp; &quot;ertexBorder(self.v, size/3.0);\n    end,\n};\n\nlet view =\n{\n  graphv&quot;
 &amp; &quot;bt =&gt; graph_new(),\n  g =&gt; meth (self) self.graphvbt end,\n\n  nodeCnt &quot;
 &amp; &quot;=&gt; ok,\n  maxQS =&gt; ok,\n  bounded =&gt; ok,\n\n  minNodeSize =&gt; 0.0,\n  ma&quot;
 &amp; &quot;xNodeSize =&gt; ok,\n\n  changed =&gt; ok,\t\t(* array of verteces whose size&quot;
 &amp; &quot; has changed *)\n\n  vertexFont =&gt; ok,\n\n  nodeT =&gt; ok,\n  edgeT =&gt; ok&quot;
 &amp; &quot;,\n\n  condEdges =&gt; [],\n\n  node =&gt; meth(self, id)\n    self.nodeT[id]&quot;
 &amp; &quot;;\n  end,\n\n  edge =&gt; meth(self, id1, id2)\n    var res = self.edgeT.l&quot;
 &amp; &quot;ookup(id1, id2);\n    if res is ok then\n      res := self.edgeT.lookup&quot;
 &amp; &quot;(id2, id1);\n    end;\n    res\n  end,\n\n  StartGraph =&gt; meth (self, n&quot;
 &amp; &quot;odeCnt, maxQS, bounded, xMax, yMax)\n    graph_setWorld(self.graphvbt, &quot;
 &amp; &quot;0.0, xMax, yMax, 0.0);\n    self.changed := array_new(nodeCnt, ok);\n  &quot;
 &amp; &quot;  self.vertexFont := graph_newFont(self.graphvbt, \&quot;Helvetica\&quot;,\n     &quot;
 &amp; &quot;                                       0.5, \&quot;Roman\&quot;, \&quot;bold\&quot;, \&quot;*\&quot;)&quot;
 &amp; &quot;;\n    self.nodeCnt := nodeCnt;\n    self.maxQS := maxQS;\n    self.bou&quot;
 &amp; &quot;nded := bounded;\n    self.nodeT := array_new(nodeCnt, ok);\n    self.e&quot;
 &amp; &quot;dgeT := HashTable.create(nodeCnt);\n  end,\n\n  NewNode =&gt; meth (self, &quot;
 &amp; &quot;id, x, y)\n    self.nodeT[id] :=\n        clone(Node).create(self, id, &quot;
 &amp; &quot;x, y);\n  end,\n\n  NewStraightEdge =&gt; meth (self, id1, id2)\n    self.&quot;
 &amp; &quot;edgeT.insert(id1, id2,\n      \t        clone(StraightEdge).create( sel&quot;
 &amp; &quot;f, \n      \t\t\t                    self.node(id1), \n      \t\t\t    &quot;
 &amp; &quot;                self.node(id2)));\n  end,\n\n\n  NewCurvedEdge =&gt; meth &quot;
 &amp; &quot;(self, id1, id2, x1, y1, x2, y2)\n    self.edgeT.insert(id1, id2,\n    &quot;
 &amp; &quot;  \t        clone(CurvedEdge).create( self,\n      \t\t\t\t\t  self.nod&quot;
 &amp; &quot;e(id1),\n      \t\t\t\t\t  self.node(id2),\n      &quot;;

CONST E2_5 =
   &quot;\t\t\t\t\t  x1, y1, x2, y2));\n  end,\n\n  NewLabel =&gt; meth (self, labe&quot;
 &amp; &quot;l, x, y)\n    let vl = graph_newVertex(self.graphvbt);\n    graph_setVe&quot;
 &amp; &quot;rtexFont(vl, self.vertexFont);\n    graph_setVertexSize(vl, 0.5, 0.5);\n&quot;
 &amp; &quot;    graph_setVertexColor(vl, backgroundColor);\n    graph_moveVertex(vl&quot;
 &amp; &quot;, x, y, false);\n    graph_setVertexLabel(vl, label);\n    graph_setVer&quot;
 &amp; &quot;texLabelColor(vl, labelColor);\n  end,\n\n  EndGraph =&gt; meth (self)\n  &quot;
 &amp; &quot;  let distance = proc(pt1, pt2)\n      let dx = pt2[1] - pt1[1], dy = p&quot;
 &amp; &quot;t2[0] - pt1[0];\n      (dx * dx) + (dy * dy)\n    end;\n    var minDst &quot;
 &amp; &quot;= ok;\n    if #(self.nodeT) &gt; 1 then\n      minDst := distance(self.nod&quot;
 &amp; &quot;eT[0].pos, self.nodeT[1].pos);\n      for i = 0 to #(self.nodeT) - 1 do&quot;
 &amp; &quot;\n\tlet pos1 = self.nodeT[i].pos;\n\tfor j = i+1 to #(self.nodeT) - 1 d&quot;
 &amp; &quot;o\n\t  let curDst = distance(pos1, self.nodeT[j].pos);\n\t  if curDst &lt;&quot;
 &amp; &quot; minDst then\n\t    minDst := curDst\n\t  end\n\tend\n      end;\n     &quot;
 &amp; &quot; minDst := math_sqrt(minDst);\n    else\n      minDst := 1.0\n    end;\n&quot;
 &amp; &quot;    self.maxNodeSize := minDst * 0.9;\n    self.minNodeSize := self.max&quot;
 &amp; &quot;NodeSize/6.0; \n    for i = 0 to #(self.nodeT) - 1 do\n      self.nodeT&quot;
 &amp; &quot;[i].initialSize(self.minNodeSize);\n    end;\n    var edge = self.edgeT&quot;
 &amp; &quot;.getfirst();\n    if edge isnot ok then\n      edge.initialWidth(self.m&quot;
 &amp; &quot;axNodeSize, self.minNodeSize);\n      loop\n        edge := self.edgeT.&quot;
 &amp; &quot;getnext();\n        if edge is ok then\n          exit;\n        else\n&quot;
 &amp; &quot;          edge.initialWidth(self.maxNodeSize, self.minNodeSize);\n     &quot;
 &amp; &quot;   end;\n      end;\n    end;\n  end,\n\n  NewPacket =&gt; meth (self, id,&quot;
 &amp; &quot; source, dest, fewestHops, name)\n    self.node(source).incQS();\n  end&quot;
 &amp; &quot;,\n\n  EndPackets =&gt; meth (self)\n    let nsize = proc(qsize)\n      le&quot;
 &amp; &quot;t ns = (float(qsize) * \n              ((self.maxNodeSize - self.minNod&quot;
 &amp; &quot;eSize) /\n                float(self.maxQS))) + self.minNodeSize;\n    &quot;
 &amp; &quot;  ns\n    end;\n    if self.bounded is true then\n      for i = 0 to #(&quot;
 &amp; &quot;self.nodeT) - 1 do\n        if self.nodeT[i].qs  &gt;= self.maxQS then\n  &quot;
 &amp; &quot;        self.nodeT[i].qs := self.maxQS;\n          graph_setVertexColor&quot;
 &amp; &quot;( self.nodeT[i].v, &quot;;

CONST E2_6 =
   &quot;nodeColor[congested]);\n        else\n          graph_setVertexColor( s&quot;
 &amp; &quot;elf.nodeT[i].v, nodeColor[normal]);\n        end;\n        let size = n&quot;
 &amp; &quot;size(self.nodeT[i].qs);\n        graph_setVertexSize(self.nodeT[i].v, s&quot;
 &amp; &quot;ize, size);\n      end;\n    else\n      for i = 0 to #(self.nodeT) - 1&quot;
 &amp; &quot; do\n        graph_setVertexColor( self.nodeT[i].v, nodeColor[normal]);&quot;
 &amp; &quot;\n        let size = nsize(self.nodeT[i].qs);\n        graph_setVertexS&quot;
 &amp; &quot;ize(self.nodeT[i].v, size, size);\n      end;\n    end;\n    graph_redi&quot;
 &amp; &quot;splay(self.graphvbt);\n  end,\n\n  MovePacket =&gt; meth (self, id, fromN,&quot;
 &amp; &quot; toN)\n    self.condEdges := self.condEdges @\n           [self.edge(fr&quot;
 &amp; &quot;omN, toN)];\n    self.edge(fromN, toN).showMoveCondEdge(fromN, toN);\n &quot;
 &amp; &quot; end,\n\n  Blocked =&gt; meth(self, id, fromN, toN)\n    self.condEdges :=&quot;
 &amp; &quot; self.condEdges @\n           [self.edge(fromN, toN)];\n    self.edge(f&quot;
 &amp; &quot;romN, toN).showBlockedCondEdge(fromN, toN);\n  end,\n\n  QueueSizes =&gt; &quot;
 &amp; &quot;meth (self, queueSizes)\n    let nsize = proc(qsize)\n      let factor &quot;
 &amp; &quot;= float(qsize) / float(self.maxQS);\n      let delta = self.maxNodeSize&quot;
 &amp; &quot; - self.minNodeSize;\n      self.minNodeSize + (factor * delta)\n    en&quot;
 &amp; &quot;d;\n    var cnt = 0;\n    graph_redisplay(self.graphvbt);\n    for i = &quot;
 &amp; &quot;0 to #(self.nodeT) - 1 do\n      if self.nodeT[i].qs isnot queueSizes[i&quot;
 &amp; &quot;] then\n        self.nodeT[i].qs := queueSizes[i];\n        self.change&quot;
 &amp; &quot;d[cnt] := i;\n        cnt := cnt + 1\n      end\n    end;\n    if self.&quot;
 &amp; &quot;bounded then\n      for i = 0 to cnt - 1 do\n\tlet node = self.nodeT[se&quot;
 &amp; &quot;lf.changed[i]];\n\tif node.qs isnot self.maxQS then\n\t  graph_setVerte&quot;
 &amp; &quot;xColor(node.v, nodeColor[normal]);\n\tend\n      end\n    end;\n    gra&quot;
 &amp; &quot;ph_redisplay(self.graphvbt);\n    for i = 0 to cnt - 1 do\n      let no&quot;
 &amp; &quot;de = self.nodeT[self.changed[i]];\n      let size = nsize(node.qs);\n  &quot;
 &amp; &quot;    sys_call(\&quot;VertexSizeAnim.Linear\&quot;, [node.v, size, size]);\n    end&quot;
 &amp; &quot;;\n    zeus_animate(self.graphvbt, 0.0, 1.0);\n    if self.bounded then&quot;
 &amp; &quot;\n      for i = 0 to cnt - 1 do\n\tlet node = self.nodeT[self.changed[i&quot;
 &amp; &quot;]];\n\tif node.qs is self.maxQS then\n\t  graph_setVertexColor(node.v, &quot;
 &amp; &quot;nodeColor[con&quot;;

CONST E2_7 =
   &quot;gested]);\n\tend\n      end\n    end;\n    graph_redisplay(self.graphvb&quot;
 &amp; &quot;t);\n  end,\n\n  Absorb =&gt; meth(self, pktID, node)\n    let nsize = pro&quot;
 &amp; &quot;c(qsize)\n      let ns = (float(qsize) * \n              ((self.maxNode&quot;
 &amp; &quot;Size - self.minNodeSize) /\n                float(self.maxQS))) + self.&quot;
 &amp; &quot;minNodeSize;\n      ns\n    end;\n    if (self.nodeT[node].qs is self.m&quot;
 &amp; &quot;axQS) and self.bounded then\n      graph_setVertexColor(self.nodeT[node&quot;
 &amp; &quot;].v,\n      \t\t     nodeColor[normal]);\n    end;\n    self.nodeT[node&quot;
 &amp; &quot;].qs := self.nodeT[node].qs - 1;\n    graph_setVertexSize(self.nodeT[no&quot;
 &amp; &quot;de].v,\n      \t\t  nsize(self.nodeT[node].qs),\n      \t\t  nsize(self&quot;
 &amp; &quot;.nodeT[node].qs));\n  end,\n\n  Step =&gt; meth(self)\n    for i = 0 to #(&quot;
 &amp; &quot;self.condEdges) - 1 do\n      self.condEdges[i].hideCondEdge();\n    en&quot;
 &amp; &quot;d;\n    self.condEdges := [];\n    graph_redisplay(self.graphvbt);\n  e&quot;
 &amp; &quot;nd,\n};\n&quot;;

CONST E3 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:29:09 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Binp&quot;
 &amp; &quot;ack.evt.\n;************************************************************&quot;
 &amp; &quot;********\n\n(VBox\n  (Border (Pen 1)\n    (Shape\n      (Height 75 - 25&quot;
 &amp; &quot; + Inf)\n      (Viewport\n        (HBox\n          (Glue 4 + Inf)\n    &quot;
 &amp; &quot;      (VBox\n            (Glue 6)\n            (Shape (Height 16 + 0)\n&quot;
 &amp; &quot;              (HBox Fill (Shape (Width + 0) (Height + 0) \n            &quot;
 &amp; &quot;                    \&quot;Code View events:   Stop? \&quot;) \n                 &quot;
 &amp; &quot;   (Boolean %stopatCodeEvents =TRUE \&quot;\&quot;)\n                    (Glue 10&quot;
 &amp; &quot;)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n &quot;
 &amp; &quot;                   (Shape (Width 80) (Numeric %waitatCodeEvents =1 \n  &quot;
 &amp; &quot;                                             (Min 0) (Max 100)))))\n   &quot;
 &amp; &quot;         (Glue 6)\n            (Shape (Height 16 + 0)\n              (H&quot;
 &amp; &quot;Box Fill (Shape (Width + 0) (Height + 0) \n                            &quot;
 &amp; &quot;    \&quot;Setup:   Stop? \&quot;) \n                    (Boolean %stopAtSetup =T&quot;
 &amp; &quot;RUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (W&quot;
 &amp; &quot;idth + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width&quot;
 &amp; &quot; 80) (Numeric %waitAtSetup =1 \n                                       &quot;
 &amp; &quot;        (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape&quot;
 &amp; &quot; (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height +&quot;
 &amp; &quot; 0) \n                                \&quot;NewWeight:   Stop? \&quot;) \n      &quot;
 &amp; &quot;              (Boolean %stopAtNewWeight =TRUE \&quot;\&quot;)\n                  &quot;
 &amp; &quot;  (Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weig&quot;
 &amp; &quot;ht: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtNewWeigh&quot;
 &amp; &quot;t =1 \n                                               (Min 0) (Max 100)&quot;
 &amp; &quot;))))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n       &quot;
 &amp; &quot;       &quot;;

CONST E3_0 =
   &quot;(HBox Fill (Shape (Width + 0) (Height + 0) \n                          &quot;
 &amp; &quot;      \&quot;Pack:   Stop? \&quot;) \n                    (Boolean %stopAtPack =T&quot;
 &amp; &quot;RUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (W&quot;
 &amp; &quot;idth + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width&quot;
 &amp; &quot; 80) (Numeric %waitAtPack =1 \n                                        &quot;
 &amp; &quot;       (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape &quot;
 &amp; &quot;(Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + &quot;
 &amp; &quot;0) \n                                \&quot;Ignore:   Stop? \&quot;) \n          &quot;
 &amp; &quot;          (Boolean %stopAtIgnore =TRUE \&quot;\&quot;)\n                    (Glue&quot;
 &amp; &quot; 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)&quot;
 &amp; &quot;\n                    (Shape (Width 80) (Numeric %waitAtIgnore =1 \n   &quot;
 &amp; &quot;                                            (Min 0) (Max 100)))))\n    &quot;
 &amp; &quot;        (Glue 6)\n            (Shape (Height 16 + 0)\n              (HB&quot;
 &amp; &quot;ox Fill (Shape (Width + 0) (Height + 0) \n                             &quot;
 &amp; &quot;   \&quot;Probe:   Stop? \&quot;) \n                    (Boolean %stopAtProbe =TR&quot;
 &amp; &quot;UE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Wi&quot;
 &amp; &quot;dth + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width &quot;
 &amp; &quot;80) (Numeric %waitAtProbe =1 \n                                        &quot;
 &amp; &quot;       (Min 0) (Max 100)))))\n            (Glue 6)\n          )\n      &quot;
 &amp; &quot;    (Glue 4)\n          (VBox\n            (Glue 5)\n            (Shape&quot;
 &amp; &quot; (Width + 0) (Height 16 + 0) \&quot;Cts:\&quot;)\n            (Button %eventCount&quot;
 &amp; &quot;s\n              (VBox\n                (Glue 6)\n                (HBox&quot;
 &amp; &quot; Fill (Shape (Width + 0) (Height 16 + 0) \n                            &quot;
 &amp; &quot;      (Text %ctOfSetup \&quot;0\&quot;)))\n                (Glue 6)\n            &quot;
 &amp; &quot;    (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n                   &quot;
 &amp; &quot;               (Text %ctOfNewWeight \&quot;0\&quot;)))\n                (Glue 6)\n&quot;
 &amp; &quot;                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n       &quot;
 &amp; &quot;                           (Text %ctOfPack \&quot;0\&quot;)))\n                (G&quot;
 &amp; &quot;lue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n&quot;
 &amp; &quot;         &quot;;

CONST E3_1 =
   &quot;                         (Text %ctOfIgnore \&quot;0\&quot;)))\n                (G&quot;
 &amp; &quot;lue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n&quot;
 &amp; &quot;                                  (Text %ctOfProbe \&quot;0\&quot;)))\n          &quot;
 &amp; &quot;      (Glue 3))))\n          Fill\n          (Glue 4 + Inf)\n        )\n&quot;
 &amp; &quot;      )\n    )\n  )\n)\n&quot;;

CONST E4 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:37:06 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Matc&quot;
 &amp; &quot;h.evt.\n;**************************************************************&quot;
 &amp; &quot;******\n\n(VBox\n  (Rim\n    (Pen 2)\n    (HBox\n      (VBox (Glue 4) (&quot;
 &amp; &quot;Shape (Height + Inf) (Button %clear \&quot;CLEAR\&quot;)) (Glue 4))\n      (Glue &quot;
 &amp; &quot;4)\n      (VBox\n        (Boolean =TRUE %alg (Text LeftAlign \&quot;Algorith&quot;
 &amp; &quot;m events\&quot;))\n        (Boolean =FALSE %zeus (Text LeftAlign \&quot;Zeus even&quot;
 &amp; &quot;ts\&quot;))\n        (Boolean =TRUE %args (Text LeftAlign \&quot;Display args to &quot;
 &amp; &quot;events\&quot;)))\n      Fill))\n  (Bar 1)\n  (Shape (ShadowSize 0) (Height 2&quot;
 &amp; &quot;00 + INF) (TextEdit ReadOnly %transcript)))\n&quot;;

CONST E5 =
   &quot;@Insertion\nprocedure insertion;@\n  var v: integer;\n  begin\n  @1 for&quot;
 &amp; &quot; i := 2 to N do@\n    begin\n    @2 v := a[i];@ @3 j := i;@\n    @4 whi&quot;
 &amp; &quot;le a[j-1] &gt; v do@\n      begin @5 a[j] := a[j - 1];@ @6 j := j - 1@ end&quot;
 &amp; &quot;;\n    end;\n    @7 a[j] := v;@\n  end;\n@Insertion\n&quot;;

CONST E6 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:37:06 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file CP.e&quot;
 &amp; &quot;vt.\n;*****************************************************************&quot;
 &amp; &quot;***\n\n(VBox\n  (Rim\n    (Pen 2)\n    (HBox\n      (VBox (Glue 4) (Sha&quot;
 &amp; &quot;pe (Height + Inf) (Button %clear \&quot;CLEAR\&quot;)) (Glue 4))\n      (Glue 4)\n&quot;
 &amp; &quot;      (VBox\n        (Boolean =TRUE %alg (Text LeftAlign \&quot;Algorithm ev&quot;
 &amp; &quot;ents\&quot;))\n        (Boolean =FALSE %zeus (Text LeftAlign \&quot;Zeus events\&quot;&quot;
 &amp; &quot;))\n        (Boolean =TRUE %args (Text LeftAlign \&quot;Display args to even&quot;
 &amp; &quot;ts\&quot;)))\n      Fill))\n  (Bar 1)\n  (Shape (ShadowSize 0) (Height 200 +&quot;
 &amp; &quot; INF) (TextEdit ReadOnly %transcript)))\n&quot;;

CONST E7 =
   &quot;; Copyright (C) 1992, Digital Equipment Corporation\n; All rights reser&quot;
 &amp; &quot;ved.\n; See the file COPYRIGHT for a full description.\n\n(Scale\n  (HS&quot;
 &amp; &quot;cale 1)\n  (VScale 1)\n  (Rim\n    (Pen 10)\n    (HBox\n      (VBox\n  &quot;
 &amp; &quot;      (Text RightAlign \&quot;current flow: \&quot;)\n        (Text RightAlign \&quot;&quot;
 &amp; &quot;capacity: \&quot;))\n      (VBox\n        (Shape (Width 100) (TextEdit ReadO&quot;
 &amp; &quot;nly %tflow))\n        (Shape (Width 100) (TextEdit ReadOnly %tcapacity)&quot;
 &amp; &quot;)))))\n&quot;;

CONST E8 =
   &quot;Program CPAlgorithm(Input, Output);\n\nTYPE \n  Cell =  RECORD\n       &quot;
 &amp; &quot;     p: POINT;\n            next: ^Cell;\n          END;\n  Link = ^Cel&quot;
 &amp; &quot;l;\n\nCONST MaxDistance = 1.0E30;\n\nVAR\n   min   : REAL;\n   h,z    :&quot;
 &amp; &quot; Link;\n   N: INTEGER;\n\n@CheckforMin\nPROCEDURE CheckforMin (p1, p2: &quot;
 &amp; &quot;Point) =@\n  VAR dist: REAL;\n  BEGIN\n@5     IF (dist(p1,p2) &lt; min) TH&quot;
 &amp; &quot;EN @\n@10       updatemin(p1,p2); @\n  END;\n@CheckforMin\n\n\n@FindClo&quot;
 &amp; &quot;sestPair\nPROCEDURE FindClosestPair(VAR c: Link; N: INTEGER): Link =@\n&quot;
 &amp; &quot;  VAR\n    a, b, t1, t2  : Link;\n    middle_xcoord : REAL;\n    p1, p2&quot;
 &amp; &quot;, p3, p4: Point;\n\n  BEGIN\n@5    a := c;@\n@10   b := MiddleofList(c,&quot;
 &amp; &quot;N);@\n@15   middle_xcoord := b^.p.x;@\n\n@20   t1 := FindClosestPair(a,&quot;
 &amp; &quot; N DIV 2);@\n@25   t2 := FindClosestPair(b, N - (N DIV 2));@\n\n@30   c&quot;
 &amp; &quot; := Merge(t1, t2);@\n\n@35   a := c;@\n      REPEAT\n@40     IF ((ABS(a&quot;
 &amp; &quot;^.p.x - middle_xcoord) &lt; min) AND (p1 &lt;&gt; z^.p)) THEN@\n        BEGIN\n@&quot;
 &amp; &quot;45       CheckforMin(a^.p, p1);@\n@50       CheckforMin(a^.p, p2);@\n@5&quot;
 &amp; &quot;5       CheckforMin(a^.p, p3);@\n@60       CheckforMin(a^.p, p4);@\n@65&quot;
 &amp; &quot;       p1 := p2; p2 := p3; p3 := p4; p4 := a^.p;@\n        END { IF };\n&quot;
 &amp; &quot;@70     a := a^.next;@\n@75   UNTIL a = z;@\n\n@80 RETURN c;@\n  END;\n&quot;
 &amp; &quot;@FindClosestPair\n\n\n@Main\nBEGIN {main module: computes closest pair &quot;
 &amp; &quot;in given set of points} @\n\n@5   InitializeListofPoints(h,N);@\n\n@10 &quot;
 &amp; &quot; h := Sort_byXcoordinate(h, N);@\n\n@15  h := FindClosestPair(h, N);@\n&quot;
 &amp; &quot;\nEND.\n@Main\n&quot;;

CONST E9 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:37:06 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Hull&quot;
 &amp; &quot;.evt.\n;***************************************************************&quot;
 &amp; &quot;*****\n\n(VBox\n  (Rim\n    (Pen 2)\n    (HBox\n      (VBox (Glue 4) (S&quot;
 &amp; &quot;hape (Height + Inf) (Button %clear \&quot;CLEAR\&quot;)) (Glue 4))\n      (Glue 4&quot;
 &amp; &quot;)\n      (VBox\n        (Boolean =TRUE %alg (Text LeftAlign \&quot;Algorithm&quot;
 &amp; &quot; events\&quot;))\n        (Boolean =FALSE %zeus (Text LeftAlign \&quot;Zeus event&quot;
 &amp; &quot;s\&quot;))\n        (Boolean =TRUE %args (Text LeftAlign \&quot;Display args to e&quot;
 &amp; &quot;vents\&quot;)))\n      Fill))\n  (Bar 1)\n  (Shape (ShadowSize 0) (Height 20&quot;
 &amp; &quot;0 + INF) (TextEdit ReadOnly %transcript)))\n&quot;;

CONST E10 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:37:06 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file logo&quot;
 &amp; &quot;.evt.\n;***************************************************************&quot;
 &amp; &quot;*****\n\n(VBox\n  (Rim\n    (Pen 2)\n    (HBox\n      (VBox (Glue 4) (S&quot;
 &amp; &quot;hape (Height + Inf) (Button %clear \&quot;CLEAR\&quot;)) (Glue 4))\n      (Glue 4&quot;
 &amp; &quot;)\n      (VBox\n        (Boolean =TRUE %alg (Text LeftAlign \&quot;Algorithm&quot;
 &amp; &quot; events\&quot;))\n        (Boolean =FALSE %zeus (Text LeftAlign \&quot;Zeus event&quot;
 &amp; &quot;s\&quot;))\n        (Boolean =TRUE %args (Text LeftAlign \&quot;Display args to e&quot;
 &amp; &quot;vents\&quot;)))\n      Fill))\n  (Bar 1)\n  (Shape (ShadowSize 0) (Height 20&quot;
 &amp; &quot;0 + INF) (TextEdit ReadOnly %transcript)))\n&quot;;

CONST E11 =
   &quot;@DFS\nPROCEDURE DepthFirstSearch(a: ARRAY OF ARRAY OF BOOLEAN; V: INTEG&quot;
 &amp; &quot;ER) @=\n  VAR now: INTEGER := -1;\n      val := NEW(REF ARRAY OF INTEGE&quot;
 &amp; &quot;R, V);\n\n  BEGIN\n    @6 FOR k := V-1 DO val[k] := -1 END; @\n    @7 F&quot;
 &amp; &quot;OR k := 0 TO V-1 DO @\n    @8   IF val[k] &lt; 0 THEN @\n    @9     Visit(&quot;
 &amp; &quot;k) @\n         END;\n       END;\n  @10 END DepthFirstSearch; @\n@DFS\n&quot;
 &amp; &quot;\n@VISIT\nPROCEDURE Visit(k: INTEGER) @=\n  BEGIN\n@1  INC(now); val[k]&quot;
 &amp; &quot; := now;@\n@2  FOR t := 0 TO V-1 DO @\n@3    IF a[k, t] THEN @\n@4     &quot;
 &amp; &quot; IF val[t] &lt; 0 THEN @\n@5        Visit(t); @\n      END;\n    END;\n  E&quot;
 &amp; &quot;ND;\nEND Visit;\n  @VISIT\n&quot;;

CONST E12 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:37:06 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Hash&quot;
 &amp; &quot;.evt.\n;***************************************************************&quot;
 &amp; &quot;*****\n\n(VBox\n  (Rim\n    (Pen 2)\n    (HBox\n      (VBox (Glue 4) (S&quot;
 &amp; &quot;hape (Height + Inf) (Button %clear \&quot;CLEAR\&quot;)) (Glue 4))\n      (Glue 4&quot;
 &amp; &quot;)\n      (VBox\n        (Boolean =TRUE %alg (Text LeftAlign \&quot;Algorithm&quot;
 &amp; &quot; events\&quot;))\n        (Boolean =FALSE %zeus (Text LeftAlign \&quot;Zeus event&quot;
 &amp; &quot;s\&quot;))\n        (Boolean =TRUE %args (Text LeftAlign \&quot;Display args to e&quot;
 &amp; &quot;vents\&quot;)))\n      Fill))\n  (Bar 1)\n  (Shape (ShadowSize 0) (Height 20&quot;
 &amp; &quot;0 + INF) (TextEdit ReadOnly %transcript)))\n&quot;;

CONST E13 =
   &quot;; Copyright (C) 1992, Digital Equipment Corporation\n; All rights reser&quot;
 &amp; &quot;ved.\n; See the file COPYRIGHT for a full description.\n\n(Rim (Pen 5) &quot;
 &amp; &quot;\n  (Frame Lowered \n    (Shape (Width 100) (Height 30) \n      (TextEd&quot;
 &amp; &quot;it %text (Value \&quot;MENTOR\&quot;)))))\n&quot;;

CONST E14 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:29:09 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Subt&quot;
 &amp; &quot;ype.evt.\n;************************************************************&quot;
 &amp; &quot;********\n\n(VBox\n  (Border (Pen 1)\n    (Shape\n      (Height 75 - 25&quot;
 &amp; &quot; + Inf)\n      (Viewport\n        (HBox\n          (Glue 4 + Inf)\n    &quot;
 &amp; &quot;      (VBox\n            (Glue 6)\n            (Shape (Height 16 + 0)\n&quot;
 &amp; &quot;              (HBox Fill (Shape (Width + 0) (Height + 0) \n            &quot;
 &amp; &quot;                    \&quot;Code View events:   Stop? \&quot;) \n                 &quot;
 &amp; &quot;   (Boolean %stopatCodeEvents =TRUE \&quot;\&quot;)\n                    (Glue 10&quot;
 &amp; &quot;)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n &quot;
 &amp; &quot;                   (Shape (Width 80) (Numeric %waitatCodeEvents =1 \n  &quot;
 &amp; &quot;                                             (Min 0) (Max 100)))))\n   &quot;
 &amp; &quot;         (Glue 6)\n            (Shape (Height 16 + 0)\n              (H&quot;
 &amp; &quot;Box Fill (Shape (Width + 0) (Height + 0) \n                            &quot;
 &amp; &quot;    \&quot;Setup:   Stop? \&quot;) \n                    (Boolean %stopAtSetup =T&quot;
 &amp; &quot;RUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (W&quot;
 &amp; &quot;idth + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width&quot;
 &amp; &quot; 80) (Numeric %waitAtSetup =1 \n                                       &quot;
 &amp; &quot;        (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape&quot;
 &amp; &quot; (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height +&quot;
 &amp; &quot; 0) \n                                \&quot;Begin:   Stop? \&quot;) \n          &quot;
 &amp; &quot;          (Boolean %stopAtBegin =TRUE \&quot;\&quot;)\n                    (Glue &quot;
 &amp; &quot;10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n&quot;
 &amp; &quot;                    (Shape (Width 80) (Numeric %waitAtBegin =1 \n      &quot;
 &amp; &quot;                                         (Min 0) (Max 100)))))\n       &quot;
 &amp; &quot;     (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox &quot;
 &amp; &quot;Fill (&quot;;

CONST E14_0 =
   &quot;Shape (Width + 0) (Height + 0) \n                                \&quot;NewB&quot;
 &amp; &quot;ot:   Stop? \&quot;) \n                    (Boolean %stopAtNewBot =TRUE \&quot;\&quot;&quot;
 &amp; &quot;)\n                    (Glue 10)\n                    (Shape (Width + 0&quot;
 &amp; &quot;) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Nu&quot;
 &amp; &quot;meric %waitAtNewBot =1 \n                                              &quot;
 &amp; &quot; (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape (Heigh&quot;
 &amp; &quot;t 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n &quot;
 &amp; &quot;                               \&quot;NewTop:   Stop? \&quot;) \n                &quot;
 &amp; &quot;    (Boolean %stopAtNewTop =TRUE \&quot;\&quot;)\n                    (Glue 10)\n&quot;
 &amp; &quot;                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n    &quot;
 &amp; &quot;                (Shape (Width 80) (Numeric %waitAtNewTop =1 \n         &quot;
 &amp; &quot;                                      (Min 0) (Max 100)))))\n          &quot;
 &amp; &quot;  (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox Fil&quot;
 &amp; &quot;l (Shape (Width + 0) (Height + 0) \n                                \&quot;N&quot;
 &amp; &quot;ewFun:   Stop? \&quot;) \n                    (Boolean %stopAtNewFun =TRUE \&quot;&quot;
 &amp; &quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Width +&quot;
 &amp; &quot; 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (&quot;
 &amp; &quot;Numeric %waitAtNewFun =1 \n                                            &quot;
 &amp; &quot;   (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape (Hei&quot;
 &amp; &quot;ght 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n&quot;
 &amp; &quot;                                \&quot;NewDomRng:   Stop? \&quot;) \n            &quot;
 &amp; &quot;        (Boolean %stopAtNewDomRng =TRUE \&quot;\&quot;)\n                    (Glu&quot;
 &amp; &quot;e 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;&quot;
 &amp; &quot;)\n                    (Shape (Width 80) (Numeric %waitAtNewDomRng =1 \n&quot;
 &amp; &quot;                                               (Min 0) (Max 100)))))\n &quot;
 &amp; &quot;           (Glue 6)\n            (Shape (Height 16 + 0)\n              &quot;
 &amp; &quot;(HBox Fill (Shape (Width + 0) (Height + 0) \n                          &quot;
 &amp; &quot;      \&quot;NewLoop:   Stop? \&quot;) \n                    (Boolean %stopAtNewL&quot;
 &amp; &quot;oop =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Sh&quot;
 &amp; &quot;ape (W&quot;;

CONST E14_1 =
   &quot;idth + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width&quot;
 &amp; &quot; 80) (Numeric %waitAtNewLoop =1 \n                                     &quot;
 &amp; &quot;          (Min 0) (Max 100)))))\n            (Glue 6)\n            (Sha&quot;
 &amp; &quot;pe (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height&quot;
 &amp; &quot; + 0) \n                                \&quot;Enter:   Stop? \&quot;) \n        &quot;
 &amp; &quot;            (Boolean %stopAtEnter =TRUE \&quot;\&quot;)\n                    (Glu&quot;
 &amp; &quot;e 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;&quot;
 &amp; &quot;)\n                    (Shape (Width 80) (Numeric %waitAtEnter =1 \n   &quot;
 &amp; &quot;                                            (Min 0) (Max 100)))))\n    &quot;
 &amp; &quot;        (Glue 6)\n            (Shape (Height 16 + 0)\n              (HB&quot;
 &amp; &quot;ox Fill (Shape (Width + 0) (Height + 0) \n                             &quot;
 &amp; &quot;   \&quot;Exit:   Stop? \&quot;) \n                    (Boolean %stopAtExit =TRUE&quot;
 &amp; &quot; \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Widt&quot;
 &amp; &quot;h + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80&quot;
 &amp; &quot;) (Numeric %waitAtExit =1 \n                                           &quot;
 &amp; &quot;    (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape (He&quot;
 &amp; &quot;ight 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) &quot;
 &amp; &quot;\n                                \&quot;SeenOK:   Stop? \&quot;) \n             &quot;
 &amp; &quot;       (Boolean %stopAtSeenOK =TRUE \&quot;\&quot;)\n                    (Glue 10&quot;
 &amp; &quot;)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n &quot;
 &amp; &quot;                   (Shape (Width 80) (Numeric %waitAtSeenOK =1 \n      &quot;
 &amp; &quot;                                         (Min 0) (Max 100)))))\n       &quot;
 &amp; &quot;     (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox &quot;
 &amp; &quot;Fill (Shape (Width + 0) (Height + 0) \n                                &quot;
 &amp; &quot;\&quot;Notice:   Stop? \&quot;) \n                    (Boolean %stopAtNotice =TRU&quot;
 &amp; &quot;E \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Wid&quot;
 &amp; &quot;th + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 8&quot;
 &amp; &quot;0) (Numeric %waitAtNotice =1 \n                                        &quot;
 &amp; &quot;       (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape &quot;
 &amp; &quot;(Height&quot;;

CONST E14_2 =
   &quot; 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n  &quot;
 &amp; &quot;                              \&quot;BotLessAnyOK:   Stop? \&quot;) \n           &quot;
 &amp; &quot;         (Boolean %stopAtBotLessAnyOK =TRUE \&quot;\&quot;)\n                    &quot;
 &amp; &quot;(Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight&quot;
 &amp; &quot;: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtBotLessAny&quot;
 &amp; &quot;OK =1 \n                                               (Min 0) (Max 100&quot;
 &amp; &quot;)))))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n      &quot;
 &amp; &quot;        (HBox Fill (Shape (Width + 0) (Height + 0) \n                  &quot;
 &amp; &quot;              \&quot;TopLessTopOK:   Stop? \&quot;) \n                    (Boolea&quot;
 &amp; &quot;n %stopAtTopLessTopOK =TRUE \&quot;\&quot;)\n                    (Glue 10)\n     &quot;
 &amp; &quot;               (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n         &quot;
 &amp; &quot;           (Shape (Width 80) (Numeric %waitAtTopLessTopOK =1 \n        &quot;
 &amp; &quot;                                       (Min 0) (Max 100)))))\n         &quot;
 &amp; &quot;   (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox Fi&quot;
 &amp; &quot;ll (Shape (Width + 0) (Height + 0) \n                                \&quot;&quot;
 &amp; &quot;TopLessNonTopKO:   Stop? \&quot;) \n                    (Boolean %stopAtTopL&quot;
 &amp; &quot;essNonTopKO =TRUE \&quot;\&quot;)\n                    (Glue 10)\n               &quot;
 &amp; &quot;     (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                   &quot;
 &amp; &quot; (Shape (Width 80) (Numeric %waitAtTopLessNonTopKO =1 \n               &quot;
 &amp; &quot;                                (Min 0) (Max 100)))))\n            (Glu&quot;
 &amp; &quot;e 6)\n            (Shape (Height 16 + 0)\n              (HBox Fill (Sha&quot;
 &amp; &quot;pe (Width + 0) (Height + 0) \n                                \&quot;FunLess&quot;
 &amp; &quot;BotKO:   Stop? \&quot;) \n                    (Boolean %stopAtFunLessBotKO =&quot;
 &amp; &quot;TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (&quot;
 &amp; &quot;Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Widt&quot;
 &amp; &quot;h 80) (Numeric %waitAtFunLessBotKO =1 \n                               &quot;
 &amp; &quot;                (Min 0) (Max 100)))))\n            (Glue 6)\n          &quot;
 &amp; &quot;  (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (&quot;
 &amp; &quot;Height + 0) \n                                \&quot;FunLessTopOK:   Stop? \&quot;&quot;
 &amp; &quot;) \n &quot;;

CONST E14_3 =
   &quot;                   (Boolean %stopAtFunLessTopOK =TRUE \&quot;\&quot;)\n          &quot;
 &amp; &quot;          (Glue 10)\n                    (Shape (Width + 0) (Height + 0&quot;
 &amp; &quot;) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAt&quot;
 &amp; &quot;FunLessTopOK =1 \n                                               (Min 0&quot;
 &amp; &quot;) (Max 100)))))\n            (Glue 6)\n            (Shape (Height 16 + &quot;
 &amp; &quot;0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n        &quot;
 &amp; &quot;                        \&quot;FunLessFun:   Stop? \&quot;) \n                   &quot;
 &amp; &quot; (Boolean %stopAtFunLessFun =TRUE \&quot;\&quot;)\n                    (Glue 10)\n&quot;
 &amp; &quot;                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n    &quot;
 &amp; &quot;                (Shape (Width 80) (Numeric %waitAtFunLessFun =1 \n     &quot;
 &amp; &quot;                                          (Min 0) (Max 100)))))\n      &quot;
 &amp; &quot;      (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox&quot;
 &amp; &quot; Fill (Shape (Width + 0) (Height + 0) \n                               &quot;
 &amp; &quot; \&quot;OK:   Stop? \&quot;) \n                    (Boolean %stopAtOK =TRUE \&quot;\&quot;)&quot;
 &amp; &quot;\n                    (Glue 10)\n                    (Shape (Width + 0)&quot;
 &amp; &quot; (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Num&quot;
 &amp; &quot;eric %waitAtOK =1 \n                                               (Min&quot;
 &amp; &quot; 0) (Max 100)))))\n            (Glue 6)\n            (Shape (Height 16 &quot;
 &amp; &quot;+ 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n      &quot;
 &amp; &quot;                          \&quot;KO:   Stop? \&quot;) \n                    (Bool&quot;
 &amp; &quot;ean %stopAtKO =TRUE \&quot;\&quot;)\n                    (Glue 10)\n             &quot;
 &amp; &quot;       (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                 &quot;
 &amp; &quot;   (Shape (Width 80) (Numeric %waitAtKO =1 \n                          &quot;
 &amp; &quot;                     (Min 0) (Max 100)))))\n            (Glue 6)\n     &quot;
 &amp; &quot;     )\n          (Glue 4)\n          (VBox\n            (Glue 5)\n    &quot;
 &amp; &quot;        (Shape (Width + 0) (Height 16 + 0) \&quot;Cts:\&quot;)\n            (Butt&quot;
 &amp; &quot;on %eventCounts\n              (VBox\n                (Glue 6)\n       &quot;
 &amp; &quot;         (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n              &quot;
 &amp; &quot;                    (Text %ctOfSetup \&quot;0\&quot;)))\n                (Glue 6)&quot;
 &amp; &quot;\n        &quot;;

CONST E14_4 =
   &quot;        (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n               &quot;
 &amp; &quot;                   (Text %ctOfBegin \&quot;0\&quot;)))\n                (Glue 6)\n&quot;
 &amp; &quot;                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n       &quot;
 &amp; &quot;                           (Text %ctOfNewBot \&quot;0\&quot;)))\n                &quot;
 &amp; &quot;(Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0)&quot;
 &amp; &quot; \n                                  (Text %ctOfNewTop \&quot;0\&quot;)))\n      &quot;
 &amp; &quot;          (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Heig&quot;
 &amp; &quot;ht 16 + 0) \n                                  (Text %ctOfNewFun \&quot;0\&quot;)&quot;
 &amp; &quot;))\n                (Glue 6)\n                (HBox Fill (Shape (Width &quot;
 &amp; &quot;+ 0) (Height 16 + 0) \n                                  (Text %ctOfNew&quot;
 &amp; &quot;DomRng \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (&quot;
 &amp; &quot;Shape (Width + 0) (Height 16 + 0) \n                                  (&quot;
 &amp; &quot;Text %ctOfNewLoop \&quot;0\&quot;)))\n                (Glue 6)\n                (&quot;
 &amp; &quot;HBox Fill (Shape (Width + 0) (Height 16 + 0) \n                        &quot;
 &amp; &quot;          (Text %ctOfEnter \&quot;0\&quot;)))\n                (Glue 6)\n        &quot;
 &amp; &quot;        (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n               &quot;
 &amp; &quot;                   (Text %ctOfExit \&quot;0\&quot;)))\n                (Glue 6)\n&quot;
 &amp; &quot;                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n       &quot;
 &amp; &quot;                           (Text %ctOfSeenOK \&quot;0\&quot;)))\n                &quot;
 &amp; &quot;(Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0)&quot;
 &amp; &quot; \n                                  (Text %ctOfNotice \&quot;0\&quot;)))\n      &quot;
 &amp; &quot;          (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Heig&quot;
 &amp; &quot;ht 16 + 0) \n                                  (Text %ctOfBotLessAnyOK &quot;
 &amp; &quot;\&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Shape (&quot;
 &amp; &quot;Width + 0) (Height 16 + 0) \n                                  (Text %c&quot;
 &amp; &quot;tOfTopLessTopOK \&quot;0\&quot;)))\n                (Glue 6)\n                (HB&quot;
 &amp; &quot;ox Fill (Shape (Width + 0) (Height 16 + 0) \n                          &quot;
 &amp; &quot;        (Text %ctOfTopLessNonTopKO \&quot;0\&quot;)))\n                (Glue 6)\n&quot;
 &amp; &quot;                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n       &quot;
 &amp; &quot;      &quot;;

CONST E14_5 =
   &quot;                     (Text %ctOfFunLessBotKO \&quot;0\&quot;)))\n                &quot;
 &amp; &quot;(Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0)&quot;
 &amp; &quot; \n                                  (Text %ctOfFunLessTopOK \&quot;0\&quot;)))\n&quot;
 &amp; &quot;                (Glue 6)\n                (HBox Fill (Shape (Width + 0)&quot;
 &amp; &quot; (Height 16 + 0) \n                                  (Text %ctOfFunLess&quot;
 &amp; &quot;Fun \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Sha&quot;
 &amp; &quot;pe (Width + 0) (Height 16 + 0) \n                                  (Tex&quot;
 &amp; &quot;t %ctOfOK \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fil&quot;
 &amp; &quot;l (Shape (Width + 0) (Height 16 + 0) \n                                &quot;
 &amp; &quot;  (Text %ctOfKO \&quot;0\&quot;)))\n                (Glue 3))))\n          Fill\n&quot;
 &amp; &quot;          (Glue 4 + Inf)\n        )\n      )\n    )\n  )\n)\n&quot;;

CONST E15 =
   &quot;; Copyright (C) 1994, Digital Equipment Corporation\n; All rights reser&quot;
 &amp; &quot;ved.\n; See the file COPYRIGHT for a full description.\n\n(Filter\n  (M&quot;
 &amp; &quot;acro Label BOA (text) `(Shape (Width 120) (Text RightAlign ,text)))\n  &quot;
 &amp; &quot;(Macro Line BOA (label expr) `(HBox (Label ,label) ,expr Fill))\n  (TSp&quot;
 &amp; &quot;lit\n    =0\n    %opts\n    (Text %ch0 \n      (BgColor \&quot;VeryLightGree&quot;
 &amp; &quot;n\&quot;) \&quot;Press GO or STEP to start algorithm...\&quot;)\n    (Filter\n      %c&quot;
 &amp; &quot;h1\n      (BgColor \&quot;VeryLightBlue\&quot;)\n      (HBox\n        (Button %go&quot;
 &amp; &quot;tMaxes \&quot;  OK  \&quot;)\n        (VBox\n          (Line \&quot;Number of bins: \&quot;&quot;
 &amp; &quot; (Numeric (Min 1) (Max 1000) %B =26))\n          (Glue 10)\n          (&quot;
 &amp; &quot;Line \&quot;Number of weights: \&quot; (Numeric (Min 1) (Max 1000) %N =10)))))\n &quot;
 &amp; &quot;   (Filter\n      %ch2\n      (BgColor \&quot;VeryLightRed\&quot;)\n      (VBox\n&quot;
 &amp; &quot;        Fill\n        (VBox\n          (Text LeftAlign \&quot;New weight [0.&quot;
 &amp; &quot;0 .. 1.0]:\&quot;)\n          (Frame Lowered (TypeIn %new)))\n        Fill))&quot;
 &amp; &quot;))\n&quot;;

CONST E16 =
   &quot;; Copyright (C) 1992, Digital Equipment Corporation\n; All rights reser&quot;
 &amp; &quot;ved.\n; See the file COPYRIGHT for a full description.\n\n(Rim\n  (Pen &quot;
 &amp; &quot;10)\n  (VBox\n    (LabelFont (Family \&quot;helvetica\&quot;) (WeightName \&quot;bold\&quot;&quot;
 &amp; &quot;) (PointSize 240))\n    (Font \&quot;-adobe-helvetica-bold-r-normal--34-240-&quot;
 &amp; &quot;*-*-p-182-iso8859-1\&quot;)\n      (HBox\n        (Text LeftAlign \&quot;Ops:  \&quot;&quot;
 &amp; &quot;)\n        (Shape (Width 100) (Numeric %Operations)))\n    (Glue 10)\n &quot;
 &amp; &quot;   (HBox\n      (Text LeftAlign \&quot;Run time:  \&quot;)\n      (Shape (Width 1&quot;
 &amp; &quot;00) (Numeric %Runtime)))))&quot;;

CONST E17 =
   &quot;(* Copyright 1993 Digital Equipment Corporation.                       &quot;
 &amp; &quot;      *)\n(* Distributed only by permission.                           &quot;
 &amp; &quot;                *)\n(*                                                 &quot;
 &amp; &quot;                          *)\n(* Last modified on Thu Oct 14 17:07:36 P&quot;
 &amp; &quot;DT 1993 by heydon                   *)\n(*      modified on Tue Jul 27 &quot;
 &amp; &quot;16:25:00 PDT 1993 by rsanchez                 *)\n\n(* This view shows &quot;
 &amp; &quot;the total number of hops that each packet needs to traverse\n   to go f&quot;
 &amp; &quot;rom its source to its destination node. *) \n\nlet BackGroundColor = co&quot;
 &amp; &quot;lor_named(\&quot;White\&quot;);\nlet MinHopsColor = color_named(\&quot;Pink\&quot;);\nlet C&quot;
 &amp; &quot;urrHopsColor = color_named(\&quot;Yellow\&quot;);\nlet LabelColor = color_named(\&quot;&quot;
 &amp; &quot;Black\&quot;);\nlet CapColor = LabelColor;\nlet BorderColor = LabelColor;\n\n&quot;
 &amp; &quot;let BarWidth = 0.40;\nlet CapFactor = 0.025;\nlet Gap = 0.05;\nlet Sout&quot;
 &amp; &quot;hInit = ~3.0;\nlet BorderSize = 0.05;\nlet ScaleFactor = 1.5;\n\nlet XV&quot;
 &amp; &quot;alR = proc(i) float(i) + (Gap+BarWidth)/2.0 end;\nlet XValL = proc(i) f&quot;
 &amp; &quot;loat(i) - (Gap+BarWidth)/2.0 end;\n\nlet FontFromSize =\n  proc(g, sz)\n&quot;
 &amp; &quot;    graph_newFont(g, \&quot;Helvetica\&quot;, sz, \&quot;Roman\&quot;, \&quot;bold\&quot;, \&quot;*\&quot;)\n  &quot;
 &amp; &quot;end;\n\nlet MoveTextVertex =\n  proc(vtx, font, x, y, height)\n    grap&quot;
 &amp; &quot;h_setVertexFont(vtx, font);\n    graph_moveVertex(vtx, x, y, false);\n &quot;
 &amp; &quot;   graph_setVertexSize(vtx, 1.0, height);\n  end;\n\nlet MakeTextVertex&quot;
 &amp; &quot; =\n  proc(vtx, font, x, y, height)\n    graph_setVertexColor(vtx, Back&quot;
 &amp; &quot;GroundColor);\n    graph_setVertexLabelColor(vtx, LabelColor);\n    Mov&quot;
 &amp; &quot;eTextVertex(vtx, font, x, y, height)\n  end;\n\nlet MoveBarVertex =\n  &quot;
 &amp; &quot;proc(vtx, width, height, x)\n    graph_setVertexSize(vtx, width, height&quot;
 &amp; &quot;);\n    graph_moveVertex(vtx, x, height/2.0, false);\n  end;\n    \nlet&quot;
 &amp; &quot; MakeBarVertex =\n  proc(vtx, clr, width, height, x)\n    graph_setVert&quot;
 &amp; &quot;exBorder(vtx, BorderSize);\n    graph_setVertexBorderColor(vtx, BorderC&quot;
 &amp; &quot;olor); \n    graph_setVertexColor(vtx, clr);\n    MoveBarVertex(vtx, wi&quot;
 &amp; &quot;dth, height, x)\n  end;\n\nlet MoveCapVertex =\n  proc(vtx, (*int*) x, &quot;
 &amp; &quot;(*int*) y, (*real*) height)\n    graph_setVertexSize(vtx, BarWidth, hei&quot;
 &amp; &quot;ght);\n    graph&quot;;

CONST E17_0 =
   &quot;_moveVertex(vtx, XValR(x), float(y)+(height/2.0), false);\n  end;\n\nle&quot;
 &amp; &quot;t MakeCapVertex =\n  proc(vw, (*int*) x, (*int*) y, (*real*) height)\n &quot;
 &amp; &quot;   let vtx = graph_newVertex(vw.graphvbt);\n    graph_setVertexBorder(v&quot;
 &amp; &quot;tx, BorderSize);\n    graph_setVertexBorderColor(vtx, BorderColor);\n  &quot;
 &amp; &quot;  graph_setVertexColor(vtx, CapColor);\n    MoveCapVertex(vtx, x, y, he&quot;
 &amp; &quot;ight);\n    vtx\n  end;\n\nlet view =\n  {\n    graphvbt =&gt; graph_new()&quot;
 &amp; &quot;,\n    pktCnt =&gt; ok,\t(* total number of packets (from \&quot;StartPackets\&quot;&quot;
 &amp; &quot;) *)\n    maxHops =&gt; 0.0,\t(* current max number of hops (related to \&quot;&quot;
 &amp; &quot;north\&quot; *)\n    hopsT =&gt; ok,\t(* array of packets *)\n    caps =&gt; ok,\t&quot;
 &amp; &quot;\t(* array of caps *)\n    capCnt =&gt; 0,\t(* number of caps *)\n    resc&quot;
 &amp; &quot;ale =&gt; false,\t(* should world coordinates be scaled vertically? *)\n  &quot;
 &amp; &quot;  fontSz =&gt; 0.5,\t(* label font size *)\n    vtxFont =&gt; ok,\t(* font us&quot;
 &amp; &quot;ed to display two rows of labels *)\n    labH =&gt; 1.0,\t(* vertical size&quot;
 &amp; &quot; of label vertex *)\n    yLab1 =&gt; ~1.0,\t(* \&quot;y\&quot; coordinate of first r&quot;
 &amp; &quot;ow of labels *)\n    yLab2 =&gt; ~2.0,\t(* \&quot;y\&quot; coordinate of second row &quot;
 &amp; &quot;of labels *)\n    (* world coordinates *)\n    west =&gt; ~1.0,\t(* readon&quot;
 &amp; &quot;ly *)\n    south =&gt; SouthInit,\n    east =&gt; ok,\t\t(* depends on pktCnt&quot;
 &amp; &quot; *)\n    north =&gt; meth(self) self.maxHops+self.capH + (self.south/South&quot;
 &amp; &quot;Init) end,\n    capH =&gt;  meth(self) CapFactor * self.maxHops end,\n\n  &quot;
 &amp; &quot;  StartGraph =&gt; meth (self, nodeCnt, maxQS, bounded, xMax, yMax)\n     &quot;
 &amp; &quot; (* initialize graph window to be over empty space *)\n      graph_setW&quot;
 &amp; &quot;orld(self.graphvbt, ~10.0, ~9.0, 1.0, 0.0)\n    end,\n\n    StartPacket&quot;
 &amp; &quot;s =&gt; meth (self, pktCnt)\n      self.pktCnt := pktCnt;\n      self.east&quot;
 &amp; &quot; := float(pktCnt);\n      self.vtxFont := FontFromSize(self.graphvbt, s&quot;
 &amp; &quot;elf.fontSz);\n\n      self.hopsT := array_new(pktCnt, ok);\n      self.&quot;
 &amp; &quot;caps := array_new(pktCnt, ok);\n      for i = 0 to pktCnt-1 do\n       &quot;
 &amp; &quot; let vtx1 = graph_newVertex(self.graphvbt);\n\tMakeBarVertex(vtx1, Curr&quot;
 &amp; &quot;HopsColor, BarWidth, BorderSize, XValR(i));\n\n\tlet vtx2 = graph_newVe&quot;
 &amp; &quot;rtex(self.graphvbt);\n\tMakeTextVertex(vtx2, self.vtxFont, float(i), se&quot;
 &amp; &quot;lf.yLab1, self.lab&quot;;

CONST E17_1 =
   &quot;H);\n\n\tlet vtx3 = graph_newVertex(self.graphvbt);\n\tMakeTextVertex(v&quot;
 &amp; &quot;tx3, self.vtxFont, float(i), self.yLab2, self.labH);\n\tgraph_setVertex&quot;
 &amp; &quot;Label(vtx3, \&quot;0%\&quot;);\n\n\tself.hopsT[i] := {\n\t  minNumHops =&gt; ok,\t(*&quot;
 &amp; &quot; length of shortest path for this packet *)\n\t  curNumHops =&gt; 0,\t(* n&quot;
 &amp; &quot;umber of times this packet has moved *)\n\t  vmin =&gt; vtx1,\t\t(* vertex&quot;
 &amp; &quot; that grows each time packet moves *)\n\t  vlab1 =&gt; vtx2,\t(* packet na&quot;
 &amp; &quot;me label *)\n\t  vlab2 =&gt; vtx3,\t(* percentage label *)\n\t}\n      end&quot;
 &amp; &quot;\n    end,\n\n    NewPacket =&gt; meth (self, id, source, dest, fewestHops&quot;
 &amp; &quot;, name)\n      let pkt = self.hopsT[id];\n      pkt.minNumHops := fewes&quot;
 &amp; &quot;tHops;\n      if float(fewestHops) &gt; self.maxHops then\n        self.ma&quot;
 &amp; &quot;xHops := float(fewestHops)\n      end;\n      graph_setVertexLabel(pkt.&quot;
 &amp; &quot;vlab1, name);\n      let vtx = graph_newVertex(self.graphvbt);\n      M&quot;
 &amp; &quot;akeBarVertex(vtx, MinHopsColor, BarWidth, float(fewestHops), XValL(id))&quot;
 &amp; &quot;\n    end,\n\n    EndPackets =&gt; meth (self)\n      graph_setWorld(self.&quot;
 &amp; &quot;graphvbt,\n\tself.west, self.east, self.north, self.south);\n      grap&quot;
 &amp; &quot;h_redisplay(self.graphvbt)\n    end,\n\n    MovePacket =&gt; meth(self, id&quot;
 &amp; &quot;, fromN, toN) \n      let Percent = proc(pkt)\n        let num = 100.0 &quot;
 &amp; &quot;* float(pkt.curNumHops);\n        let denom = float(pkt.minNumHops);\n\t&quot;
 &amp; &quot;fmt_int(round(num / denom)) &amp; \&quot;%\&quot;\n      end;\n\n      let pkt = self&quot;
 &amp; &quot;.hopsT[id];\n      pkt.curNumHops := pkt.curNumHops + 1;\n      MoveBar&quot;
 &amp; &quot;Vertex(pkt.vmin, BarWidth, float(pkt.curNumHops), XValR(id));\n      gr&quot;
 &amp; &quot;aph_setVertexLabel(pkt.vlab2, Percent(pkt));\n      if float(pkt.curNum&quot;
 &amp; &quot;Hops) &gt; self.maxHops then\n\tself.rescale := true;\n      end\n    end,&quot;
 &amp; &quot;\n\n    Absorb =&gt; meth(self, id, (*unused*) dest)\n      let v = MakeCa&quot;
 &amp; &quot;pVertex(self, id, self.hopsT[id].curNumHops, self.capH());\n      self.&quot;
 &amp; &quot;caps[self.capCnt] := { vtx =&gt; v, id =&gt; id };\n      self.capCnt := self&quot;
 &amp; &quot;.capCnt + 1\n    end,\n\n    Step =&gt; meth (self)\n      if self.rescale&quot;
 &amp; &quot; then\n\tself.rescale := false;\n\tself.maxHops := self.maxHops * Scale&quot;
 &amp; &quot;Factor;\n\tself.south   := self.south   * ScaleFactor;\n\tself.fontSz  &quot;
 &amp; &quot;:= self.fontSz  * ScaleFact&quot;;

CONST E17_2 =
   &quot;or;\n\tself.labH    := self.labH    * ScaleFactor;\n\tself.yLab1   := s&quot;
 &amp; &quot;elf.yLab1   * ScaleFactor;\n\tself.yLab2   := self.yLab2   * ScaleFacto&quot;
 &amp; &quot;r;\n\n        (* reposition labels and caps *)\n        self.vtxFont :=&quot;
 &amp; &quot; FontFromSize(self.graphvbt, self.fontSz);\n        for i = 0 to self.p&quot;
 &amp; &quot;ktCnt-1 do\n          let pkt = self.hopsT[i];\n\t  MoveTextVertex(pkt.&quot;
 &amp; &quot;vlab1, self.vtxFont,\n            float(i), self.yLab1, self.labH);\n\t&quot;
 &amp; &quot;  MoveTextVertex(pkt.vlab2, self.vtxFont,\n            float(i), self.y&quot;
 &amp; &quot;Lab2, self.labH)\n        end;\n        for i = 0 to self.capCnt - 1 do&quot;
 &amp; &quot;\n\t  let obj = self.caps[i];\n          let id = obj.id;\n          le&quot;
 &amp; &quot;t y = self.hopsT[id].curNumHops;\n          MoveCapVertex(obj.vtx, id, &quot;
 &amp; &quot;y, self.capH())\n        end;\n\n        (* double height of world coor&quot;
 &amp; &quot;dinates *)\n        graph_setWorld(self.graphvbt, \n\t  self.west, self&quot;
 &amp; &quot;.east, self.north, self.south);\n      end;\n\n      graph_redisplay(se&quot;
 &amp; &quot;lf.graphvbt)\n    end\n  };\n&quot;;

CONST E18 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:29:09 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Sear&quot;
 &amp; &quot;chTree.evt.\n;*********************************************************&quot;
 &amp; &quot;***********\n\n(VBox\n  (Border (Pen 1)\n    (Shape\n      (Height 75 -&quot;
 &amp; &quot; 25 + Inf)\n      (Viewport\n        (HBox\n          (Glue 4 + Inf)\n &quot;
 &amp; &quot;         (VBox\n            (Glue 6)\n            (Shape (Height 16 + 0&quot;
 &amp; &quot;)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n         &quot;
 &amp; &quot;                       \&quot;Code View events:   Stop? \&quot;) \n              &quot;
 &amp; &quot;      (Boolean %stopatCodeEvents =TRUE \&quot;\&quot;)\n                    (Glue&quot;
 &amp; &quot; 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)&quot;
 &amp; &quot;\n                    (Shape (Width 80) (Numeric %waitatCodeEvents =1 \n&quot;
 &amp; &quot;                                               (Min 0) (Max 100)))))\n &quot;
 &amp; &quot;           (Glue 6)\n            (Shape (Height 16 + 0)\n              &quot;
 &amp; &quot;(HBox Fill (Shape (Width + 0) (Height + 0) \n                          &quot;
 &amp; &quot;      \&quot;NewNode:   Stop? \&quot;) \n                    (Boolean %stopAtNewN&quot;
 &amp; &quot;ode =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Sh&quot;
 &amp; &quot;ape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape &quot;
 &amp; &quot;(Width 80) (Numeric %waitAtNewNode =1 \n                               &quot;
 &amp; &quot;                (Min 0) (Max 100)))))\n            (Glue 6)\n          &quot;
 &amp; &quot;  (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (&quot;
 &amp; &quot;Height + 0) \n                                \&quot;CompareKeys:   Stop? \&quot;&quot;
 &amp; &quot;) \n                    (Boolean %stopAtCompareKeys =TRUE \&quot;\&quot;)\n      &quot;
 &amp; &quot;              (Glue 10)\n                    (Shape (Width + 0) (Height&quot;
 &amp; &quot; + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric %wa&quot;
 &amp; &quot;itAtCompareKeys =1 \n                                               (Mi&quot;
 &amp; &quot;n 0) (Max 100)))))\n            (Glue 6)\n            (Shape (Height 16&quot;
 &amp; &quot; + 0)&quot;;

CONST E18_0 =
   &quot;\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n          &quot;
 &amp; &quot;                      \&quot;AddLeaf:   Stop? \&quot;) \n                    (Boo&quot;
 &amp; &quot;lean %stopAtAddLeaf =TRUE \&quot;\&quot;)\n                    (Glue 10)\n       &quot;
 &amp; &quot;             (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n           &quot;
 &amp; &quot;         (Shape (Width 80) (Numeric %waitAtAddLeaf =1 \n               &quot;
 &amp; &quot;                                (Min 0) (Max 100)))))\n            (Glu&quot;
 &amp; &quot;e 6)\n            (Shape (Height 16 + 0)\n              (HBox Fill (Sha&quot;
 &amp; &quot;pe (Width + 0) (Height + 0) \n                                \&quot;NewSear&quot;
 &amp; &quot;chKey:   Stop? \&quot;) \n                    (Boolean %stopAtNewSearchKey =&quot;
 &amp; &quot;TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (&quot;
 &amp; &quot;Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Widt&quot;
 &amp; &quot;h 80) (Numeric %waitAtNewSearchKey =1 \n                               &quot;
 &amp; &quot;                (Min 0) (Max 100)))))\n            (Glue 6)\n          &quot;
 &amp; &quot;  (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (&quot;
 &amp; &quot;Height + 0) \n                                \&quot;SearchEnd:   Stop? \&quot;) &quot;
 &amp; &quot;\n                    (Boolean %stopAtSearchEnd =TRUE \&quot;\&quot;)\n          &quot;
 &amp; &quot;          (Glue 10)\n                    (Shape (Width + 0) (Height + 0&quot;
 &amp; &quot;) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAt&quot;
 &amp; &quot;SearchEnd =1 \n                                               (Min 0) (&quot;
 &amp; &quot;Max 100)))))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n&quot;
 &amp; &quot;              (HBox Fill (Shape (Width + 0) (Height + 0) \n            &quot;
 &amp; &quot;                    \&quot;GoLeft:   Stop? \&quot;) \n                    (Boolea&quot;
 &amp; &quot;n %stopAtGoLeft =TRUE \&quot;\&quot;)\n                    (Glue 10)\n           &quot;
 &amp; &quot;         (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n               &quot;
 &amp; &quot;     (Shape (Width 80) (Numeric %waitAtGoLeft =1 \n                    &quot;
 &amp; &quot;                           (Min 0) (Max 100)))))\n            (Glue 6)\n&quot;
 &amp; &quot;            (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Wi&quot;
 &amp; &quot;dth + 0) (Height + 0) \n                                \&quot;SpliceOut:   &quot;
 &amp; &quot;Stop? \&quot;) \n                    (Boolean %stopAtSpliceOut =TRUE \&quot;\&quot;)\n&quot;
 &amp; &quot;       &quot;;

CONST E18_1 =
   &quot;             (Glue 10)\n                    (Shape (Width + 0) (Height &quot;
 &amp; &quot;+ 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric %wai&quot;
 &amp; &quot;tAtSpliceOut =1 \n                                               (Min 0&quot;
 &amp; &quot;) (Max 100)))))\n            (Glue 6)\n            (Shape (Height 16 + &quot;
 &amp; &quot;0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n        &quot;
 &amp; &quot;                        \&quot;Copy:   Stop? \&quot;) \n                    (Bool&quot;
 &amp; &quot;ean %stopAtCopy =TRUE \&quot;\&quot;)\n                    (Glue 10)\n           &quot;
 &amp; &quot;         (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n               &quot;
 &amp; &quot;     (Shape (Width 80) (Numeric %waitAtCopy =1 \n                      &quot;
 &amp; &quot;                         (Min 0) (Max 100)))))\n            (Glue 6)\n &quot;
 &amp; &quot;           (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Wid&quot;
 &amp; &quot;th + 0) (Height + 0) \n                                \&quot;CurrentNode:  &quot;
 &amp; &quot; Stop? \&quot;) \n                    (Boolean %stopAtCurrentNode =TRUE \&quot;\&quot;&quot;
 &amp; &quot;)\n                    (Glue 10)\n                    (Shape (Width + 0&quot;
 &amp; &quot;) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Nu&quot;
 &amp; &quot;meric %waitAtCurrentNode =1 \n                                         &quot;
 &amp; &quot;      (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape (&quot;
 &amp; &quot;Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0&quot;
 &amp; &quot;) \n                                \&quot;SetType:   Stop? \&quot;) \n          &quot;
 &amp; &quot;          (Boolean %stopAtSetType =TRUE \&quot;\&quot;)\n                    (Glu&quot;
 &amp; &quot;e 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;&quot;
 &amp; &quot;)\n                    (Shape (Width 80) (Numeric %waitAtSetType =1 \n &quot;
 &amp; &quot;                                              (Min 0) (Max 100)))))\n  &quot;
 &amp; &quot;          (Glue 6)\n            (Shape (Height 16 + 0)\n              (&quot;
 &amp; &quot;HBox Fill (Shape (Width + 0) (Height + 0) \n                           &quot;
 &amp; &quot;     \&quot;RedRedClash:   Stop? \&quot;) \n                    (Boolean %stopAtR&quot;
 &amp; &quot;edRedClash =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                &quot;
 &amp; &quot;    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    &quot;
 &amp; &quot;(Shape (Width 80) (Numeric %waitAtRedRedClash =1 \n                    &quot;
 &amp; &quot;      &quot;;

CONST E18_2 =
   &quot;                     (Min 0) (Max 100)))))\n            (Glue 6)\n     &quot;
 &amp; &quot;       (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width +&quot;
 &amp; &quot; 0) (Height + 0) \n                                \&quot;CheckUncle:   Stop&quot;
 &amp; &quot;? \&quot;) \n                    (Boolean %stopAtCheckUncle =TRUE \&quot;\&quot;)\n   &quot;
 &amp; &quot;                 (Glue 10)\n                    (Shape (Width + 0) (Hei&quot;
 &amp; &quot;ght + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric &quot;
 &amp; &quot;%waitAtCheckUncle =1 \n                                               (&quot;
 &amp; &quot;Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape (Height &quot;
 &amp; &quot;16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n   &quot;
 &amp; &quot;                             \&quot;Rotate:   Stop? \&quot;) \n                  &quot;
 &amp; &quot;  (Boolean %stopAtRotate =TRUE \&quot;\&quot;)\n                    (Glue 10)\n  &quot;
 &amp; &quot;                  (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n      &quot;
 &amp; &quot;              (Shape (Width 80) (Numeric %waitAtRotate =1 \n           &quot;
 &amp; &quot;                                    (Min 0) (Max 100)))))\n            &quot;
 &amp; &quot;(Glue 6)\n          )\n          (Glue 4)\n          (VBox\n           &quot;
 &amp; &quot; (Glue 5)\n            (Shape (Width + 0) (Height 16 + 0) \&quot;Cts:\&quot;)\n  &quot;
 &amp; &quot;          (Button %eventCounts\n              (VBox\n                (G&quot;
 &amp; &quot;lue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n&quot;
 &amp; &quot;                                  (Text %ctOfNewNode \&quot;0\&quot;)))\n        &quot;
 &amp; &quot;        (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height&quot;
 &amp; &quot; 16 + 0) \n                                  (Text %ctOfCompareKeys \&quot;0&quot;
 &amp; &quot;\&quot;)))\n                (Glue 6)\n                (HBox Fill (Shape (Wid&quot;
 &amp; &quot;th + 0) (Height 16 + 0) \n                                  (Text %ctOf&quot;
 &amp; &quot;AddLeaf \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill &quot;
 &amp; &quot;(Shape (Width + 0) (Height 16 + 0) \n                                  &quot;
 &amp; &quot;(Text %ctOfNewSearchKey \&quot;0\&quot;)))\n                (Glue 6)\n           &quot;
 &amp; &quot;     (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n                  &quot;
 &amp; &quot;                (Text %ctOfSearchEnd \&quot;0\&quot;)))\n                (Glue 6)&quot;
 &amp; &quot;\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n     &quot;
 &amp; &quot;        &quot;;

CONST E18_3 =
   &quot;                     (Text %ctOfGoLeft \&quot;0\&quot;)))\n                (Glue &quot;
 &amp; &quot;6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n   &quot;
 &amp; &quot;                               (Text %ctOfSpliceOut \&quot;0\&quot;)))\n         &quot;
 &amp; &quot;       (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height &quot;
 &amp; &quot;16 + 0) \n                                  (Text %ctOfCopy \&quot;0\&quot;)))\n &quot;
 &amp; &quot;               (Glue 6)\n                (HBox Fill (Shape (Width + 0) &quot;
 &amp; &quot;(Height 16 + 0) \n                                  (Text %ctOfCurrentN&quot;
 &amp; &quot;ode \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Sha&quot;
 &amp; &quot;pe (Width + 0) (Height 16 + 0) \n                                  (Tex&quot;
 &amp; &quot;t %ctOfSetType \&quot;0\&quot;)))\n                (Glue 6)\n                (HBo&quot;
 &amp; &quot;x Fill (Shape (Width + 0) (Height 16 + 0) \n                           &quot;
 &amp; &quot;       (Text %ctOfRedRedClash \&quot;0\&quot;)))\n                (Glue 6)\n     &quot;
 &amp; &quot;           (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n            &quot;
 &amp; &quot;                      (Text %ctOfCheckUncle \&quot;0\&quot;)))\n                (&quot;
 &amp; &quot;Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) &quot;
 &amp; &quot;\n                                  (Text %ctOfRotate \&quot;0\&quot;)))\n       &quot;
 &amp; &quot;         (Glue 3))))\n          Fill\n          (Glue 4 + Inf)\n       &quot;
 &amp; &quot; )\n      )\n    )\n  )\n)\n&quot;;

CONST E19 =
   &quot;#| Copyright 1993 Digital Equipment Corporation. |#\n#| Distributed onl&quot;
 &amp; &quot;y by permission. |#\n#| Last modified on Tue Sep 21 14:51:34 PDT 1993 b&quot;
 &amp; &quot;y hania |#\n#|      modified on Wed Jul 14 23:01:32 PDT 1993 by mhb |#\n&quot;
 &amp; &quot;\n(Rim (Pen 5) (Shape (Width + 300)\n  (VBox\n    (HBox \n    (Menu \&quot;C&quot;
 &amp; &quot;anned Examples\&quot;\n      (VBox \n        (MButton %ex1 \&quot;Example 1\&quot;) \n&quot;
 &amp; &quot;        (MButton %ex2 \&quot;Example 2\&quot;)\n        (MButton %ex3 \&quot;Example 3&quot;
 &amp; &quot;\&quot;) \n        (MButton %ex4 \&quot;Example 4\&quot;)\n        (MButton %ex5 \&quot;Exa&quot;
 &amp; &quot;mple 5\&quot;) \n        (MButton %ex6 \&quot;Example 6\&quot;)\n        (MButton %ex7&quot;
 &amp; &quot; \&quot;Example 7\&quot;) \n        (MButton %ex8 \&quot;Example 8\&quot;)\n        (MButto&quot;
 &amp; &quot;n %ex9 \&quot;Example 9\&quot;) \n        (MButton %ex10 \&quot;Example 10\&quot;)\n       &quot;
 &amp; &quot; ))\n    (Glue 10)\n    (Menu \&quot;Canned Non-Examples\&quot;\n      (VBox \n  &quot;
 &amp; &quot;      (MButton %nonex1 \&quot;Example 1\&quot;) \n        (MButton %nonex2 \&quot;Exam&quot;
 &amp; &quot;ple 2\&quot;)\n        (MButton %nonex3 \&quot;Example 3\&quot;) \n        (MButton %n&quot;
 &amp; &quot;onex4 \&quot;Example 4\&quot;)\n        (MButton %nonex5 \&quot;Example 5\&quot;) \n       &quot;
 &amp; &quot; (MButton %nonex6 \&quot;Example 6\&quot;)\n        (MButton %nonex7 \&quot;Example 7\&quot;&quot;
 &amp; &quot;) \n        (MButton %nonex8 \&quot;Example 8\&quot;)\n        (MButton %nonex9 \&quot;&quot;
 &amp; &quot;Example 9\&quot;) \n        (MButton %nonex10 \&quot;Example 10\&quot;)\n        )) Fi&quot;
 &amp; &quot;ll )\n  (Glue 10)\n  (HBox \n    (Text \&quot;Left type:   \&quot;) \n    (Border&quot;
 &amp; &quot; (Rim (TypeIn %typeleft))))\n  (Glue 10)\n  (HBox \n    (Text \&quot;Right t&quot;
 &amp; &quot;ype: \&quot;) \n    (Border (Rim (TypeIn %typeright)))))))\n\n\n&quot;;

CONST E20 =
   &quot;(* Copyright (C) 1994, Digital Equipment Corporation         *)\n(* All&quot;
 &amp; &quot; rights reserved.                                      *)\n(* See the f&quot;
 &amp; &quot;ile COPYRIGHT for a full description.            *)\n\n@RedBlackTest\nP&quot;
 &amp; &quot;ROCEDURE RedBlackTest(insKey, delKey: ARRAY OF Key)@\n  VAR t: Tree; n:&quot;
 &amp; &quot; Node; BEGIN\n    @1 t.root := NIL@;\n    @2 FOR i := FIRST(insKey^) TO&quot;
 &amp; &quot; LAST(insKey^) DO@\n      @3 n := NEW(Node, key := insKey[i])@;\n      &quot;
 &amp; &quot;@4 RedBlackInsert(t, n)@\n    END\n\n    (* Delete \&quot;delKey\&quot; keys *)\n&quot;
 &amp; &quot;    @5 FOR i := FIRST(delKey^) TO LAST(delKey^) DO@\n      @6 n := Sear&quot;
 &amp; &quot;ch(alg, delKey[i])@;\n      @7 RedBlackDelete(alg, n)@\n    END;\n  END&quot;
 &amp; &quot; RedBlackTest;\n@RedBlackTest\n\n@Insert\nPROCEDURE Insert(t: Tree; n: &quot;
 &amp; &quot;Node)@ =\n  VAR temp, curr: Node; BEGIN\n    @3 temp := t.root;@\n    @&quot;
 &amp; &quot;4 curr := NIL;@\n    @5 WHILE temp # NIL DO@\n      @6 curr := temp;@\n&quot;
 &amp; &quot;      @7 IF n.key &lt; curr.key@\n        THEN @8 temp := curr.left@\n    &quot;
 &amp; &quot;    ELSE @9 temp := curr.right@\n      END\n    END;\n    @10 n.parent &quot;
 &amp; &quot;:= curr;@\n    @11 IF curr = NIL@ THEN @12 t.root := n@ ELSE\n      @13&quot;
 &amp; &quot; IF n.key &lt; curr.key@\n        THEN @14 curr.left := n@\n        ELSE @&quot;
 &amp; &quot;15 curr.right := n@\n      END\n    END\n  END Insert;\n@Insert\n\n@Red&quot;
 &amp; &quot;BlackInsert\nPROCEDURE RedBlackInsert(t: Tree; n: Node)@ =\n  VAR side,&quot;
 &amp; &quot; other: Side; BEGIN\n    @1 Insert(t, n)@;\n    @2 n.type := NodeType.R&quot;
 &amp; &quot;ed@;\n    @3 WHILE n.parent # NIL AND n.parent.type = NodeType.Red@ DO\n&quot;
 &amp; &quot;      &lt;* ASSERT n.parent.parent # NIL *&gt;\n      @4 IF n.parent = n.pare&quot;
 &amp; &quot;nt.parent.left@\n        THEN @5 side := BSTAlg.Side.Left@;\n        EL&quot;
 &amp; &quot;SE @6 side := BSTAlg.Side.Right;@\n      END;\n      @7 other := BSTAlg&quot;
 &amp; &quot;.OtherSide[side]@;\n      @8 y := GetChild(n.parent.parent, other)@;\n &quot;
 &amp; &quot;     @9 IF y # NIL AND y.type = NodeType.Red@ THEN\n        (* Case 1 *&quot;
 &amp; &quot;)\n        @10 n.parent.type := NodeType.Black@;\n        @11 y.type :=&quot;
 &amp; &quot; NodeType.Black@;\n        @12 n.parent.parent.type := NodeType.Red@;\n&quot;
 &amp; &quot;        @13 n := n.parent.parent@\n      ELSE\n        @14 IF n = BSTAl&quot;
 &amp; &quot;g.GetChild(n.parent, other)@ THEN\n          (* Case 2 *)\n          @1&quot;
 &amp; &quot;5 n := &quot;;

CONST E20_0 =
   &quot;n.parent@;\n          @16 BSTAlg.Rotate(tree, n, side)@\n        END;\n&quot;
 &amp; &quot;        (* Case 3 *)\n        @17 n.parent.type := NodeType.Black@;\n  &quot;
 &amp; &quot;      @18 n.parent.parent.type := NodeType.Red@;\n        @19 Rotate(tr&quot;
 &amp; &quot;ee, n.parent.parent, other)@\n      END;\n    END;\n    &lt;* ASSERT tree.&quot;
 &amp; &quot;root # NIL *&gt;\n    @20 IF tree.root.type # NodeType.Black THEN\n      @&quot;
 &amp; &quot;21 tree.root.type := NodeType.Black@\n    END\n  END RedBlackInsert;\n@&quot;
 &amp; &quot;RedBlackInsert\n\n@Search\nPROCEDURE Search(t: Tree; k: Key): Node@ =\n&quot;
 &amp; &quot;  VAR n: Node; BEGIN\n    @1 n := t.root@;\n    @2 WHILE n # t.nil AND &quot;
 &amp; &quot;n.key # key DO@\n      @3 IF key &lt; n.key@\n        THEN @4 n := n.left@&quot;
 &amp; &quot;\n        ELSE @5 n := n.right@\n      END\n    END;\n    @6 RETURN n@\n&quot;
 &amp; &quot;  END Search;\n@Search\n\n@RedBlackDelete\nPROCEDURE RedBlackDelete(t: &quot;
 &amp; &quot;Tree; n: Node)@ =\n  VAR splice, splice_ch: Node; BEGIN\n    (* Set \&quot;s&quot;
 &amp; &quot;plice\&quot; to the node to splice out *)\n    @1 IF n.left = t.nil OR n.rig&quot;
 &amp; &quot;ht = t.nil@\n      THEN @2 splice := n@\n      ELSE @3 splice := FindMi&quot;
 &amp; &quot;n(n.right)@\n    END;\n\n    (* Splice out \&quot;splice\&quot; node *)\n    @4 s&quot;
 &amp; &quot;plice_ch := SpliceOut(t, splice)@;\n\n    (* Replace \&quot;n\&quot; by \&quot;splice\&quot;&quot;
 &amp; &quot; if necessary *)\n    @5 IF splice # n@ THEN\n      @6 n.key := splice.&quot;
 &amp; &quot;key@\n      (* &lt;&lt; copy other node fields here &gt;&gt; *)\n    END\n\n    (* &quot;
 &amp; &quot;Fix up tree if there is potential for double-black *)\n    @7 IF splice&quot;
 &amp; &quot;.type = NodeType.Black@ THEN\n      @8 RedBlackFixUp(t, splice_ch)@\n  &quot;
 &amp; &quot;END RedBlackDelete;\n@RedBlackDelete\n\n@FindMin\nPROCEDURE FindMin(n: &quot;
 &amp; &quot;Node): Node@ =\n  BEGIN\n    @1 WHILE n.left # NIL DO@\n      @2 n := n&quot;
 &amp; &quot;.left2@\n    END;\n    @3 RETURN n@\n  END FindMin;\n@FindMin\n\n@Splic&quot;
 &amp; &quot;eOut\nPROCEDURE SpliceOut(t: Tree; n: Node)@ =\n  VAR ch: Node; BEGIN\n&quot;
 &amp; &quot;    (* Set \&quot;ch\&quot; to child of \&quot;n\&quot; or NIL *)\n    @1 IF n.left # NIL@\n&quot;
 &amp; &quot;      THEN @2 ch := n.left@\n      ELSE @3 ch := n.right@\n    END;\n\n&quot;
 &amp; &quot;    (* Update \&quot;up\&quot; pointer *)\n    @4 IF ch # NIL@ THEN\n      @5 ch.&quot;
 &amp; &quot;parent := n.parent@\n    END;\n\n    (* Update \&quot;down\&quot; pointers *)\n  &quot;
 &amp; &quot;  @6 IF n.parent = NIL@ THEN\n      @7 t.root := ch@\n    ELSE\n      @&quot;
 &amp; &quot;8 IF n = n.parent.left@\n        THEN&quot;;

CONST E20_1 =
   &quot; @9 n.parent.left := ch@\n        ELSE @10 n.parent.right := ch@\n     &quot;
 &amp; &quot; END\n    END;\n    @11 RETURN ch@\n  END SpliceOut;\n@SpliceOut\n\n@Re&quot;
 &amp; &quot;dBlackFixUp\nPROCEDURE RedBlackFixUp(t: Tree; n: Node)@ =\n  VAR siblin&quot;
 &amp; &quot;g: Node; side, other: Side BEGIN\n    @1 WHILE n # t.root AND n.type = &quot;
 &amp; &quot;NodeType.Black DO@\n      @2 IF n = n.parent.left@\n        THEN @3 sid&quot;
 &amp; &quot;e := Side.Left;  other := side.Right@;\n        ELSE @4 side := Side.Ri&quot;
 &amp; &quot;ght; other := side.Left@;\n      END;\n      @5 sibling := GetChild(n.p&quot;
 &amp; &quot;arent, other)@;\n      @6 IF sibling.type = NodeType.Red@ THEN\n       &quot;
 &amp; &quot; (* Case 1 *)\n        @7 sibling.type := NodeType.Black@;\n        @8 &quot;
 &amp; &quot;n.parent.type := NodeType.Red@;\n        @9 Rotate(t, n.parent, side)@;&quot;
 &amp; &quot;\n        @10 sibling := GetChild(n.parent, other)@\n      END;\n      &quot;
 &amp; &quot;@11 IF sibling.left.type = NodeType.Black\n         AND sibling.right.t&quot;
 &amp; &quot;ype = NodeType.Black@ THEN\n        (* Case 2 *)\n        @12 sibling.t&quot;
 &amp; &quot;ype := NodeType.Red@;\n        @13 n := n.parent@\n      ELSE\n        &quot;
 &amp; &quot;@14 IF GetChild(sibling, other).type = NodeType.Black@ THEN\n          &quot;
 &amp; &quot;@15 GetChild(sibling, side).type := NodeType.Black@;\n          @16 sib&quot;
 &amp; &quot;ling.type := NodeType.Red@;\n          @17 Rotate(t, sibling, other)@;\n&quot;
 &amp; &quot;          @18 sibling := GetChild(n.parent, other)@\n        END;\n    &quot;
 &amp; &quot;    (* Case 4 *)\n        @19 sibling.type := n.parent.type@;\n        &quot;
 &amp; &quot;@20 n.parent.type := NodeType.Black@;\n        @21 GetChild(sibling, ot&quot;
 &amp; &quot;her).type := NodeType.Black@;\n        @22 Rotate(t, n.parent, side)@;\n&quot;
 &amp; &quot;        @23 n := t.root@\n      END\n    END;\n    @24 IF n.type # Node&quot;
 &amp; &quot;Type.Black@ THEN\n      @25 n.type := NodeType.Black@\n    END\n  END R&quot;
 &amp; &quot;edBlackFixUp\n@RedBlackFixUp\n&quot;;

CONST E21 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:29:09 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Pars&quot;
 &amp; &quot;e.evt.\n;**************************************************************&quot;
 &amp; &quot;******\n\n(VBox\n  (Border (Pen 1)\n    (Shape\n      (Height 75 - 25 +&quot;
 &amp; &quot; Inf)\n      (Viewport\n        (HBox\n          (Glue 4 + Inf)\n      &quot;
 &amp; &quot;    (VBox\n            (Glue 6)\n            (Shape (Height 16 + 0)\n  &quot;
 &amp; &quot;            (HBox Fill (Shape (Width + 0) (Height + 0) \n              &quot;
 &amp; &quot;                  \&quot;Code View events:   Stop? \&quot;) \n                   &quot;
 &amp; &quot; (Boolean %stopatCodeEvents =TRUE \&quot;\&quot;)\n                    (Glue 10)\n&quot;
 &amp; &quot;                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n    &quot;
 &amp; &quot;                (Shape (Width 80) (Numeric %waitatCodeEvents =1 \n     &quot;
 &amp; &quot;                                          (Min 0) (Max 100)))))\n      &quot;
 &amp; &quot;      (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox&quot;
 &amp; &quot; Fill (Shape (Width + 0) (Height + 0) \n                               &quot;
 &amp; &quot; \&quot;Setup:   Stop? \&quot;) \n                    (Boolean %stopAtSetup =TRUE&quot;
 &amp; &quot; \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Widt&quot;
 &amp; &quot;h + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80&quot;
 &amp; &quot;) (Numeric %waitAtSetup =1 \n                                          &quot;
 &amp; &quot;     (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape (H&quot;
 &amp; &quot;eight 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0)&quot;
 &amp; &quot; \n                                \&quot;Push:   Stop? \&quot;) \n              &quot;
 &amp; &quot;      (Boolean %stopAtPush =TRUE \&quot;\&quot;)\n                    (Glue 10)\n&quot;
 &amp; &quot;                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n    &quot;
 &amp; &quot;                (Shape (Width 80) (Numeric %waitAtPush =1 \n           &quot;
 &amp; &quot;                                    (Min 0) (Max 100)))))\n            &quot;
 &amp; &quot;(Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox Fill &quot;
 &amp; &quot;(Shape&quot;;

CONST E21_0 =
   &quot; (Width + 0) (Height + 0) \n                                \&quot;Pop:   St&quot;
 &amp; &quot;op? \&quot;) \n                    (Boolean %stopAtPop =TRUE \&quot;\&quot;)\n        &quot;
 &amp; &quot;            (Glue 10)\n                    (Shape (Width + 0) (Height +&quot;
 &amp; &quot; 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric %wait&quot;
 &amp; &quot;AtPop =1 \n                                               (Min 0) (Max &quot;
 &amp; &quot;100)))))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n   &quot;
 &amp; &quot;           (HBox Fill (Shape (Width + 0) (Height + 0) \n               &quot;
 &amp; &quot;                 \&quot;Scan:   Stop? \&quot;) \n                    (Boolean %st&quot;
 &amp; &quot;opAtScan =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                  &quot;
 &amp; &quot;  (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (S&quot;
 &amp; &quot;hape (Width 80) (Numeric %waitAtScan =1 \n                             &quot;
 &amp; &quot;                  (Min 0) (Max 100)))))\n            (Glue 6)\n        &quot;
 &amp; &quot;    (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0)&quot;
 &amp; &quot; (Height + 0) \n                                \&quot;NoteError:   Stop? \&quot;&quot;
 &amp; &quot;) \n                    (Boolean %stopAtNoteError =TRUE \&quot;\&quot;)\n        &quot;
 &amp; &quot;            (Glue 10)\n                    (Shape (Width + 0) (Height +&quot;
 &amp; &quot; 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric %wait&quot;
 &amp; &quot;AtNoteError =1 \n                                               (Min 0)&quot;
 &amp; &quot; (Max 100)))))\n            (Glue 6)\n            (Shape (Height 16 + 0&quot;
 &amp; &quot;)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n         &quot;
 &amp; &quot;                       \&quot;Goto:   Stop? \&quot;) \n                    (Boole&quot;
 &amp; &quot;an %stopAtGoto =TRUE \&quot;\&quot;)\n                    (Glue 10)\n            &quot;
 &amp; &quot;        (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                &quot;
 &amp; &quot;    (Shape (Width 80) (Numeric %waitAtGoto =1 \n                       &quot;
 &amp; &quot;                        (Min 0) (Max 100)))))\n            (Glue 6)\n  &quot;
 &amp; &quot;          (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Widt&quot;
 &amp; &quot;h + 0) (Height + 0) \n                                \&quot;NewNode:   Stop&quot;
 &amp; &quot;? \&quot;) \n                    (Boolean %stopAtNewNode =TRUE \&quot;\&quot;)\n      &quot;
 &amp; &quot;              (Glue 10)\n                    (Shape (Width + 0) (Height&quot;
 &amp; &quot; + 0) \&quot;We&quot;;

CONST E21_1 =
   &quot;ight: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtNewNod&quot;
 &amp; &quot;e =1 \n                                               (Min 0) (Max 100)&quot;
 &amp; &quot;))))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n       &quot;
 &amp; &quot;       (HBox Fill (Shape (Width + 0) (Height + 0) \n                   &quot;
 &amp; &quot;             \&quot;NewTerm:   Stop? \&quot;) \n                    (Boolean %sto&quot;
 &amp; &quot;pAtNewTerm =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                &quot;
 &amp; &quot;    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    &quot;
 &amp; &quot;(Shape (Width 80) (Numeric %waitAtNewTerm =1 \n                        &quot;
 &amp; &quot;                       (Min 0) (Max 100)))))\n            (Glue 6)\n   &quot;
 &amp; &quot;         (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width&quot;
 &amp; &quot; + 0) (Height + 0) \n                                \&quot;NewEdge:   Stop?&quot;
 &amp; &quot; \&quot;) \n                    (Boolean %stopAtNewEdge =TRUE \&quot;\&quot;)\n       &quot;
 &amp; &quot;             (Glue 10)\n                    (Shape (Width + 0) (Height &quot;
 &amp; &quot;+ 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric %wai&quot;
 &amp; &quot;tAtNewEdge =1 \n                                               (Min 0) &quot;
 &amp; &quot;(Max 100)))))\n            (Glue 6)\n            (Shape (Height 16 + 0)&quot;
 &amp; &quot;\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n          &quot;
 &amp; &quot;                      \&quot;DeleteLeaf:   Stop? \&quot;) \n                    (&quot;
 &amp; &quot;Boolean %stopAtDeleteLeaf =TRUE \&quot;\&quot;)\n                    (Glue 10)\n &quot;
 &amp; &quot;                   (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n     &quot;
 &amp; &quot;               (Shape (Width 80) (Numeric %waitAtDeleteLeaf =1 \n      &quot;
 &amp; &quot;                                         (Min 0) (Max 100)))))\n       &quot;
 &amp; &quot;     (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox &quot;
 &amp; &quot;Fill (Shape (Width + 0) (Height + 0) \n                                &quot;
 &amp; &quot;\&quot;UpdateDone:   Stop? \&quot;) \n                    (Boolean %stopAtUpdateD&quot;
 &amp; &quot;one =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Sh&quot;
 &amp; &quot;ape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape &quot;
 &amp; &quot;(Width 80) (Numeric %waitAtUpdateDone =1 \n                            &quot;
 &amp; &quot;                   (Min 0) (Max 100)))))\n            (Glue 6)\n       &quot;
 &amp; &quot;   )\n &quot;;

CONST E21_2 =
   &quot;         (Glue 4)\n          (VBox\n            (Glue 5)\n            (&quot;
 &amp; &quot;Shape (Width + 0) (Height 16 + 0) \&quot;Cts:\&quot;)\n            (Button %event&quot;
 &amp; &quot;Counts\n              (VBox\n                (Glue 6)\n                &quot;
 &amp; &quot;(HBox Fill (Shape (Width + 0) (Height 16 + 0) \n                       &quot;
 &amp; &quot;           (Text %ctOfSetup \&quot;0\&quot;)))\n                (Glue 6)\n       &quot;
 &amp; &quot;         (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n              &quot;
 &amp; &quot;                    (Text %ctOfPush \&quot;0\&quot;)))\n                (Glue 6)\n&quot;
 &amp; &quot;                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n       &quot;
 &amp; &quot;                           (Text %ctOfPop \&quot;0\&quot;)))\n                (Gl&quot;
 &amp; &quot;ue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n&quot;
 &amp; &quot;                                  (Text %ctOfScan \&quot;0\&quot;)))\n           &quot;
 &amp; &quot;     (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16&quot;
 &amp; &quot; + 0) \n                                  (Text %ctOfNoteError \&quot;0\&quot;)))&quot;
 &amp; &quot;\n                (Glue 6)\n                (HBox Fill (Shape (Width + &quot;
 &amp; &quot;0) (Height 16 + 0) \n                                  (Text %ctOfGoto &quot;
 &amp; &quot;\&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Shape (&quot;
 &amp; &quot;Width + 0) (Height 16 + 0) \n                                  (Text %c&quot;
 &amp; &quot;tOfNewNode \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fi&quot;
 &amp; &quot;ll (Shape (Width + 0) (Height 16 + 0) \n                               &quot;
 &amp; &quot;   (Text %ctOfNewTerm \&quot;0\&quot;)))\n                (Glue 6)\n             &quot;
 &amp; &quot;   (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n                    &quot;
 &amp; &quot;              (Text %ctOfNewEdge \&quot;0\&quot;)))\n                (Glue 6)\n  &quot;
 &amp; &quot;              (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n         &quot;
 &amp; &quot;                         (Text %ctOfDeleteLeaf \&quot;0\&quot;)))\n              &quot;
 &amp; &quot;  (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + &quot;
 &amp; &quot;0) \n                                  (Text %ctOfUpdateDone \&quot;0\&quot;)))\n&quot;
 &amp; &quot;                (Glue 3))))\n          Fill\n          (Glue 4 + Inf)\n&quot;
 &amp; &quot;        )\n      )\n    )\n  )\n)\n&quot;;

CONST E22 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:29:09 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Unio&quot;
 &amp; &quot;nFind.evt.\n;**********************************************************&quot;
 &amp; &quot;**********\n\n(VBox\n  (Border (Pen 1)\n    (Shape\n      (Height 75 - &quot;
 &amp; &quot;25 + Inf)\n      (Viewport\n        (HBox\n          (Glue 4 + Inf)\n  &quot;
 &amp; &quot;        (VBox\n            (Glue 6)\n            (Shape (Height 16 + 0)&quot;
 &amp; &quot;\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n          &quot;
 &amp; &quot;                      \&quot;Code View events:   Stop? \&quot;) \n               &quot;
 &amp; &quot;     (Boolean %stopatCodeEvents =TRUE \&quot;\&quot;)\n                    (Glue &quot;
 &amp; &quot;10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n&quot;
 &amp; &quot;                    (Shape (Width 80) (Numeric %waitatCodeEvents =1 \n &quot;
 &amp; &quot;                                              (Min 0) (Max 100)))))\n  &quot;
 &amp; &quot;          (Glue 6)\n            (Shape (Height 16 + 0)\n              (&quot;
 &amp; &quot;HBox Fill (Shape (Width + 0) (Height + 0) \n                           &quot;
 &amp; &quot;     \&quot;Setup:   Stop? \&quot;) \n                    (Boolean %stopAtSetup =&quot;
 &amp; &quot;TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (&quot;
 &amp; &quot;Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Widt&quot;
 &amp; &quot;h 80) (Numeric %waitAtSetup =1 \n                                      &quot;
 &amp; &quot;         (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shap&quot;
 &amp; &quot;e (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height &quot;
 &amp; &quot;+ 0) \n                                \&quot;NewSet:   Stop? \&quot;) \n        &quot;
 &amp; &quot;            (Boolean %stopAtNewSet =TRUE \&quot;\&quot;)\n                    (Gl&quot;
 &amp; &quot;ue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;&quot;
 &amp; &quot;)\n                    (Shape (Width 80) (Numeric %waitAtNewSet =1 \n  &quot;
 &amp; &quot;                                             (Min 0) (Max 100)))))\n   &quot;
 &amp; &quot;         (Glue 6)\n            (Shape (Height 16 + 0)\n              (H&quot;
 &amp; &quot;Box F&quot;;

CONST E22_0 =
   &quot;ill (Shape (Width + 0) (Height + 0) \n                                \&quot;&quot;
 &amp; &quot;FinishedSets:   Stop? \&quot;) \n                    (Boolean %stopAtFinishe&quot;
 &amp; &quot;dSets =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (&quot;
 &amp; &quot;Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shap&quot;
 &amp; &quot;e (Width 80) (Numeric %waitAtFinishedSets =1 \n                        &quot;
 &amp; &quot;                       (Min 0) (Max 100)))))\n            (Glue 6)\n   &quot;
 &amp; &quot;         (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width&quot;
 &amp; &quot; + 0) (Height + 0) \n                                \&quot;StartFind:   Sto&quot;
 &amp; &quot;p? \&quot;) \n                    (Boolean %stopAtStartFind =TRUE \&quot;\&quot;)\n   &quot;
 &amp; &quot;                 (Glue 10)\n                    (Shape (Width + 0) (Hei&quot;
 &amp; &quot;ght + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric &quot;
 &amp; &quot;%waitAtStartFind =1 \n                                               (M&quot;
 &amp; &quot;in 0) (Max 100)))))\n            (Glue 6)\n            (Shape (Height 1&quot;
 &amp; &quot;6 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n    &quot;
 &amp; &quot;                            \&quot;EndFind:   Stop? \&quot;) \n                  &quot;
 &amp; &quot;  (Boolean %stopAtEndFind =TRUE \&quot;\&quot;)\n                    (Glue 10)\n &quot;
 &amp; &quot;                   (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n     &quot;
 &amp; &quot;               (Shape (Width 80) (Numeric %waitAtEndFind =1 \n         &quot;
 &amp; &quot;                                      (Min 0) (Max 100)))))\n          &quot;
 &amp; &quot;  (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox Fil&quot;
 &amp; &quot;l (Shape (Width + 0) (Height + 0) \n                                \&quot;S&quot;
 &amp; &quot;tartDoFind:   Stop? \&quot;) \n                    (Boolean %stopAtStartDoFi&quot;
 &amp; &quot;nd =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Sha&quot;
 &amp; &quot;pe (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (&quot;
 &amp; &quot;Width 80) (Numeric %waitAtStartDoFind =1 \n                            &quot;
 &amp; &quot;                   (Min 0) (Max 100)))))\n            (Glue 6)\n       &quot;
 &amp; &quot;     (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0&quot;
 &amp; &quot;) (Height + 0) \n                                \&quot;StepUp:   Stop? \&quot;) &quot;
 &amp; &quot;\n                    (Boolean %stopAtStepUp =TRUE \&quot;\&quot;)\n             &quot;
 &amp; &quot;       &quot;;

CONST E22_1 =
   &quot;(Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight&quot;
 &amp; &quot;: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtStepUp =1 &quot;
 &amp; &quot;\n                                               (Min 0) (Max 100)))))\n&quot;
 &amp; &quot;            (Glue 6)\n            (Shape (Height 16 + 0)\n             &quot;
 &amp; &quot; (HBox Fill (Shape (Width + 0) (Height + 0) \n                         &quot;
 &amp; &quot;       \&quot;Found:   Stop? \&quot;) \n                    (Boolean %stopAtFound&quot;
 &amp; &quot; =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape&quot;
 &amp; &quot; (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Wi&quot;
 &amp; &quot;dth 80) (Numeric %waitAtFound =1 \n                                    &quot;
 &amp; &quot;           (Min 0) (Max 100)))))\n            (Glue 6)\n            (Sh&quot;
 &amp; &quot;ape (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Heigh&quot;
 &amp; &quot;t + 0) \n                                \&quot;StepDown:   Stop? \&quot;) \n    &quot;
 &amp; &quot;                (Boolean %stopAtStepDown =TRUE \&quot;\&quot;)\n                 &quot;
 &amp; &quot;   (Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Wei&quot;
 &amp; &quot;ght: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtStepDow&quot;
 &amp; &quot;n =1 \n                                               (Min 0) (Max 100)&quot;
 &amp; &quot;))))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n       &quot;
 &amp; &quot;       (HBox Fill (Shape (Width + 0) (Height + 0) \n                   &quot;
 &amp; &quot;             \&quot;ChangeParent:   Stop? \&quot;) \n                    (Boolean&quot;
 &amp; &quot; %stopAtChangeParent =TRUE \&quot;\&quot;)\n                    (Glue 10)\n      &quot;
 &amp; &quot;              (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n          &quot;
 &amp; &quot;          (Shape (Width 80) (Numeric %waitAtChangeParent =1 \n         &quot;
 &amp; &quot;                                      (Min 0) (Max 100)))))\n          &quot;
 &amp; &quot;  (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox Fil&quot;
 &amp; &quot;l (Shape (Width + 0) (Height + 0) \n                                \&quot;E&quot;
 &amp; &quot;ndDoFind:   Stop? \&quot;) \n                    (Boolean %stopAtEndDoFind =&quot;
 &amp; &quot;TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (&quot;
 &amp; &quot;Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Widt&quot;
 &amp; &quot;h 80) (Numeric %waitAtEndDoFind =1 \n                                  &quot;
 &amp; &quot;     &quot;;

CONST E22_2 =
   &quot;        (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape&quot;
 &amp; &quot; (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height +&quot;
 &amp; &quot; 0) \n                                \&quot;StartUnion:   Stop? \&quot;) \n     &quot;
 &amp; &quot;               (Boolean %stopAtStartUnion =TRUE \&quot;\&quot;)\n                &quot;
 &amp; &quot;    (Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;We&quot;
 &amp; &quot;ight: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtStartU&quot;
 &amp; &quot;nion =1 \n                                               (Min 0) (Max 1&quot;
 &amp; &quot;00)))))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n    &quot;
 &amp; &quot;          (HBox Fill (Shape (Width + 0) (Height + 0) \n                &quot;
 &amp; &quot;                \&quot;FoundFirst:   Stop? \&quot;) \n                    (Boolea&quot;
 &amp; &quot;n %stopAtFoundFirst =TRUE \&quot;\&quot;)\n                    (Glue 10)\n       &quot;
 &amp; &quot;             (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n           &quot;
 &amp; &quot;         (Shape (Width 80) (Numeric %waitAtFoundFirst =1 \n            &quot;
 &amp; &quot;                                   (Min 0) (Max 100)))))\n            (&quot;
 &amp; &quot;Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox Fill (&quot;
 &amp; &quot;Shape (Width + 0) (Height + 0) \n                                \&quot;Comp&quot;
 &amp; &quot;areRanks:   Stop? \&quot;) \n                    (Boolean %stopAtCompareRank&quot;
 &amp; &quot;s =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shap&quot;
 &amp; &quot;e (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (W&quot;
 &amp; &quot;idth 80) (Numeric %waitAtCompareRanks =1 \n                            &quot;
 &amp; &quot;                   (Min 0) (Max 100)))))\n            (Glue 6)\n       &quot;
 &amp; &quot;     (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0&quot;
 &amp; &quot;) (Height + 0) \n                                \&quot;Unite:   Stop? \&quot;) \n&quot;
 &amp; &quot;                    (Boolean %stopAtUnite =TRUE \&quot;\&quot;)\n                &quot;
 &amp; &quot;    (Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;We&quot;
 &amp; &quot;ight: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtUnite &quot;
 &amp; &quot;=1 \n                                               (Min 0) (Max 100)))&quot;
 &amp; &quot;))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n         &quot;
 &amp; &quot;     (HBox Fill (Shape (Width + 0) (Height + 0) \n                     &quot;
 &amp; &quot;    &quot;;

CONST E22_3 =
   &quot;       \&quot;EndUnion:   Stop? \&quot;) \n                    (Boolean %stopAtEn&quot;
 &amp; &quot;dUnion =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    &quot;
 &amp; &quot;(Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Sha&quot;
 &amp; &quot;pe (Width 80) (Numeric %waitAtEndUnion =1 \n                           &quot;
 &amp; &quot;                    (Min 0) (Max 100)))))\n            (Glue 6)\n      &quot;
 &amp; &quot;    )\n          (Glue 4)\n          (VBox\n            (Glue 5)\n     &quot;
 &amp; &quot;       (Shape (Width + 0) (Height 16 + 0) \&quot;Cts:\&quot;)\n            (Butto&quot;
 &amp; &quot;n %eventCounts\n              (VBox\n                (Glue 6)\n        &quot;
 &amp; &quot;        (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n               &quot;
 &amp; &quot;                   (Text %ctOfSetup \&quot;0\&quot;)))\n                (Glue 6)\n&quot;
 &amp; &quot;                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n       &quot;
 &amp; &quot;                           (Text %ctOfNewSet \&quot;0\&quot;)))\n                &quot;
 &amp; &quot;(Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0)&quot;
 &amp; &quot; \n                                  (Text %ctOfFinishedSets \&quot;0\&quot;)))\n&quot;
 &amp; &quot;                (Glue 6)\n                (HBox Fill (Shape (Width + 0)&quot;
 &amp; &quot; (Height 16 + 0) \n                                  (Text %ctOfStartFi&quot;
 &amp; &quot;nd \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Shap&quot;
 &amp; &quot;e (Width + 0) (Height 16 + 0) \n                                  (Text&quot;
 &amp; &quot; %ctOfEndFind \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox&quot;
 &amp; &quot; Fill (Shape (Width + 0) (Height 16 + 0) \n                            &quot;
 &amp; &quot;      (Text %ctOfStartDoFind \&quot;0\&quot;)))\n                (Glue 6)\n      &quot;
 &amp; &quot;          (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n             &quot;
 &amp; &quot;                     (Text %ctOfStepUp \&quot;0\&quot;)))\n                (Glue &quot;
 &amp; &quot;6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n   &quot;
 &amp; &quot;                               (Text %ctOfFound \&quot;0\&quot;)))\n             &quot;
 &amp; &quot;   (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 +&quot;
 &amp; &quot; 0) \n                                  (Text %ctOfStepDown \&quot;0\&quot;)))\n &quot;
 &amp; &quot;               (Glue 6)\n                (HBox Fill (Shape (Width + 0) &quot;
 &amp; &quot;(Height 16 + 0) \n                                  (Text %ctOfChangePa&quot;
 &amp; &quot;rent \&quot;0\&quot;)&quot;;

CONST E22_4 =
   &quot;))\n                (Glue 6)\n                (HBox Fill (Shape (Width &quot;
 &amp; &quot;+ 0) (Height 16 + 0) \n                                  (Text %ctOfEnd&quot;
 &amp; &quot;DoFind \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (&quot;
 &amp; &quot;Shape (Width + 0) (Height 16 + 0) \n                                  (&quot;
 &amp; &quot;Text %ctOfStartUnion \&quot;0\&quot;)))\n                (Glue 6)\n              &quot;
 &amp; &quot;  (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n                     &quot;
 &amp; &quot;             (Text %ctOfFoundFirst \&quot;0\&quot;)))\n                (Glue 6)\n&quot;
 &amp; &quot;                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n       &quot;
 &amp; &quot;                           (Text %ctOfCompareRanks \&quot;0\&quot;)))\n          &quot;
 &amp; &quot;      (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 1&quot;
 &amp; &quot;6 + 0) \n                                  (Text %ctOfUnite \&quot;0\&quot;)))\n &quot;
 &amp; &quot;               (Glue 6)\n                (HBox Fill (Shape (Width + 0) &quot;
 &amp; &quot;(Height 16 + 0) \n                                  (Text %ctOfEndUnion&quot;
 &amp; &quot; \&quot;0\&quot;)))\n                (Glue 3))))\n          Fill\n          (Glue&quot;
 &amp; &quot; 4 + Inf)\n        )\n      )\n    )\n  )\n)\n&quot;;

CONST E23 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:29:09 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Mini&quot;
 &amp; &quot;max.evt.\n;************************************************************&quot;
 &amp; &quot;********\n\n(VBox\n  (Border (Pen 1)\n    (Shape\n      (Height 75 - 25&quot;
 &amp; &quot; + Inf)\n      (Viewport\n        (HBox\n          (Glue 4 + Inf)\n    &quot;
 &amp; &quot;      (VBox\n            (Glue 6)\n            (Shape (Height 16 + 0)\n&quot;
 &amp; &quot;              (HBox Fill (Shape (Width + 0) (Height + 0) \n            &quot;
 &amp; &quot;                    \&quot;Code View events:   Stop? \&quot;) \n                 &quot;
 &amp; &quot;   (Boolean %stopatCodeEvents =TRUE \&quot;\&quot;)\n                    (Glue 10&quot;
 &amp; &quot;)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n &quot;
 &amp; &quot;                   (Shape (Width 80) (Numeric %waitatCodeEvents =1 \n  &quot;
 &amp; &quot;                                             (Min 0) (Max 100)))))\n   &quot;
 &amp; &quot;         (Glue 6)\n            (Shape (Height 16 + 0)\n              (H&quot;
 &amp; &quot;Box Fill (Shape (Width + 0) (Height + 0) \n                            &quot;
 &amp; &quot;    \&quot;Setup:   Stop? \&quot;) \n                    (Boolean %stopAtSetup =T&quot;
 &amp; &quot;RUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (W&quot;
 &amp; &quot;idth + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width&quot;
 &amp; &quot; 80) (Numeric %waitAtSetup =1 \n                                       &quot;
 &amp; &quot;        (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape&quot;
 &amp; &quot; (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height +&quot;
 &amp; &quot; 0) \n                                \&quot;PlayerMove:   Stop? \&quot;) \n     &quot;
 &amp; &quot;               (Boolean %stopAtPlayerMove =TRUE \&quot;\&quot;)\n                &quot;
 &amp; &quot;    (Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;We&quot;
 &amp; &quot;ight: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtPlayer&quot;
 &amp; &quot;Move =1 \n                                               (Min 0) (Max 1&quot;
 &amp; &quot;00)))))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n    &quot;
 &amp; &quot;       &quot;;

CONST E23_0 =
   &quot;   (HBox Fill (Shape (Width + 0) (Height + 0) \n                       &quot;
 &amp; &quot;         \&quot;Finished:   Stop? \&quot;) \n                    (Boolean %stopAt&quot;
 &amp; &quot;Finished =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                  &quot;
 &amp; &quot;  (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (S&quot;
 &amp; &quot;hape (Width 80) (Numeric %waitAtFinished =1 \n                         &quot;
 &amp; &quot;                      (Min 0) (Max 100)))))\n            (Glue 6)\n    &quot;
 &amp; &quot;        (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width &quot;
 &amp; &quot;+ 0) (Height + 0) \n                                \&quot;EvaluateNode:   S&quot;
 &amp; &quot;top? \&quot;) \n                    (Boolean %stopAtEvaluateNode =TRUE \&quot;\&quot;)&quot;
 &amp; &quot;\n                    (Glue 10)\n                    (Shape (Width + 0)&quot;
 &amp; &quot; (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Num&quot;
 &amp; &quot;eric %waitAtEvaluateNode =1 \n                                         &quot;
 &amp; &quot;      (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape (&quot;
 &amp; &quot;Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0&quot;
 &amp; &quot;) \n                                \&quot;PlayerThinking:   Stop? \&quot;) \n   &quot;
 &amp; &quot;                 (Boolean %stopAtPlayerThinking =TRUE \&quot;\&quot;)\n          &quot;
 &amp; &quot;          (Glue 10)\n                    (Shape (Width + 0) (Height + 0&quot;
 &amp; &quot;) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAt&quot;
 &amp; &quot;PlayerThinking =1 \n                                               (Min&quot;
 &amp; &quot; 0) (Max 100)))))\n            (Glue 6)\n            (Shape (Height 16 &quot;
 &amp; &quot;+ 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n      &quot;
 &amp; &quot;                          \&quot;FinishedEvalNode:   Stop? \&quot;) \n           &quot;
 &amp; &quot;         (Boolean %stopAtFinishedEvalNode =TRUE \&quot;\&quot;)\n                &quot;
 &amp; &quot;    (Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;We&quot;
 &amp; &quot;ight: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtFinish&quot;
 &amp; &quot;edEvalNode =1 \n                                               (Min 0) &quot;
 &amp; &quot;(Max 100)))))\n            (Glue 6)\n            (Shape (Height 16 + 0)&quot;
 &amp; &quot;\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n          &quot;
 &amp; &quot;                      \&quot;BoardValueUpdated:   Stop? \&quot;) \n              &quot;
 &amp; &quot;     &quot;;

CONST E23_1 =
   &quot; (Boolean %stopAtBoardValueUpdated =TRUE \&quot;\&quot;)\n                    (Gl&quot;
 &amp; &quot;ue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;&quot;
 &amp; &quot;)\n                    (Shape (Width 80) (Numeric %waitAtBoardValueUpda&quot;
 &amp; &quot;ted =1 \n                                               (Min 0) (Max 10&quot;
 &amp; &quot;0)))))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n     &quot;
 &amp; &quot;         (HBox Fill (Shape (Width + 0) (Height + 0) \n                 &quot;
 &amp; &quot;               \&quot;HumanCellSelected:   Stop? \&quot;) \n                    (&quot;
 &amp; &quot;Boolean %stopAtHumanCellSelected =TRUE \&quot;\&quot;)\n                    (Glue&quot;
 &amp; &quot; 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)&quot;
 &amp; &quot;\n                    (Shape (Width 80) (Numeric %waitAtHumanCellSelect&quot;
 &amp; &quot;ed =1 \n                                               (Min 0) (Max 100&quot;
 &amp; &quot;)))))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n      &quot;
 &amp; &quot;        (HBox Fill (Shape (Width + 0) (Height + 0) \n                  &quot;
 &amp; &quot;              \&quot;HumanIllegalMove:   Stop? \&quot;) \n                    (Bo&quot;
 &amp; &quot;olean %stopAtHumanIllegalMove =TRUE \&quot;\&quot;)\n                    (Glue 10&quot;
 &amp; &quot;)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n &quot;
 &amp; &quot;                   (Shape (Width 80) (Numeric %waitAtHumanIllegalMove =&quot;
 &amp; &quot;1 \n                                               (Min 0) (Max 100))))&quot;
 &amp; &quot;)\n            (Glue 6)\n          )\n          (Glue 4)\n          (VB&quot;
 &amp; &quot;ox\n            (Glue 5)\n            (Shape (Width + 0) (Height 16 + 0&quot;
 &amp; &quot;) \&quot;Cts:\&quot;)\n            (Button %eventCounts\n              (VBox\n   &quot;
 &amp; &quot;             (Glue 6)\n                (HBox Fill (Shape (Width + 0) (H&quot;
 &amp; &quot;eight 16 + 0) \n                                  (Text %ctOfSetup \&quot;0\&quot;&quot;
 &amp; &quot;)))\n                (Glue 6)\n                (HBox Fill (Shape (Width&quot;
 &amp; &quot; + 0) (Height 16 + 0) \n                                  (Text %ctOfPl&quot;
 &amp; &quot;ayerMove \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill&quot;
 &amp; &quot; (Shape (Width + 0) (Height 16 + 0) \n                                 &quot;
 &amp; &quot; (Text %ctOfFinished \&quot;0\&quot;)))\n                (Glue 6)\n              &quot;
 &amp; &quot;  (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n                     &quot;
 &amp; &quot;     &quot;;

CONST E23_2 =
   &quot;        (Text %ctOfEvaluateNode \&quot;0\&quot;)))\n                (Glue 6)\n   &quot;
 &amp; &quot;             (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n          &quot;
 &amp; &quot;                        (Text %ctOfPlayerThinking \&quot;0\&quot;)))\n           &quot;
 &amp; &quot;     (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16&quot;
 &amp; &quot; + 0) \n                                  (Text %ctOfFinishedEvalNode \&quot;&quot;
 &amp; &quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Shape (Wi&quot;
 &amp; &quot;dth + 0) (Height 16 + 0) \n                                  (Text %ctO&quot;
 &amp; &quot;fBoardValueUpdated \&quot;0\&quot;)))\n                (Glue 6)\n                &quot;
 &amp; &quot;(HBox Fill (Shape (Width + 0) (Height 16 + 0) \n                       &quot;
 &amp; &quot;           (Text %ctOfHumanCellSelected \&quot;0\&quot;)))\n                (Glue&quot;
 &amp; &quot; 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n  &quot;
 &amp; &quot;                                (Text %ctOfHumanIllegalMove \&quot;0\&quot;)))\n &quot;
 &amp; &quot;               (Glue 3))))\n          Fill\n          (Glue 4 + Inf)\n &quot;
 &amp; &quot;       )\n      )\n    )\n  )\n)\n&quot;;

CONST E24 =
   &quot;; Copyright (C) 1992, Digital Equipment Corporation\n; All rights reser&quot;
 &amp; &quot;ved.\n; See the file COPYRIGHT for a full description.\n\n(Rim\n  (Pen &quot;
 &amp; &quot;10)\n  (VBox\n    (Text LeftAlign \&quot;Search pattern: \&quot;)\n    (Frame Low&quot;
 &amp; &quot;ered (TypeIn ExpandOnDemand (BgColor \&quot;White\&quot;) %pattern =\&quot;abra\&quot;))\n &quot;
 &amp; &quot;   (Glue 10)\n    (Text LeftAlign \&quot;Text to search in: \&quot;)\n    (Frame &quot;
 &amp; &quot;Lowered (TypeIn ExpandOnDemand (BgColor \&quot;White\&quot;) %text =\&quot;abracadabra&quot;
 &amp; &quot;\&quot;))))&quot;;

CONST E25 =
   &quot;; Copyright (C) 1992, Digital Equipment Corporation\n; All rights reser&quot;
 &amp; &quot;ved.\n; See the file COPYRIGHT for a full description.\n\n(Scale\n  (HS&quot;
 &amp; &quot;cale 1)\n  (VScale 1)\n  (Rim\n    (Pen 10)\n    (VBox\n      (HBox\n  &quot;
 &amp; &quot;      (Text RightAlign \&quot;Number of Points: \&quot;)\n        Fill\n        (&quot;
 &amp; &quot;Text LeftAlign %N \&quot;\&quot;)\n        Fill)\n      (Glue 10)\n      (HBox\n &quot;
 &amp; &quot;       (Text RightAlign \&quot;Min length: \&quot;)\n        Fill\n        (Text &quot;
 &amp; &quot;LeftAlign %min \&quot;\&quot;)\n        Fill))))\n&quot;;

CONST E26 =
   &quot;Source 100 50\nV12 100 250\nV14 100 450\nV16 100 650\nV30 300 50\nV32 3&quot;
 &amp; &quot;00 250\nV34 250 500\nV35 350 450\nV36 300 650\nV50 500 50\nV52 500 250\n&quot;
 &amp; &quot;V54 500 450\nV56 500 650\nV58 500 850\nV70 700 50\nV72 700 250\nV74 700&quot;
 &amp; &quot; 450\nV76 700 650\nV78 700 850\nV94 900 450\nV96 900 650\nSink 900 850\n&quot;
 &amp; &quot;Source -&gt; V32 0.94\nV32 -&gt; V54 3.3\nV54 -&gt; V76 0.94\nV76 -&gt; Sink 1.2\nS&quot;
 &amp; &quot;ource -&gt; V52 1.9\nV52 -&gt; V74 2.5\nV74 -&gt; Sink 0.9\nSource -&gt; V34 0.56\n&quot;
 &amp; &quot;V34 -&gt; V56 2.3\nV56 -&gt; Sink 0.56\nSource -&gt; V30 2.22\nV30 -&gt; V50 2.89\n&quot;
 &amp; &quot;V50 -&gt; V74 1.1\nV52 -&gt; V70 2.5\nV70 -&gt; V72 1.89\nV72 -&gt; V94 2.56\nV94 -&quot;
 &amp; &quot;&gt; V96 2.22\nV96 -&gt; Sink 3.1\nSource -&gt; V12 2.19\nV12 -&gt; V35 2.67\nV35 -&quot;
 &amp; &quot;&gt; V54 1.1\nV32 -&gt; V14 1.14\nV14 -&gt; V36 2.3\nV36 -&gt; V56 1.3\nV34 -&gt; V16 &quot;
 &amp; &quot;1.7\nV16 -&gt; V58 1.0\nV58 -&gt; V78 1.234\nV78 -&gt; Sink 2.013\n.\n&quot;;

CONST E27 =
   &quot;@Decompress\nPROCEDURE Decompress(input, alphabet) =@\n    @1 (* uncomp&quot;
 &amp; &quot;ress input to get codes array, pos *)@\n    @2 (* decode codes array (u&quot;
 &amp; &quot;sing alphabet) to get lastchars array *)@\n    @3 (* recompute original&quot;
 &amp; &quot; string using lastchars, pos *)@\n         @4 (* sort lastchars array t&quot;
 &amp; &quot;o get firstchars array *)@\n         @5 (* for each character in firstc&quot;
 &amp; &quot;hars, find corresponding\n               character in lastchars *)@\n  &quot;
 &amp; &quot;       @6 (* starting with char in firstchars[pos], reconstruct\n      &quot;
 &amp; &quot;         original string *)@\n@Decompress\n&quot;;

CONST E28 =
   &quot;(* Copyright (C) 1993, Digital Equipment Corporation                   &quot;
 &amp; &quot;      *)\n(* All rights reserved.                                      &quot;
 &amp; &quot;                *)\n(* See the file COPYRIGHT for a full description.  &quot;
 &amp; &quot;                          *)\n(*                                       &quot;
 &amp; &quot;                                    *)\n(* Last modified on Mon Jan  9 &quot;
 &amp; &quot;12:14:14 PST 1995 by najork                   *)\n(*      modified on W&quot;
 &amp; &quot;ed Oct 13 19:41:10 PDT 1993 by mann                     *)\n(*      mod&quot;
 &amp; &quot;ified on Mon Jul 19 11:59:36 PDT 1993 by perl                     *)\n\n&quot;
 &amp; &quot;let codesColor = color_named(\&quot;White\&quot;);\nlet codesLabelColor = color_n&quot;
 &amp; &quot;amed(\&quot;Black\&quot;);\nlet codesHiliteLabelColor = color_named(\&quot;DarkRed\&quot;);&quot;
 &amp; &quot;\nlet arrowColor = color_named(\&quot;DarkRed\&quot;);\nlet rowIndexColor = color&quot;
 &amp; &quot;_named(\&quot;Pink\&quot;);\nlet rowIndexLabelColor = color_named(\&quot;Black\&quot;);\nle&quot;
 &amp; &quot;t otherIndexColor = color_named(\&quot;White\&quot;);\nlet otherIndexLabelColor =&quot;
 &amp; &quot; color_named(\&quot;DarkGray\&quot;);\nlet alphaColor = color_named(\&quot;LightYellow&quot;
 &amp; &quot;\&quot;);\nlet alphaLabelColor = color_named(\&quot;Black\&quot;);\nlet initialColor =&quot;
 &amp; &quot; color_named(\&quot;DarkGray\&quot;);\nlet initialLabelColor = color_named(\&quot;Blac&quot;
 &amp; &quot;k\&quot;);\n(*!! let shadowColor = color_named(\&quot;LightGray\&quot;);*)\nlet shadow&quot;
 &amp; &quot;Color = color_named(\&quot;VerySlightlyLightGray\&quot;);\nlet shadowLabelColor =&quot;
 &amp; &quot; color_named(\&quot;Black\&quot;);\nlet ghostColor = color_named(\&quot;White\&quot;);\nlet&quot;
 &amp; &quot; ghostLabelColor = color_named(\&quot;Gray\&quot;);\nlet duplColor = color_named(&quot;
 &amp; &quot;\&quot;LightGray\&quot;);\nlet duplLabelColor = color_named(\&quot;VeryDarkGray\&quot;);\n\n&quot;
 &amp; &quot;(***\nlet charColorNames = [\&quot;LightVividBlue\&quot;,\n                      &quot;
 &amp; &quot;\&quot;VerySlightlyLightQuiteVividRed\&quot;,\n                      \&quot;VerySlight&quot;
 &amp; &quot;lyLightVividGreen\&quot;,\n                      \&quot;Yellow\&quot;,\n              &quot;
 &amp; &quot;        \&quot;VerySlightlyLightPurple\&quot;,\n                      \&quot;VividRedd&quot;
 &amp; &quot;ishOrange\&quot;];\n***)\nlet charColorNames = [\&quot;VerySlightlyLightQuiteVivi&quot;
 &amp; &quot;dRed\&quot;,\n                      \&quot;VerySlightlyDarkVividGreen\&quot;,\n       &quot;
 &amp; &quot;               \&quot;SlightlyLightVividBlue\&quot;,\n                      \&quot;Red&quot;
 &amp; &quot;dishVividOrange\&quot;,\n                      \&quot;VerySlightlyLightPurple\&quot;,\n&quot;
 &amp; &quot;                      \&quot;VerySlightlyDark&quot;;

CONST E28_0 =
   &quot;VeryVividYellow\&quot;];\n\nlet charColors = foreach c in charColorNames map&quot;
 &amp; &quot; color_named(c) end;\n\nlet makeDippingPath = proc(startX, endX, y, dip&quot;
 &amp; &quot;)\n    proc(t)\n        [ (startX * (1.0 - t)) + (endX * t),\n\t  y + (&quot;
 &amp; &quot;dip * (0.25 - ((t - 0.5) * (t - 0.5))))]\n    end\nend;\n\nlet view =\n&quot;
 &amp; &quot;  {\n    graphvbt =&gt; graph_new(),\n    vertexFont =&gt; ok,\n    codes =&gt; &quot;
 &amp; &quot;{array =&gt; ok, vtx =&gt; ok},\n    last =&gt; {chars =&gt; ok, vtx =&gt; ok},\n    x&quot;
 &amp; &quot;last =&gt; {chars =&gt; ok, vtx =&gt; ok},\n    first =&gt; {chars =&gt; ok, vtx =&gt; ok&quot;
 &amp; &quot;, vtxColor =&gt; ok, pendingMoves =&gt; ok},\n    n =&gt; 0,\n    alphalen =&gt; 0,&quot;
 &amp; &quot;\n    colorIndex =&gt; -1,\n    rowIndices =&gt; ok,\n    rowIndex =&gt; ok,\n  &quot;
 &amp; &quot;  rowIndexVtx =&gt; ok,\n    codeSearchArrow =&gt; ok,\n\n    InitDecode =&gt; m&quot;
 &amp; &quot;eth(self, alpha, codes, rowIndex)\n    (* Start of phase where we recon&quot;
 &amp; &quot;struct lastchars from codes. *)\n        self.n := #(codes);\n\tself.xl&quot;
 &amp; &quot;ast.chars := alpha;\n\tself.alphalen := text_length(alpha);\n        se&quot;
 &amp; &quot;lf.vertexFont := graph_newFont(self.graphvbt, \&quot;Helvetica\&quot;,\n         &quot;
 &amp; &quot;                                0.5, \&quot;Roman\&quot;, \&quot;bold\&quot;, \&quot;*\&quot;);\n\tle&quot;
 &amp; &quot;t north = ~5.25,\n            south = float(self.n),\n            west &quot;
 &amp; &quot;= -(float(self.alphalen) + 1.0),\n            east = float(self.n) + 1.&quot;
 &amp; &quot;0;\n\tgraph_setWorld(self.graphvbt, west, east, north, south);\n\tgraph&quot;
 &amp; &quot;_setAspect(self.graphvbt, (south - north) / (east - west));\n\tgraph_se&quot;
 &amp; &quot;tPixelSizeDivisor(self.graphvbt,\n                                  rou&quot;
 &amp; &quot;nd(east - west),\n\t\t\t          round(south - north));\n\n        sel&quot;
 &amp; &quot;f.xlast.vtx := array_new(self.alphalen + self.n, ok);\n        for i = &quot;
 &amp; &quot;0 to self.alphalen - 1 do\n            let v = graph_newVertex(self.gra&quot;
 &amp; &quot;phvbt);\n            self.xlast.vtx[i] := v;\n\t    graph_setVertexSize&quot;
 &amp; &quot;(v, 0.0, 0.0); (*avoid glitches*)\n            graph_setVertexLabel(v, &quot;
 &amp; &quot;text_sub(self.xlast.chars, i, 1));\n            graph_setVertexFont(v, &quot;
 &amp; &quot;self.vertexFont);\n            graph_setVertexColor(v, alphaColor);\n  &quot;
 &amp; &quot;          graph_setVertexLabelColor(v, alphaLabelColor);\n            g&quot;
 &amp; &quot;raph_setVertexBorder(v, 0.05);\n            graph_moveVertex(v, float(i&quot;
 &amp; &quot; - (2 * self.al&quot;;

CONST E28_1 =
   &quot;phalen)) - 4.0, ~2.0,\n                             false);\n        en&quot;
 &amp; &quot;d;\n\n        self.codes.array := codes;\n        self.codes.vtx := arr&quot;
 &amp; &quot;ay_new(self.n, ok);\n        for i = 0 to self.n - 1 do\n            le&quot;
 &amp; &quot;t v = graph_newVertex(self.graphvbt);\n            self.codes.vtx[i] :=&quot;
 &amp; &quot; v;\n            graph_setVertexLabel(v, fmt_int(codes[i]));\n         &quot;
 &amp; &quot;   graph_setVertexFont(v, self.vertexFont);\n            graph_setVerte&quot;
 &amp; &quot;xColor(v, codesColor);\n            graph_setVertexLabelColor(v, codesL&quot;
 &amp; &quot;abelColor);\n            graph_setVertexBorder(v, 0.05);\n            g&quot;
 &amp; &quot;raph_moveVertex(v, float(i), ~4.25, false);\n\t    graph_setVertexSize(&quot;
 &amp; &quot;v, 0.95, 0.95);\n        end;\n\n\tlet v = graph_newVertex(self.graphvb&quot;
 &amp; &quot;t);\n\tself.rowIndex := rowIndex;\n\tself.rowIndexVtx := v;\n\tgraph_se&quot;
 &amp; &quot;tVertexShape(v, \&quot;ellipse\&quot;);\n\tgraph_setVertexLabel(v, fmt_int(self.r&quot;
 &amp; &quot;owIndex));\n\tgraph_setVertexFont(v, self.vertexFont);\n\tgraph_setVert&quot;
 &amp; &quot;exColor(v, rowIndexColor);\n\tgraph_setVertexLabelColor(v, rowIndexLabe&quot;
 &amp; &quot;lColor);\n\tgraph_setVertexBorder(v, 0.05);\n\tgraph_moveVertex(v, floa&quot;
 &amp; &quot;t(self.n), ~4.25, false);\n\tgraph_setVertexSize(v, 0.95, 0.95);\n\n   &quot;
 &amp; &quot;     graph_redisplay(self.graphvbt);\n    end,\n\t\n    StartDecode =&gt; &quot;
 &amp; &quot;meth(self)\n        for i = 0 to self.alphalen - 1 do\n\t    graph_setV&quot;
 &amp; &quot;ertexSize(self.xlast.vtx[i], 0.95, 0.95);\n            graph_moveVertex&quot;
 &amp; &quot;(self.xlast.vtx[i],\n                             float(i - self.alphal&quot;
 &amp; &quot;en), ~2.0, true);\n\tend;\n\n\tzeus_animate(self.graphvbt, 0.0, 1.0);\n&quot;
 &amp; &quot;\n\tself.rowIndices := array_new(self.n, ok);\n    end,\n\n    DecodeNe&quot;
 &amp; &quot;xtCode =&gt; meth(self, i)\n    (* Looking at i\'th code, before starting &quot;
 &amp; &quot;to find its corresponding\n       character.\n     *)\n\tlet v = self.c&quot;
 &amp; &quot;odes.vtx[i];\n\tgraph_setVertexLabelColor(v, codesHiliteLabelColor);\n\t&quot;
 &amp; &quot;graph_setVertexBorder(v, 0.12);\n\n\tlet v = graph_newVertex(self.graph&quot;
 &amp; &quot;vbt);\n\tself.codeSearchArrow := v;\n\tgraph_setVertexFont(v, self.vert&quot;
 &amp; &quot;exFont);\n\tgraph_setVertexColor(v, codesColor);\n\tgraph_setVertexLabe&quot;
 &amp; &quot;lColor(v, codesHiliteLabelColor);\n\tgraph_setVertexBorder(v, 0.12);\n\t&quot;
 &amp; &quot;graph_setVertexSize(v, 0.95,&quot;;

CONST E28_2 =
   &quot; 0.95);\n\tgraph_setVertexLabel(self.codeSearchArrow, \&quot;0\&quot;);\n  \tgrap&quot;
 &amp; &quot;h_moveVertex(self.codeSearchArrow, float(i), ~3.0, false);\n        gra&quot;
 &amp; &quot;ph_redisplay(self.graphvbt);\n    end,\n\n    DecodeDistinctCount =&gt; me&quot;
 &amp; &quot;th(self, i, k, n)\n    (* Found another distinct character at position &quot;
 &amp; &quot;k in xchars while looking \n       for the character corresponding to c&quot;
 &amp; &quot;ode i. The number of distinct \n       characters found so far is n. *)&quot;
 &amp; &quot;\n\n  \tgraph_moveVertex(self.codeSearchArrow, float(k - self.alphalen)&quot;
 &amp; &quot;,\n                         ~3.0, true);\n\tzeus_animate(self.graphvbt,&quot;
 &amp; &quot; 0.0, 1.0);\n\tgraph_setVertexLabel(self.codeSearchArrow, fmt_int(n));\n&quot;
 &amp; &quot;        graph_redisplay(self.graphvbt);\n    end,\n\n    DecodeFoundCha&quot;
 &amp; &quot;r =&gt; meth(self, i, k, c)\n    (* Found that the character for code i is&quot;
 &amp; &quot; at position k in the\n       concatenated alphabet and current string &quot;
 &amp; &quot;and its value is c. *)\n\n  \tgraph_moveVertex(self.codeSearchArrow, fl&quot;
 &amp; &quot;oat(k - self.alphalen),\n                         ~3.0, true);\n\tzeus_&quot;
 &amp; &quot;animate(self.graphvbt, 0.0, 1.0);\n\n        self.xlast.chars := self.x&quot;
 &amp; &quot;last.chars &amp;\n                            text_sub(self.xlast.chars, k,&quot;
 &amp; &quot; 1);\n        let v = graph_newVertex(self.graphvbt);\n        self.xla&quot;
 &amp; &quot;st.vtx[i + self.alphalen] := v;\n        graph_setVertexLabel(v, text_s&quot;
 &amp; &quot;ub(self.xlast.chars, k, 1));\n\tgraph_setVertexFont(v, self.vertexFont)&quot;
 &amp; &quot;;\n\tgraph_setVertexSize(v, 0.95, 0.95);\n\tgraph_setVertexBorder(v, 0.&quot;
 &amp; &quot;05);\n        graph_vertexToFront(v);\n  \tgraph_setVertexColor(v, alph&quot;
 &amp; &quot;aColor);\n  \tgraph_setVertexLabelColor(v, alphaLabelColor);\n\n       &quot;
 &amp; &quot; graph_setVertexColor(self.xlast.vtx[k], duplColor);\n        graph_set&quot;
 &amp; &quot;VertexLabelColor(self.xlast.vtx[k], duplLabelColor);\n\n\tlet pathfunc &quot;
 &amp; &quot;= makeDippingPath(float(k - self.alphalen),\n                          &quot;
 &amp; &quot;             float(i), ~2.0, 2.0);\n\tgraph_moveVertexOnPath(v, pathfun&quot;
 &amp; &quot;c);\n        zeus_animate(self.graphvbt, 1.0, 2.0);\n\tgraph_removeVert&quot;
 &amp; &quot;ex(self.codeSearchArrow);\n        self.codeSearchArrow := ok;\n\tlet v&quot;
 &amp; &quot; = self.codes.vtx[i];\n  \tgraph_setVertexColor(v, ghostColor);\n  \tgr&quot;
 &amp; &quot;aph_setVe&quot;;

CONST E28_3 =
   &quot;rtexLabelColor(v, ghostLabelColor);\n\tgraph_setVertexBorder(v, 0.05);\n&quot;
 &amp; &quot;\tgraph_redisplay(self.graphvbt);\n    end,\n\n    DecodeDone =&gt; meth(s&quot;
 &amp; &quot;elf, t, rowIndex)\n    (* Declare computed lastchars array. *)\n       &quot;
 &amp; &quot; self.last.chars := t;\n        self.last.vtx := array_sub(self.xlast.v&quot;
 &amp; &quot;tx, self.alphalen, self.n);\n\n(*****\n        for m = 0 to self.alphal&quot;
 &amp; &quot;en-1 do\n\t    graph_moveVertex(self.xlast.vtx[m],\n                   &quot;
 &amp; &quot;          float(m - (2 *self.alphalen)) - 4.0,\n\t\t\t     ~2.0, true);&quot;
 &amp; &quot;\n        end;\n*****)\n        (* ghost alpha vertices *)\n        for&quot;
 &amp; &quot; m = 0 to self.alphalen-1 do\n\t    graph_setVertexColor(self.xlast.vtx&quot;
 &amp; &quot;[m], ghostColor);\n\t    graph_setVertexLabelColor(self.xlast.vtx[m], g&quot;
 &amp; &quot;hostLabelColor);\n        end;\n\tzeus_animate(self.graphvbt, 0.0, 2.0 &quot;
 &amp; &quot;(*!!*));\n(****\n        for m = 0 to self.alphalen-1 do\n            g&quot;
 &amp; &quot;raph_removeVertex(self.xlast.vtx[m]);\n        end;\n****)\n\tgraph_red&quot;
 &amp; &quot;isplay(self.graphvbt);\n    end,\n\n    StartReconstruct =&gt; meth(self, &quot;
 &amp; &quot;lastchars, rowIndex)\n    (* Start of phase where we reconstruct the or&quot;
 &amp; &quot;iginal string from\n       lastchars and rowIndex.\n     *)\n        fo&quot;
 &amp; &quot;r i = 0 to self.n-1 do\n            let v = self.last.vtx[i];\n\t    gr&quot;
 &amp; &quot;aph_setVertexColor(self.last.vtx[i], initialColor);\n\t    graph_setVer&quot;
 &amp; &quot;texLabelColor(self.last.vtx[i], initialLabelColor);\n            graph_&quot;
 &amp; &quot;moveVertex(v, ~1.0, float(i), true);\n\n\t    let w = graph_newVertex(s&quot;
 &amp; &quot;elf.graphvbt);\n            graph_moveVertex(w, float(i), ~2.0, false);&quot;
 &amp; &quot;\n\t    graph_setVertexLabel(w, text_sub(self.last.chars, i, 1));\n\t  &quot;
 &amp; &quot;  graph_setVertexSize(w, 0.95, 0.95);\n\t    graph_setVertexColor(w, gh&quot;
 &amp; &quot;ostColor);\n            graph_setVertexLabelColor(w, ghostLabelColor);\n&quot;
 &amp; &quot;            graph_setVertexFont(w, self.vertexFont);\n            graph&quot;
 &amp; &quot;_setVertexBorder(w, 0.05);\n\n            zeus_animate(self.graphvbt, f&quot;
 &amp; &quot;loat(i)/float(self.n),\n                         (float(i)+1.0)/float(s&quot;
 &amp; &quot;elf.n));\n        end;\n    end,\n\n    FirstChars =&gt; meth(self, t)\n  &quot;
 &amp; &quot;  (* Declare sorted firstchars array. *)\n        self.first.vtx := arr&quot;
 &amp; &quot;ay_new(self.&quot;;

CONST E28_4 =
   &quot;n, ok);\n        self.first.pendingMoves := [];\n        self.first.vtx&quot;
 &amp; &quot;Color := array_new(self.n, ok);\n        self.first.chars := t;\n      &quot;
 &amp; &quot;  let tmp = array_new(self.n, ok);\n        for i = 0 to self.n-1 do\n &quot;
 &amp; &quot;           let v = graph_newVertex(self.graphvbt);\n            graph_m&quot;
 &amp; &quot;oveVertex(v, ~1.0, float(i), false);\n\t    graph_setVertexLabel(v, tex&quot;
 &amp; &quot;t_sub(self.last.chars, i, 1));\n\t    graph_setVertexShape(v, \&quot;rectang&quot;
 &amp; &quot;le\&quot;);\n\t    graph_setVertexSize(v, 0.95, 0.95);\n\t    graph_setVerte&quot;
 &amp; &quot;xColor(v, initialColor);\n            graph_setVertexLabelColor(v, init&quot;
 &amp; &quot;ialLabelColor);\n            graph_setVertexFont(v, self.vertexFont);\n&quot;
 &amp; &quot;            graph_setVertexBorder(v, 0.05);\n            graph_setVerte&quot;
 &amp; &quot;xColor(self.last.vtx[i], shadowColor);\n            graph_setVertexLabe&quot;
 &amp; &quot;lColor(self.last.vtx[i], shadowLabelColor);\n            tmp[i] := v;\n&quot;
 &amp; &quot;         end;\n         let moved = array_new(self.n, false);\n        &quot;
 &amp; &quot; for i = 0 to self.n-1 do\n             for j = 0 to self.n-1 do\n     &quot;
 &amp; &quot;            if not(moved[j]) and\n                    (text_char(self.f&quot;
 &amp; &quot;irst.chars, i) is\n                      text_char(self.last.chars, j))&quot;
 &amp; &quot;\n                 then\n                     graph_vertexToFront(tmp[j&quot;
 &amp; &quot;]);\n                     graph_moveVertex(tmp[j], 0.0, float(i), true)&quot;
 &amp; &quot;;\n                     self.first.vtx[i] := tmp[j];\n                 &quot;
 &amp; &quot;    moved[j] := true;\n                     zeus_animate(self.graphvbt,&quot;
 &amp; &quot;\n                         (float(i)) / 2.0,\n                         &quot;
 &amp; &quot;(float(i)+1.0) / 2.0 );\n                     exit;\n                 e&quot;
 &amp; &quot;nd;\n             end;\n         end;\n    end,\n\n    ConsiderChar =&gt; &quot;
 &amp; &quot;meth(self, i)\n    (* About to look for match for element i for firstch&quot;
 &amp; &quot;ars *)\n\tself.colorIndex := (self.colorIndex + 1) % #(charColors);\n\t&quot;
 &amp; &quot;let c = charColors[self.colorIndex];\n\tlet v = self.first.vtx[i];\n\tg&quot;
 &amp; &quot;raph_setVertexColor(v, c);\n\tgraph_redisplay(self.graphvbt);\n    end,&quot;
 &amp; &quot;\n\n\n    EqualChars =&gt; meth(self, i, j)\n    (* Decided element i of f&quot;
 &amp; &quot;irstchars matches element j of lastchars. *)\n\tlet c = charColors[self&quot;
 &amp; &quot;.col&quot;;

CONST E28_5 =
   &quot;orIndex];\n\tlet v = self.last.vtx[j];\n\tgraph_setVertexColor(v, c);\n&quot;
 &amp; &quot;        graph_redisplay(self.graphvbt);\n    end,\n\n    FinishCharRun &quot;
 &amp; &quot;=&gt; meth(self)\n    (* Done with a run of identical chars in firstchar c&quot;
 &amp; &quot;olumn. *)\n\tok\n    end,\n\n    StartResult =&gt; meth(self)\n    (* Setu&quot;
 &amp; &quot;p to pick off result chars. *)\n\tfor i = 0 to self.n - 1 do\n\t    let&quot;
 &amp; &quot; v = graph_newVertex(self.graphvbt);\n\t    self.rowIndices[i] := v;\n\t&quot;
 &amp; &quot;    graph_setVertexLabel(v, fmt_int(i));\n\t    graph_setVertexFont(v, &quot;
 &amp; &quot;self.vertexFont);\n\t    graph_setVertexColor(v, otherIndexColor);\n\t &quot;
 &amp; &quot;   graph_setVertexLabelColor(v, otherIndexLabelColor);\n\t    graph_mov&quot;
 &amp; &quot;eVertex(v, ~2.0, float(i), false);\n\t    graph_setVertexSize(v, 0.95, &quot;
 &amp; &quot;0.95);\n\tend;\n\tgraph_redisplay(self.graphvbt);\n\n        let v = gr&quot;
 &amp; &quot;aph_newVertex(self.graphvbt);\n\tgraph_setVertexLabel(v, fmt_int(self.r&quot;
 &amp; &quot;owIndex));\n\tgraph_setVertexFont(v, self.vertexFont);\n\tgraph_setVert&quot;
 &amp; &quot;exColor(v, ghostColor);\n\tgraph_setVertexLabelColor(v, ghostLabelColor&quot;
 &amp; &quot;);\n\tgraph_setVertexShape(v, \&quot;ellipse\&quot;);\n\tgraph_moveVertex(v, floa&quot;
 &amp; &quot;t(self.n), ~4.25, false);\n\tgraph_setVertexBorder(v, 0.05);\n\tgraph_v&quot;
 &amp; &quot;ertexToFront(self.rowIndexVtx);\n\tgraph_setVertexSize(v, 0.95, 0.95);\n&quot;
 &amp; &quot;\tgraph_moveVertex(self.rowIndexVtx, ~2.0, float(self.rowIndex), true);&quot;
 &amp; &quot;\n\tzeus_animate(self.graphvbt, 0.0, 1.0);\n    end,\n\n    ResultNextC&quot;
 &amp; &quot;har =&gt; meth(self, pos, k)\n    (* Pick off the pos\'th element of first&quot;
 &amp; &quot;chars and put into the\n       k\'th position in the result string. *)\n&quot;
 &amp; &quot;       if pos is self.rowIndex then\n\t    (* Just gray out the extra c&quot;
 &amp; &quot;opy of the last character *)\n    \t    let v = self.last.vtx[self.rowI&quot;
 &amp; &quot;ndex];\n\t    graph_setVertexColor(v, ghostColor);\n\t    graph_setVert&quot;
 &amp; &quot;exLabelColor(v, ghostLabelColor);\n       else\n           let sv1 = se&quot;
 &amp; &quot;lf.last.vtx[pos];\n           self.last.vtx[pos] := graph_newVertex(sel&quot;
 &amp; &quot;f.graphvbt);\n           let sv2 = self.first.vtx[pos];\n           sel&quot;
 &amp; &quot;f.first.vtx[pos] := graph_newVertex(self.graphvbt);\n           graph_m&quot;
 &amp; &quot;oveVertex(self.last.vtx[pos], ~1.0, float(pos), false);\n           gra&quot;
 &amp; &quot;ph_setVertexLabel(self.l&quot;;

CONST E28_6 =
   &quot;ast.vtx[pos],\n                                text_sub(self.last.chars&quot;
 &amp; &quot;, pos, 1));\n           graph_setVertexSize(self.last.vtx[pos], 0.95, 0&quot;
 &amp; &quot;.95);\n           graph_setVertexColor(self.last.vtx[pos], ghostColor);&quot;
 &amp; &quot;\n           graph_setVertexLabelColor(self.last.vtx[pos], ghostLabelCo&quot;
 &amp; &quot;lor);\n           graph_setVertexFont(self.last.vtx[pos], self.vertexFo&quot;
 &amp; &quot;nt);\n           graph_setVertexBorder(self.last.vtx[pos], 0.05);\n    &quot;
 &amp; &quot;       graph_moveVertex(self.first.vtx[pos], 0.0, float(pos), false);\n&quot;
 &amp; &quot;           graph_setVertexLabel(self.first.vtx[pos],\n                 &quot;
 &amp; &quot;               text_sub(self.first.chars, pos, 1));\n           graph_s&quot;
 &amp; &quot;etVertexSize(self.first.vtx[pos], 0.95, 0.95);\n           graph_setVer&quot;
 &amp; &quot;texColor(self.first.vtx[pos], ghostColor);\n           graph_setVertexL&quot;
 &amp; &quot;abelColor(self.first.vtx[pos], ghostLabelColor);\n           graph_setV&quot;
 &amp; &quot;ertexFont(self.first.vtx[pos], self.vertexFont);\n           graph_setV&quot;
 &amp; &quot;ertexBorder(self.first.vtx[pos], 0.05);\n\n           graph_vertexToFro&quot;
 &amp; &quot;nt(sv1);\n           graph_vertexToFront(sv2);\n           graph_moveVe&quot;
 &amp; &quot;rtex(sv1, float(k-1), float(self.rowIndex),\n                          &quot;
 &amp; &quot;  true);\n           graph_moveVertex(sv2, float(k), float(self.rowInde&quot;
 &amp; &quot;x),\n                            true);\n       end;\n       zeus_anima&quot;
 &amp; &quot;te(self.graphvbt, 0.0, 1.0);\n    end,\n\n    EndResult =&gt; meth(self)\n&quot;
 &amp; &quot;    (* Done *)\n\tfor i = 0 to self.n - 1 do\n\t    graph_setVertexColo&quot;
 &amp; &quot;r(self.rowIndices[i], ghostColor);\n   \t    graph_setVertexLabelColor(&quot;
 &amp; &quot;self.rowIndices[i], ghostLabelColor);\n        end;\n\tgraph_setVertexC&quot;
 &amp; &quot;olor(self.rowIndexVtx, ghostColor);\n\tgraph_setVertexLabelColor(self.r&quot;
 &amp; &quot;owIndexVtx, ghostLabelColor);\n\tgraph_redisplay(self.graphvbt);\n    e&quot;
 &amp; &quot;nd\n\n  };\n&quot;;

CONST E29 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:29:09 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Sort&quot;
 &amp; &quot;.evt.\n;***************************************************************&quot;
 &amp; &quot;*****\n\n(VBox\n  (Border (Pen 1)\n    (Shape\n      (Height 75 - 25 + &quot;
 &amp; &quot;Inf)\n      (Viewport\n        (HBox\n          (Glue 4 + Inf)\n       &quot;
 &amp; &quot;   (VBox\n            (Glue 6)\n            (Shape (Height 16 + 0)\n   &quot;
 &amp; &quot;           (HBox Fill (Shape (Width + 0) (Height + 0) \n               &quot;
 &amp; &quot;                 \&quot;Code View events:   Stop? \&quot;) \n                    &quot;
 &amp; &quot;(Boolean %stopatCodeEvents =TRUE \&quot;\&quot;)\n                    (Glue 10)\n&quot;
 &amp; &quot;                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n    &quot;
 &amp; &quot;                (Shape (Width 80) (Numeric %waitatCodeEvents =1 \n     &quot;
 &amp; &quot;                                          (Min 0) (Max 100)))))\n      &quot;
 &amp; &quot;      (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox&quot;
 &amp; &quot; Fill (Shape (Width + 0) (Height + 0) \n                               &quot;
 &amp; &quot; \&quot;Init:   Stop? \&quot;) \n                    (Boolean %stopAtInit =TRUE \&quot;&quot;
 &amp; &quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Width +&quot;
 &amp; &quot; 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (&quot;
 &amp; &quot;Numeric %waitAtInit =1 \n                                              &quot;
 &amp; &quot; (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape (Heigh&quot;
 &amp; &quot;t 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n &quot;
 &amp; &quot;                               \&quot;SetVal:   Stop? \&quot;) \n                &quot;
 &amp; &quot;    (Boolean %stopAtSetVal =TRUE \&quot;\&quot;)\n                    (Glue 10)\n&quot;
 &amp; &quot;                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n    &quot;
 &amp; &quot;                (Shape (Width 80) (Numeric %waitAtSetVal =1 \n         &quot;
 &amp; &quot;                                      (Min 0) (Max 100)))))\n          &quot;
 &amp; &quot;  (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox Fil&quot;
 &amp; &quot;l (Sha&quot;;

CONST E29_0 =
   &quot;pe (Width + 0) (Height + 0) \n                                \&quot;SwapElt&quot;
 &amp; &quot;s:   Stop? \&quot;) \n                    (Boolean %stopAtSwapElts =TRUE \&quot;\&quot;&quot;
 &amp; &quot;)\n                    (Glue 10)\n                    (Shape (Width + 0&quot;
 &amp; &quot;) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Nu&quot;
 &amp; &quot;meric %waitAtSwapElts =1 \n                                            &quot;
 &amp; &quot;   (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape (Hei&quot;
 &amp; &quot;ght 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n&quot;
 &amp; &quot;                                \&quot;StartPass:   Stop? \&quot;) \n            &quot;
 &amp; &quot;        (Boolean %stopAtStartPass =TRUE \&quot;\&quot;)\n                    (Glu&quot;
 &amp; &quot;e 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;&quot;
 &amp; &quot;)\n                    (Shape (Width 80) (Numeric %waitAtStartPass =1 \n&quot;
 &amp; &quot;                                               (Min 0) (Max 100)))))\n &quot;
 &amp; &quot;           (Glue 6)\n          )\n          (Glue 4)\n          (VBox\n&quot;
 &amp; &quot;            (Glue 5)\n            (Shape (Width + 0) (Height 16 + 0) \&quot;&quot;
 &amp; &quot;Cts:\&quot;)\n            (Button %eventCounts\n              (VBox\n       &quot;
 &amp; &quot;         (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Heigh&quot;
 &amp; &quot;t 16 + 0) \n                                  (Text %ctOfInit \&quot;0\&quot;)))\n&quot;
 &amp; &quot;                (Glue 6)\n                (HBox Fill (Shape (Width + 0)&quot;
 &amp; &quot; (Height 16 + 0) \n                                  (Text %ctOfSetVal &quot;
 &amp; &quot;\&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Shape (&quot;
 &amp; &quot;Width + 0) (Height 16 + 0) \n                                  (Text %c&quot;
 &amp; &quot;tOfSwapElts \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox F&quot;
 &amp; &quot;ill (Shape (Width + 0) (Height 16 + 0) \n                              &quot;
 &amp; &quot;    (Text %ctOfStartPass \&quot;0\&quot;)))\n                (Glue 3))))\n       &quot;
 &amp; &quot;   Fill\n          (Glue 4 + Inf)\n        )\n      )\n    )\n  )\n)\n&quot;;

CONST E30 =
   &quot;; Copyright (C) 1992, Digital Equipment Corporation\n; All rights reser&quot;
 &amp; &quot;ved.\n; See the file COPYRIGHT for a full description.\n\n(Scale\n  (HS&quot;
 &amp; &quot;cale 1)\n  (VScale 1)\n  (LabelFont (Family \&quot;Courier\&quot;))\n  (Rim\n    &quot;
 &amp; &quot;(Pen 10)\n    (VBox\n      (Shape\n        (Height + 0)\n        (HBox\n&quot;
 &amp; &quot;          (Shape\n            (Width + 0)\n            (HBox\n         &quot;
 &amp; &quot;     (VBox (Text \&quot;Vertex: \&quot;) (Text RightAlign \&quot;val: \&quot;))\n          &quot;
 &amp; &quot;    (VBox\n                (Font (Family \&quot;Courier\&quot;))\n               &quot;
 &amp; &quot; (Text\n                  LeftAlign\n                  \&quot;A B C D E F G &quot;
 &amp; &quot;H I J K L M\&quot;)\n                (Text\n                  LeftAlign\n   &quot;
 &amp; &quot;               %val\n                  \&quot;* * * * * * * * * * * * *\&quot;)))&quot;
 &amp; &quot;)\n          Fill))\n      Fill)))\n&quot;;

CONST E31 =
   &quot;(* Copyright 1993 Digital Equipment Corporation.                       &quot;
 &amp; &quot;      *)\n(* Distributed only by permission.                           &quot;
 &amp; &quot;                *)\n(*                                                 &quot;
 &amp; &quot;                          *)\n(* Last modified on Thu Oct 14 17:06:57 P&quot;
 &amp; &quot;DT 1993 by heydon                   *)\n(*      modified on Tue Aug 10 &quot;
 &amp; &quot;23:56:52 PDT 1993 by rsanchez                 *)\n\n(* This view shows &quot;
 &amp; &quot;the total number of steps that each packet needs *)\n(* to traverse to &quot;
 &amp; &quot;go from its source to its destination node.       *)\n(* (Condensed Ver&quot;
 &amp; &quot;sion).                                             *)\n\nlet MoveColor &quot;
 &amp; &quot;= color_named(\&quot;Green\&quot;);\nlet NoMoveColor = color_named(\&quot;Yellow\&quot;);\n&quot;
 &amp; &quot;let BlockedColor = color_named(\&quot;Red\&quot;);\nlet InitialColor = color_name&quot;
 &amp; &quot;d(\&quot;Black\&quot;);\nlet FinishedColor = color_named(\&quot;Black\&quot;);\nlet LabelCo&quot;
 &amp; &quot;lor = color_named(\&quot;Black\&quot;);\nlet BackgroundColor = color_named(\&quot;Whit&quot;
 &amp; &quot;e\&quot;);\nlet EdgeColor = color_named(\&quot;Black\&quot;);\nlet BorderColor = color&quot;
 &amp; &quot;_named(\&quot;Black\&quot;);\n\nlet CondColor = [MoveColor, NoMoveColor, BlockedC&quot;
 &amp; &quot;olor];\n\nlet moveIndx = 0;\nlet noMoveIndx = 1;\nlet blockedIndx = 2;\n&quot;
 &amp; &quot;\nlet BarWidth = 0.40;\nlet Gap = 0.05;\nlet SouthInit = ~3.0;\nlet Bor&quot;
 &amp; &quot;derSize = 0.0;\nlet ScaleFactor = 1.5;\n\nlet PartialColumns = 3;\nlet &quot;
 &amp; &quot;TotalColumnIndex = 3;\nlet LabelColumns = 4;\n\nlet FontFromSize =\n  p&quot;
 &amp; &quot;roc(g, sz)\n      graph_newFont(g, \&quot;Helvetica\&quot;, sz, \&quot;Roman\&quot;, \&quot;bold&quot;
 &amp; &quot;\&quot;, \&quot;*\&quot;)\n  end;\n\nlet MoveTextVertex =\n  proc(vtx, font, width, he&quot;
 &amp; &quot;ight, x, y)\n    graph_setVertexFont(vtx, font);\n    graph_moveVertex(&quot;
 &amp; &quot;vtx, x, y, false);\n    graph_setVertexSize(vtx, width, height);\n  end&quot;
 &amp; &quot;;\n\nlet MakeTextVertex =\n  proc(vtx, font, width, height, x, y)\n    &quot;
 &amp; &quot;graph_setVertexColor(vtx, BackgroundColor);\n    graph_setVertexLabelCo&quot;
 &amp; &quot;lor(vtx, LabelColor);\n    MoveTextVertex(vtx, font, width, height, x, &quot;
 &amp; &quot;y)\n  end;\n\nlet MoveBlockVertex =\n  proc(vtx, width, height, x, y)\n&quot;
 &amp; &quot;    graph_setVertexSize(vtx, width, height);\n    graph_moveVertex(vtx,&quot;
 &amp; &quot; x, y, false);\n  end;\n    \nlet MakeBlockVertex =\n  proc(vtx, clr, w&quot;
 &amp; &quot;idth, height, x, y)\n    grap&quot;;

CONST E31_0 =
   &quot;h_setVertexBorder(vtx, 0.05);\n    graph_setVertexBorderColor(vtx, Bord&quot;
 &amp; &quot;erColor); \n    graph_setVertexColor(vtx, clr);\n    MoveBlockVertex(vt&quot;
 &amp; &quot;x, width, height, x, y)\n  end;\n\nlet view =\n  {\n    graphvbt =&gt; gra&quot;
 &amp; &quot;ph_new(),\n    pktCnt =&gt; ok,\n    steps =&gt; 0,\n    maxSteps =&gt; ok,\n   &quot;
 &amp; &quot; hopsT =&gt; ok,\n    vtxFont =&gt; ok,\n    fontSize =&gt; 0.5,\n    border =&gt; &quot;
 &amp; &quot;BorderSize,\n    labelH =&gt; 1.0,\n    yLabels1 =&gt; ok,\n    yLabels2 =&gt; o&quot;
 &amp; &quot;k,\n    yLabels3 =&gt; ok,\n    labels1 =&gt; ok,\n    labels2 =&gt; ok,\n    la&quot;
 &amp; &quot;bels3 =&gt; ok,\n    totalMove =&gt; 0,\n    totalNoMove =&gt; 0,\n    totalBloc&quot;
 &amp; &quot;ked =&gt; 0,\n    east =&gt; ok,\n    west =&gt; ok,\n    north =&gt; ok,\n    sout&quot;
 &amp; &quot;h =&gt; ok,\n    labelW =&gt; meth(self) (self.east - self.west) / float(Labe&quot;
 &amp; &quot;lColumns+2) end,\n\n    xLoc =&gt; meth(self, index)\n       self.west + (&quot;
 &amp; &quot;self.labelW * float(index+1))\n    end,\n\n    StartPackets =&gt; meth (se&quot;
 &amp; &quot;lf, pktCnt)\n      self.west := ~1.0;\n      self.east := float(pktCnt)&quot;
 &amp; &quot;;\n      self.north := 11.0;\n      self.south := ~4.0;\n      self.max&quot;
 &amp; &quot;Steps := 10.0;\n      self.fontSize := 1.0;\n      self.yLabels1 := ~1.&quot;
 &amp; &quot;0;\n      self.yLabels2 := ~2.0;\n      self.yLabels3 := ~3.0;\n      g&quot;
 &amp; &quot;raph_setWorld(self.graphvbt, \n                     self.west, self.eas&quot;
 &amp; &quot;t, self.north, self.south);\n      self.vtxFont := FontFromSize(self.gr&quot;
 &amp; &quot;aphvbt, self.fontSize);\n\n      self.pktCnt := pktCnt;\n\n      self.h&quot;
 &amp; &quot;opsT := array_new(pktCnt, ok);\n      self.labels1 := array_new(LabelCo&quot;
 &amp; &quot;lumns, ok);\n      self.labels2 := array_new(LabelColumns, ok);\n      &quot;
 &amp; &quot;self.labels3 := array_new(LabelColumns, ok);\n\n      for i = 0 to pktC&quot;
 &amp; &quot;nt-1 do\n        let vtx1 = graph_newVertex(self.graphvbt);\n        gr&quot;
 &amp; &quot;aph_vertexToBack(vtx1);\n\tgraph_setVertexBorder(vtx1, self.border);\n\t&quot;
 &amp; &quot;graph_setVertexBorderColor(vtx1, BackgroundColor); \n\tgraph_setVertexC&quot;
 &amp; &quot;olor(vtx1, MoveColor);\n\tgraph_moveVertex(vtx1, float(i), self.border/&quot;
 &amp; &quot;2.0, false);\n\tgraph_setVertexSize(vtx1, 0.95, self.border);\n\tself.h&quot;
 &amp; &quot;opsT[i] := {\n          minNumHops =&gt; 0,\n\t  moved =&gt; false,\n\t  bloc&quot;
 &amp; &quot;ked =&gt; false,\n\t  progress =&gt; true,\n\t  finished =&gt; false,\n\t  src =&quot;
 &amp; &quot;&gt; ok,\n\t  dst =&gt; ok,\n\t &quot;;

CONST E31_1 =
   &quot; vmove =&gt; vtx1,\n\t  vlastblocked =&gt; ok,\n\t  blockedTempCnt =&gt; 0,\n\t &quot;
 &amp; &quot; vlastnomove =&gt; ok,\n\t  noMoveTempCnt =&gt; 0\n        };\n      end;\n  &quot;
 &amp; &quot;    for i = 0 to PartialColumns - 1 do\n        self.labels1[i] := grap&quot;
 &amp; &quot;h_newVertex(self.graphvbt); \n        MakeBlockVertex(self.labels1[i], &quot;
 &amp; &quot;CondColor[i], \n                        self.labelW, self.labelH,\n    &quot;
 &amp; &quot;                    self.xLoc(i), self.yLabels1);\n      end;\n\n      &quot;
 &amp; &quot;self.labels1[TotalColumnIndex] := graph_newVertex(self.graphvbt);\n\n  &quot;
 &amp; &quot;    MakeTextVertex(self.labels1[TotalColumnIndex], self.vtxFont, \n    &quot;
 &amp; &quot;                 self.labelW * 2.0, self.labelH,\n                     &quot;
 &amp; &quot;self.xLoc(TotalColumnIndex+1), self.yLabels1);\n\n      graph_setVertex&quot;
 &amp; &quot;Label(self.labels1[TotalColumnIndex], \&quot;Total:\&quot;);\n\n      for i = 0 t&quot;
 &amp; &quot;o PartialColumns - 1 do                        \n        self.labels2[i&quot;
 &amp; &quot;] := graph_newVertex(self.graphvbt);\n        MakeTextVertex(self.label&quot;
 &amp; &quot;s2[i], self.vtxFont, \n                        self.labelW, self.labelH&quot;
 &amp; &quot;,\n                        self.xLoc(i), self.yLabels2);\n        graph&quot;
 &amp; &quot;_setVertexLabel(self.labels2[i], \&quot;0\&quot;);\n\n        self.labels3[i] := &quot;
 &amp; &quot;graph_newVertex(self.graphvbt);\n        MakeTextVertex(self.labels3[i]&quot;
 &amp; &quot;, self.vtxFont, \n                        self.labelW, self.labelH,\n  &quot;
 &amp; &quot;                      self.xLoc(i), self.yLabels3);\n        graph_setV&quot;
 &amp; &quot;ertexLabel(self.labels3[i], \&quot;0%\&quot;);\n      end;\n\n      self.labels2[&quot;
 &amp; &quot;TotalColumnIndex] := graph_newVertex(self.graphvbt);\n      MakeTextVer&quot;
 &amp; &quot;tex(self.labels2[TotalColumnIndex], self.vtxFont, \n                   &quot;
 &amp; &quot;   self.labelW, self.labelH,\n                      self.xLoc(TotalColu&quot;
 &amp; &quot;mnIndex+1), self.yLabels2);\n      graph_setVertexLabel(self.labels2[To&quot;
 &amp; &quot;talColumnIndex], \&quot;0\&quot;);\n\n      self.labels3[TotalColumnIndex] := gra&quot;
 &amp; &quot;ph_newVertex(self.graphvbt);\n      MakeTextVertex(self.labels3[TotalCo&quot;
 &amp; &quot;lumnIndex], self.vtxFont, \n                      self.labelW * 2.0, se&quot;
 &amp; &quot;lf.labelH,\n                      self.xLoc(TotalColumnIndex+1), self.y&quot;
 &amp; &quot;Labels3);\n      graph_setVertexLabel(self.labels3[TotalColumnIndex], &quot;;

CONST E31_2 =
   &quot;\&quot;0 Step(s)\&quot;);\n\n    end,\n\n    NewPacket =&gt; meth (self, id, source,&quot;
 &amp; &quot; dest, fewestHops, name)\n      self.hopsT[id].minNumHops := fewestHops&quot;
 &amp; &quot;;\n      self.hopsT[id].src := source;\n      self.hopsT[id].dst := des&quot;
 &amp; &quot;t;\n    end,\n\n    EndPackets =&gt; meth (self)\n      graph_redisplay(se&quot;
 &amp; &quot;lf.graphvbt);\n    end,\n\n    Blocked =&gt; meth(self, id, fromN, toN)\n &quot;
 &amp; &quot;     self.hopsT[id].blocked := true;\n      self.totalBlocked := self.t&quot;
 &amp; &quot;otalBlocked + 1;\n    end,\n\n    MovePacket =&gt; meth(self, id, fromN, t&quot;
 &amp; &quot;oN) \n      self.hopsT[id].moved := true;\n      self.totalMove := self&quot;
 &amp; &quot;.totalMove + 1; \n    end,\n\n    Absorb =&gt; meth(self, id, node)\n     &quot;
 &amp; &quot; self.hopsT[id].progress := false;\n    end,\n\n    Step =&gt; meth (self)&quot;
 &amp; &quot;\n      let Percent = proc(num, denom)\n        fmt_int(round((100.0 * &quot;
 &amp; &quot;float(num)) / float(denom))) &amp; \&quot;%\&quot;\n      end;\n\n      self.steps :=&quot;
 &amp; &quot; self.steps + 1;\n      if float(self.steps) &gt; self.maxSteps then\n    &quot;
 &amp; &quot;    self.maxSteps := self.maxSteps * ScaleFactor;\n        self.north :&quot;
 &amp; &quot;= self.north * ScaleFactor;\n\tself.south := self.south * ScaleFactor;\n&quot;
 &amp; &quot;\tself.fontSize := self.fontSize * ScaleFactor;\n\tself.border := self.&quot;
 &amp; &quot;border * ScaleFactor;\n\tself.labelH := self.labelH * ScaleFactor;\n   &quot;
 &amp; &quot;     self.yLabels1 := self.yLabels1 * ScaleFactor;\n        self.yLabel&quot;
 &amp; &quot;s2 := self.yLabels2 * ScaleFactor;\n        self.yLabels3 := self.yLabe&quot;
 &amp; &quot;ls3 * ScaleFactor;\n\n        var index = ok, width = ok;\n\tfor i = 0 &quot;
 &amp; &quot;to LabelColumns - 1 do\n\t  index := i; width := self.labelW;\n        &quot;
 &amp; &quot;  if i is TotalColumnIndex then\n            index := index + 1;\n     &quot;
 &amp; &quot;       width := width * 2.0\n          end;\n\t  MoveBlockVertex(self.l&quot;
 &amp; &quot;abels1[i], \n\t    width, self.labelH, self.xLoc(index), self.yLabels1)&quot;
 &amp; &quot;;\n          MoveTextVertex(self.labels2[i], self.vtxFont,\n           &quot;
 &amp; &quot; width, self.labelH, self.xLoc(index), self.yLabels2);\n          MoveT&quot;
 &amp; &quot;extVertex(self.labels3[i], self.vtxFont,\n            width, self.label&quot;
 &amp; &quot;H, self.xLoc(index), self.yLabels3);\n\tend;\n\n        graph_setWorld(&quot;
 &amp; &quot;self.graphvbt, \n          self.west, self.east, self.north, self.south&quot;
 &amp; &quot;);\n      end;\n&quot;;

CONST E31_3 =
   &quot;\n      for i = 0 to self.pktCnt-1 do\n\tif self.hopsT[i].finished is f&quot;
 &amp; &quot;alse then\n          if self.hopsT[i].moved is false then\n            &quot;
 &amp; &quot;if self.hopsT[i].blocked is true then\n\t      self.hopsT[i].blocked :=&quot;
 &amp; &quot; false;\n\t      if self.hopsT[i].vlastnomove isnot ok then\n\t\tself.h&quot;
 &amp; &quot;opsT[i].vlastnomove := ok;\n\t\tself.hopsT[i].noMoveTempCnt := 0;\n    &quot;
 &amp; &quot;          end;\n\t      if self.hopsT[i].vlastblocked is ok then\n\t\tl&quot;
 &amp; &quot;et vblocked = graph_newVertex(self.graphvbt);\n\t\tgraph_setVertexBorde&quot;
 &amp; &quot;r(vblocked, self.border);\n\t\tgraph_setVertexBorderColor(vblocked, col&quot;
 &amp; &quot;or_rgb(0.0, 0.0, 0.0));\n\t\tgraph_setVertexColor(vblocked, BlockedColo&quot;
 &amp; &quot;r);\n\t\tgraph_moveVertex(vblocked,\n\t\t\t\t  float(i), float(self.ste&quot;
 &amp; &quot;ps) - 0.5, false);\n                graph_setVertexSize(vblocked,  0.95&quot;
 &amp; &quot;, 1.0);\n\t\tself.hopsT[i].vlastblocked:= vblocked;\n\t\tself.hopsT[i].&quot;
 &amp; &quot;blockedTempCnt := 1;\n              else\n\t\tself.hopsT[i].blockedTemp&quot;
 &amp; &quot;Cnt := \n                                    self.hopsT[i].blockedTempC&quot;
 &amp; &quot;nt + 1;\n\t\tgraph_moveVertex(self.hopsT[i].vlastblocked,\n\t\t        &quot;
 &amp; &quot;         float(i),\n\t\t                 float(self.steps) -\n\t\t     &quot;
 &amp; &quot;               (float(self.hopsT[i].blockedTempCnt)/2.0),\n\t\t        &quot;
 &amp; &quot;         false);\n                graph_setVertexSize(self.hopsT[i].vla&quot;
 &amp; &quot;stblocked,\n\t\t\t\t    0.95, float(self.hopsT[i].blockedTempCnt));\n  &quot;
 &amp; &quot;            end;\n            else\n\t      if self.hopsT[i].vlastblock&quot;
 &amp; &quot;ed isnot ok then\n\t\tself.hopsT[i].vlastblocked := ok;\n\t\tself.hopsT&quot;
 &amp; &quot;[i].blockedTempCnt := 0;\n\t      end;\n              self.totalNoMove &quot;
 &amp; &quot;:= self.totalNoMove + 1;\n\t      if self.hopsT[i].vlastnomove is ok th&quot;
 &amp; &quot;en\n\t        let vnomove = graph_newVertex(self.graphvbt);\n\t        &quot;
 &amp; &quot;graph_setVertexBorder(vnomove, self.border);\n\t        graph_setVertex&quot;
 &amp; &quot;BorderColor(vnomove, color_rgb(0.0, 0.0, 0.0)); \n\t        graph_setVe&quot;
 &amp; &quot;rtexColor(vnomove, NoMoveColor);\n\t        graph_moveVertex(vnomove, \n&quot;
 &amp; &quot;\t\t\t       float(i), float(self.steps) - 0.5, false);\n              &quot;
 &amp; &quot;  graph_setVertexSize(vnomove, 0.95, 1.0); \n\t        self.hopsT[i].vl&quot;
 &amp; &quot;astnomove := vnomove;\n\t        self.hopsT[i&quot;;

CONST E31_4 =
   &quot;].noMoveTempCnt := 1;\n              else\n\t        self.hopsT[i].noMo&quot;
 &amp; &quot;veTempCnt := self.hopsT[i].noMoveTempCnt + 1;\n                graph_mo&quot;
 &amp; &quot;veVertex(self.hopsT[i].vlastnomove,\n\t\t  float(i),  \n\t\t  float(sel&quot;
 &amp; &quot;f.steps)-(float(self.hopsT[i].noMoveTempCnt)/2.0),\n\t          false);&quot;
 &amp; &quot;\n                graph_setVertexSize(self.hopsT[i].vlastnomove, \n\t\t&quot;
 &amp; &quot;\t\t  0.95, float(self.hopsT[i].noMoveTempCnt));\n              end;\n &quot;
 &amp; &quot;           end;\n          else\n\t    self.hopsT[i].moved := false;\n\t&quot;
 &amp; &quot;    self.hopsT[i].vlastnomove := ok;\n\t    self.hopsT[i].noMoveTempCnt&quot;
 &amp; &quot; := 0;\n\t    self.hopsT[i].vlastblocked := ok;\n\t    self.hopsT[i].bl&quot;
 &amp; &quot;ockedTempCnt := 0;\n            graph_moveVertex(self.hopsT[i].vmove, f&quot;
 &amp; &quot;loat(i),\n\t                     float(self.steps)/2.0, false);\n      &quot;
 &amp; &quot;      graph_setVertexSize(self.hopsT[i].vmove, 0.95, float(self.steps))&quot;
 &amp; &quot;;\n          end;\n\n          if self.hopsT[i].progress isnot true the&quot;
 &amp; &quot;n\n\t    self.hopsT[i].finished := true;\n\t    let vtx = graph_newVert&quot;
 &amp; &quot;ex(self.graphvbt);\n\t    graph_setVertexColor(vtx, FinishedColor);\n\t&quot;
 &amp; &quot;    graph_moveVertex(vtx, float(i),\n\t\t\t     float(self.steps+1) - 0&quot;
 &amp; &quot;.75, false);\n            graph_setVertexSize(vtx, 0.96, 0.5);\n       &quot;
 &amp; &quot;   end;\n\n\tend;\n      end;\n\n      graph_setVertexLabel(self.labels&quot;
 &amp; &quot;2[0], fmt_int(self.totalMove));\n      graph_setVertexLabel(self.labels&quot;
 &amp; &quot;2[1], fmt_int(self.totalNoMove));\n      graph_setVertexLabel(self.labe&quot;
 &amp; &quot;ls2[2], fmt_int(self.totalBlocked));\n\n      let sum = self.totalMove &quot;
 &amp; &quot;+ self.totalNoMove + self.totalBlocked;\n      graph_setVertexLabel(sel&quot;
 &amp; &quot;f.labels2[3], fmt_int(sum));\n\n      let sum = self.totalMove + self.t&quot;
 &amp; &quot;otalNoMove + self.totalBlocked;\n      graph_setVertexLabel(self.labels&quot;
 &amp; &quot;3[0],\n                           Percent(self.totalMove, sum));\n     &quot;
 &amp; &quot; graph_setVertexLabel(self.labels3[1],\n                           Perc&quot;
 &amp; &quot;ent(self.totalNoMove, sum));\n      graph_setVertexLabel(self.labels3[2&quot;
 &amp; &quot;],\n                           Percent(self.totalBlocked, sum));\n     &quot;
 &amp; &quot; graph_setVertexLabel(self.labels3[3], fmt_int(self.steps) &amp; \&quot; Step(s)&quot;
 &amp; &quot;\&quot;);\n\n      gr&quot;;

CONST E31_5 =
   &quot;aph_redisplay(self.graphvbt);\n    end\n  };\n&quot;;

CONST E32 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:37:06 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Bres&quot;
 &amp; &quot;enham.evt.\n;**********************************************************&quot;
 &amp; &quot;**********\n\n(VBox\n  (Rim\n    (Pen 2)\n    (HBox\n      (VBox (Glue &quot;
 &amp; &quot;4) (Shape (Height + Inf) (Button %clear \&quot;CLEAR\&quot;)) (Glue 4))\n      (G&quot;
 &amp; &quot;lue 4)\n      (VBox\n        (Boolean =TRUE %alg (Text LeftAlign \&quot;Algo&quot;
 &amp; &quot;rithm events\&quot;))\n        (Boolean =FALSE %zeus (Text LeftAlign \&quot;Zeus &quot;
 &amp; &quot;events\&quot;))\n        (Boolean =TRUE %args (Text LeftAlign \&quot;Display args&quot;
 &amp; &quot; to events\&quot;)))\n      Fill))\n  (Bar 1)\n  (Shape (ShadowSize 0) (Heig&quot;
 &amp; &quot;ht 200 + INF) (TextEdit ReadOnly %transcript)))\n&quot;;

CONST E33 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:37:06 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Maxf&quot;
 &amp; &quot;low.evt.\n;************************************************************&quot;
 &amp; &quot;********\n\n(VBox\n  (Rim\n    (Pen 2)\n    (HBox\n      (VBox (Glue 4)&quot;
 &amp; &quot; (Shape (Height + Inf) (Button %clear \&quot;CLEAR\&quot;)) (Glue 4))\n      (Glu&quot;
 &amp; &quot;e 4)\n      (VBox\n        (Boolean =TRUE %alg (Text LeftAlign \&quot;Algori&quot;
 &amp; &quot;thm events\&quot;))\n        (Boolean =FALSE %zeus (Text LeftAlign \&quot;Zeus ev&quot;
 &amp; &quot;ents\&quot;))\n        (Boolean =TRUE %args (Text LeftAlign \&quot;Display args t&quot;
 &amp; &quot;o events\&quot;)))\n      Fill))\n  (Bar 1)\n  (Shape (ShadowSize 0) (Height&quot;
 &amp; &quot; 200 + INF) (TextEdit ReadOnly %transcript)))\n&quot;;

CONST E34 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:29:09 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file PQue&quot;
 &amp; &quot;ue.evt.\n;*************************************************************&quot;
 &amp; &quot;*******\n\n(VBox\n  (Border (Pen 1)\n    (Shape\n      (Height 75 - 25 &quot;
 &amp; &quot;+ Inf)\n      (Viewport\n        (HBox\n          (Glue 4 + Inf)\n     &quot;
 &amp; &quot;     (VBox\n            (Glue 6)\n            (Shape (Height 16 + 0)\n &quot;
 &amp; &quot;             (HBox Fill (Shape (Width + 0) (Height + 0) \n             &quot;
 &amp; &quot;                   \&quot;Code View events:   Stop? \&quot;) \n                  &quot;
 &amp; &quot;  (Boolean %stopatCodeEvents =TRUE \&quot;\&quot;)\n                    (Glue 10)&quot;
 &amp; &quot;\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n  &quot;
 &amp; &quot;                  (Shape (Width 80) (Numeric %waitatCodeEvents =1 \n   &quot;
 &amp; &quot;                                            (Min 0) (Max 100)))))\n    &quot;
 &amp; &quot;        (Glue 6)\n            (Shape (Height 16 + 0)\n              (HB&quot;
 &amp; &quot;ox Fill (Shape (Width + 0) (Height + 0) \n                             &quot;
 &amp; &quot;   \&quot;Setup:   Stop? \&quot;) \n                    (Boolean %stopAtSetup =TR&quot;
 &amp; &quot;UE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Wi&quot;
 &amp; &quot;dth + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width &quot;
 &amp; &quot;80) (Numeric %waitAtSetup =1 \n                                        &quot;
 &amp; &quot;       (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape &quot;
 &amp; &quot;(Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + &quot;
 &amp; &quot;0) \n                                \&quot;InitSort:   Stop? \&quot;) \n        &quot;
 &amp; &quot;            (Boolean %stopAtInitSort =TRUE \&quot;\&quot;)\n                    (&quot;
 &amp; &quot;Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight:&quot;
 &amp; &quot; \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtInitSort =1&quot;
 &amp; &quot; \n                                               (Min 0) (Max 100)))))&quot;
 &amp; &quot;\n            (Glue 6)\n            (Shape (Height 16 + 0)\n           &quot;
 &amp; &quot;   (HBo&quot;;

CONST E34_0 =
   &quot;x Fill (Shape (Width + 0) (Height + 0) \n                              &quot;
 &amp; &quot;  \&quot;Insert:   Stop? \&quot;) \n                    (Boolean %stopAtInsert =T&quot;
 &amp; &quot;RUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (W&quot;
 &amp; &quot;idth + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width&quot;
 &amp; &quot; 80) (Numeric %waitAtInsert =1 \n                                      &quot;
 &amp; &quot;         (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shap&quot;
 &amp; &quot;e (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height &quot;
 &amp; &quot;+ 0) \n                                \&quot;HeapOpInit:   Stop? \&quot;) \n    &quot;
 &amp; &quot;                (Boolean %stopAtHeapOpInit =TRUE \&quot;\&quot;)\n               &quot;
 &amp; &quot;     (Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;W&quot;
 &amp; &quot;eight: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtHeapO&quot;
 &amp; &quot;pInit =1 \n                                               (Min 0) (Max &quot;
 &amp; &quot;100)))))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n   &quot;
 &amp; &quot;           (HBox Fill (Shape (Width + 0) (Height + 0) \n               &quot;
 &amp; &quot;                 \&quot;UpHeapStep:   Stop? \&quot;) \n                    (Boole&quot;
 &amp; &quot;an %stopAtUpHeapStep =TRUE \&quot;\&quot;)\n                    (Glue 10)\n      &quot;
 &amp; &quot;              (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n          &quot;
 &amp; &quot;          (Shape (Width 80) (Numeric %waitAtUpHeapStep =1 \n           &quot;
 &amp; &quot;                                    (Min 0) (Max 100)))))\n            &quot;
 &amp; &quot;(Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox Fill &quot;
 &amp; &quot;(Shape (Width + 0) (Height + 0) \n                                \&quot;Hea&quot;
 &amp; &quot;pStep:   Stop? \&quot;) \n                    (Boolean %stopAtHeapStep =TRUE&quot;
 &amp; &quot; \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Widt&quot;
 &amp; &quot;h + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80&quot;
 &amp; &quot;) (Numeric %waitAtHeapStep =1 \n                                       &quot;
 &amp; &quot;        (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape&quot;
 &amp; &quot; (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height +&quot;
 &amp; &quot; 0) \n                                \&quot;PlaceElement:   Stop? \&quot;) \n   &quot;
 &amp; &quot;                 (Boolean %stopAtPlaceElement =TRUE \&quot;\&quot;)\n            &quot;
 &amp; &quot;        &quot;;

CONST E34_1 =
   &quot;(Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight&quot;
 &amp; &quot;: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtPlaceEleme&quot;
 &amp; &quot;nt =1 \n                                               (Min 0) (Max 100&quot;
 &amp; &quot;)))))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n      &quot;
 &amp; &quot;        (HBox Fill (Shape (Width + 0) (Height + 0) \n                  &quot;
 &amp; &quot;              \&quot;Remove:   Stop? \&quot;) \n                    (Boolean %sto&quot;
 &amp; &quot;pAtRemove =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                 &quot;
 &amp; &quot;   (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (&quot;
 &amp; &quot;Shape (Width 80) (Numeric %waitAtRemove =1 \n                          &quot;
 &amp; &quot;                     (Min 0) (Max 100)))))\n            (Glue 6)\n     &quot;
 &amp; &quot;       (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width +&quot;
 &amp; &quot; 0) (Height + 0) \n                                \&quot;Compare:   Stop? \&quot;&quot;
 &amp; &quot;) \n                    (Boolean %stopAtCompare =TRUE \&quot;\&quot;)\n          &quot;
 &amp; &quot;          (Glue 10)\n                    (Shape (Width + 0) (Height + 0&quot;
 &amp; &quot;) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAt&quot;
 &amp; &quot;Compare =1 \n                                               (Min 0) (Ma&quot;
 &amp; &quot;x 100)))))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n &quot;
 &amp; &quot;             (HBox Fill (Shape (Width + 0) (Height + 0) \n             &quot;
 &amp; &quot;                   \&quot;Pause:   Stop? \&quot;) \n                    (Boolean &quot;
 &amp; &quot;%stopAtPause =TRUE \&quot;\&quot;)\n                    (Glue 10)\n              &quot;
 &amp; &quot;      (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                  &quot;
 &amp; &quot;  (Shape (Width 80) (Numeric %waitAtPause =1 \n                        &quot;
 &amp; &quot;                       (Min 0) (Max 100)))))\n            (Glue 6)\n   &quot;
 &amp; &quot;         (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width&quot;
 &amp; &quot; + 0) (Height + 0) \n                                \&quot;SortStep:   Stop&quot;
 &amp; &quot;? \&quot;) \n                    (Boolean %stopAtSortStep =TRUE \&quot;\&quot;)\n     &quot;
 &amp; &quot;               (Glue 10)\n                    (Shape (Width + 0) (Heigh&quot;
 &amp; &quot;t + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric %w&quot;
 &amp; &quot;aitAtSortStep =1 \n                                               (Min &quot;
 &amp; &quot;0) (M&quot;;

CONST E34_2 =
   &quot;ax 100)))))\n            (Glue 6)\n          )\n          (Glue 4)\n   &quot;
 &amp; &quot;       (VBox\n            (Glue 5)\n            (Shape (Width + 0) (Hei&quot;
 &amp; &quot;ght 16 + 0) \&quot;Cts:\&quot;)\n            (Button %eventCounts\n              &quot;
 &amp; &quot;(VBox\n                (Glue 6)\n                (HBox Fill (Shape (Wid&quot;
 &amp; &quot;th + 0) (Height 16 + 0) \n                                  (Text %ctOf&quot;
 &amp; &quot;Setup \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (S&quot;
 &amp; &quot;hape (Width + 0) (Height 16 + 0) \n                                  (T&quot;
 &amp; &quot;ext %ctOfInitSort \&quot;0\&quot;)))\n                (Glue 6)\n                (&quot;
 &amp; &quot;HBox Fill (Shape (Width + 0) (Height 16 + 0) \n                        &quot;
 &amp; &quot;          (Text %ctOfInsert \&quot;0\&quot;)))\n                (Glue 6)\n       &quot;
 &amp; &quot;         (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n              &quot;
 &amp; &quot;                    (Text %ctOfHeapOpInit \&quot;0\&quot;)))\n                (Gl&quot;
 &amp; &quot;ue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n&quot;
 &amp; &quot;                                  (Text %ctOfUpHeapStep \&quot;0\&quot;)))\n     &quot;
 &amp; &quot;           (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Hei&quot;
 &amp; &quot;ght 16 + 0) \n                                  (Text %ctOfHeapStep \&quot;0&quot;
 &amp; &quot;\&quot;)))\n                (Glue 6)\n                (HBox Fill (Shape (Wid&quot;
 &amp; &quot;th + 0) (Height 16 + 0) \n                                  (Text %ctOf&quot;
 &amp; &quot;PlaceElement \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox &quot;
 &amp; &quot;Fill (Shape (Width + 0) (Height 16 + 0) \n                             &quot;
 &amp; &quot;     (Text %ctOfRemove \&quot;0\&quot;)))\n                (Glue 6)\n            &quot;
 &amp; &quot;    (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n                   &quot;
 &amp; &quot;               (Text %ctOfCompare \&quot;0\&quot;)))\n                (Glue 6)\n &quot;
 &amp; &quot;               (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n        &quot;
 &amp; &quot;                          (Text %ctOfPause \&quot;0\&quot;)))\n                (G&quot;
 &amp; &quot;lue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n&quot;
 &amp; &quot;                                  (Text %ctOfSortStep \&quot;0\&quot;)))\n       &quot;
 &amp; &quot;         (Glue 3))))\n          Fill\n          (Glue 4 + Inf)\n       &quot;
 &amp; &quot; )\n      )\n    )\n  )\n)\n&quot;;

CONST E35 =
   &quot;#| Copyright 1993 Digital Equipment Corporation. |#\n#| Distributed onl&quot;
 &amp; &quot;y by permission. |#\n#| Last modified on Tue Jul 13 19:31:37 PDT 1993 b&quot;
 &amp; &quot;y comba |#\n#|      modified on Sun Jul 11 23:10:48 PDT 1993 by mhb |#\n&quot;
 &amp; &quot;\n(VBox\n  (Glue 5)\n  (HBox (Boolean %E \&quot;Show Errors\&quot;) Fill) (Glue 5&quot;
 &amp; &quot;))\n\n&quot;;

CONST E36 =
   &quot;(* Copyright (C) 1994, Digital Equipment Corporation                   &quot;
 &amp; &quot;      *)\n(* All rights reserved.                                      &quot;
 &amp; &quot;                *)\n(* See the file COPYRIGHT for a full description.  &quot;
 &amp; &quot;                          *)\n(*                                       &quot;
 &amp; &quot;                                    *)\n(* Last modified on Mon Jan  9 &quot;
 &amp; &quot;12:04:21 PST 1995 by najork                   *)\n(*      modified on T&quot;
 &amp; &quot;ue Aug 16 18:56:37 PDT 1994 by heydon                   *)\n(*      mod&quot;
 &amp; &quot;ified on Wed Jul 27 12:22:30 PDT 1994 by shillner                 *)\n\n&quot;
 &amp; &quot;(* FindLength.obl -- histogram of path lengths to root on \&quot;Find\&quot; oper&quot;
 &amp; &quot;ations *)\n\nlet Margin   = 5.0;           (* in mm *)\nlet InitMaxX = &quot;
 &amp; &quot;4;\nlet InitMaxY = 5.0;\n\nlet BarColor    = color_named(\&quot;red\&quot;);\nlet&quot;
 &amp; &quot; BorderColor = color_named(\&quot;black\&quot;);\nlet BorderWidth = 0.05;\nlet Te&quot;
 &amp; &quot;xtColor   = color_named(\&quot;black\&quot;);\nlet FontSz      = 0.6;\nlet Lab1Y &quot;
 &amp; &quot;      = ~0.5;\nlet Lab2Y       = ~1.5;\nlet MinY        = ~2.0;\n\n(* B&quot;
 &amp; &quot;ar Object =============================================================&quot;
 &amp; &quot; *)\n\nlet Bar = {\n  slot: Int =&gt; ok,\n  count: Int =&gt; 0,\n  v: Vertex&quot;
 &amp; &quot; =&gt; ok,\n\n  barHeight =&gt; meth(self: Bar): Real,\n    math_sqrt(float(s&quot;
 &amp; &quot;elf.count))\n  end,\n\n  updateVertex =&gt; meth(self): Ok,\n    let ht = &quot;
 &amp; &quot;self.barHeight();\n    graph_setVertexSize(self.v, 0.9, ht);\n    graph&quot;
 &amp; &quot;_moveVertex(self.v, 0.5 + float(self.slot), ht / 2.0, false);\n    ok\n&quot;
 &amp; &quot;  end,\n\n  updateLabel =&gt; meth(self): Ok,\n    graph_setVertexLabel(se&quot;
 &amp; &quot;lf.v, fmt_int(self.count));\n    ok\n  end,\n\n  new =&gt; meth(self: Bar,&quot;
 &amp; &quot; g: Graph, f: Font, slot: Int): Bar,\n    self.slot := slot;\n    self.&quot;
 &amp; &quot;v := graph_newVertex(g);\n    graph_setVertexColor(self.v, BarColor);\n&quot;
 &amp; &quot;    graph_setVertexBorderColor(self.v, BorderColor);\n    graph_setVert&quot;
 &amp; &quot;exBorder(self.v, BorderWidth);\n    graph_setVertexFont(self.v, f);\n  &quot;
 &amp; &quot;  graph_setVertexLabelColor(self.v, TextColor);\n    graph_setVertexLab&quot;
 &amp; &quot;el(self.v, \&quot;\&quot;);\n    self.updateVertex();\n    let v = graph_newVerte&quot;
 &amp; &quot;x(g);\n    graph_vertexToBack(v);\n    graph_setVertexColor(v, color_na&quot;
 &amp; &quot;med(\&quot;whi&quot;;

CONST E36_0 =
   &quot;te\&quot;));\n    graph_setVertexFont(v, f);\n    graph_setVertexLabelColor(&quot;
 &amp; &quot;v, TextColor);\n    graph_setVertexLabel(v, fmt_int(slot));\n    graph_&quot;
 &amp; &quot;setVertexSize(v, 1.0, 1.0);\n    graph_moveVertex(v, 0.5 + float(slot),&quot;
 &amp; &quot; Lab1Y, false);\n    self\n  end,\n\n  inc =&gt; meth(self: Bar): Ok,\n  (&quot;
 &amp; &quot;* increment the count of the bar \&quot;self\&quot;, and update its vertex\n     &quot;
 &amp; &quot;to reflect the change. *)\n    self.count := self.count + 1;\n    self.&quot;
 &amp; &quot;updateVertex();\n    self.updateLabel();\n    ok\n  end,\n};\n\n(* View&quot;
 &amp; &quot; Object ============================================================ *)&quot;
 &amp; &quot;\n\nlet view: View = {\n\n  (* Data members ---------------------------&quot;
 &amp; &quot;------------------------------ *)\n\n  graphvbt =&gt; graph_new(),\n  bar:&quot;
 &amp; &quot; [Bar] =&gt; ok,\n  maxX: Int =&gt; InitMaxX,    (* slots [0..maxX-1] *)\n  m&quot;
 &amp; &quot;axY: Real =&gt; InitMaxY,    (* values [0..maxY] *)\n  currLen: Int =&gt; ok,&quot;
 &amp; &quot;\n  labelFont: Font =&gt; ok,\n  total: Int =&gt; 0,\n  count: Int =&gt; 0,\n  t&quot;
 &amp; &quot;otalV: Vertex =&gt; ok,\n\n  setWorld =&gt; meth(self: View): Ok,\n    graph_&quot;
 &amp; &quot;setWorld(self.graphvbt,\n      0.0, float(self.maxX), self.maxY + 2.0, &quot;
 &amp; &quot;MinY);\n    ok\n  end,\n\n  updateTotal =&gt; meth(self: View): Ok,\n    l&quot;
 &amp; &quot;et txt = \&quot;Total = \&quot; &amp; fmt_int(self.total) &amp; \&quot;  Average = \&quot; &amp;\n     &quot;
 &amp; &quot; if self.count is 0 then \&quot;0.00\&quot; else\n        text_replaceAll(\&quot;d\&quot;, &quot;
 &amp; &quot;\&quot;0\&quot;,\n                        text_sub(fmt_real(float(self.total)/flo&quot;
 &amp; &quot;at(self.count)),\n                                 0, 4));\n      end;\n&quot;
 &amp; &quot;    graph_setVertexLabel(self.totalV, txt);\n    ok\n  end,\n\n  moveTo&quot;
 &amp; &quot;talLabel =&gt; meth(self: View): Ok,\n    graph_moveVertex(self.totalV, fl&quot;
 &amp; &quot;oat(self.maxX)/2.0, Lab2Y, true);\n    ok\n  end,\n\n  (* Setup -------&quot;
 &amp; &quot;--------------------------------------------------------- *)\n\n  Setup&quot;
 &amp; &quot; =&gt; meth(self: View): Ok,\n    self.labelFont := graph_newFont(self.gra&quot;
 &amp; &quot;phvbt, \&quot;Helvetica\&quot;, FontSz,\n      \&quot;Roman\&quot;, \&quot;bold\&quot;, \&quot;*\&quot;);\n    &quot;
 &amp; &quot;graph_setMargin(self.graphvbt, Margin);\n    self.setWorld();\n    ok\n&quot;
 &amp; &quot;  end,\n\n  NewSet =&gt; meth(self: View, nm: Text): Ok,\n    ok\n  end,\n&quot;
 &amp; &quot;\n  FinishedSets =&gt; meth(self: View, numSets: Int, usesRanks: Bool): Ok&quot;
 &amp; &quot;,\n    self.totalV := graph_newVe&quot;;

CONST E36_1 =
   &quot;rtex(self.graphvbt);\n    graph_vertexToBack(self.totalV);\n    graph_s&quot;
 &amp; &quot;etVertexFont(self.totalV, self.labelFont);\n    graph_setVertexLabelCol&quot;
 &amp; &quot;or(self.totalV, TextColor);\n    graph_setVertexColor(self.totalV, colo&quot;
 &amp; &quot;r_named(\&quot;white\&quot;));\n    graph_setVertexSize(self.totalV, 200.0, 1.0);&quot;
 &amp; &quot;\n    self.updateTotal(); self.moveTotalLabel();\n\n    self.bar := arr&quot;
 &amp; &quot;ay_new(self.maxX, ok);\n    for i = 0 to self.maxX - 1 do\n      self.b&quot;
 &amp; &quot;ar[i] := clone(Bar).new(self.graphvbt, self.labelFont, i)\n    end;\n  &quot;
 &amp; &quot;  zeus_animate(self.graphvbt, 0.0, 0.0);\n    ok\n  end,\n\n  (* DoFind&quot;
 &amp; &quot; events -------------------------------------------------------- *)\n\n&quot;
 &amp; &quot;  StartDoFind =&gt; meth(self, id): Ok,\n    self.currLen := 0;\n    ok\n &quot;
 &amp; &quot; end,\n\n  StepUp =&gt; meth(self, child, parent): Ok,\n    self.currLen :&quot;
 &amp; &quot;= self.currLen + 1;\n    ok\n  end,\n\n  Found =&gt; meth(self, root): Ok,&quot;
 &amp; &quot;\n    var rescale: Bool = false;\n    if self.currLen &gt;= self.maxX then&quot;
 &amp; &quot;\n      var sz: Int = (self.currLen - self.maxX) + 1;\n      var new: [&quot;
 &amp; &quot;Bar] = array_new(sz, ok);\n      for i = 0 to sz - 1 do\n        new[i]&quot;
 &amp; &quot; := clone(Bar).new(self.graphvbt, self.labelFont, self.maxX + i)\n     &quot;
 &amp; &quot; end;\n      self.bar := self.bar @ new;\n      self.maxX := self.currL&quot;
 &amp; &quot;en + 1;\n      self.moveTotalLabel();\n      rescale := true\n    end;\n&quot;
 &amp; &quot;    if self.bar[self.currLen].barHeight() &gt;= self.maxY then\n      self&quot;
 &amp; &quot;.maxY := 1.5 * self.maxY;\n      rescale := true\n    end;\n    if resc&quot;
 &amp; &quot;ale then\n      self.setWorld();\n      graph_redisplay(self.graphvbt)\n&quot;
 &amp; &quot;    end;\n    self.bar[self.currLen].inc();\n    self.total := self.tot&quot;
 &amp; &quot;al + self.currLen;\n    self.count := self.count + 1;\n    self.updateT&quot;
 &amp; &quot;otal();\n    zeus_animate(self.graphvbt, 0.0, 0.0);\n    ok\n  end,\n\n&quot;
 &amp; &quot;  StepDown =&gt; meth(self: View, childId, parentId: Int): Ok,\n    ok\n  &quot;
 &amp; &quot;end,\n\n  ChangeParent =&gt; meth(self: View, childId, parentId, rootId: I&quot;
 &amp; &quot;nt): Ok,\n    ok\n  end,\n\n  EndDoFind =&gt; meth(self, id): Ok,\n    ok\n&quot;
 &amp; &quot;  end,\n\n  (* Find events --------------------------------------------&quot;
 &amp; &quot;-------------- *)\n\n  StartFind =&gt; meth(self: View, id: Int): Ok,\n   &quot;
 &amp; &quot; ok\n  end,\n\n&quot;;

CONST E36_2 =
   &quot;  EndFind =&gt; meth(self: View, id: Int): Ok,\n    ok\n  end,\n\n  (* Uni&quot;
 &amp; &quot;on events --------------------------------------------------------- *)\n&quot;
 &amp; &quot;\n  StartUnion =&gt; meth(self: View, id1, id2: Int, bothRoots: Bool): Ok,&quot;
 &amp; &quot;\n    ok\n  end,\n\n  FoundFirst =&gt; meth(self: View, root1: Int): Ok,\n&quot;
 &amp; &quot;    ok\n  end,\n\n  CompareRanks =&gt; meth(self: View, id1, id2: Int): Ok&quot;
 &amp; &quot;,\n    ok\n  end,\n\n  Unite =&gt; meth(self: View, childId, parentId, pRa&quot;
 &amp; &quot;nk: Int): Ok,\n    ok\n  end,\n\n  EndUnion =&gt; meth(self): Ok,\n    ok\n&quot;
 &amp; &quot;  end,\n};\n&quot;;

CONST E37 =
   &quot;(* Copyright (C) 1994, Digital Equipment Corporation         *)\n(* All&quot;
 &amp; &quot; rights reserved.                                      *)\n(* See the f&quot;
 &amp; &quot;ile COPYRIGHT for a full description.            *)\n\nTYPE PriorityQue&quot;
 &amp; &quot;ue = RECORD\n   size: INTEGER;\n   heap: REF ARRAY OF INTEGER\n  END;\n&quot;
 &amp; &quot;\n@Insert\nPROCEDURE Insert(pq: PriorityQueue; v: INTEGER) RAISES {}= @&quot;
 &amp; &quot;\n  BEGIN\n@101     INC(pq.size); pq.heap[size] := v; UpHeap(size) @\n &quot;
 &amp; &quot; END Insert;\n@Insert\n\n@UpHeap\nPROCEDURE UpHeap(pq: PriorityQueue; k&quot;
 &amp; &quot;:INTEGER) RAISES {}=@\n  VAR v: INTEGER;\n  BEGIN\n@201     v := pq.hea&quot;
 &amp; &quot;p[k]; pq.heap[0] := LAST(INTEGER); @\n@202     WHILE pq.heap[k DIV 2] &lt;&quot;
 &amp; &quot;= v DO\n      pq.heap[k] := pq.heap[k DIV 2]; k := k DIV 2 \n    END;@\n&quot;
 &amp; &quot;@204     pq.heap[k] := v;@\n  END UpHeap;\n@UpHeap\n\n@Remove\nPROCEDUR&quot;
 &amp; &quot;E Remove(pq: PriorityQueue): INTEGER RAISES {}=@\n  VAR outVal: INTEGER&quot;
 &amp; &quot;;\n  BEGIN\n@301     outVal := pq.heap[1];\n    pq.heap[1] := pq.heap[p&quot;
 &amp; &quot;q.size]; DEC(pq.size); @\n@302     DownHeap(pq, 1);@\n@303    RETURN ou&quot;
 &amp; &quot;tVal;@\n  END Remove;\n@Remove\n\n@DownHeap \nPROCEDURE DownHeap(pq: Pr&quot;
 &amp; &quot;iorityQueue; k: INTEGER) RAISES {} = @\n  VAR i, j, v: INTEGER;\n  BEGI&quot;
 &amp; &quot;N\n@401     v := pq.heap[k];@\n    WHILE k &lt;= pq.size DIV 2 DO\n@402   &quot;
 &amp; &quot;    j := k+k;\n      IF j &lt; pq.size THEN\n        IF pq.heap[j] &lt; pq.he&quot;
 &amp; &quot;ap[j+1] THEN\n          INC(j)\n        END;\n      END;@\n@406       I&quot;
 &amp; &quot;F v &gt;= pq.heap[j] THEN\n        EXIT;\n      END;@\n@408       pq.heap[&quot;
 &amp; &quot;k] := pq.heap[j]; k := j;@\n    END;\n@409     pq.heap[k] := v;@\n  END&quot;
 &amp; &quot; DownHeap;\n@DownHeap\n\n\n@HeapSort\nPROCEDURE HeapSort(pq: PriorityQu&quot;
 &amp; &quot;eue) RAISES {} = @\n  VAR t: INTEGER;\n  BEGIN\n@501     FOR k := pq.si&quot;
 &amp; &quot;ze DIV 2 TO 1 BY -1 DO @\n@502       DownHeap(pq, k); @\n    END; \n@50&quot;
 &amp; &quot;3     (* array is now a heap *)@\n    REPEAT \n@504       t := pq.heap[&quot;
 &amp; &quot;1]; pq.heap[1] := pq.heap[pq.size];\n      pq.heap[pq.size] := t;\n    &quot;
 &amp; &quot;  DEC[pq.size];@\n@505       DownHeap(pq, 1);@\n    UNTIL pq.size &lt;= 1;&quot;
 &amp; &quot;\n  END HeapSort;\n@HeapSort\n\n&quot;;

CONST E38 =
   &quot;(* Copyright (C) 1993, Digital Equipment Corporation                   &quot;
 &amp; &quot;      *)\n(* All rights reserved.                                      &quot;
 &amp; &quot;                *)\n(* See the file COPYRIGHT for a full description.  &quot;
 &amp; &quot;                          *)\n\n\nlet view = {\n  graphvbt =&gt; graph_new&quot;
 &amp; &quot;(),\n\n  Setup =&gt;\n    meth (self)\n      graph_setWorld(self.graphvbt,&quot;
 &amp; &quot; ~11.0, 11.0, 0.0, 2.0);\n      graph_setAspect(self.graphvbt, 2.0 / 23&quot;
 &amp; &quot;.0);\n      for c = -10 to 10 do\n        (let v = graph_newVertex(self&quot;
 &amp; &quot;.graphvbt);\n         graph_setVertexSize(v, 1.0, 1.0);\n         graph&quot;
 &amp; &quot;_setVertexColor(v, \n             color_hsv(((float(c+10)) / 21.0) * 0.&quot;
 &amp; &quot;7, 1.0, 1.0));\n         graph_setVertexBorder(v, 0.0);\n         graph&quot;
 &amp; &quot;_moveVertex(v, float(c), 1.0, false);)\n      end;\n      graph_redispl&quot;
 &amp; &quot;ay(self.graphvbt);\n    end,\n  };\n&quot;;

CONST E39 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:29:09 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file PktR&quot;
 &amp; &quot;oute.evt.\n;***********************************************************&quot;
 &amp; &quot;*********\n\n(VBox\n  (Border (Pen 1)\n    (Shape\n      (Height 75 - 2&quot;
 &amp; &quot;5 + Inf)\n      (Viewport\n        (HBox\n          (Glue 4 + Inf)\n   &quot;
 &amp; &quot;       (VBox\n            (Glue 6)\n            (Shape (Height 16 + 0)\n&quot;
 &amp; &quot;              (HBox Fill (Shape (Width + 0) (Height + 0) \n            &quot;
 &amp; &quot;                    \&quot;Code View events:   Stop? \&quot;) \n                 &quot;
 &amp; &quot;   (Boolean %stopatCodeEvents =TRUE \&quot;\&quot;)\n                    (Glue 10&quot;
 &amp; &quot;)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n &quot;
 &amp; &quot;                   (Shape (Width 80) (Numeric %waitatCodeEvents =1 \n  &quot;
 &amp; &quot;                                             (Min 0) (Max 100)))))\n   &quot;
 &amp; &quot;         (Glue 6)\n            (Shape (Height 16 + 0)\n              (H&quot;
 &amp; &quot;Box Fill (Shape (Width + 0) (Height + 0) \n                            &quot;
 &amp; &quot;    \&quot;StartGraph:   Stop? \&quot;) \n                    (Boolean %stopAtSta&quot;
 &amp; &quot;rtGraph =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                   &quot;
 &amp; &quot; (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Sh&quot;
 &amp; &quot;ape (Width 80) (Numeric %waitAtStartGraph =1 \n                        &quot;
 &amp; &quot;                       (Min 0) (Max 100)))))\n            (Glue 6)\n   &quot;
 &amp; &quot;         (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width&quot;
 &amp; &quot; + 0) (Height + 0) \n                                \&quot;NewNode:   Stop?&quot;
 &amp; &quot; \&quot;) \n                    (Boolean %stopAtNewNode =TRUE \&quot;\&quot;)\n       &quot;
 &amp; &quot;             (Glue 10)\n                    (Shape (Width + 0) (Height &quot;
 &amp; &quot;+ 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric %wai&quot;
 &amp; &quot;tAtNewNode =1 \n                                               (Min 0) &quot;
 &amp; &quot;(Max 100)))))\n            (Glue 6)\n            (Shape (Height 16 + 0)&quot;
 &amp; &quot;\n    &quot;;

CONST E39_0 =
   &quot;          (HBox Fill (Shape (Width + 0) (Height + 0) \n                &quot;
 &amp; &quot;                \&quot;NewStraightEdge:   Stop? \&quot;) \n                    (B&quot;
 &amp; &quot;oolean %stopAtNewStraightEdge =TRUE \&quot;\&quot;)\n                    (Glue 10&quot;
 &amp; &quot;)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n &quot;
 &amp; &quot;                   (Shape (Width 80) (Numeric %waitAtNewStraightEdge =1&quot;
 &amp; &quot; \n                                               (Min 0) (Max 100)))))&quot;
 &amp; &quot;\n            (Glue 6)\n            (Shape (Height 16 + 0)\n           &quot;
 &amp; &quot;   (HBox Fill (Shape (Width + 0) (Height + 0) \n                       &quot;
 &amp; &quot;         \&quot;NewCurvedEdge:   Stop? \&quot;) \n                    (Boolean %s&quot;
 &amp; &quot;topAtNewCurvedEdge =TRUE \&quot;\&quot;)\n                    (Glue 10)\n        &quot;
 &amp; &quot;            (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n            &quot;
 &amp; &quot;        (Shape (Width 80) (Numeric %waitAtNewCurvedEdge =1 \n          &quot;
 &amp; &quot;                                     (Min 0) (Max 100)))))\n           &quot;
 &amp; &quot; (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox Fill&quot;
 &amp; &quot; (Shape (Width + 0) (Height + 0) \n                                \&quot;Ne&quot;
 &amp; &quot;wLabel:   Stop? \&quot;) \n                    (Boolean %stopAtNewLabel =TRU&quot;
 &amp; &quot;E \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Wid&quot;
 &amp; &quot;th + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 8&quot;
 &amp; &quot;0) (Numeric %waitAtNewLabel =1 \n                                      &quot;
 &amp; &quot;         (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shap&quot;
 &amp; &quot;e (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height &quot;
 &amp; &quot;+ 0) \n                                \&quot;EndGraph:   Stop? \&quot;) \n      &quot;
 &amp; &quot;              (Boolean %stopAtEndGraph =TRUE \&quot;\&quot;)\n                   &quot;
 &amp; &quot; (Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weigh&quot;
 &amp; &quot;t: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtEndGraph &quot;
 &amp; &quot;=1 \n                                               (Min 0) (Max 100)))&quot;
 &amp; &quot;))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n         &quot;
 &amp; &quot;     (HBox Fill (Shape (Width + 0) (Height + 0) \n                     &quot;
 &amp; &quot;           \&quot;StartPackets:   Stop? \&quot;) \n                    (Boolean %&quot;
 &amp; &quot;stopA&quot;;

CONST E39_1 =
   &quot;tStartPackets =TRUE \&quot;\&quot;)\n                    (Glue 10)\n             &quot;
 &amp; &quot;       (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                 &quot;
 &amp; &quot;   (Shape (Width 80) (Numeric %waitAtStartPackets =1 \n                &quot;
 &amp; &quot;                               (Min 0) (Max 100)))))\n            (Glue&quot;
 &amp; &quot; 6)\n            (Shape (Height 16 + 0)\n              (HBox Fill (Shap&quot;
 &amp; &quot;e (Width + 0) (Height + 0) \n                                \&quot;NewPacke&quot;
 &amp; &quot;t:   Stop? \&quot;) \n                    (Boolean %stopAtNewPacket =TRUE \&quot;&quot;
 &amp; &quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Width +&quot;
 &amp; &quot; 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (&quot;
 &amp; &quot;Numeric %waitAtNewPacket =1 \n                                         &quot;
 &amp; &quot;      (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape (&quot;
 &amp; &quot;Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0&quot;
 &amp; &quot;) \n                                \&quot;EndPackets:   Stop? \&quot;) \n       &quot;
 &amp; &quot;             (Boolean %stopAtEndPackets =TRUE \&quot;\&quot;)\n                  &quot;
 &amp; &quot;  (Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weig&quot;
 &amp; &quot;ht: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtEndPacke&quot;
 &amp; &quot;ts =1 \n                                               (Min 0) (Max 100&quot;
 &amp; &quot;)))))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n      &quot;
 &amp; &quot;        (HBox Fill (Shape (Width + 0) (Height + 0) \n                  &quot;
 &amp; &quot;              \&quot;Blocked:   Stop? \&quot;) \n                    (Boolean %st&quot;
 &amp; &quot;opAtBlocked =TRUE \&quot;\&quot;)\n                    (Glue 10)\n               &quot;
 &amp; &quot;     (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                   &quot;
 &amp; &quot; (Shape (Width 80) (Numeric %waitAtBlocked =1 \n                       &quot;
 &amp; &quot;                        (Min 0) (Max 100)))))\n            (Glue 6)\n  &quot;
 &amp; &quot;          (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Widt&quot;
 &amp; &quot;h + 0) (Height + 0) \n                                \&quot;MovePacket:   S&quot;
 &amp; &quot;top? \&quot;) \n                    (Boolean %stopAtMovePacket =TRUE \&quot;\&quot;)\n&quot;
 &amp; &quot;                    (Glue 10)\n                    (Shape (Width + 0) (&quot;
 &amp; &quot;Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numer&quot;
 &amp; &quot;ic %wait&quot;;

CONST E39_2 =
   &quot;AtMovePacket =1 \n                                               (Min 0&quot;
 &amp; &quot;) (Max 100)))))\n            (Glue 6)\n            (Shape (Height 16 + &quot;
 &amp; &quot;0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n        &quot;
 &amp; &quot;                        \&quot;QueueSizes:   Stop? \&quot;) \n                   &quot;
 &amp; &quot; (Boolean %stopAtQueueSizes =TRUE \&quot;\&quot;)\n                    (Glue 10)\n&quot;
 &amp; &quot;                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n    &quot;
 &amp; &quot;                (Shape (Width 80) (Numeric %waitAtQueueSizes =1 \n     &quot;
 &amp; &quot;                                          (Min 0) (Max 100)))))\n      &quot;
 &amp; &quot;      (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox&quot;
 &amp; &quot; Fill (Shape (Width + 0) (Height + 0) \n                               &quot;
 &amp; &quot; \&quot;Absorb:   Stop? \&quot;) \n                    (Boolean %stopAtAbsorb =TR&quot;
 &amp; &quot;UE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Wi&quot;
 &amp; &quot;dth + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width &quot;
 &amp; &quot;80) (Numeric %waitAtAbsorb =1 \n                                       &quot;
 &amp; &quot;        (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape&quot;
 &amp; &quot; (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height +&quot;
 &amp; &quot; 0) \n                                \&quot;Step:   Stop? \&quot;) \n           &quot;
 &amp; &quot;         (Boolean %stopAtStep =TRUE \&quot;\&quot;)\n                    (Glue 10&quot;
 &amp; &quot;)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n &quot;
 &amp; &quot;                   (Shape (Width 80) (Numeric %waitAtStep =1 \n        &quot;
 &amp; &quot;                                       (Min 0) (Max 100)))))\n         &quot;
 &amp; &quot;   (Glue 6)\n          )\n          (Glue 4)\n          (VBox\n        &quot;
 &amp; &quot;    (Glue 5)\n            (Shape (Width + 0) (Height 16 + 0) \&quot;Cts:\&quot;)\n&quot;
 &amp; &quot;            (Button %eventCounts\n              (VBox\n                &quot;
 &amp; &quot;(Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0)&quot;
 &amp; &quot; \n                                  (Text %ctOfStartGraph \&quot;0\&quot;)))\n  &quot;
 &amp; &quot;              (Glue 6)\n                (HBox Fill (Shape (Width + 0) (&quot;
 &amp; &quot;Height 16 + 0) \n                                  (Text %ctOfNewNode \&quot;&quot;
 &amp; &quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Shape (Wi&quot;
 &amp; &quot;dth + &quot;;

CONST E39_3 =
   &quot;0) (Height 16 + 0) \n                                  (Text %ctOfNewSt&quot;
 &amp; &quot;raightEdge \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fi&quot;
 &amp; &quot;ll (Shape (Width + 0) (Height 16 + 0) \n                               &quot;
 &amp; &quot;   (Text %ctOfNewCurvedEdge \&quot;0\&quot;)))\n                (Glue 6)\n       &quot;
 &amp; &quot;         (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n              &quot;
 &amp; &quot;                    (Text %ctOfNewLabel \&quot;0\&quot;)))\n                (Glue&quot;
 &amp; &quot; 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n  &quot;
 &amp; &quot;                                (Text %ctOfEndGraph \&quot;0\&quot;)))\n         &quot;
 &amp; &quot;       (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height &quot;
 &amp; &quot;16 + 0) \n                                  (Text %ctOfStartPackets \&quot;0&quot;
 &amp; &quot;\&quot;)))\n                (Glue 6)\n                (HBox Fill (Shape (Wid&quot;
 &amp; &quot;th + 0) (Height 16 + 0) \n                                  (Text %ctOf&quot;
 &amp; &quot;NewPacket \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fil&quot;
 &amp; &quot;l (Shape (Width + 0) (Height 16 + 0) \n                                &quot;
 &amp; &quot;  (Text %ctOfEndPackets \&quot;0\&quot;)))\n                (Glue 6)\n           &quot;
 &amp; &quot;     (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n                  &quot;
 &amp; &quot;                (Text %ctOfBlocked \&quot;0\&quot;)))\n                (Glue 6)\n&quot;
 &amp; &quot;                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n       &quot;
 &amp; &quot;                           (Text %ctOfMovePacket \&quot;0\&quot;)))\n            &quot;
 &amp; &quot;    (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 &quot;
 &amp; &quot;+ 0) \n                                  (Text %ctOfQueueSizes \&quot;0\&quot;)))&quot;
 &amp; &quot;\n                (Glue 6)\n                (HBox Fill (Shape (Width + &quot;
 &amp; &quot;0) (Height 16 + 0) \n                                  (Text %ctOfAbsor&quot;
 &amp; &quot;b \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Shape&quot;
 &amp; &quot; (Width + 0) (Height 16 + 0) \n                                  (Text &quot;
 &amp; &quot;%ctOfStep \&quot;0\&quot;)))\n                (Glue 3))))\n          Fill\n      &quot;
 &amp; &quot;    (Glue 4 + Inf)\n        )\n      )\n    )\n  )\n)\n&quot;;

CONST E40 =
   &quot;@UnbalancedTest\nUnbalancedTest(InsKeys, DelKeys)@\n  @1 create a new, &quot;
 &amp; &quot;empty tree T@\n  @2 foreach k in InsKeys do@\n    @3 create a new node &quot;
 &amp; &quot;n with key k@\n    @4 Insert(T, n)@\n  end\n  @5 foreach k in DelKeys d&quot;
 &amp; &quot;o@\n    @6 n &lt;- Search(T, k)@\n    @7 Delete(T, n)@\n  end\nend\n@Unbal&quot;
 &amp; &quot;ancedTest\n\n@Insert\nInsert(T, n)@\n  @4 curr := root(T)@\n  @5 while &quot;
 &amp; &quot;curr is not the place to attach n do@\n    @7 if key(n) &lt; key(curr)@\n &quot;
 &amp; &quot;     then @8 curr &lt;- left(curr)@\n      else @9 curr &lt;- right(curr)@\n &quot;
 &amp; &quot;   end\n  end\n  @11 if T has no root@\n    then @12 make n the new roo&quot;
 &amp; &quot;t of T@\n    else @13 make n the proper child of curr@\n  end\nend\n@In&quot;
 &amp; &quot;sert\n\n@Search\nSearch(T, k)@\n  @1 n &lt;- root(T)@\n  @2 while key(n) #&quot;
 &amp; &quot; k do@\n    @3 if key(n) &lt; k@\n      then @4 n &lt;- left(n)@\n      else &quot;
 &amp; &quot;@5 n &lt;- right(n)@\n    end\n  end\n  @6 return n@\nend\n@Search\n\n@Del&quot;
 &amp; &quot;ete\nDelete(T, n)@\n  @1 if n has &lt; 2 children@\n    then @2 splice &lt;- &quot;
 &amp; &quot;n@\n    else @3 splice &lt;- FindMin(right(n))@\n  end\n  @4 SpliceOut(t, &quot;
 &amp; &quot;splice)@\n  @5 if splice # n@ then\n    @6 copy contents of splice node&quot;
 &amp; &quot; into n@\n  end\nend\n@Delete\n\n@FindMin\nFindMin(n)@\n  @1 while left&quot;
 &amp; &quot;(n) # NIL do@\n    @2 n &lt;- left(n)@\n  end\n  @3 return n@\nend\n@FindM&quot;
 &amp; &quot;in\n\n@SpliceOut\nSpliceOut(T, n)@\n  @1 ch &lt;- \&quot;a child of n, or NIL i&quot;
 &amp; &quot;f n has no children\&quot;@\n  @4 parent(ch) &lt;- parent(n)@\n  @6 if n = root&quot;
 &amp; &quot;(T)@ then\n    @7 root(T) &lt;- ch@\n  else\n    @8 make appropriate \&quot;dow&quot;
 &amp; &quot;n\&quot; pointer of parent(n) point to ch@\n  end\nend\n@SpliceOut\n&quot;;

CONST E41 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:37:06 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Shor&quot;
 &amp; &quot;testPath.evt.\n;*******************************************************&quot;
 &amp; &quot;*************\n\n(VBox\n  (Rim\n    (Pen 2)\n    (HBox\n      (VBox (Gl&quot;
 &amp; &quot;ue 4) (Shape (Height + Inf) (Button %clear \&quot;CLEAR\&quot;)) (Glue 4))\n     &quot;
 &amp; &quot; (Glue 4)\n      (VBox\n        (Boolean =TRUE %alg (Text LeftAlign \&quot;A&quot;
 &amp; &quot;lgorithm events\&quot;))\n        (Boolean =FALSE %zeus (Text LeftAlign \&quot;Ze&quot;
 &amp; &quot;us events\&quot;))\n        (Boolean =TRUE %args (Text LeftAlign \&quot;Display a&quot;
 &amp; &quot;rgs to events\&quot;)))\n      Fill))\n  (Bar 1)\n  (Shape (ShadowSize 0) (H&quot;
 &amp; &quot;eight 200 + INF) (TextEdit ReadOnly %transcript)))\n&quot;;

CONST E42 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:37:06 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file DGra&quot;
 &amp; &quot;ph.evt.\n;*************************************************************&quot;
 &amp; &quot;*******\n\n(VBox\n  (Rim\n    (Pen 2)\n    (HBox\n      (VBox (Glue 4) &quot;
 &amp; &quot;(Shape (Height + Inf) (Button %clear \&quot;CLEAR\&quot;)) (Glue 4))\n      (Glue&quot;
 &amp; &quot; 4)\n      (VBox\n        (Boolean =TRUE %alg (Text LeftAlign \&quot;Algorit&quot;
 &amp; &quot;hm events\&quot;))\n        (Boolean =FALSE %zeus (Text LeftAlign \&quot;Zeus eve&quot;
 &amp; &quot;nts\&quot;))\n        (Boolean =TRUE %args (Text LeftAlign \&quot;Display args to&quot;
 &amp; &quot; events\&quot;)))\n      Fill))\n  (Bar 1)\n  (Shape (ShadowSize 0) (Height &quot;
 &amp; &quot;200 + INF) (TextEdit ReadOnly %transcript)))\n&quot;;

CONST E43 =
   &quot;\n@Parse\nPROCEDURE Parse ()@\n   @1 token := Scan ()@\n   @2 Program (&quot;
 &amp; &quot;)@\n\nPROCEDURE Match (s)\n   IF (token # s) THEN ERROR END\n   token :&quot;
 &amp; &quot;= Scan ()\n@Parse\n\n@Program\nPROCEDURE Program ()@\n   LOOP\n     @1 &quot;
 &amp; &quot;Stmt ()@\n     @2 IF (token # \';\') THEN EXIT END@\n     @3 Match (\';&quot;
 &amp; &quot;\')@\n   END\n   @4 Match (&lt;EOF&gt;)@\n@Program\n\n@Stmt\nPROCEDURE Stmt (&quot;
 &amp; &quot;)@\n   @1 Match (&lt;ID&gt;)@\n   @2 Match (\'=\')@\n   @3 Expr ()@\n@Stmt\n\n&quot;
 &amp; &quot;@Expr\nPROCEDURE Expr ()@\n   @1 Term ()@\n   @2 WHILE (token = \'+\') &quot;
 &amp; &quot;DO@\n     @3 Match (\'+\')@\n     @4 Term ()@\n   END\n@Expr\n\n@Term\n&quot;
 &amp; &quot;PROCEDURE Term ()@\n   @1 Factor ()@\n   @2 WHILE (token = \'*\') DO@\n&quot;
 &amp; &quot;     @3 Match (\'*\')@\n     @4 Factor ()@\n   END\n@Term\n\n@Factor\nP&quot;
 &amp; &quot;ROCEDURE Factor ()@\n   @1 IF (token = &lt;ID&gt;) THEN@\n      @2 Match (&lt;ID&quot;
 &amp; &quot;&gt;)@\n   @3 ELSE@\n      @4 Match (\'(\')@\n      @5 Expr ()@\n      @6 &quot;
 &amp; &quot;Match (\')\')@\n   END\n@Factor\n\n\n&quot;;

CONST E44 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:37:06 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file ZPap&quot;
 &amp; &quot;er.evt.\n;*************************************************************&quot;
 &amp; &quot;*******\n\n(VBox\n  (Rim\n    (Pen 2)\n    (HBox\n      (VBox (Glue 4) &quot;
 &amp; &quot;(Shape (Height + Inf) (Button %clear \&quot;CLEAR\&quot;)) (Glue 4))\n      (Glue&quot;
 &amp; &quot; 4)\n      (VBox\n        (Boolean =TRUE %alg (Text LeftAlign \&quot;Algorit&quot;
 &amp; &quot;hm events\&quot;))\n        (Boolean =FALSE %zeus (Text LeftAlign \&quot;Zeus eve&quot;
 &amp; &quot;nts\&quot;))\n        (Boolean =TRUE %args (Text LeftAlign \&quot;Display args to&quot;
 &amp; &quot; events\&quot;)))\n      Fill))\n  (Bar 1)\n  (Shape (ShadowSize 0) (Height &quot;
 &amp; &quot;200 + INF) (TextEdit ReadOnly %transcript)))\n&quot;;

CONST E45 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:37:06 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Eucl&quot;
 &amp; &quot;id.evt.\n;*************************************************************&quot;
 &amp; &quot;*******\n\n(VBox\n  (Rim\n    (Pen 2)\n    (HBox\n      (VBox (Glue 4) &quot;
 &amp; &quot;(Shape (Height + Inf) (Button %clear \&quot;CLEAR\&quot;)) (Glue 4))\n      (Glue&quot;
 &amp; &quot; 4)\n      (VBox\n        (Boolean =TRUE %alg (Text LeftAlign \&quot;Algorit&quot;
 &amp; &quot;hm events\&quot;))\n        (Boolean =FALSE %zeus (Text LeftAlign \&quot;Zeus eve&quot;
 &amp; &quot;nts\&quot;))\n        (Boolean =TRUE %args (Text LeftAlign \&quot;Display args to&quot;
 &amp; &quot; events\&quot;)))\n      Fill))\n  (Bar 1)\n  (Shape (ShadowSize 0) (Height &quot;
 &amp; &quot;200 + INF) (TextEdit ReadOnly %transcript)))\n&quot;;

CONST E46 =
   &quot;(\n (A B C D E F G H I J K L M)\n ((0.1 0.1)\n  (0.2 0.5)\n  (0.35 0.5)&quot;
 &amp; &quot;\n  (0.2 0.6)\n  (0.35 0.6)\n  (0.1 0.9)\n  (0.5 0.5)\n  (0.7 0.3)\n  (&quot;
 &amp; &quot;0.9 0.3)\n  (0.7 0.6)\n  (0.9 0.6)\n  (0.7 0.8)\n  (0.9 0.8))\n ((A B) &quot;
 &amp; &quot;(A F) (A G)\n (C A)\n (D F)\n (E D)\n (F E) \n (G C) (G E) (G J)\n (H I&quot;
 &amp; &quot;) (H G)\n (I H)\n (J K) (J L) (J M)\n (L M) (L G)\n (M L)))\n&quot;;

CONST E47 =
   &quot;; Copyright (C) 1992, Digital Equipment Corporation\n; All rights reser&quot;
 &amp; &quot;ved.\n; See the file COPYRIGHT for a full description.\n\n\n(Border (Sh&quot;
 &amp; &quot;ape (Width 750 - 600 + INF) (Height 500 - 400 + INF)\n  (BgColor \&quot;Whit&quot;
 &amp; &quot;e\&quot;)\n  (Macro B () \n    `(Bar 1))\n  (Macro G (name)\n    `(Rim (Pen &quot;
 &amp; &quot;3) (Shape (Width 0 + INF) (Height 0 + INF) (Generic %,name))))\n  (VBox&quot;
 &amp; &quot;\n    (Shape (Height 0) (Width 0 + INF) (Numeric %cells =6))\n    (HBox&quot;
 &amp; &quot; (G (name v1)) (B) (G (name v2)) (B) (G (name v3)))\n    (B)\n    (HBox&quot;
 &amp; &quot; (G (name v4)) (B) (G (name v5)) (B) (G (name v6))))))\n&quot;;

CONST E48 =
   &quot;   @Proposition             Proposition 47\n@\n   In right-angled trian&quot;
 &amp; &quot;gles the square \n   on the side subtending the right\n   angle is equa&quot;
 &amp; &quot;l to the squares on the \n   sides containing the right angle.\n   @Pro&quot;
 &amp; &quot;position\n   \n   @Figure @\n   Let @1 ABC@ be a right-angled triangle@&quot;
 &amp; &quot; \n   having the angle BAC right;\n   \n   I say that \n     @2 the squ&quot;
 &amp; &quot;are on BC@\n     is equal to \n     @3 the squares on BA, AC@.\n   @Fig&quot;
 &amp; &quot;ure\n   \n   @Squares @\n   For let there be described on BC the\n   @1&quot;
 &amp; &quot;1 square BDEC@, and on BA, AC the\n   @12 squares BAGF, ACKH@;\n   @Squ&quot;
 &amp; &quot;ares\n   \n   @LineAL @\n   Through A let @21 AL@ be drawn \n   paralle&quot;
 &amp; &quot;l to either @22 BD or CE@.\n   @LineAL\n   \n   @Shear1 @\n   Now the @&quot;
 &amp; &quot;31 triangle ABF@ is equal \n   to the @32 triangle CBF@, for they\n   h&quot;
 &amp; &quot;ave the same @33 base BF@, and are \n   in the same @34 parallels BF, G&quot;
 &amp; &quot;C@.\n   @Shear1\n   \n   @Angles @\n   And, since the @51 angle DBC@ is&quot;
 &amp; &quot; equal\n   to the @52 angle FBA@: for each is right:\n   \n   Let the @&quot;
 &amp; &quot;53 angle ABC@ be added to each;\n   \n   Therefore the whole @54 angle &quot;
 &amp; &quot;FBC@ is\n   equal to the whole @55 angle ABD@.\n   @Angles\n   \n   @Si&quot;
 &amp; &quot;des @\n   Now the @41 side BF@ is equal to the\n   @42 side BA@; and th&quot;
 &amp; &quot;e @43 side BC@ is equal\n   to the @44 side BD@;\n   @Sides\n   \n   @R&quot;
 &amp; &quot;otate @\n   Therefore @61 triangle FBC@ is equal\n   to @62 triangle AB&quot;
 &amp; &quot;D@.\n   @Rotate\n   \n   @Shear2 @\n   And again the @71 triangle ABD@ &quot;
 &amp; &quot;is \n   equal to the @72 triangle BDL@, for they\n   have the same @73 &quot;
 &amp; &quot;base BD@, and are \n   in the same @74 parallels BD, AL@.\n   @Shear2\n&quot;
 &amp; &quot;   \n   @End1 @\n   Thus we have shown that @81 triangle ABF@\n   is eq&quot;
 &amp; &quot;ual to the @82 triangle BDL@.  And\n   therefore, the @83 square GB@ is&quot;
 &amp; &quot; equal\n   to the @84 rectangle BL@.\n   @End1\n   \n   @Symmetry @\n  &quot;
 &amp; &quot; And by the same argument, the \n   @91 triangle CAK@ is equal to the\n&quot;
 &amp; &quot;   @92 triangle CEL@.\n   \n   And the @93 square HC@ is equal to the\n&quot;
 &amp; &quot;   @94 rectangle CL@.\n   @Symmetry\n   \n   @Rehash @\n@100   And ther&quot;
 &amp; &quot;efore the square \n   on the side subtending the right\n   angle is equ&quot;
 &amp; &quot;al to the squares on the&quot;;

CONST E48_0 =
   &quot; \n   sides containing the right angle.                                &quot;
 &amp; &quot;          @\n   \n@101   Which is what was to be proved.               &quot;
 &amp; &quot;                         @\n   @Rehash\n&quot;;

CONST E49 =
   &quot;; Copyright (C) 1994, Digital Equipment Corporation\n; All rights reser&quot;
 &amp; &quot;ved.\n; See the file COPYRIGHT for a full description.\n\n(Scale\n  (HS&quot;
 &amp; &quot;cale 1)\n  (VScale 1)\n  (Rim\n    (Pen 10)\n    (HBox\n      (Shape (W&quot;
 &amp; &quot;idth + 0) (VBox\n        (Text RightAlign \&quot;# of bins: \&quot;)\n        (Te&quot;
 &amp; &quot;xt RightAlign \&quot;# of items: \&quot;)\n        (Text RightAlign \&quot;current wei&quot;
 &amp; &quot;ght: \&quot;)\n        (Text RightAlign \&quot;probing bin #: \&quot;)\n        (Text &quot;
 &amp; &quot;RightAlign \&quot;total missing weights: \&quot;)))\n      (Shape (Width 50) (VBo&quot;
 &amp; &quot;x\n        (Text %B \&quot;\&quot;)\n        (Text %N \&quot;\&quot;)\n        (Text %wt \&quot;&quot;
 &amp; &quot;\&quot;)\n        (Text %bin \&quot;\&quot;)\n        (Text %lost \&quot;\&quot;))))))\n&quot;;

CONST E50 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:29:09 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Matc&quot;
 &amp; &quot;h.evt.\n;**************************************************************&quot;
 &amp; &quot;******\n\n(VBox\n  (Border (Pen 1)\n    (Shape\n      (Height 75 - 25 +&quot;
 &amp; &quot; Inf)\n      (Viewport\n        (HBox\n          (Glue 4 + Inf)\n      &quot;
 &amp; &quot;    (VBox\n            (Glue 6)\n            (Shape (Height 16 + 0)\n  &quot;
 &amp; &quot;            (HBox Fill (Shape (Width + 0) (Height + 0) \n              &quot;
 &amp; &quot;                  \&quot;Code View events:   Stop? \&quot;) \n                   &quot;
 &amp; &quot; (Boolean %stopatCodeEvents =TRUE \&quot;\&quot;)\n                    (Glue 10)\n&quot;
 &amp; &quot;                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n    &quot;
 &amp; &quot;                (Shape (Width 80) (Numeric %waitatCodeEvents =1 \n     &quot;
 &amp; &quot;                                          (Min 0) (Max 100)))))\n      &quot;
 &amp; &quot;      (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox&quot;
 &amp; &quot; Fill (Shape (Width + 0) (Height + 0) \n                               &quot;
 &amp; &quot; \&quot;Init:   Stop? \&quot;) \n                    (Boolean %stopAtInit =TRUE \&quot;&quot;
 &amp; &quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Width +&quot;
 &amp; &quot; 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (&quot;
 &amp; &quot;Numeric %waitAtInit =1 \n                                              &quot;
 &amp; &quot; (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape (Heigh&quot;
 &amp; &quot;t 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n &quot;
 &amp; &quot;                               \&quot;SetState:   Stop? \&quot;) \n              &quot;
 &amp; &quot;      (Boolean %stopAtSetState =TRUE \&quot;\&quot;)\n                    (Glue 1&quot;
 &amp; &quot;0)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n&quot;
 &amp; &quot;                    (Shape (Width 80) (Numeric %waitAtSetState =1 \n   &quot;
 &amp; &quot;                                            (Min 0) (Max 100)))))\n    &quot;
 &amp; &quot;        (Glue 6)\n          )\n          (Glue 4)\n          (VBox\n   &quot;
 &amp; &quot;       &quot;;

CONST E50_0 =
   &quot;  (Glue 5)\n            (Shape (Width + 0) (Height 16 + 0) \&quot;Cts:\&quot;)\n &quot;
 &amp; &quot;           (Button %eventCounts\n              (VBox\n                (&quot;
 &amp; &quot;Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) &quot;
 &amp; &quot;\n                                  (Text %ctOfInit \&quot;0\&quot;)))\n         &quot;
 &amp; &quot;       (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height &quot;
 &amp; &quot;16 + 0) \n                                  (Text %ctOfSetState \&quot;0\&quot;))&quot;
 &amp; &quot;)\n                (Glue 3))))\n          Fill\n          (Glue 4 + Inf&quot;
 &amp; &quot;)\n        )\n      )\n    )\n  )\n)\n&quot;;

CONST E51 =
   &quot;(* Copyright (C) 1993, Digital Equipment Corporation                   &quot;
 &amp; &quot;      *)\n(* All rights reserved.                                      &quot;
 &amp; &quot;                *)\n(* See the file COPYRIGHT for a full description.  &quot;
 &amp; &quot;                          *)\n\n\nlet RingSize = [0.15, 0.10, 0.05];\nl&quot;
 &amp; &quot;et RingColor = [color_named(\&quot;darkred\&quot;), color_named(\&quot;darkgreen\&quot;),\n&quot;
 &amp; &quot;                 color_named(\&quot;darkblue\&quot;)];\nlet GraphEdgeColor = colo&quot;
 &amp; &quot;r_named(\&quot;gray\&quot;);\nlet FlickerColor = color_named(\&quot;verylightgray\&quot;);\n&quot;
 &amp; &quot;let HighColor = color_named(\&quot;black\&quot;);\nlet HighBorder = 0.01;\n\nlet &quot;
 &amp; &quot;PathColor = color_named(\&quot;red\&quot;);\nlet PromoteColor = RingColor;\nlet C&quot;
 &amp; &quot;andidateColor = [GraphEdgeColor, color_named(\&quot;lightred\&quot;),\n          &quot;
 &amp; &quot;            color_named(\&quot;lightgreen\&quot;), color_named(\&quot;lightblue\&quot;)];\n&quot;
 &amp; &quot;let BackgroundColor = color_named(\&quot;darkslategray\&quot;);\nlet EdgeWidth = &quot;
 &amp; &quot;[0.00575, 0.00375, 0.00375, 0.00375];\nlet SourceColor = RingColor[0];\n&quot;
 &amp; &quot;let DestColor = RingColor[2];\n  \nlet Graphic = {\n        go =&gt; ok, (&quot;
 &amp; &quot;* the graphical object *)\n        up =&gt; ok, (* the predecessor Graphic&quot;
 &amp; &quot; *)\n        bottom =&gt; ok, (* the lowest element *)\n\n        newAbove&quot;
 &amp; &quot; =&gt; meth(self, obj)\n          var res = clone(self);\n          res.go&quot;
 &amp; &quot; := obj;\n          self.up := res;\n          var lift = res;\n       &quot;
 &amp; &quot;   loop\n            if lift is ok then exit end;\n            graph_se&quot;
 &amp; &quot;tObjectLayer(lift.go, 0);\n            lift := lift.up\n          end;\n&quot;
 &amp; &quot;          res\n        end,\n          \n        down =&gt; meth(self)\n  &quot;
 &amp; &quot;        var p = self.bottom;\n          loop\n            if p is ok th&quot;
 &amp; &quot;en exit end;\n            if p.up is self then exit end;\n            p&quot;
 &amp; &quot; := p.up\n          end;\n          p\n        end,\n\n        newBelow&quot;
 &amp; &quot; =&gt; meth(self, obj)\n          self.down.newAbove(obj)\n        end,\n\n&quot;
 &amp; &quot;        remove =&gt; meth(self)\n          var p = self.down;\n          i&quot;
 &amp; &quot;f not (p is ok) then p.up := self.up end;\n          self.go\n        e&quot;
 &amp; &quot;nd\n};\n\nlet Edge = {\n  t =&gt; ok,\n  sourceV =&gt; ok,\n  sourceN =&gt; -1,\n&quot;
 &amp; &quot;  destV =&gt; ok,\n  destN =&gt; -1,\n  gr =&gt; ok,\n  ctls =&gt; ok,\n  sex =&gt; ok&quot;
 &amp; &quot;,\n\n  create =&gt; meth(self, t&quot;;

CONST E51_0 =
   &quot;, fromV, fromN, toV, toN, sex)\n    let invisible = proc(pt)\n      let&quot;
 &amp; &quot; res = graph_newVertex(t.g);\n      graph_setVertexSize(res, 0.0, 0.0);&quot;
 &amp; &quot;\n      graph_moveVertex(res, pt[0], pt[1], false);\n      res\n    end&quot;
 &amp; &quot;;\n    let +++ = proc(p, q)\n      [ p[0] + q[0], p[1] + q[1] ]\n    en&quot;
 &amp; &quot;d;\n    let --- = proc(p, q)\n      [ p[0] - q[0], p[1] - q[1] ]\n    e&quot;
 &amp; &quot;nd;\n    let *** = proc(p, q)\n      [ (p[0] * q[0]) - (p[1] * q[1]),\n&quot;
 &amp; &quot;        (p[0] * q[1]) + (p[1] * q[0]) ]\n    end;\n    let rel = proc(z&quot;
 &amp; &quot;, w) \n      w[0] +++ (z *** (w[1] --- w[0]))\n    end;\n    self.gr :=&quot;
 &amp; &quot; [ok, ok];\n    self.t := t;\n    self.sex := sex;\n    self.sourceV :=&quot;
 &amp; &quot; fromV;\n    self.sourceN := fromN;\n    self.destV := toV;\n    self.d&quot;
 &amp; &quot;estN := toN;\n    let spos = fromV.pos;\n    let dpos = toV.pos;\n    v&quot;
 &amp; &quot;ar skew = float(fromN + 1) / (0.0 - 10.0);\n    if sex is \&quot;L\&quot; then sk&quot;
 &amp; &quot;ew := 0.0 - skew end;\n    var mid = [0.5, skew] rel [spos, dpos];\n   &quot;
 &amp; &quot; var s2 = [0.33, skew] rel [spos, dpos];\n    var s1 = [0.5, skew / 4.0&quot;
 &amp; &quot;] rel [spos, s2];\n    var d2 = [0.67, skew] rel [spos, dpos];\n    var&quot;
 &amp; &quot; d1 = [0.5, skew / 4.0] rel [d2, dpos];\n    var midpt = invisible(mid)&quot;
 &amp; &quot;;\n    var s1pt = invisible(s1);\n    var s2pt = invisible(s2);\n    va&quot;
 &amp; &quot;r d1pt = invisible(d1);\n    var d2pt = invisible(d2);\n    self.ctls :&quot;
 &amp; &quot;= [midpt, s1pt, s2pt, d1pt, d2pt];\n    var sedge = graph_newEdge(fromV&quot;
 &amp; &quot;.graphic(fromN).go, midpt);\n    graph_moveEdgeBezier(sedge, fromV.grap&quot;
 &amp; &quot;hic(fromN).go, midpt,\n                         s1pt, s2pt, false);\n  &quot;
 &amp; &quot;  self.gr[0] := fromV.graphic(fromN).newBelow(sedge);\n    var dedge = &quot;
 &amp; &quot;graph_newEdge(midpt, toV.graphic(toN).go);\n    graph_moveEdgeBezier(de&quot;
 &amp; &quot;dge, midpt, toV.graphic(toN).go,\n                         d2pt, d1pt, &quot;
 &amp; &quot;false);\n    self.gr[1] := toV.graphic(toN).newBelow(dedge);\n    graph&quot;
 &amp; &quot;_setEdgeColor(sedge, CandidateColor[fromN+1]);\n    graph_setEdgeColor(&quot;
 &amp; &quot;dedge, CandidateColor[fromN+1]);\n    graph_setEdgeWidth(sedge, EdgeWid&quot;
 &amp; &quot;th[fromN+1]);\n    graph_setEdgeWidth(dedge, EdgeWidth[fromN+1]);\n    &quot;
 &amp; &quot;graph_setEdgeArrows(dedge, false, true);\n    if toN &gt;= 0 then toV.se&quot;;

CONST E51_1 =
   &quot;tInEdge(toN, self) end;\n    self\n  end,\n\n  midpt =&gt; meth(self) self&quot;
 &amp; &quot;.ctls[0] end,\n\n  demote =&gt; meth(self)\n    foreach g in self.gr do\n &quot;
 &amp; &quot;     if not (g is ok) then\n        graph_removeEdge(g.remove)\n      e&quot;
 &amp; &quot;nd\n    end;\n    foreach g in self.ctls do\n      if not (g is ok) the&quot;
 &amp; &quot;n graph_removeVertex(g) end\n    end;\n    if (self.destN + 1) &lt; #(Ring&quot;
 &amp; &quot;Color) then\n      self.create(self.t, self.sourceV, self.sourceN, self&quot;
 &amp; &quot;.destV, \n                  self.destN + 1)\n    end\n  end,\n\n  highl&quot;
 &amp; &quot;ight =&gt; meth(self, clr)\n    foreach g in self.gr do\n      graph_setEd&quot;
 &amp; &quot;geColor(g.go, clr);\n    end\n  end,\n};\n  \nlet Vertex = {\n  positio&quot;
 &amp; &quot;n =&gt; ok,\n  t =&gt; ok,\n  gr =&gt; ok,\n  incEdge =&gt; ok,\n\n  pos =&gt; meth(se&quot;
 &amp; &quot;lf) self.position end,\n\n  graphic =&gt; meth(self, i)\n    if (i+1) &lt; #(&quot;
 &amp; &quot;self.gr) then self.gr[i+1] else self.t.bottom end end,\n\n  inEdge =&gt; m&quot;
 &amp; &quot;eth(self, i) self.incEdge[i] end,\n\n  setInEdge =&gt; meth(self, i, e) se&quot;
 &amp; &quot;lf.incEdge[i] := e end,\n\n  highlight =&gt; meth(self, i, clr)\n    graph&quot;
 &amp; &quot;_setVertexColor(self.graphic(i).go, clr)\n  end,\n\n create =&gt; meth(sel&quot;
 &amp; &quot;f, t, x, y, name)\n    self.gr := [ok, ok, ok, ok];\n    self.incEdge :&quot;
 &amp; &quot;= [ok, ok, ok];\n    var stack = t.bottom;\n    self.position := [x, y]&quot;
 &amp; &quot;;\n    self.t := t;\n    for i = 0 to 2 do\n      var v = graph_newVert&quot;
 &amp; &quot;ex(t.g);\n      graph_moveVertex(v, x, y, false);\n      graph_setVerte&quot;
 &amp; &quot;xShape(v, \&quot;ellipse\&quot;);\n      graph_setVertexSize(v, RingSize[i], Ring&quot;
 &amp; &quot;Size[i]);\n      graph_setVertexLabel(v, name);\n      graph_setVertexC&quot;
 &amp; &quot;olor(v, CandidateColor[3-i]);\n      stack := stack.newAbove(v);\n     &quot;
 &amp; &quot; self.gr[3-i] := stack\n    end;\n    self.gr[0] := self.gr[3];\n    se&quot;
 &amp; &quot;lf\n  end,\n};\n\nlet view = {\n graphvbt =&gt; graph_new(),\n g =&gt; meth (&quot;
 &amp; &quot;self) self.graphvbt end,\n\n bottom =&gt; clone(Graphic),\n spotlight =&gt; {&quot;
 &amp; &quot;current =&gt; ok, curIndex =&gt; 0, spot =&gt;ok},\n \n vtable =&gt; ok,\n etable =&quot;
 &amp; &quot;&gt; [ ],\n\n vertex =&gt; meth(self, name)\n   var res = ok;\n   for i = 0 t&quot;
 &amp; &quot;o #(self.vtable)-1 do\n     if self.vtable[i].name is name then\n      &quot;
 &amp; &quot; res := self.vtable[i].vertex;\n       exit\n     end\n   end;\n   res\n&quot;
 &amp; &quot; end,\n \n edge =&gt; meth(self, n&quot;;

CONST E51_2 =
   &quot;ame)\n   var res = ok;\n   for i = 0 to #(self.etable)-1 do\n     if se&quot;
 &amp; &quot;lf.etable[i].name is name then\n       res := self.etable[i].edge;\n   &quot;
 &amp; &quot;    exit\n     end\n   end;\n   res\n end,\n \n NewVertex =&gt; meth (self&quot;
 &amp; &quot;, name, x, y)\n   if self.vtable is ok then\n     self.bottom.bottom :=&quot;
 &amp; &quot; self.bottom;\n     self.vtable := [ ];\n     graph_setAspect(self.g, 1&quot;
 &amp; &quot;.0);\n     graph_setWorld(self.g, 0.0, 1.0, 1.0, 0.0);\n     let bg = g&quot;
 &amp; &quot;raph_newVertex(self.g);\n     graph_moveVertex(bg, 0.5, 0.5, false);\n &quot;
 &amp; &quot;    graph_setVertexColor(bg, BackgroundColor);\n     graph_setVertexSiz&quot;
 &amp; &quot;e(bg, 1.0, 1.0);\n   end;\n   self.vtable :=\n     self.vtable @\n     &quot;
 &amp; &quot;  [{name =&gt; name,\n         vertex =&gt; clone(Vertex).create(self, x, y, &quot;
 &amp; &quot;name)}];\n   graph_redisplay(self.g)\n end,\n\n NewEdge =&gt; meth (self, &quot;
 &amp; &quot;name, frompt, topt, orientation)\n   self.etable :=\n     self.etable @&quot;
 &amp; &quot;\n       [{name =&gt; name,\n         edge =&gt; clone(Edge).create(self, sel&quot;
 &amp; &quot;f.vertex(frompt),\n                                    -1, self.vertex(&quot;
 &amp; &quot;topt), -1, orientation)}];\n   graph_redisplay(self.g)\n end,\n\n Start&quot;
 &amp; &quot;Find =&gt; meth (self, frompt, topt)\n   self.vertex(frompt).highlight(0, &quot;
 &amp; &quot;SourceColor);\n   self.spotlight.current := self.vertex(frompt);\n   se&quot;
 &amp; &quot;lf.spotlight.curIndex := 0;\n   self.spotlight.spot :=\n     self.spotl&quot;
 &amp; &quot;ight.current.graphic(1).newAbove(\n       graph_newVertexHiLi(self.spot&quot;
 &amp; &quot;light.current.graphic(0).go));\n   graph_setVertexHiLiBorder(self.spotl&quot;
 &amp; &quot;ight.spot.go, HighBorder, HighBorder);\n   graph_setVertexHiLiColor(sel&quot;
 &amp; &quot;f.spotlight.spot.go, HighColor);\n(* self.vertex(topt).highlight(2, Des&quot;
 &amp; &quot;tColor); *)\n   graph_redisplay(self.g)\n end,\n\n Promote =&gt; meth (sel&quot;
 &amp; &quot;f, edge, sIndex, dIndex)\n   let dest = self.edge(edge).destV;\n   let &quot;
 &amp; &quot;mid = graph_newVertex(self.g);\n   let spot = self.spotlight.spot.go;\n&quot;
 &amp; &quot;   let size = (* (RingSize[2-dIndex] + RingSize[2-self.spotlight.curInd&quot;
 &amp; &quot;ex])/2.0; *) 0.0;\n   graph_setVertexSize(mid, size, size);\n   graph_s&quot;
 &amp; &quot;etVertexColor(mid, BackgroundColor);\n   graph_setVertexShape(mid, \&quot;el&quot;
 &amp; &quot;lipse\&quot;);\n   graph_moveVertex(mid,\n     (self.spotlight.current.pos[0&quot;
 &amp; &quot;] +&quot;;

CONST E51_3 =
   &quot; dest.pos[0]) / 2.0,\n     (self.spotlight.current.pos[1] + dest.pos[1]&quot;
 &amp; &quot;) / 2.0, false);\n   graph_moveVertexHiLi(spot, mid, true);\n   zeus_an&quot;
 &amp; &quot;imate(self.g, 0.0, 0.5);\n   self.spotlight.spot.remove;\n   self.spotl&quot;
 &amp; &quot;ight.spot := dest.graphic(dIndex+1).newAbove(spot);\n   self.spotlight.&quot;
 &amp; &quot;curIndex := dIndex;\n   graph_moveVertexHiLi(spot, dest.graphic(dIndex)&quot;
 &amp; &quot;.go, true);\n   zeus_animate(self.g, 0.5, 1.0);\n   graph_removeVertex(&quot;
 &amp; &quot;mid);\n   self.spotlight.current := dest;\n   dest.inEdge(dIndex).highl&quot;
 &amp; &quot;ight(CandidateColor[sIndex+1]);\n   graph_redisplay(self.g);\n   dest.i&quot;
 &amp; &quot;nEdge(dIndex).highlight(PromoteColor[sIndex]);\n   graph_redisplay(self&quot;
 &amp; &quot;.g);\n   dest.inEdge(dIndex).highlight(CandidateColor[sIndex+1]);\n   g&quot;
 &amp; &quot;raph_redisplay(self.g);\n   dest.inEdge(dIndex).highlight(PromoteColor[&quot;
 &amp; &quot;sIndex]);\n   graph_redisplay(self.g);\n   self.edge(edge).destV.highli&quot;
 &amp; &quot;ght(dIndex, RingColor[dIndex]);\n   graph_redisplay(self.g)\n end,\n\n &quot;
 &amp; &quot;Consider =&gt; meth (self, edge, sIndex, dIndex)\n   let e = self.edge(edg&quot;
 &amp; &quot;e);\n   let s = e.sourceV;\n   let d = e.destV;\n   for t = 1 to 4 do\n&quot;
 &amp; &quot;     e.highlight(CandidateColor[sIndex+1]);\n     graph_redisplay(self.&quot;
 &amp; &quot;g);\n     e.highlight(GraphEdgeColor);\n     graph_redisplay(self.g);\n&quot;
 &amp; &quot;   end;\n   if dIndex &gt;= 0 then\n     var i = #(d.incEdge)-1;\n     loo&quot;
 &amp; &quot;p\n       let inP = d.inEdge(i);\n       if not (inP is ok) then inP.de&quot;
 &amp; &quot;mote() end;\n       if i is dIndex then exit end;\n       i := i - 1\n &quot;
 &amp; &quot;    end;\n     clone(Edge).create(self, s, sIndex, d, dIndex, e.sex)\n &quot;
 &amp; &quot;  end;\n   graph_redisplay(self.g)\n end,\n\n Traceback =&gt; meth (self, &quot;
 &amp; &quot;edge, sIndex, dIndex)\n(*   self.edge(edge).destV.inEdge(dIndex).highli&quot;
 &amp; &quot;ght(PathColor);\n   graph_redisplay(self.g) *)\n   ok\n end,\n};\n\n&quot;;

CONST E52 =
   &quot;(* Copyright (C) 1994, Digital Equipment Corporation         *)\n(* All&quot;
 &amp; &quot; rights reserved.                                      *)\n(* See the f&quot;
 &amp; &quot;ile COPYRIGHT for a full description.            *)\n\n@Insertion\nPROC&quot;
 &amp; &quot;EDURE InsertionSort (a: ARRAY OF INTEGER) @=\n  VAR j: CARDINAL; v: INT&quot;
 &amp; &quot;EGER;\n  BEGIN\n    @1 FOR i := 2 TO LAST(a) DO@\n      @2 v := a[i];@\n&quot;
 &amp; &quot;      @3 j := i;@\n      @4 WHILE a[j - 1] &gt; v DO@ \n        @5 a[j] :=&quot;
 &amp; &quot; a[j - 1];@\n        @6 DEC (j);@\n      END;\n      @7 a[j] := v;@\n  &quot;
 &amp; &quot;  END\n  END InsertionRun;\n@Insertion\n&quot;;

CONST E53 =
   &quot;(* Copyright (C) 1994, Digital Equipment Corporation                   &quot;
 &amp; &quot;      *)\n(* All rights reserved.                                      &quot;
 &amp; &quot;                *)\n(* See the file COPYRIGHT for a full description.  &quot;
 &amp; &quot;                          *)\n(*                                       &quot;
 &amp; &quot;                                    *)\n(* AverageDepth.obl - view of a&quot;
 &amp; &quot;verage node depths.                           *)\n(* Last modified on M&quot;
 &amp; &quot;on Jan  9 12:04:03 PST 1995 by najork                   *)\n(*      mod&quot;
 &amp; &quot;ified on Wed Jul 27 11:24:28 PDT 1994 by shillner                 *)\n\n&quot;
 &amp; &quot;(* Screen dimensions. *)\nlet North: Real = 1.0;\nlet South: Real = 0.0&quot;
 &amp; &quot;;\nlet West: Real = 0.0;\nlet East: Real = 1.0;\nlet Margin: Real = 5.0&quot;
 &amp; &quot;;\n\n(* Caption stuff. *)\nlet CaptionHeight   = 0.1;\nlet BackgroundCo&quot;
 &amp; &quot;lor = color_named(\&quot;white\&quot;);\nlet FontSz          = 0.07;\n\n(* Bar se&quot;
 &amp; &quot;ttings. *)\nlet BarColor    = color_named(\&quot;magenta\&quot;);\nlet BorderColo&quot;
 &amp; &quot;r = color_named(\&quot;black\&quot;);\nlet BorderWidth = 0.005;\nlet TextColor   &quot;
 &amp; &quot;= color_named(\&quot;black\&quot;);\nlet BarGap      = 0.1;  (* Fraction of bar w&quot;
 &amp; &quot;idth. *)\nvar g = ok;\nvar labelFont = ok;\n\n(* Node Object ==========&quot;
 &amp; &quot;=================================================== *)\n\nlet Node = {\n&quot;
 &amp; &quot;  parent: Node =&gt; ok,\n  children: Node =&gt; ok,\n  next: Node =&gt; ok,    &quot;
 &amp; &quot;  (* Siblings. *)\n  prev: Node =&gt; ok,\n\n  (* Adds child as a child of&quot;
 &amp; &quot; parent, inserted to the right of \n     the child \&quot;rightOf\&quot;, which m&quot;
 &amp; &quot;ust be a child of parent, or as\n     the leftmost child if rightOf is &quot;
 &amp; &quot;ok *)\n  addChild =&gt; meth(parent, rightOf, child: Node)\n    if rightOf&quot;
 &amp; &quot; is ok then\n      child.next := parent.children;\n      child.prev := &quot;
 &amp; &quot;ok;\n      if child.next isnot ok then child.next.prev := child; end;\n&quot;
 &amp; &quot;      parent.children := child;\n    else\n      child.prev := rightOf;&quot;
 &amp; &quot;\n      child.next := rightOf.next;\n      if child.next isnot ok then &quot;
 &amp; &quot;child.next.prev := child; end;\n      rightOf.next := child;\n    end;\n&quot;
 &amp; &quot;  end,\n\n  (* removes child from parent, which must be its parent *)\n&quot;
 &amp; &quot;  removeChild =&gt; meth(parent, child: Node)\n    if child.prev isnot ok\n&quot;
 &amp; &quot;    &quot;;

CONST E53_0 =
   &quot;  then child.prev.next := child.next;\n      else parent.children := ch&quot;
 &amp; &quot;ild.next;\n    end;\n    if child.next isnot ok then child.next.prev :=&quot;
 &amp; &quot; child.prev; end;\n    child.prev := ok;\n    child.next := ok;\n  end,&quot;
 &amp; &quot;\n\n  walk =&gt; meth(node: Node, level: Int)\n    var ch = node.children;&quot;
 &amp; &quot;\n    var acc = 0;\n    var count = 0;\n    loop\n      if ch is ok the&quot;
 &amp; &quot;n exit end;\n      let res = ch.walk(level + 1);\n      acc := acc + re&quot;
 &amp; &quot;s.acc;\n      count := count + res.count;\n      ch := ch.next;\n    en&quot;
 &amp; &quot;d;\n    {acc =&gt; acc + level, count =&gt; count + 1};\n  end,\n\n};\n\n\n(*&quot;
 &amp; &quot; Bar Object ===========================================================&quot;
 &amp; &quot;=== *)\n\nlet Bar = {\n  size: Float =&gt; ok,\n  next: Bar =&gt; ok,\n  col:&quot;
 &amp; &quot; Int =&gt; ok,\n  v: Vertex =&gt; ok,\n\n  init =&gt; meth(self: Bar, col: Int, &quot;
 &amp; &quot;size: Float): Bar,\n    self.size := size;\n    self.col := col;\n    s&quot;
 &amp; &quot;elf.next := ok;\n    if self.col &gt;= 0 then\n      self.v := graph_newVe&quot;
 &amp; &quot;rtex(g);\n      graph_setVertexColor(self.v, BarColor);\n      graph_se&quot;
 &amp; &quot;tVertexBorderColor(self.v, BorderColor);\n(*      graph_setVertexBorder&quot;
 &amp; &quot;(self.v, BorderWidth);*)\n      graph_setVertexSize(self.v, 1.0, 0.0);\n&quot;
 &amp; &quot;(*      graph_setVertexLabelColor(self.v, TextColor);\n      graph_setV&quot;
 &amp; &quot;ertexFont(self.v, labelFont);*)\n      graph_moveVertex(self.v, float(s&quot;
 &amp; &quot;elf.col), 0.0, true);\n    end;\n    self;\n  end,\n\n  clear =&gt; meth(s&quot;
 &amp; &quot;elf: Bar)\n    self.size := 0.0;\n    if self.next isnot ok then self.n&quot;
 &amp; &quot;ext.clear() end;\n  end,\n\n  update =&gt; meth(self: Bar, maxHeight: Floa&quot;
 &amp; &quot;t, maxCols: Int,\n                 barGraph: BarGraph): ok,\n    let he&quot;
 &amp; &quot;ight = if self.size &gt; maxHeight then self.size else maxHeight end;\n   &quot;
 &amp; &quot; let cols = if self.size isnot 0.0 then self.col else maxCols end;\n\n &quot;
 &amp; &quot;   if self.next isnot ok then self.next.update(height, cols, barGraph)\n&quot;
 &amp; &quot;    else barGraph.barCounts(height, cols + 1) end;\n\n    let shape = b&quot;
 &amp; &quot;arGraph.barShape(self.size, self.col);\n    graph_setVertexSize(self.v,&quot;
 &amp; &quot; shape.w, shape.h);\n    graph_moveVertex(self.v, shape.x, shape.y, fal&quot;
 &amp; &quot;se);\n(*    graph_setVertexLabel(self.v, fmt_real(self.size));*)\n  end&quot;
 &amp; &quot;,\n};\n\n&quot;;

CONST E53_1 =
   &quot;(* BarGraph Object ====================================================&quot;
 &amp; &quot;===== *)\n\nlet BarGraph = {\n  west: Float =&gt; ok,\n  east: Float =&gt; ok&quot;
 &amp; &quot;,\n  north: Float =&gt; ok,\n  south: Float =&gt; ok,\n  height: Float =&gt; ok,&quot;
 &amp; &quot;\n  width: Float =&gt; ok,\n  bar: Bar =&gt; ok,\n  lastBar: Bar =&gt; ok,\n  co&quot;
 &amp; &quot;lWidth: Float =&gt; ok,\n  unitHeight: Float =&gt; ok,\n  baseCol: Float =&gt; o&quot;
 &amp; &quot;k,\n  barWidth: Float =&gt; ok,\n  tallest: Float =&gt; ok,\n\n  init =&gt; meth&quot;
 &amp; &quot;(self: BarGraph, west, east, north, south: Float,\n               bar: &quot;
 &amp; &quot;Bar): BarGraph,\n    self.west := west;\n    self.east := east;\n    se&quot;
 &amp; &quot;lf.north := north;\n    self.south := south;\n    self.height := north &quot;
 &amp; &quot;- south;\n    self.width := east - west;\n    self.bar := bar;\n    sel&quot;
 &amp; &quot;f.lastBar := bar;\n    self;\n  end,\n\n  barCounts =&gt; meth(self: BarGr&quot;
 &amp; &quot;aph, height: Float, cols: Int): ok,\n    self.colWidth := self.width / &quot;
 &amp; &quot;float(cols);\n    self.unitHeight := if height is 0.0 then 0.0\n       &quot;
 &amp; &quot;                else self.height / height end;\n    self.baseCol := sel&quot;
 &amp; &quot;f.west + (0.5 * self.colWidth);\n    self.barWidth := self.colWidth (*-&quot;
 &amp; &quot; (self.colWidth * BarGap)*);\n    self.tallest := height;\n  end,\n\n  &quot;
 &amp; &quot;barShape =&gt; meth(self: BarGraph, size: Float, col: Int): Shape,\n    va&quot;
 &amp; &quot;r shape = {w =&gt; ok, h =&gt; ok, x =&gt; ok, y =&gt; ok};\n\n    shape.w := self.&quot;
 &amp; &quot;barWidth;\n    shape.h := size * self.unitHeight;\n    shape.x := self.&quot;
 &amp; &quot;baseCol + (self.colWidth * float(col));\n    shape.y := self.south + (0&quot;
 &amp; &quot;.5 * shape.h);\n    shape;\n  end,\n\n  update =&gt; meth(self: BarGraph, &quot;
 &amp; &quot;avg: Float): Float,\n    self.lastBar.next := clone(Bar).init(self.last&quot;
 &amp; &quot;Bar.col + 1, avg);\n    self.lastBar := self.lastBar.next;\n    self.ba&quot;
 &amp; &quot;r.next.update(0.0, 0, self);\n    self.tallest;\n  end,\n  \n};\n\n\n(*&quot;
 &amp; &quot; View Object ==========================================================&quot;
 &amp; &quot;=== *)\n\nlet view = {\n\n  graphvbt =&gt; graph_new(),\n  counts =&gt; ok,\n&quot;
 &amp; &quot;  numSets =&gt; 0,\n  node =&gt; ok,\n  root: Node =&gt; ok,\n  bar: Bar =&gt; ok,\n&quot;
 &amp; &quot;  barGraph: BarGraph =&gt; ok,\n  height: Int =&gt; ok,\n  width: Int =&gt; ok,\n&quot;
 &amp; &quot;  caption: Vertex =&gt; ok,\n\n  FinishedSets =&gt; meth(self: View, numSets:&quot;
 &amp; &quot; Int, usesRan&quot;;

CONST E53_2 =
   &quot;ks: Bool)\n    g := self.graphvbt;  (* Must be done before Bar.init(). &quot;
 &amp; &quot;*)\n    self.numSets := numSets;\n    self.root := clone(Node);\n    se&quot;
 &amp; &quot;lf.bar := clone(Bar).init(-1, 0.0);\n    self.barGraph := clone(BarGrap&quot;
 &amp; &quot;h).init(West, East, North,\n                                          S&quot;
 &amp; &quot;outh + CaptionHeight, self.bar);\n    self.node := array_new(numSets, o&quot;
 &amp; &quot;k);\n    labelFont := graph_newFont(self.graphvbt, \&quot;Helvetica\&quot;, FontS&quot;
 &amp; &quot;z,\n                               \&quot;Roman\&quot;, \&quot;bold\&quot;, \&quot;*\&quot;);\n\n    &quot;
 &amp; &quot;for i=0 to numSets-1 do\n      var node = clone(Node);\n      self.root&quot;
 &amp; &quot;.addChild(ok, node);\n      self.node[i] := node;\n    end;\n\n    grap&quot;
 &amp; &quot;h_setWorld(self.graphvbt, West, East, North, South);\n    graph_setMarg&quot;
 &amp; &quot;in(self.graphvbt, Margin);\n    self.caption := graph_newVertex(self.gr&quot;
 &amp; &quot;aphvbt);\n    graph_moveVertex(self.caption, (West + East) / 2.0,\n    &quot;
 &amp; &quot;                 South + (CaptionHeight / 2.0), false);\n    graph_setV&quot;
 &amp; &quot;ertexSize(self.caption, East - West, CaptionHeight);\n    graph_setVert&quot;
 &amp; &quot;exColor(self.caption, BackgroundColor);\n    graph_setVertexFont(self.c&quot;
 &amp; &quot;aption, labelFont);\n    graph_setVertexLabel(self.caption, \&quot;\&quot;);\n   &quot;
 &amp; &quot; graph_setVertexLabelColor(self.caption, TextColor);\n(*    self.update&quot;
 &amp; &quot;();*)\n  end,\n\n  update =&gt; meth(self: View): ok,\n    let res = self.&quot;
 &amp; &quot;root.walk(-1);\n    let avg = float(res.acc + 1) / float(self.numSets);&quot;
 &amp; &quot;\n    let tallest = self.barGraph.update(avg);\n    graph_setVertexLabe&quot;
 &amp; &quot;l(self.caption,\n                         \&quot;Scale: \&quot; &amp;\n              &quot;
 &amp; &quot;            text_replaceAll(\&quot;d\&quot;, \&quot;0\&quot;,\n                            &quot;
 &amp; &quot;              text_sub(fmt_real(tallest), 0, 4)));\n    graph_redisplay&quot;
 &amp; &quot;(self.graphvbt);\n(*    zeus_animate(self.graphvbt, 0.0, 0.0);*)\n  end&quot;
 &amp; &quot;,\n\n  ChangeParent =&gt; meth(self: View, childId, parentId, rootId: Int)&quot;
 &amp; &quot;\n    let parent = self.node[parentId];\n    let child = self.node[chil&quot;
 &amp; &quot;dId];\n    let root = self.node[rootId];\n    \n    parent.removeChild(&quot;
 &amp; &quot;child);\n    root.addChild(ok, child);\n\n    self.update();\n    ok;\n&quot;
 &amp; &quot;  end,\n\n  Unite =&gt; meth(self: View, childId, parentId, pRank: Int)\n &quot;
 &amp; &quot;   let paren&quot;;

CONST E53_3 =
   &quot;t = self.node[parentId];\n    let child = self.node[childId];\n\n    se&quot;
 &amp; &quot;lf.root.removeChild(child);\n    parent.addChild(ok, child);\n\n    sel&quot;
 &amp; &quot;f.update();\n    ok;\n  end,\n\n};\n\n&quot;;

CONST E54 =
   &quot;; Copyright (C) 1992, Digital Equipment Corporation\n; All rights reser&quot;
 &amp; &quot;ved.\n; See the file COPYRIGHT for a full description.\n\n(Rim\n  (Pen &quot;
 &amp; &quot;0)\n  (HBox\n    (VBox\n      (Shape\n        (BgColor \&quot;White\&quot;)\n    &quot;
 &amp; &quot;    (LightShadow \&quot;White\&quot;)\n        (DarkShadow \&quot;White\&quot;)\n        (W&quot;
 &amp; &quot;idth 300 + inf)\n        (Height 100 + inf)\n        (PageButton (For p&quot;
 &amp; &quot;arms) (Generic %g)))\n      (TSplit\n        %parms\n        Flex\n    &quot;
 &amp; &quot;    Circular\n        (Shape (Width + Inf) (Generic))\n        (Rim\n  &quot;
 &amp; &quot;        (Pen 5)\n          (HBox\n            (VBox\n              (HBo&quot;
 &amp; &quot;x\n                (Fill)\n                (Shape (Width + 0) (Height +&quot;
 &amp; &quot; 0) \&quot;Bezier parameters \&quot;)\n                (Fill))\n              (Gl&quot;
 &amp; &quot;ue 6)\n              (HBox\n                (VBox\n                  (H&quot;
 &amp; &quot;Box \&quot;px\&quot;)\n                  (Glue 2)\n                  (Numeric %px&quot;
 &amp; &quot; =25 (Min 0) (Max 100)))\n                (Glue 10)\n                (V&quot;
 &amp; &quot;Box\n                  (HBox \&quot;py\&quot;)\n                  (Glue 2)\n     &quot;
 &amp; &quot;             (Numeric %py =25 (Min 0) (Max 100)))\n                (Glu&quot;
 &amp; &quot;e 10)\n                (VBox\n                  (HBox \&quot;Control points &quot;
 &amp; &quot;size\&quot;)\n                  (Glue 2)\n                  (Numeric %cpsize&quot;
 &amp; &quot; =0 (Min 0) (Max 10)))))\n            (Fill)))))))\n&quot;;

CONST E55 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:29:09 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file CP.e&quot;
 &amp; &quot;vt.\n;*****************************************************************&quot;
 &amp; &quot;***\n\n(VBox\n  (Border (Pen 1)\n    (Shape\n      (Height 75 - 25 + In&quot;
 &amp; &quot;f)\n      (Viewport\n        (HBox\n          (Glue 4 + Inf)\n         &quot;
 &amp; &quot; (VBox\n            (Glue 6)\n            (Shape (Height 16 + 0)\n     &quot;
 &amp; &quot;         (HBox Fill (Shape (Width + 0) (Height + 0) \n                 &quot;
 &amp; &quot;               \&quot;Code View events:   Stop? \&quot;) \n                    (B&quot;
 &amp; &quot;oolean %stopatCodeEvents =TRUE \&quot;\&quot;)\n                    (Glue 10)\n  &quot;
 &amp; &quot;                  (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n      &quot;
 &amp; &quot;              (Shape (Width 80) (Numeric %waitatCodeEvents =1 \n       &quot;
 &amp; &quot;                                        (Min 0) (Max 100)))))\n        &quot;
 &amp; &quot;    (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox F&quot;
 &amp; &quot;ill (Shape (Width + 0) (Height + 0) \n                                \&quot;&quot;
 &amp; &quot;Setup:   Stop? \&quot;) \n                    (Boolean %stopAtSetup =TRUE \&quot;&quot;
 &amp; &quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Width +&quot;
 &amp; &quot; 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (&quot;
 &amp; &quot;Numeric %waitAtSetup =1 \n                                             &quot;
 &amp; &quot;  (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape (Heig&quot;
 &amp; &quot;ht 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n&quot;
 &amp; &quot;                                \&quot;AddPoint:   Stop? \&quot;) \n             &quot;
 &amp; &quot;       (Boolean %stopAtAddPoint =TRUE \&quot;\&quot;)\n                    (Glue &quot;
 &amp; &quot;10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n&quot;
 &amp; &quot;                    (Shape (Width 80) (Numeric %waitAtAddPoint =1 \n   &quot;
 &amp; &quot;                                            (Min 0) (Max 100)))))\n    &quot;
 &amp; &quot;        (Glue 6)\n            (Shape (Height 16 + 0)\n              (HB&quot;
 &amp; &quot;ox Fi&quot;;

CONST E55_0 =
   &quot;ll (Shape (Width + 0) (Height + 0) \n                                \&quot;&quot;
 &amp; &quot;NotProcessed:   Stop? \&quot;) \n                    (Boolean %stopAtNotProc&quot;
 &amp; &quot;essed =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (&quot;
 &amp; &quot;Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shap&quot;
 &amp; &quot;e (Width 80) (Numeric %waitAtNotProcessed =1 \n                        &quot;
 &amp; &quot;                       (Min 0) (Max 100)))))\n            (Glue 6)\n   &quot;
 &amp; &quot;         (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width&quot;
 &amp; &quot; + 0) (Height + 0) \n                                \&quot;RemoveNotProcess&quot;
 &amp; &quot;ed:   Stop? \&quot;) \n                    (Boolean %stopAtRemoveNotProcesse&quot;
 &amp; &quot;d =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shap&quot;
 &amp; &quot;e (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (W&quot;
 &amp; &quot;idth 80) (Numeric %waitAtRemoveNotProcessed =1 \n                      &quot;
 &amp; &quot;                         (Min 0) (Max 100)))))\n            (Glue 6)\n &quot;
 &amp; &quot;           (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Wid&quot;
 &amp; &quot;th + 0) (Height + 0) \n                                \&quot;ActiveR:   Sto&quot;
 &amp; &quot;p? \&quot;) \n                    (Boolean %stopAtActiveR =TRUE \&quot;\&quot;)\n     &quot;
 &amp; &quot;               (Glue 10)\n                    (Shape (Width + 0) (Heigh&quot;
 &amp; &quot;t + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric %w&quot;
 &amp; &quot;aitAtActiveR =1 \n                                               (Min 0&quot;
 &amp; &quot;) (Max 100)))))\n            (Glue 6)\n            (Shape (Height 16 + &quot;
 &amp; &quot;0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n        &quot;
 &amp; &quot;                        \&quot;RemoveActiveR:   Stop? \&quot;) \n                &quot;
 &amp; &quot;    (Boolean %stopAtRemoveActiveR =TRUE \&quot;\&quot;)\n                    (Glu&quot;
 &amp; &quot;e 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;&quot;
 &amp; &quot;)\n                    (Shape (Width 80) (Numeric %waitAtRemoveActiveR &quot;
 &amp; &quot;=1 \n                                               (Min 0) (Max 100)))&quot;
 &amp; &quot;))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n         &quot;
 &amp; &quot;     (HBox Fill (Shape (Width + 0) (Height + 0) \n                     &quot;
 &amp; &quot;           \&quot;CloseR:   Stop? \&quot;) \n                    (Boolean %stopAt&quot;
 &amp; &quot;Close&quot;;

CONST E55_1 =
   &quot;R =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shap&quot;
 &amp; &quot;e (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (W&quot;
 &amp; &quot;idth 80) (Numeric %waitAtCloseR =1 \n                                  &quot;
 &amp; &quot;             (Min 0) (Max 100)))))\n            (Glue 6)\n            (&quot;
 &amp; &quot;Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Hei&quot;
 &amp; &quot;ght + 0) \n                                \&quot;RemoveCloseR:   Stop? \&quot;) &quot;
 &amp; &quot;\n                    (Boolean %stopAtRemoveCloseR =TRUE \&quot;\&quot;)\n       &quot;
 &amp; &quot;             (Glue 10)\n                    (Shape (Width + 0) (Height &quot;
 &amp; &quot;+ 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric %wai&quot;
 &amp; &quot;tAtRemoveCloseR =1 \n                                               (Mi&quot;
 &amp; &quot;n 0) (Max 100)))))\n            (Glue 6)\n            (Shape (Height 16&quot;
 &amp; &quot; + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n     &quot;
 &amp; &quot;                           \&quot;Split:   Stop? \&quot;) \n                    (&quot;
 &amp; &quot;Boolean %stopAtSplit =TRUE \&quot;\&quot;)\n                    (Glue 10)\n      &quot;
 &amp; &quot;              (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n          &quot;
 &amp; &quot;          (Shape (Width 80) (Numeric %waitAtSplit =1 \n                &quot;
 &amp; &quot;                               (Min 0) (Max 100)))))\n            (Glue&quot;
 &amp; &quot; 6)\n            (Shape (Height 16 + 0)\n              (HBox Fill (Shap&quot;
 &amp; &quot;e (Width + 0) (Height + 0) \n                                \&quot;SplitRem&quot;
 &amp; &quot;ove:   Stop? \&quot;) \n                    (Boolean %stopAtSplitRemove =TRU&quot;
 &amp; &quot;E \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Wid&quot;
 &amp; &quot;th + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 8&quot;
 &amp; &quot;0) (Numeric %waitAtSplitRemove =1 \n                                   &quot;
 &amp; &quot;            (Min 0) (Max 100)))))\n            (Glue 6)\n            (S&quot;
 &amp; &quot;hape (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Heig&quot;
 &amp; &quot;ht + 0) \n                                \&quot;NewMin:   Stop? \&quot;) \n     &quot;
 &amp; &quot;               (Boolean %stopAtNewMin =TRUE \&quot;\&quot;)\n                    &quot;
 &amp; &quot;(Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight&quot;
 &amp; &quot;: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtNewMin =1 &quot;
 &amp; &quot;\n       &quot;;

CONST E55_2 =
   &quot;                                        (Min 0) (Max 100)))))\n        &quot;
 &amp; &quot;    (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox F&quot;
 &amp; &quot;ill (Shape (Width + 0) (Height + 0) \n                                \&quot;&quot;
 &amp; &quot;NoChangeMin:   Stop? \&quot;) \n                    (Boolean %stopAtNoChange&quot;
 &amp; &quot;Min =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Sh&quot;
 &amp; &quot;ape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape &quot;
 &amp; &quot;(Width 80) (Numeric %waitAtNoChangeMin =1 \n                           &quot;
 &amp; &quot;                    (Min 0) (Max 100)))))\n            (Glue 6)\n      &quot;
 &amp; &quot;      (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width + &quot;
 &amp; &quot;0) (Height + 0) \n                                \&quot;SelectTrialPoint:  &quot;
 &amp; &quot; Stop? \&quot;) \n                    (Boolean %stopAtSelectTrialPoint =TRUE&quot;
 &amp; &quot; \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Widt&quot;
 &amp; &quot;h + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80&quot;
 &amp; &quot;) (Numeric %waitAtSelectTrialPoint =1 \n                               &quot;
 &amp; &quot;                (Min 0) (Max 100)))))\n            (Glue 6)\n          &quot;
 &amp; &quot;  (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (&quot;
 &amp; &quot;Height + 0) \n                                \&quot;DeselectTrialPoint:   S&quot;
 &amp; &quot;top? \&quot;) \n                    (Boolean %stopAtDeselectTrialPoint =TRUE&quot;
 &amp; &quot; \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Widt&quot;
 &amp; &quot;h + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80&quot;
 &amp; &quot;) (Numeric %waitAtDeselectTrialPoint =1 \n                             &quot;
 &amp; &quot;                  (Min 0) (Max 100)))))\n            (Glue 6)\n        &quot;
 &amp; &quot;    (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0)&quot;
 &amp; &quot; (Height + 0) \n                                \&quot;SelectTargetPoint:   &quot;
 &amp; &quot;Stop? \&quot;) \n                    (Boolean %stopAtSelectTargetPoint =TRUE&quot;
 &amp; &quot; \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Widt&quot;
 &amp; &quot;h + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80&quot;
 &amp; &quot;) (Numeric %waitAtSelectTargetPoint =1 \n                              &quot;
 &amp; &quot;                 (Min 0) (Max 100)))))\n            (Glue 6)\n         &quot;
 &amp; &quot;  &quot;;

CONST E55_3 =
   &quot; (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (H&quot;
 &amp; &quot;eight + 0) \n                                \&quot;DeselectTargetPoint:   S&quot;
 &amp; &quot;top? \&quot;) \n                    (Boolean %stopAtDeselectTargetPoint =TRU&quot;
 &amp; &quot;E \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Wid&quot;
 &amp; &quot;th + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 8&quot;
 &amp; &quot;0) (Numeric %waitAtDeselectTargetPoint =1 \n                           &quot;
 &amp; &quot;                    (Min 0) (Max 100)))))\n            (Glue 6)\n      &quot;
 &amp; &quot;      (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width + &quot;
 &amp; &quot;0) (Height + 0) \n                                \&quot;DrawBar:   Stop? \&quot;&quot;
 &amp; &quot;) \n                    (Boolean %stopAtDrawBar =TRUE \&quot;\&quot;)\n          &quot;
 &amp; &quot;          (Glue 10)\n                    (Shape (Width + 0) (Height + 0&quot;
 &amp; &quot;) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAt&quot;
 &amp; &quot;DrawBar =1 \n                                               (Min 0) (Ma&quot;
 &amp; &quot;x 100)))))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n &quot;
 &amp; &quot;             (HBox Fill (Shape (Width + 0) (Height + 0) \n             &quot;
 &amp; &quot;                   \&quot;RemoveBar:   Stop? \&quot;) \n                    (Bool&quot;
 &amp; &quot;ean %stopAtRemoveBar =TRUE \&quot;\&quot;)\n                    (Glue 10)\n      &quot;
 &amp; &quot;              (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n          &quot;
 &amp; &quot;          (Shape (Width 80) (Numeric %waitAtRemoveBar =1 \n            &quot;
 &amp; &quot;                                   (Min 0) (Max 100)))))\n            (&quot;
 &amp; &quot;Glue 6)\n          )\n          (Glue 4)\n          (VBox\n            &quot;
 &amp; &quot;(Glue 5)\n            (Shape (Width + 0) (Height 16 + 0) \&quot;Cts:\&quot;)\n   &quot;
 &amp; &quot;         (Button %eventCounts\n              (VBox\n                (Gl&quot;
 &amp; &quot;ue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n&quot;
 &amp; &quot;                                  (Text %ctOfSetup \&quot;0\&quot;)))\n          &quot;
 &amp; &quot;      (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 1&quot;
 &amp; &quot;6 + 0) \n                                  (Text %ctOfAddPoint \&quot;0\&quot;)))&quot;
 &amp; &quot;\n                (Glue 6)\n                (HBox Fill (Shape (Width + &quot;
 &amp; &quot;0) (Height 16 + 0) \n                                  (Text %ctOfNotPr&quot;
 &amp; &quot;ocessed&quot;;

CONST E55_4 =
   &quot; \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Shape &quot;
 &amp; &quot;(Width + 0) (Height 16 + 0) \n                                  (Text %&quot;
 &amp; &quot;ctOfRemoveNotProcessed \&quot;0\&quot;)))\n                (Glue 6)\n            &quot;
 &amp; &quot;    (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n                   &quot;
 &amp; &quot;               (Text %ctOfActiveR \&quot;0\&quot;)))\n                (Glue 6)\n &quot;
 &amp; &quot;               (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n        &quot;
 &amp; &quot;                          (Text %ctOfRemoveActiveR \&quot;0\&quot;)))\n          &quot;
 &amp; &quot;      (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 1&quot;
 &amp; &quot;6 + 0) \n                                  (Text %ctOfCloseR \&quot;0\&quot;)))\n&quot;
 &amp; &quot;                (Glue 6)\n                (HBox Fill (Shape (Width + 0)&quot;
 &amp; &quot; (Height 16 + 0) \n                                  (Text %ctOfRemoveC&quot;
 &amp; &quot;loseR \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (S&quot;
 &amp; &quot;hape (Width + 0) (Height 16 + 0) \n                                  (T&quot;
 &amp; &quot;ext %ctOfSplit \&quot;0\&quot;)))\n                (Glue 6)\n                (HBo&quot;
 &amp; &quot;x Fill (Shape (Width + 0) (Height 16 + 0) \n                           &quot;
 &amp; &quot;       (Text %ctOfSplitRemove \&quot;0\&quot;)))\n                (Glue 6)\n     &quot;
 &amp; &quot;           (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n            &quot;
 &amp; &quot;                      (Text %ctOfNewMin \&quot;0\&quot;)))\n                (Glue&quot;
 &amp; &quot; 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n  &quot;
 &amp; &quot;                                (Text %ctOfNoChangeMin \&quot;0\&quot;)))\n      &quot;
 &amp; &quot;          (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Heig&quot;
 &amp; &quot;ht 16 + 0) \n                                  (Text %ctOfSelectTrialPo&quot;
 &amp; &quot;int \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Sha&quot;
 &amp; &quot;pe (Width + 0) (Height 16 + 0) \n                                  (Tex&quot;
 &amp; &quot;t %ctOfDeselectTrialPoint \&quot;0\&quot;)))\n                (Glue 6)\n         &quot;
 &amp; &quot;       (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n                &quot;
 &amp; &quot;                  (Text %ctOfSelectTargetPoint \&quot;0\&quot;)))\n              &quot;
 &amp; &quot;  (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + &quot;
 &amp; &quot;0) \n                                  (Text %ctOfDeselectTargetPoint \&quot;&quot;
 &amp; &quot;0\&quot;)))\n&quot;;

CONST E55_5 =
   &quot;                (Glue 6)\n                (HBox Fill (Shape (Width + 0)&quot;
 &amp; &quot; (Height 16 + 0) \n                                  (Text %ctOfDrawBar&quot;
 &amp; &quot; \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Shape &quot;
 &amp; &quot;(Width + 0) (Height 16 + 0) \n                                  (Text %&quot;
 &amp; &quot;ctOfRemoveBar \&quot;0\&quot;)))\n                (Glue 3))))\n          Fill\n  &quot;
 &amp; &quot;        (Glue 4 + Inf)\n        )\n      )\n    )\n  )\n)\n&quot;;

CONST E56 =
   &quot;(* Copyright 1993 Digital Equipment Corporation.                       &quot;
 &amp; &quot;      *)\n(* Distributed only by permission.                           &quot;
 &amp; &quot;                *)\n(*                                                 &quot;
 &amp; &quot;                          *)\n(* Last modified on Thu Oct 14 17:08:38 P&quot;
 &amp; &quot;DT 1993 by heydon                   *)\n(*      modified on Thu Aug  5 &quot;
 &amp; &quot;09:58:52 PDT 1993 by rsanchez                 *)\n\n(* This view shows &quot;
 &amp; &quot;the total number of steps that each packet needs to\n   traverse to go &quot;
 &amp; &quot;from its source to its destination node. *)\n\nlet moveColor = color_na&quot;
 &amp; &quot;med(\&quot;Green\&quot;);\nlet blockedColor = color_named(\&quot;Red\&quot;);\nlet nomoveCo&quot;
 &amp; &quot;lor = color_named(\&quot;Yellow\&quot;);\nlet finishedColor = color_named(\&quot;Black&quot;
 &amp; &quot;\&quot;);\nlet labelColor = color_named(\&quot;Black\&quot;);\nlet backgroundColor = c&quot;
 &amp; &quot;olor_named(\&quot;White\&quot;);\nlet edgeColor = color_named(\&quot;Black\&quot;);\n\nlet &quot;
 &amp; &quot;view =\n  {\n    graphvbt =&gt; graph_new(),\n    g =&gt; meth (self) self.gr&quot;
 &amp; &quot;aphvbt end,\n    vertexFont =&gt; ok,\n    pktCnt =&gt; ok,\n    steps =&gt; 0,\n&quot;
 &amp; &quot;    maxSteps =&gt; ok,\n    hopsT =&gt; [],\n    border =&gt; ok,\n    fntVSize &quot;
 &amp; &quot;=&gt; ok,\n    yLab1 =&gt; ok,\n    yLab2 =&gt; ok,\n    east =&gt; ok,\n    west =&quot;
 &amp; &quot;&gt; ok,\n    north =&gt; ok,\n    south =&gt; ok,\n\n\n    StartGraph =&gt; meth (&quot;
 &amp; &quot;self, nodeCnt, maxQS, bounded, xMax, yMax)\n      ok;\n    end,\n\n    &quot;
 &amp; &quot;NewNode =&gt; meth (self, id, x, y)\n      ok;\n    end,\n\n    NewStraigh&quot;
 &amp; &quot;tEdge =&gt; meth (self, id1, id2)\n      ok;\n    end,\n\n    NewCurvedEdg&quot;
 &amp; &quot;e =&gt; meth (self, id1, id2, x1, y1, x2, y2)\n      ok;\n    end,\n\n    &quot;
 &amp; &quot;NewLabel =&gt; meth (self, label, x, y)\n      ok;\n    end,\n\n    EndGra&quot;
 &amp; &quot;ph =&gt; meth (self)\n      ok;\n    end,\n\n    StartPackets =&gt; meth (sel&quot;
 &amp; &quot;f, pktCnt)\n      self.east := ~1.0;\n      self.west := float(pktCnt);&quot;
 &amp; &quot;\n      self.north := 11.0;\n      self.south := ~2.0;\n      self.maxS&quot;
 &amp; &quot;teps := 10;\n      self.border := 0.0;\n      self.fntVSize := 1.0;\n  &quot;
 &amp; &quot;    self.yLab1 := ~0.5;\n      self.yLab2 := ~1.5;\n\n      graph_setWo&quot;
 &amp; &quot;rld(self.graphvbt,\n\t             self.east, self.west, self.north, se&quot;
 &amp; &quot;lf.south);\n      self.vertexFont := \n\t graph_newFont(self.graphvbt, &quot;
 &amp; &quot;\&quot;Helvetica\&quot;, 0.2, \&quot;Roman\&quot;, \&quot;bo&quot;;

CONST E56_0 =
   &quot;ld\&quot;,\&quot;*\&quot;);\n\n      self.pktCnt := pktCnt;\n      for i = 0 to pktCnt&quot;
 &amp; &quot;-1 do\n        let vtx1 = graph_newVertex(self.graphvbt);\n        let &quot;
 &amp; &quot;vtx2 = graph_newVertex(self.graphvbt);\n        let vtx3 = graph_newVer&quot;
 &amp; &quot;tex(self.graphvbt);\n\tself.hopsT :=\n\t    self.hopsT @\n\t\t[{minNumH&quot;
 &amp; &quot;ops =&gt; 0,\n\t\t  congested =&gt; 0.0,\n\t\t  moved =&gt; false,\n\t\t  blocke&quot;
 &amp; &quot;d =&gt; false,\n\t\t  progress =&gt; true,\n\t\t  finished =&gt; false,\n\t\t  s&quot;
 &amp; &quot;rc =&gt; ok,\n\t\t  dst =&gt; ok,\n\t\t  vmove =&gt; vtx1,\n\t\t  vlastnomove =&gt;&quot;
 &amp; &quot; ok,\n\t\t  nomovecnt =&gt; 0,\n\t\t  vlastblocked =&gt; ok,\n\t\t  blockedcn&quot;
 &amp; &quot;t =&gt; 0,\n\t\t  vlab1 =&gt; vtx2,\n\t\t  vlab2 =&gt; vtx3}];\n        graph_ve&quot;
 &amp; &quot;rtexToBack(vtx1);\n\tgraph_setVertexBorder(vtx1, self.border);\n\tgraph&quot;
 &amp; &quot;_setVertexBorderColor(vtx1, color_rgb(0.0, 0.0, 0.0)); \n\tgraph_setVer&quot;
 &amp; &quot;texColor(vtx1, moveColor);\n\tgraph_moveVertex(vtx1, float(i), self.bor&quot;
 &amp; &quot;der/2.0, false);\n\tgraph_setVertexSize(vtx1, 0.95, self.border);\n\n\t&quot;
 &amp; &quot;graph_setVertexFont(vtx2, self.vertexFont);\n\tgraph_setVertexColor(vtx&quot;
 &amp; &quot;2, backgroundColor);\n\tgraph_setVertexLabelColor(vtx2, labelColor);\n\t&quot;
 &amp; &quot;graph_moveVertex(vtx2, float(i), self.yLab1, false);\n\tgraph_setVertex&quot;
 &amp; &quot;Size(vtx2, 0.95, self.fntVSize);\n\n\tgraph_setVertexLabel(vtx3, \&quot;0%\&quot;&quot;
 &amp; &quot;);\n\tgraph_setVertexFont(vtx3, self.vertexFont);\n\tgraph_setVertexCol&quot;
 &amp; &quot;or(vtx3, backgroundColor);\n        graph_setVertexLabelColor(vtx3, lab&quot;
 &amp; &quot;elColor);\n\tgraph_moveVertex(vtx3, float(i), self.yLab2, false);\n\tgr&quot;
 &amp; &quot;aph_setVertexSize(vtx3, 0.95, self.fntVSize);\n      end;\n    end,\n\n&quot;
 &amp; &quot;    NewPacket =&gt; meth (self, id, source, dest, fewestHops, name)\n     &quot;
 &amp; &quot; self.hopsT[id].minNumHops := fewestHops;\n      self.hopsT[id].src := &quot;
 &amp; &quot;source;\n      self.hopsT[id].dst := dest;\n      graph_setVertexLabel(&quot;
 &amp; &quot;self.hopsT[id].vlab1, name);\n    end,\n\n    EndPackets =&gt; meth (self)&quot;
 &amp; &quot;\n      graph_redisplay(self.graphvbt);\n    end,\n\n    Blocked =&gt; met&quot;
 &amp; &quot;h(self, id, fromN, toN)\n      self.hopsT[id].blocked := true;\n    end&quot;
 &amp; &quot;,\n\n    MovePacket =&gt; meth(self, id, fromN, toN) \n      self.hopsT[id&quot;
 &amp; &quot;].moved := true;\n    end,\n\n    Absorb =&gt; meth(self, id, node)\n     &quot;
 &amp; &quot; self.hopsT[id].progress := false;\n    end,\n\n    QueueSize&quot;;

CONST E56_1 =
   &quot;s =&gt; meth(self, queueSizes)\n      ok;\n    end,\n\n    Step =&gt; meth (s&quot;
 &amp; &quot;elf)\n      let fmtReal = proc (txt, dec)\n\tvar auxtxt = txt;\n\tlet i&quot;
 &amp; &quot;ndex = text_findFirstChar(\'.\', txt, 0);\n\tif index isnot ~1 then\n\t&quot;
 &amp; &quot;  auxtxt := text_sub(txt, 0, index+dec);\n        end;\n\tauxtxt\n     &quot;
 &amp; &quot; end;\n\n      self.steps := self.steps + 1;\n      if self.steps &gt;self&quot;
 &amp; &quot;.maxSteps then\n        self.maxSteps := self.maxSteps * 2;\n        se&quot;
 &amp; &quot;lf.north := self.north * 2.0;\n\tself.south := self.south * 2.0;\n\tsel&quot;
 &amp; &quot;f.fntVSize := self.fntVSize * 2.0;\n\tself.border := self.border * 2.0;&quot;
 &amp; &quot;\n\tself.yLab1 := self.yLab1 * 2.0;\n\tself.yLab2 := self.yLab2 * 2.0;\n&quot;
 &amp; &quot;\n        graph_setWorld(self.graphvbt,\n\t\t       self.east, self.wes&quot;
 &amp; &quot;t, self.north, self.south);\n\n        for i = 0 to self.pktCnt-1 do\n &quot;
 &amp; &quot;         graph_moveVertex(self.hopsT[i].vlab1,\n\t\t\t   float(i), self&quot;
 &amp; &quot;.yLab1, false);\n\t  graph_setVertexSize(self.hopsT[i].vlab1,\n\t\t\t  &quot;
 &amp; &quot;    0.95, self.fntVSize);\n          graph_moveVertex(self.hopsT[i].vla&quot;
 &amp; &quot;b2,\n\t                   float(i), self.yLab2, false);\n          grap&quot;
 &amp; &quot;h_setVertexSize(self.hopsT[i].vlab2,\n\t                      0.95, sel&quot;
 &amp; &quot;f.fntVSize);\n        end;\n      end;\n\n      for i = 0 to self.pktCn&quot;
 &amp; &quot;t-1 do\n\tif self.hopsT[i].finished is false then\n          if self.ho&quot;
 &amp; &quot;psT[i].moved is false then\n            if self.hopsT[i].blocked is tru&quot;
 &amp; &quot;e then\n\t      self.hopsT[i].blocked := false;\n              self.hop&quot;
 &amp; &quot;sT[i].congested := self.hopsT[i].congested + 1.0;\n\t      if self.hops&quot;
 &amp; &quot;T[i].vlastnomove isnot ok then\n\t\tself.hopsT[i].vlastnomove := ok;\n\t&quot;
 &amp; &quot;\tself.hopsT[i].nomovecnt := 0;\n              end;\n\t      if self.ho&quot;
 &amp; &quot;psT[i].vlastblocked is ok then\n\t        let vblocked = graph_newVerte&quot;
 &amp; &quot;x(self.graphvbt);\n                graph_setVertexBorder(vblocked, self&quot;
 &amp; &quot;.border);\n\t\tgraph_setVertexBorderColor(vblocked, color_rgb(0.0, 0.0,&quot;
 &amp; &quot; 0.0));\n                graph_setVertexColor(vblocked, blockedColor);\n&quot;
 &amp; &quot;\t\tgraph_moveVertex(vblocked, \n\t\t\t\t  float(i), float(self.steps) &quot;
 &amp; &quot;- 0.5, false);\n                graph_setVertexSize(vblocked,  0.95, 1.&quot;
 &amp; &quot;0);\n\t\tself.hopsT[i].vlastblocked:=&quot;;

CONST E56_2 =
   &quot; vblocked;\n\t\tself.hopsT[i].blockedcnt := 1;\n              else\n   &quot;
 &amp; &quot;             self.hopsT[i].blockedcnt := self.hopsT[i].blockedcnt + 1;\n&quot;
 &amp; &quot;\t\tgraph_moveVertex(self.hopsT[i].vblocked,\n\t\t\t\t  float(i),\n\t\t&quot;
 &amp; &quot;\t\t  float(self.steps) -\n\t\t\t\t    (float(self.hopsT[i].blockedcnt)&quot;
 &amp; &quot;/2.0),\n                                  false);\n                grap&quot;
 &amp; &quot;h_setVertexSize(self.hopsT[i].vlastblocked,\n\t\t\t\t     0.95, float(s&quot;
 &amp; &quot;elf.hopsT[i].blockedcnt));\n\n\t      end;\n            else\n\t      i&quot;
 &amp; &quot;f self.hopsT[i].vlastblocked isnot ok then\n\t\tself.hopsT[i].vlastbloc&quot;
 &amp; &quot;ked := ok;\n\t\tself.hopsT[i].blockedcnt := 0;\n              end;\n\t &quot;
 &amp; &quot;     if self.hopsT[i].vlastnomove is ok then\n\t        let vnomove = g&quot;
 &amp; &quot;raph_newVertex(self.graphvbt);\n\t        graph_setVertexBorder(vnomove&quot;
 &amp; &quot;, self.border);\n\t        graph_setVertexBorderColor(vnomove, color_rg&quot;
 &amp; &quot;b(0.0, 0.0, 0.0)); \n\t        graph_setVertexColor(vnomove, nomoveColo&quot;
 &amp; &quot;r);\n\t        graph_moveVertex(vnomove, float(i), \n\t\t\t         flo&quot;
 &amp; &quot;at(self.steps) - 0.5, false);\n                graph_setVertexSize(vnom&quot;
 &amp; &quot;ove, 0.95, 1.0); \n\t        self.hopsT[i].vlastnomove := vnomove;\n\t &quot;
 &amp; &quot;                     else\n\t        self.hopsT[i].nomovecnt := self.ho&quot;
 &amp; &quot;psT[i].nomovecnt + 1;\n                graph_moveVertex(self.hopsT[i].v&quot;
 &amp; &quot;lastnomove,\n\t\t\t         float(i),  \n\t\t\t         float(self.step&quot;
 &amp; &quot;s) - \n\t\t\t\t     (float(self.hopsT[i].nomovecnt)/2.0),\n\t\t\t      &quot;
 &amp; &quot;   false);\n                graph_setVertexSize(self.hopsT[i].vlastnomo&quot;
 &amp; &quot;ve, \n\t\t\t\t    0.95, float(self.hopsT[i].nomovecnt));\n             &quot;
 &amp; &quot; end;\n\t    end;\n          else\n\t    self.hopsT[i].moved := false;\n&quot;
 &amp; &quot;\t    self.hopsT[i].vlastnomove := ok;\n\t    self.hopsT[i].nomovecnt :&quot;
 &amp; &quot;= 0;\n\t    self.hopsT[i].vlastblocked := ok;\n\t    self.hopsT[i].bloc&quot;
 &amp; &quot;kedcnt := 0;\n            graph_moveVertex( self.hopsT[i].vmove, \n\t\t&quot;
 &amp; &quot;\t      float(i), float(self.steps)/2.0, false);\n            graph_set&quot;
 &amp; &quot;VertexSize( self.hopsT[i].vmove, 0.95, float(self.steps));\n          e&quot;
 &amp; &quot;nd;\n          graph_setVertexLabel( self.hopsT[i].vlab2,\n            &quot;
 &amp; &quot;  fmtReal(\n\t          fmt_real( 100.0 * self.hopsT[i&quot;;

CONST E56_3 =
   &quot;].congested /\n\t          float(self.steps)), 2)  &amp; \&quot;%\&quot; );\n        &quot;
 &amp; &quot;  if self.hopsT[i].progress isnot true then\n\t    self.hopsT[i].finish&quot;
 &amp; &quot;ed := true;\n            let vtx = graph_newVertex(self.graphvbt);\n   &quot;
 &amp; &quot;         graph_setVertexColor(vtx, finishedColor);\n\t    graph_moveVer&quot;
 &amp; &quot;tex(vtx, float(i),\n\t\t\t     float(self.steps+1) - 0.75, false);\n   &quot;
 &amp; &quot;         graph_setVertexSize(vtx, 0.96, 0.5);\n          end;\n\tend;\n&quot;
 &amp; &quot;      end;\n      graph_redisplay(self.graphvbt);\n    end,\n\n  };\n&quot;;

CONST E57 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:37:06 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Whee&quot;
 &amp; &quot;ler.evt.\n;************************************************************&quot;
 &amp; &quot;********\n\n(VBox\n  (Rim\n    (Pen 2)\n    (HBox\n      (VBox (Glue 4)&quot;
 &amp; &quot; (Shape (Height + Inf) (Button %clear \&quot;CLEAR\&quot;)) (Glue 4))\n      (Glu&quot;
 &amp; &quot;e 4)\n      (VBox\n        (Boolean =TRUE %alg (Text LeftAlign \&quot;Algori&quot;
 &amp; &quot;thm events\&quot;))\n        (Boolean =FALSE %zeus (Text LeftAlign \&quot;Zeus ev&quot;
 &amp; &quot;ents\&quot;))\n        (Boolean =TRUE %args (Text LeftAlign \&quot;Display args t&quot;
 &amp; &quot;o events\&quot;)))\n      Fill))\n  (Bar 1)\n  (Shape (ShadowSize 0) (Height&quot;
 &amp; &quot; 200 + INF) (TextEdit ReadOnly %transcript)))\n&quot;;

CONST E58 =
   &quot;; Copyright (C) 1992, Digital Equipment Corporation\n; All rights reser&quot;
 &amp; &quot;ved.\n; See the file COPYRIGHT for a full description.\n\n(VBox \n  (Gl&quot;
 &amp; &quot;ue 10)\n  (HBox \n    (Shape (Width + 0) \&quot;Capacity for new edges: \&quot;) &quot;
 &amp; &quot;\n    (Border (TypeIn %capacity =\&quot;3.0\&quot;))\n    (Glue 20))\n  (Glue 10)&quot;
 &amp; &quot;\n  (HBox\n    (Shape (Width + 0) \&quot;Label prefix for new vertex: \&quot;) \n&quot;
 &amp; &quot;    (Border (TypeIn %vertexname =\&quot;\&quot;))\n    (Glue 20))\n  (Glue 10) (B&quot;
 &amp; &quot;ar) (Glue 10)\n  (HBox\n    (Shape (Width + 0) \&quot;Create edge between ve&quot;
 &amp; &quot;rtex: \&quot;) \n    (Border (TypeIn %vertex0))\n    (Glue 20))\n  (Glue 10)&quot;
 &amp; &quot;\n  (HBox\n    (Shape (Width + 0) \&quot;   and vertex: \&quot;) \n    (Border (T&quot;
 &amp; &quot;ypeIn %vertex1))\n    (Glue 20)\n    (Button %DoEdge \&quot; DO IT \&quot;)\n    &quot;
 &amp; &quot;(Glue 20))\n  (Glue 10) (Bar) (Glue 10)\n  (Filter Dormant (HBox\n    (&quot;
 &amp; &quot;Glue 10)\n    (Button %Save \&quot;Save/use Pkl file\&quot;)\n    (Glue 10)\n    &quot;
 &amp; &quot;(Border (TypeIn %filename =\&quot;\&quot;))\n    (Glue 20) Fill))\n  (Glue 10)\n &quot;
 &amp; &quot; (VBox\n    (Shape (Height + 0) (Text LeftAlign \&quot;Canned data files:\&quot;)&quot;
 &amp; &quot;)\n    (Border (Shape (Height 100 + Inf)\n      (Browser =0 %asciifilen&quot;
 &amp; &quot;ame \n        (Items \&quot;data.backedge\&quot; \&quot;data.big\&quot; \&quot;data.big2\&quot; \&quot;dat&quot;
 &amp; &quot;a.fin\&quot; \&quot;data.simple\&quot;)\n        ))))\n  (Glue 10)\n)\n&quot;;

CONST E59 =
   &quot;#include &lt;algorithm.h&gt;\n#include &lt;R2.h&gt;\n#include &lt;Math.h&gt;\n\n#define M&quot;
 &amp; &quot;axDistance 1.0E30\n\ntypedef Link = struct Linkstruct {\n    Point p;\n&quot;
 &amp; &quot;    Link next;\n    } * ;\n\nfloat min = 100.0;\nLink h,z;\nint N   = 0&quot;
 &amp; &quot;.0;\n\n@CheckforMin\ncheck_for_min (p1, p2)@\npoint p1,p2;\n{\n@5    if&quot;
 &amp; &quot; (dist(p1,p2) &lt; min)@\n@10      update_min(p1,p2);@\n}\n@CheckforMin\n\n&quot;
 &amp; &quot;@FindClosestPair\nlink find_closest_pair (c,N)@\nlink c;\nint N;\n{\n  &quot;
 &amp; &quot;link a, b, t1, t2;\n  int i;\n  real middle_xcoord;\n  point p1, p2, p3&quot;
 &amp; &quot;, p4;\n\n@5   a = c;@\n@10   b = middle_of_list(c,N);@\n@15   middle_xc&quot;
 &amp; &quot;oord = b -&gt; p.x;@\n\n@20   t1 = find_closest_pair(a, N div 2);@\n@25   &quot;
 &amp; &quot;t2 = find_closest_pair(b, N - (N div 2));@\n\n@30   c = merge_lists(t1,&quot;
 &amp; &quot; t2);@\n\n@35   a = c;@\n  repeat\n  {\n@40     if ((abs(a -&gt; p.x - mid&quot;
 &amp; &quot;dle_xcoord) &lt; min) &amp;&amp; (p1 != z -&gt; p)) @\n      {\n@45       check_for_m&quot;
 &amp; &quot;in(a -&gt; p, p1);@\n@50       check_for_min(a -&gt; p, p2);@\n@55       chec&quot;
 &amp; &quot;k_for_min(a -&gt; p, p3);@\n@60       check_for_min(a -&gt; p, p4);@\n@65    &quot;
 &amp; &quot;   p1 = p2; p2 = p3; p3 = p4; p4 = a -&gt; p;@\n      }\n@70     a = a -&gt; &quot;
 &amp; &quot;next;@\n  }\n@75   until a = z;@\n@80   return c;@\n}\n@FindClosestPair&quot;
 &amp; &quot;\n \n@Main\nmain()  /* Main program: computes closest pair in given set&quot;
 &amp; &quot; of points */@\n{\n@5  initialize_list_of_points(h,&amp;N);@\n@10  sort_by_&quot;
 &amp; &quot;X(h, N);@\n@15  find_closest_pair(h, N);@\n}\n@Main\n&quot;;

CONST E60 =
   &quot;Source 100 500\nV2 300 500\nV3 500 500\nSink 700 500\nV4 200 350\nV5 40&quot;
 &amp; &quot;0 350\nV6 400 650\nV7 600 650\nSource -&gt; V2 1.9\nV2 -&gt; V3 2.4\nV3 -&gt; Si&quot;
 &amp; &quot;nk 1.1\nSource -&gt; V4 3.2\nV4 -&gt; V5 2.3\nV5 -&gt; V3 1.7\nV2 -&gt; V6 2.88\nV6&quot;
 &amp; &quot; -&gt; V7 3.12\nV7 -&gt; Sink 1.98\n.\n&quot;;

CONST E61 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:29:09 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Hull&quot;
 &amp; &quot;.evt.\n;***************************************************************&quot;
 &amp; &quot;*****\n\n(VBox\n  (Border (Pen 1)\n    (Shape\n      (Height 75 - 25 + &quot;
 &amp; &quot;Inf)\n      (Viewport\n        (HBox\n          (Glue 4 + Inf)\n       &quot;
 &amp; &quot;   (VBox\n            (Glue 6)\n            (Shape (Height 16 + 0)\n   &quot;
 &amp; &quot;           (HBox Fill (Shape (Width + 0) (Height + 0) \n               &quot;
 &amp; &quot;                 \&quot;Code View events:   Stop? \&quot;) \n                    &quot;
 &amp; &quot;(Boolean %stopatCodeEvents =TRUE \&quot;\&quot;)\n                    (Glue 10)\n&quot;
 &amp; &quot;                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n    &quot;
 &amp; &quot;                (Shape (Width 80) (Numeric %waitatCodeEvents =1 \n     &quot;
 &amp; &quot;                                          (Min 0) (Max 100)))))\n      &quot;
 &amp; &quot;      (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox&quot;
 &amp; &quot; Fill (Shape (Width + 0) (Height + 0) \n                               &quot;
 &amp; &quot; \&quot;Setup:   Stop? \&quot;) \n                    (Boolean %stopAtSetup =TRUE&quot;
 &amp; &quot; \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Widt&quot;
 &amp; &quot;h + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80&quot;
 &amp; &quot;) (Numeric %waitAtSetup =1 \n                                          &quot;
 &amp; &quot;     (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape (H&quot;
 &amp; &quot;eight 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0)&quot;
 &amp; &quot; \n                                \&quot;SetHalfPlane:   Stop? \&quot;) \n      &quot;
 &amp; &quot;              (Boolean %stopAtSetHalfPlane =TRUE \&quot;\&quot;)\n               &quot;
 &amp; &quot;     (Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;W&quot;
 &amp; &quot;eight: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtSetHa&quot;
 &amp; &quot;lfPlane =1 \n                                               (Min 0) (Ma&quot;
 &amp; &quot;x 100)))))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n &quot;
 &amp; &quot;       &quot;;

CONST E61_0 =
   &quot;      (HBox Fill (Shape (Width + 0) (Height + 0) \n                    &quot;
 &amp; &quot;            \&quot;ClearHead:   Stop? \&quot;) \n                    (Boolean %st&quot;
 &amp; &quot;opAtClearHead =TRUE \&quot;\&quot;)\n                    (Glue 10)\n             &quot;
 &amp; &quot;       (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                 &quot;
 &amp; &quot;   (Shape (Width 80) (Numeric %waitAtClearHead =1 \n                   &quot;
 &amp; &quot;                            (Min 0) (Max 100)))))\n            (Glue 6)&quot;
 &amp; &quot;\n            (Shape (Height 16 + 0)\n              (HBox Fill (Shape (&quot;
 &amp; &quot;Width + 0) (Height + 0) \n                                \&quot;TestSite:  &quot;
 &amp; &quot; Stop? \&quot;) \n                    (Boolean %stopAtTestSite =TRUE \&quot;\&quot;)\n&quot;
 &amp; &quot;                    (Glue 10)\n                    (Shape (Width + 0) (&quot;
 &amp; &quot;Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numer&quot;
 &amp; &quot;ic %waitAtTestSite =1 \n                                               &quot;
 &amp; &quot;(Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape (Height&quot;
 &amp; &quot; 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n  &quot;
 &amp; &quot;                              \&quot;ClearTest:   Stop? \&quot;) \n              &quot;
 &amp; &quot;      (Boolean %stopAtClearTest =TRUE \&quot;\&quot;)\n                    (Glue &quot;
 &amp; &quot;10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n&quot;
 &amp; &quot;                    (Shape (Width 80) (Numeric %waitAtClearTest =1 \n  &quot;
 &amp; &quot;                                             (Min 0) (Max 100)))))\n   &quot;
 &amp; &quot;         (Glue 6)\n            (Shape (Height 16 + 0)\n              (H&quot;
 &amp; &quot;Box Fill (Shape (Width + 0) (Height + 0) \n                            &quot;
 &amp; &quot;    \&quot;SetTail:   Stop? \&quot;) \n                    (Boolean %stopAtSetTai&quot;
 &amp; &quot;l =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shap&quot;
 &amp; &quot;e (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (W&quot;
 &amp; &quot;idth 80) (Numeric %waitAtSetTail =1 \n                                 &quot;
 &amp; &quot;              (Min 0) (Max 100)))))\n            (Glue 6)\n            &quot;
 &amp; &quot;(Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (He&quot;
 &amp; &quot;ight + 0) \n                                \&quot;ClearTail:   Stop? \&quot;) \n&quot;
 &amp; &quot;                    (Boolean %stopAtClearTail =TRUE \&quot;\&quot;)\n            &quot;
 &amp; &quot;       &quot;;

CONST E61_1 =
   &quot; (Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weigh&quot;
 &amp; &quot;t: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtClearTail&quot;
 &amp; &quot; =1 \n                                               (Min 0) (Max 100))&quot;
 &amp; &quot;)))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n        &quot;
 &amp; &quot;      (HBox Fill (Shape (Width + 0) (Height + 0) \n                    &quot;
 &amp; &quot;            \&quot;MoveHalfPlane:   Stop? \&quot;) \n                    (Boolean&quot;
 &amp; &quot; %stopAtMoveHalfPlane =TRUE \&quot;\&quot;)\n                    (Glue 10)\n     &quot;
 &amp; &quot;               (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n         &quot;
 &amp; &quot;           (Shape (Width 80) (Numeric %waitAtMoveHalfPlane =1 \n       &quot;
 &amp; &quot;                                        (Min 0) (Max 100)))))\n        &quot;
 &amp; &quot;    (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox F&quot;
 &amp; &quot;ill (Shape (Width + 0) (Height + 0) \n                                \&quot;&quot;
 &amp; &quot;Confirm:   Stop? \&quot;) \n                    (Boolean %stopAtConfirm =TRU&quot;
 &amp; &quot;E \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Wid&quot;
 &amp; &quot;th + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 8&quot;
 &amp; &quot;0) (Numeric %waitAtConfirm =1 \n                                       &quot;
 &amp; &quot;        (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape&quot;
 &amp; &quot; (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height +&quot;
 &amp; &quot; 0) \n                                \&quot;Deny:   Stop? \&quot;) \n           &quot;
 &amp; &quot;         (Boolean %stopAtDeny =TRUE \&quot;\&quot;)\n                    (Glue 10&quot;
 &amp; &quot;)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n &quot;
 &amp; &quot;                   (Shape (Width 80) (Numeric %waitAtDeny =1 \n        &quot;
 &amp; &quot;                                       (Min 0) (Max 100)))))\n         &quot;
 &amp; &quot;   (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox Fi&quot;
 &amp; &quot;ll (Shape (Width + 0) (Height + 0) \n                                \&quot;&quot;
 &amp; &quot;Swap:   Stop? \&quot;) \n                    (Boolean %stopAtSwap =TRUE \&quot;\&quot;&quot;
 &amp; &quot;)\n                    (Glue 10)\n                    (Shape (Width + 0&quot;
 &amp; &quot;) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Nu&quot;
 &amp; &quot;meric %waitAtSwap =1 \n                                               (&quot;
 &amp; &quot;Min 0&quot;;

CONST E61_2 =
   &quot;) (Max 100)))))\n            (Glue 6)\n            (Shape (Height 16 + &quot;
 &amp; &quot;0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n        &quot;
 &amp; &quot;                        \&quot;Sentinel:   Stop? \&quot;) \n                    (&quot;
 &amp; &quot;Boolean %stopAtSentinel =TRUE \&quot;\&quot;)\n                    (Glue 10)\n   &quot;
 &amp; &quot;                 (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n       &quot;
 &amp; &quot;             (Shape (Width 80) (Numeric %waitAtSentinel =1 \n          &quot;
 &amp; &quot;                                     (Min 0) (Max 100)))))\n           &quot;
 &amp; &quot; (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox Fill&quot;
 &amp; &quot; (Shape (Width + 0) (Height + 0) \n                                \&quot;Re&quot;
 &amp; &quot;Order:   Stop? \&quot;) \n                    (Boolean %stopAtReOrder =TRUE &quot;
 &amp; &quot;\&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Width&quot;
 &amp; &quot; + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80)&quot;
 &amp; &quot; (Numeric %waitAtReOrder =1 \n                                         &quot;
 &amp; &quot;      (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape (&quot;
 &amp; &quot;Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0&quot;
 &amp; &quot;) \n                                \&quot;Stretch:   Stop? \&quot;) \n          &quot;
 &amp; &quot;          (Boolean %stopAtStretch =TRUE \&quot;\&quot;)\n                    (Glu&quot;
 &amp; &quot;e 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;&quot;
 &amp; &quot;)\n                    (Shape (Width 80) (Numeric %waitAtStretch =1 \n &quot;
 &amp; &quot;                                              (Min 0) (Max 100)))))\n  &quot;
 &amp; &quot;          (Glue 6)\n            (Shape (Height 16 + 0)\n              (&quot;
 &amp; &quot;HBox Fill (Shape (Width + 0) (Height + 0) \n                           &quot;
 &amp; &quot;     \&quot;Snap:   Stop? \&quot;) \n                    (Boolean %stopAtSnap =TR&quot;
 &amp; &quot;UE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Wi&quot;
 &amp; &quot;dth + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width &quot;
 &amp; &quot;80) (Numeric %waitAtSnap =1 \n                                         &quot;
 &amp; &quot;      (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape (&quot;
 &amp; &quot;Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0&quot;
 &amp; &quot;) \n                                \&quot;Shuffle:   Stop? \&quot;) \n          &quot;
 &amp; &quot;        &quot;;

CONST E61_3 =
   &quot;  (Boolean %stopAtShuffle =TRUE \&quot;\&quot;)\n                    (Glue 10)\n &quot;
 &amp; &quot;                   (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n     &quot;
 &amp; &quot;               (Shape (Width 80) (Numeric %waitAtShuffle =1 \n         &quot;
 &amp; &quot;                                      (Min 0) (Max 100)))))\n          &quot;
 &amp; &quot;  (Glue 6)\n          )\n          (Glue 4)\n          (VBox\n         &quot;
 &amp; &quot;   (Glue 5)\n            (Shape (Width + 0) (Height 16 + 0) \&quot;Cts:\&quot;)\n&quot;
 &amp; &quot;            (Button %eventCounts\n              (VBox\n                &quot;
 &amp; &quot;(Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0)&quot;
 &amp; &quot; \n                                  (Text %ctOfSetup \&quot;0\&quot;)))\n       &quot;
 &amp; &quot;         (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Heigh&quot;
 &amp; &quot;t 16 + 0) \n                                  (Text %ctOfSetHalfPlane \&quot;&quot;
 &amp; &quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Shape (Wi&quot;
 &amp; &quot;dth + 0) (Height 16 + 0) \n                                  (Text %ctO&quot;
 &amp; &quot;fClearHead \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fi&quot;
 &amp; &quot;ll (Shape (Width + 0) (Height 16 + 0) \n                               &quot;
 &amp; &quot;   (Text %ctOfTestSite \&quot;0\&quot;)))\n                (Glue 6)\n            &quot;
 &amp; &quot;    (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n                   &quot;
 &amp; &quot;               (Text %ctOfClearTest \&quot;0\&quot;)))\n                (Glue 6)\n&quot;
 &amp; &quot;                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n       &quot;
 &amp; &quot;                           (Text %ctOfSetTail \&quot;0\&quot;)))\n               &quot;
 &amp; &quot; (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0&quot;
 &amp; &quot;) \n                                  (Text %ctOfClearTail \&quot;0\&quot;)))\n  &quot;
 &amp; &quot;              (Glue 6)\n                (HBox Fill (Shape (Width + 0) (&quot;
 &amp; &quot;Height 16 + 0) \n                                  (Text %ctOfMoveHalfP&quot;
 &amp; &quot;lane \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Sh&quot;
 &amp; &quot;ape (Width + 0) (Height 16 + 0) \n                                  (Te&quot;
 &amp; &quot;xt %ctOfConfirm \&quot;0\&quot;)))\n                (Glue 6)\n                (HB&quot;
 &amp; &quot;ox Fill (Shape (Width + 0) (Height 16 + 0) \n                          &quot;
 &amp; &quot;        (Text %ctOfDeny \&quot;0\&quot;)))\n                (Glue 6)\n           &quot;
 &amp; &quot;     (HBo&quot;;

CONST E61_4 =
   &quot;x Fill (Shape (Width + 0) (Height 16 + 0) \n                           &quot;
 &amp; &quot;       (Text %ctOfSwap \&quot;0\&quot;)))\n                (Glue 6)\n            &quot;
 &amp; &quot;    (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n                   &quot;
 &amp; &quot;               (Text %ctOfSentinel \&quot;0\&quot;)))\n                (Glue 6)\n&quot;
 &amp; &quot;                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n       &quot;
 &amp; &quot;                           (Text %ctOfReOrder \&quot;0\&quot;)))\n               &quot;
 &amp; &quot; (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0&quot;
 &amp; &quot;) \n                                  (Text %ctOfStretch \&quot;0\&quot;)))\n    &quot;
 &amp; &quot;            (Glue 6)\n                (HBox Fill (Shape (Width + 0) (He&quot;
 &amp; &quot;ight 16 + 0) \n                                  (Text %ctOfSnap \&quot;0\&quot;)&quot;
 &amp; &quot;))\n                (Glue 6)\n                (HBox Fill (Shape (Width &quot;
 &amp; &quot;+ 0) (Height 16 + 0) \n                                  (Text %ctOfShu&quot;
 &amp; &quot;ffle \&quot;0\&quot;)))\n                (Glue 3))))\n          Fill\n          (&quot;
 &amp; &quot;Glue 4 + Inf)\n        )\n      )\n    )\n  )\n)\n&quot;;

CONST E62 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:29:09 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file logo&quot;
 &amp; &quot;.evt.\n;***************************************************************&quot;
 &amp; &quot;*****\n\n(VBox\n  (Border (Pen 1)\n    (Shape\n      (Height 75 - 25 + &quot;
 &amp; &quot;Inf)\n      (Viewport\n        (HBox\n          (Glue 4 + Inf)\n       &quot;
 &amp; &quot;   (VBox\n            (Glue 6)\n            (Shape (Height 16 + 0)\n   &quot;
 &amp; &quot;           (HBox Fill (Shape (Width + 0) (Height + 0) \n               &quot;
 &amp; &quot;                 \&quot;Code View events:   Stop? \&quot;) \n                    &quot;
 &amp; &quot;(Boolean %stopatCodeEvents =TRUE \&quot;\&quot;)\n                    (Glue 10)\n&quot;
 &amp; &quot;                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n    &quot;
 &amp; &quot;                (Shape (Width 80) (Numeric %waitatCodeEvents =1 \n     &quot;
 &amp; &quot;                                          (Min 0) (Max 100)))))\n      &quot;
 &amp; &quot;      (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox&quot;
 &amp; &quot; Fill (Shape (Width + 0) (Height + 0) \n                               &quot;
 &amp; &quot; \&quot;Init:   Stop? \&quot;) \n                    (Boolean %stopAtInit =TRUE \&quot;&quot;
 &amp; &quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Width +&quot;
 &amp; &quot; 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (&quot;
 &amp; &quot;Numeric %waitAtInit =1 \n                                              &quot;
 &amp; &quot; (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape (Heigh&quot;
 &amp; &quot;t 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n &quot;
 &amp; &quot;                               \&quot;RandomStep:   Stop? \&quot;) \n            &quot;
 &amp; &quot;        (Boolean %stopAtRandomStep =TRUE \&quot;\&quot;)\n                    (Gl&quot;
 &amp; &quot;ue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;&quot;
 &amp; &quot;)\n                    (Shape (Width 80) (Numeric %waitAtRandomStep =1 &quot;
 &amp; &quot;\n                                               (Min 0) (Max 100)))))\n&quot;
 &amp; &quot;            (Glue 6)\n            (Shape (Height 16 + 0)\n             &quot;
 &amp; &quot; (HB&quot;;

CONST E62_0 =
   &quot;ox Fill (Shape (Width + 0) (Height + 0) \n                             &quot;
 &amp; &quot;   \&quot;Shift:   Stop? \&quot;) \n                    (Boolean %stopAtShift =TR&quot;
 &amp; &quot;UE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Wi&quot;
 &amp; &quot;dth + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width &quot;
 &amp; &quot;80) (Numeric %waitAtShift =1 \n                                        &quot;
 &amp; &quot;       (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape &quot;
 &amp; &quot;(Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + &quot;
 &amp; &quot;0) \n                                \&quot;Marquee:   Stop? \&quot;) \n         &quot;
 &amp; &quot;           (Boolean %stopAtMarquee =TRUE \&quot;\&quot;)\n                    (Gl&quot;
 &amp; &quot;ue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;&quot;
 &amp; &quot;)\n                    (Shape (Width 80) (Numeric %waitAtMarquee =1 \n &quot;
 &amp; &quot;                                              (Min 0) (Max 100)))))\n  &quot;
 &amp; &quot;          (Glue 6)\n            (Shape (Height 16 + 0)\n              (&quot;
 &amp; &quot;HBox Fill (Shape (Width + 0) (Height + 0) \n                           &quot;
 &amp; &quot;     \&quot;MarqueeSpots:   Stop? \&quot;) \n                    (Boolean %stopAt&quot;
 &amp; &quot;MarqueeSpots =TRUE \&quot;\&quot;)\n                    (Glue 10)\n              &quot;
 &amp; &quot;      (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                  &quot;
 &amp; &quot;  (Shape (Width 80) (Numeric %waitAtMarqueeSpots =1 \n                 &quot;
 &amp; &quot;                              (Min 0) (Max 100)))))\n            (Glue &quot;
 &amp; &quot;6)\n          )\n          (Glue 4)\n          (VBox\n            (Glue&quot;
 &amp; &quot; 5)\n            (Shape (Width + 0) (Height 16 + 0) \&quot;Cts:\&quot;)\n        &quot;
 &amp; &quot;    (Button %eventCounts\n              (VBox\n                (Glue 6)&quot;
 &amp; &quot;\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n     &quot;
 &amp; &quot;                             (Text %ctOfInit \&quot;0\&quot;)))\n                &quot;
 &amp; &quot;(Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0)&quot;
 &amp; &quot; \n                                  (Text %ctOfRandomStep \&quot;0\&quot;)))\n  &quot;
 &amp; &quot;              (Glue 6)\n                (HBox Fill (Shape (Width + 0) (&quot;
 &amp; &quot;Height 16 + 0) \n                                  (Text %ctOfShift \&quot;0&quot;
 &amp; &quot;\&quot;)))\n                (Glue 6)\n                (HBox Fill (Shape (Wid&quot;
 &amp; &quot;th + 0) (&quot;;

CONST E62_1 =
   &quot;Height 16 + 0) \n                                  (Text %ctOfMarquee \&quot;&quot;
 &amp; &quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Shape (Wi&quot;
 &amp; &quot;dth + 0) (Height 16 + 0) \n                                  (Text %ctO&quot;
 &amp; &quot;fMarqueeSpots \&quot;0\&quot;)))\n                (Glue 3))))\n          Fill\n  &quot;
 &amp; &quot;        (Glue 4 + Inf)\n        )\n      )\n    )\n  )\n)\n&quot;;

CONST E63 =
   &quot;@Warshall\nPROCEDURE Warshall(a: ARRAY OF ARRAY OF BOOLEAN; V: INTEGER)&quot;
 &amp; &quot; @=\n  BEGIN\n  @1 FOR y := 0 TO V-1 DO@\n    @2 FOR x := 0 TO V-1 DO@\n&quot;
 &amp; &quot;      @3 IF a[x, y] THEN @\n        @4 FOR j := 0 TO V-1 DO @\n        &quot;
 &amp; &quot;    @5 IF a[y, j] THEN @ @6 a[x, j] := TRUE @ END; (* if *)            &quot;
 &amp; &quot;    \n          END; (* for j *)\n        END; (* if *)\n      END; (* &quot;
 &amp; &quot;for x *)\n    END; (* for y *)\n  END Warshall;\n@Warshall\n&quot;;

CONST E64 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:29:09 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Hash&quot;
 &amp; &quot;.evt.\n;***************************************************************&quot;
 &amp; &quot;*****\n\n(VBox\n  (Border (Pen 1)\n    (Shape\n      (Height 75 - 25 + &quot;
 &amp; &quot;Inf)\n      (Viewport\n        (HBox\n          (Glue 4 + Inf)\n       &quot;
 &amp; &quot;   (VBox\n            (Glue 6)\n            (Shape (Height 16 + 0)\n   &quot;
 &amp; &quot;           (HBox Fill (Shape (Width + 0) (Height + 0) \n               &quot;
 &amp; &quot;                 \&quot;Code View events:   Stop? \&quot;) \n                    &quot;
 &amp; &quot;(Boolean %stopatCodeEvents =TRUE \&quot;\&quot;)\n                    (Glue 10)\n&quot;
 &amp; &quot;                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n    &quot;
 &amp; &quot;                (Shape (Width 80) (Numeric %waitatCodeEvents =1 \n     &quot;
 &amp; &quot;                                          (Min 0) (Max 100)))))\n      &quot;
 &amp; &quot;      (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox&quot;
 &amp; &quot; Fill (Shape (Width + 0) (Height + 0) \n                               &quot;
 &amp; &quot; \&quot;Setup:   Stop? \&quot;) \n                    (Boolean %stopAtSetup =TRUE&quot;
 &amp; &quot; \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Widt&quot;
 &amp; &quot;h + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80&quot;
 &amp; &quot;) (Numeric %waitAtSetup =1 \n                                          &quot;
 &amp; &quot;     (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape (H&quot;
 &amp; &quot;eight 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0)&quot;
 &amp; &quot; \n                                \&quot;Insert:   Stop? \&quot;) \n            &quot;
 &amp; &quot;        (Boolean %stopAtInsert =TRUE \&quot;\&quot;)\n                    (Glue 1&quot;
 &amp; &quot;0)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n&quot;
 &amp; &quot;                    (Shape (Width 80) (Numeric %waitAtInsert =1 \n     &quot;
 &amp; &quot;                                          (Min 0) (Max 100)))))\n      &quot;
 &amp; &quot;      (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox&quot;
 &amp; &quot; Fill (&quot;;

CONST E64_0 =
   &quot;Shape (Width + 0) (Height + 0) \n                                \&quot;Find&quot;
 &amp; &quot;:   Stop? \&quot;) \n                    (Boolean %stopAtFind =TRUE \&quot;\&quot;)\n &quot;
 &amp; &quot;                   (Glue 10)\n                    (Shape (Width + 0) (H&quot;
 &amp; &quot;eight + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeri&quot;
 &amp; &quot;c %waitAtFind =1 \n                                               (Min &quot;
 &amp; &quot;0) (Max 100)))))\n            (Glue 6)\n            (Shape (Height 16 +&quot;
 &amp; &quot; 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n       &quot;
 &amp; &quot;                         \&quot;Delete:   Stop? \&quot;) \n                    (B&quot;
 &amp; &quot;oolean %stopAtDelete =TRUE \&quot;\&quot;)\n                    (Glue 10)\n      &quot;
 &amp; &quot;              (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n          &quot;
 &amp; &quot;          (Shape (Width 80) (Numeric %waitAtDelete =1 \n               &quot;
 &amp; &quot;                                (Min 0) (Max 100)))))\n            (Glu&quot;
 &amp; &quot;e 6)\n            (Shape (Height 16 + 0)\n              (HBox Fill (Sha&quot;
 &amp; &quot;pe (Width + 0) (Height + 0) \n                                \&quot;Compare&quot;
 &amp; &quot;:   Stop? \&quot;) \n                    (Boolean %stopAtCompare =TRUE \&quot;\&quot;)&quot;
 &amp; &quot;\n                    (Glue 10)\n                    (Shape (Width + 0)&quot;
 &amp; &quot; (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Num&quot;
 &amp; &quot;eric %waitAtCompare =1 \n                                              &quot;
 &amp; &quot; (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape (Heigh&quot;
 &amp; &quot;t 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n &quot;
 &amp; &quot;                               \&quot;CheckDeletable:   Stop? \&quot;) \n        &quot;
 &amp; &quot;            (Boolean %stopAtCheckDeletable =TRUE \&quot;\&quot;)\n               &quot;
 &amp; &quot;     (Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;W&quot;
 &amp; &quot;eight: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtCheck&quot;
 &amp; &quot;Deletable =1 \n                                               (Min 0) (&quot;
 &amp; &quot;Max 100)))))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n&quot;
 &amp; &quot;              (HBox Fill (Shape (Width + 0) (Height + 0) \n            &quot;
 &amp; &quot;                    \&quot;CheckHashPosition:   Stop? \&quot;) \n                &quot;
 &amp; &quot;    (Boolean %stopAtCheckHashPosition =TRUE \&quot;\&quot;)\n                    &quot;
 &amp; &quot;(Glue 1&quot;;

CONST E64_1 =
   &quot;0)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n&quot;
 &amp; &quot;                    (Shape (Width 80) (Numeric %waitAtCheckHashPosition&quot;
 &amp; &quot; =1 \n                                               (Min 0) (Max 100))&quot;
 &amp; &quot;)))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n        &quot;
 &amp; &quot;      (HBox Fill (Shape (Width + 0) (Height + 0) \n                    &quot;
 &amp; &quot;            \&quot;AddToBucket:   Stop? \&quot;) \n                    (Boolean %&quot;
 &amp; &quot;stopAtAddToBucket =TRUE \&quot;\&quot;)\n                    (Glue 10)\n         &quot;
 &amp; &quot;           (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n             &quot;
 &amp; &quot;       (Shape (Width 80) (Numeric %waitAtAddToBucket =1 \n             &quot;
 &amp; &quot;                                  (Min 0) (Max 100)))))\n            (G&quot;
 &amp; &quot;lue 6)\n            (Shape (Height 16 + 0)\n              (HBox Fill (S&quot;
 &amp; &quot;hape (Width + 0) (Height + 0) \n                                \&quot;Delet&quot;
 &amp; &quot;eFromBucket:   Stop? \&quot;) \n                    (Boolean %stopAtDeleteFr&quot;
 &amp; &quot;omBucket =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                  &quot;
 &amp; &quot;  (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (S&quot;
 &amp; &quot;hape (Width 80) (Numeric %waitAtDeleteFromBucket =1 \n                 &quot;
 &amp; &quot;                              (Min 0) (Max 100)))))\n            (Glue &quot;
 &amp; &quot;6)\n          )\n          (Glue 4)\n          (VBox\n            (Glue&quot;
 &amp; &quot; 5)\n            (Shape (Width + 0) (Height 16 + 0) \&quot;Cts:\&quot;)\n        &quot;
 &amp; &quot;    (Button %eventCounts\n              (VBox\n                (Glue 6)&quot;
 &amp; &quot;\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n     &quot;
 &amp; &quot;                             (Text %ctOfSetup \&quot;0\&quot;)))\n               &quot;
 &amp; &quot; (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0&quot;
 &amp; &quot;) \n                                  (Text %ctOfInsert \&quot;0\&quot;)))\n     &quot;
 &amp; &quot;           (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Hei&quot;
 &amp; &quot;ght 16 + 0) \n                                  (Text %ctOfFind \&quot;0\&quot;))&quot;
 &amp; &quot;)\n                (Glue 6)\n                (HBox Fill (Shape (Width +&quot;
 &amp; &quot; 0) (Height 16 + 0) \n                                  (Text %ctOfDele&quot;
 &amp; &quot;te \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Shap&quot;
 &amp; &quot;e (Width&quot;;

CONST E64_2 =
   &quot; + 0) (Height 16 + 0) \n                                  (Text %ctOfCo&quot;
 &amp; &quot;mpare \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (S&quot;
 &amp; &quot;hape (Width + 0) (Height 16 + 0) \n                                  (T&quot;
 &amp; &quot;ext %ctOfCheckDeletable \&quot;0\&quot;)))\n                (Glue 6)\n           &quot;
 &amp; &quot;     (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n                  &quot;
 &amp; &quot;                (Text %ctOfCheckHashPosition \&quot;0\&quot;)))\n                &quot;
 &amp; &quot;(Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0)&quot;
 &amp; &quot; \n                                  (Text %ctOfAddToBucket \&quot;0\&quot;)))\n &quot;
 &amp; &quot;               (Glue 6)\n                (HBox Fill (Shape (Width + 0) &quot;
 &amp; &quot;(Height 16 + 0) \n                                  (Text %ctOfDeleteFr&quot;
 &amp; &quot;omBucket \&quot;0\&quot;)))\n                (Glue 3))))\n          Fill\n       &quot;
 &amp; &quot;   (Glue 4 + Inf)\n        )\n      )\n    )\n  )\n)\n&quot;;

CONST E65 =
   &quot;; Copyright (C) 1994, Digital Equipment Corporation    \n; All rights r&quot;
 &amp; &quot;eserved.                                 \n; See the file COPYRIGHT for&quot;
 &amp; &quot; a full description.       \n\n; provides for a single integer number w&quot;
 &amp; &quot;hose name is N \n\n(VBox\n  (Macro Label BOA (text) `(Shape (Width 120)&quot;
 &amp; &quot; (Text RightAlign ,text)))\n  (Macro Line BOA (label expr) `(HBox (Labe&quot;
 &amp; &quot;l ,label) ,expr Fill))\n  (Glue 10)\n  (Line \&quot;Number of weights: \&quot; (N&quot;
 &amp; &quot;umeric (Min 1) (Max 1000) %N =26))\n  (Glue 10)\n  (Line \&quot;Number of bi&quot;
 &amp; &quot;ns: \&quot; (Numeric (Min 1) (Max 100) %B =10))\n  (Glue 10)\n  (Filter %run&quot;
 &amp; &quot;timeOpts Dormant\n    (Frame Chiseled\n      (VBox\n        (Glue 10)\n&quot;
 &amp; &quot;        (Line\n          \&quot;Bin to empty: \&quot;\n          (Filter (Numeric&quot;
 &amp; &quot; (Min 0) (Max 1000) %toEmpty AllowEmpty)))\n        (Glue 10)\n        &quot;
 &amp; &quot;(Line\n          \&quot;Delete a weight: \&quot;\n          (Filter (Numeric (Min&quot;
 &amp; &quot; 0) (Max 1000) %toDelete AllowEmpty)))\n        (Glue 10))))\n  (Glue 1&quot;
 &amp; &quot;0))\n&quot;;

CONST E66 =
   &quot;; Copyright (C) 1992, Digital Equipment Corporation\n; All rights reser&quot;
 &amp; &quot;ved.\n; See the file COPYRIGHT for a full description.\n\n(Shape\n  (Wi&quot;
 &amp; &quot;dth + Inf)\n  (Rim\n    (Pen 8)\n    (Macro Fixed BOA (child) `(Shape (&quot;
 &amp; &quot;Width + 0) (Height + 0) ,child))\n    (Macro\n      Divider\n      BOA\n&quot;
 &amp; &quot;      (name str)\n      `(PageButton\n         (ShadowSize 0.0)\n      &quot;
 &amp; &quot;   (For ,name)\n         (Boolean\n           (ShadowSize 1.5)\n       &quot;
 &amp; &quot;    (HBox\n             (VBox Fill Bar Fill)\n             (Shape (Widt&quot;
 &amp; &quot;h + 0) (Height + 0) ,str)\n             (VBox Fill Bar Fill)))))\n    (&quot;
 &amp; &quot;Macro\n      Dividee\n      BOA\n      (name child)\n      `(TSplit Fle&quot;
 &amp; &quot;x =0 %,name Circular (Generic) ,child))\n    (VBox\n      (Glue 4 + 0)\n&quot;
 &amp; &quot;      (HBox\n        (Shape (Width + 0) \&quot;Number of buckets: \&quot;)\n     &quot;
 &amp; &quot;   (Numeric (Min 1) (Max 1000) %Buckets =29)\n        Fill)\n      (Glu&quot;
 &amp; &quot;e 4 + 0)\n      (HBox\n        (Boolean %PauseOnDeletes =FALSE (Text Le&quot;
 &amp; &quot;ftAlign \&quot;  Pause On Deletes\&quot;))\n        Fill)\n      (Glue 4 + 0)\n  &quot;
 &amp; &quot;    (HBox\n        (Shape (Width + 0) \&quot;Number of operations: \&quot;)\n    &quot;
 &amp; &quot;    (Numeric (Min 1) (Max 10000) %Ops =100)\n        Fill)\n      (Glue&quot;
 &amp; &quot; 4 + 0)\n      (Shape (Height + 0) (Text LeftAlign \&quot;Key generation:\&quot;)&quot;
 &amp; &quot;)\n      (HBox\n        (Radio\n          (VBox\n            (Choice %R&quot;
 &amp; &quot;andom =FALSE (Text LeftAlign \&quot;  Random\&quot;))\n            (Choice %Conse&quot;
 &amp; &quot;q =TRUE (Text LeftAlign \&quot;  Consequtive\&quot;))))\n        Fill)\n      (HB&quot;
 &amp; &quot;ox\n        (Shape (Width + 0) \&quot;Number of initial inserts: \&quot;)\n      &quot;
 &amp; &quot;  (Numeric (Min 0) (Max 10000) %InitInserts =29)\n        Fill)\n      &quot;
 &amp; &quot;(HBox\n        (Shape (Width + 0) \&quot;Number of initial deletes: \&quot;)\n   &quot;
 &amp; &quot;     (Numeric (Min 0) (Max 10000) %InitDeletes =10)\n        Fill)\n   &quot;
 &amp; &quot;   (HBox\n        (Shape (Width + 0) \&quot;Percentage of inserts: \&quot;)\n    &quot;
 &amp; &quot;    (Numeric (Min 0) (Max 100) %Inserts =20)\n        Fill)\n      (HBo&quot;
 &amp; &quot;x\n        (Shape (Width + 0) \&quot;Percentage of deletes: \&quot;)\n        (Nu&quot;
 &amp; &quot;meric (Min 0) (Max 100) %Deletes =20)\n        Fill)\n      (HBox\n    &quot;
 &amp; &quot;    (Shape (Width + 0) \&quot;Percentage of successful finds: \&quot;)\n        (&quot;
 &amp; &quot;Numeric (Min 0) (Max 100) %Su&quot;;

CONST E66_0 =
   &quot;ccFinds =5)\n        Fill)\n      (HBox\n        (Shape (Width + 0) \&quot;F&quot;
 &amp; &quot;ixed ``Random\'\' Sequence: \&quot;)\n        (Boolean %FixedRandom =FALSE \&quot;&quot;
 &amp; &quot;\&quot;)\n        Fill)\n      (Glue 10)\n      (Divider viewFormT \&quot;Input f&quot;
 &amp; &quot;or view\&quot;)\n      (Dividee\n        viewFormT\n        (HBox\n         &quot;
 &amp; &quot; (Fill)\n          (Shape\n            (Width + 0)\n            (VBox\n&quot;
 &amp; &quot;              (HBox\n                (Shape (Width + 0) \&quot;Normal Color:&quot;
 &amp; &quot; \&quot;)\n                (TypeIn %NormalColor =\&quot;QuiteLightBlue\&quot;))\n     &quot;
 &amp; &quot;         (HBox\n                (Shape (Width + 0) \&quot;Nil Color: \&quot;)\n  &quot;
 &amp; &quot;              (TypeIn %NilColor =\&quot;QuiteLightYellow\&quot;))\n              &quot;
 &amp; &quot;(HBox\n                (Shape (Width + 0) \&quot;Empty Color: \&quot;)\n         &quot;
 &amp; &quot;       (TypeIn %EmptyColor =\&quot;QuiteLightBrown\&quot;))\n              (HBox\n&quot;
 &amp; &quot;                (Shape (Width + 0) \&quot;Compare Color: \&quot;)\n              &quot;
 &amp; &quot;  (TypeIn %CompareColor =\&quot;LightOrange\&quot;))\n              (HBox\n      &quot;
 &amp; &quot;          (Shape (Width + 0) \&quot;New Color: \&quot;)\n                (TypeIn &quot;
 &amp; &quot;%NewColor =\&quot;QuiteLightGreen\&quot;))\n              (HBox\n                &quot;
 &amp; &quot;(Shape (Width + 0) \&quot;Check Deletable Color: \&quot;)\n                (TypeI&quot;
 &amp; &quot;n %CheckDeletableColor =\&quot;QuiteLightMagenta\&quot;))\n              (HBox\n &quot;
 &amp; &quot;               (Shape (Width + 0) \&quot;Check Hash Position Color: \&quot;)\n   &quot;
 &amp; &quot;             (TypeIn %CheckHashPositionColor =\&quot;QuiteLightCyan\&quot;))\n   &quot;
 &amp; &quot;           (HBox\n                (Shape (Width + 0) \&quot;Operation Highli&quot;
 &amp; &quot;ght Color: \&quot;)\n                (TypeIn %OperationHighlightColor =\&quot;Vio&quot;
 &amp; &quot;let\&quot;))\n              (HBox\n                (Shape (Width + 0) \&quot;Item&quot;
 &amp; &quot; Color: \&quot;)\n                (TypeIn %ItemColor =\&quot;QuiteLightGreenishBl&quot;
 &amp; &quot;ue\&quot;))))\n          (Fill))))))&quot;;

CONST E67 =
   &quot;(* Copyright (C) 1993, Digital Equipment Corporation                   &quot;
 &amp; &quot;      *)\n(* All rights reserved.                                      &quot;
 &amp; &quot;                *)\n(* See the file COPYRIGHT for a full description.  &quot;
 &amp; &quot;                          *)\n(*                                       &quot;
 &amp; &quot;                                    *)\n(* Last modified on Mon Jan  9 &quot;
 &amp; &quot;12:13:42 PST 1995 by najork                   *)\n(*      modified on W&quot;
 &amp; &quot;ed Oct 13 19:41:11 PDT 1993 by mann                     *)\n(*      mod&quot;
 &amp; &quot;ified on Thu Jul 22 14:27:15 PDT 1993 by perl                     *)\n\n&quot;
 &amp; &quot;let stringColor = color_named(\&quot;Pink\&quot;);\nlet stringLabelColor = color_&quot;
 &amp; &quot;named(\&quot;Black\&quot;);\nlet matrixColor = color_named(\&quot;QuiteLightSlightlyGr&quot;
 &amp; &quot;eenishVividBlue\&quot;);\nlet matrixLabelColor = color_named(\&quot;Black\&quot;);\nle&quot;
 &amp; &quot;t rowIndexColor = stringColor;\nlet rowIndexLabelColor = stringLabelCol&quot;
 &amp; &quot;or;\nlet otherIndexColor = color_named(\&quot;White\&quot;);\nlet otherIndexLabel&quot;
 &amp; &quot;Color = color_named(\&quot;DarkGray\&quot;);\nlet shadowColor = color_named(\&quot;Lig&quot;
 &amp; &quot;htGray\&quot;);\nlet shadowLabelColor = color_named(\&quot;Black\&quot;);\nlet alphaCo&quot;
 &amp; &quot;lor = color_named(\&quot;LightYellow\&quot;);\nlet alphaLabelColor = color_named(&quot;
 &amp; &quot;\&quot;Black\&quot;);\nlet permutedColor = alphaColor;\nlet permutedLabelColor = &quot;
 &amp; &quot;alphaLabelColor;\nlet codesColor = color_named(\&quot;White\&quot;);\nlet codesLa&quot;
 &amp; &quot;belColor = color_named(\&quot;Black\&quot;);\nlet codesHiliteLabelColor = color_n&quot;
 &amp; &quot;amed(\&quot;DarkRed\&quot;);\nlet arrowColor = color_named(\&quot;DarkRed\&quot;);\nlet dup&quot;
 &amp; &quot;lColor = color_named(\&quot;LightGray\&quot;);\nlet duplLabelColor = color_named(&quot;
 &amp; &quot;\&quot;VeryDarkGray\&quot;);\n\nlet makeDippingPath = proc(startX, endX, y, dip)\n&quot;
 &amp; &quot;    proc(t)\n        [ (startX * (1.0 - t)) + (endX * t),\n\t  y + (dip&quot;
 &amp; &quot; * (0.25 - ((t - 0.5) * (t - 0.5))))]\n    end\nend;\n\nlet view =\n  {&quot;
 &amp; &quot;\n    graphvbt =&gt; graph_new(),\n    vertexFont =&gt; ok,\n    n =&gt; ok,\n  &quot;
 &amp; &quot;  string =&gt; {chars =&gt; ok, vtx =&gt; ok},\n    xlast =&gt; {chars =&gt; ok, vtx =&quot;
 &amp; &quot;&gt; ok},\n    alphalen =&gt; ok,\n    matrix =&gt; ok,\n    rowIndex =&gt; ok,\n  &quot;
 &amp; &quot;  rowIndexVtx =&gt; ok,\n    rowIndexGhostVtx =&gt; ok,\n    codes =&gt; {array &quot;
 &amp; &quot;=&gt; ok, vtx =&gt; ok},\n    codeSearchArrow =&gt; ok,\n    rowIndices =&gt; ok,\n&quot;
 &amp; &quot;\n    StartPermute =&gt; me&quot;;

CONST E67_0 =
   &quot;th(self, string, alpha)\n    (* Start of first phase of compression, in&quot;
 &amp; &quot; which we permute the\n       original string.\n     *)\n        self.v&quot;
 &amp; &quot;ertexFont := graph_newFont(self.graphvbt, \&quot;Helvetica\&quot;,\n             &quot;
 &amp; &quot;                            0.5, \&quot;Roman\&quot;, \&quot;bold\&quot;, \&quot;*\&quot;);\n        &quot;
 &amp; &quot;self.n := text_length(string);\n\tself.alphalen := text_length(alpha);\n&quot;
 &amp; &quot;\n\tself.string.chars := string;\n\tself.xlast.chars := alpha;\n\n\tsel&quot;
 &amp; &quot;f.codes.array := array_new(self.n, ok);\n        self.codes.vtx := arra&quot;
 &amp; &quot;y_new(self.n, ok);\n\n\tlet north = ~3.0,\n            south = float(se&quot;
 &amp; &quot;lf.n) + 4.25,\n            west = -(float(self.alphalen) + 1.0),\n     &quot;
 &amp; &quot;       east = float(self.n) + 1.0;\n\tgraph_setWorld(self.graphvbt, wes&quot;
 &amp; &quot;t, east, north, south);\n\tgraph_setAspect(self.graphvbt, (south - nort&quot;
 &amp; &quot;h) / (east - west));\n\tgraph_setPixelSizeDivisor(self.graphvbt,\n     &quot;
 &amp; &quot;                             round(east - west),\n\t\t\t          round&quot;
 &amp; &quot;(south - north));\n\n        self.xlast.vtx := array_new(self.alphalen &quot;
 &amp; &quot;+ self.n, ok);\n        for i = 0 to self.alphalen - 1 do\n            &quot;
 &amp; &quot;let v = graph_newVertex(self.graphvbt);\n            self.xlast.vtx[i] &quot;
 &amp; &quot;:= v;\n\t    graph_setVertexSize(v, 0.0, 0.0); (*invisible for now*)\n &quot;
 &amp; &quot;           graph_setVertexLabel(v, text_sub(self.xlast.chars, i, 1));\n&quot;
 &amp; &quot;            graph_setVertexFont(v, self.vertexFont);\n            graph&quot;
 &amp; &quot;_setVertexColor(v, alphaColor);\n            graph_setVertexLabelColor(&quot;
 &amp; &quot;v, alphaLabelColor);\n            graph_setVertexBorder(v, 0.05);\n    &quot;
 &amp; &quot;        graph_moveVertex(v, float(i - (2 * self.alphalen)) - 4.0,\n    &quot;
 &amp; &quot;                            float(self.n + 1), false);\n        end;\n\n&quot;
 &amp; &quot;        self.string.vtx := array_new(self.n, ok);\n        for i = 0 to&quot;
 &amp; &quot; self.n - 1 do\n            let v = graph_newVertex(self.graphvbt);\n  &quot;
 &amp; &quot;          self.string.vtx[i] := v;\n            graph_setVertexLabel(v,&quot;
 &amp; &quot; text_sub(string, i, 1));\n            graph_setVertexFont(v, self.vert&quot;
 &amp; &quot;exFont);\n            graph_setVertexColor(v, stringColor);\n          &quot;
 &amp; &quot;  graph_setVertexLabelColor(v, stringLabelColor);\n            graph_se&quot;
 &amp; &quot;tVerte&quot;;

CONST E67_1 =
   &quot;xBorder(v, 0.05);\n            graph_moveVertex(v, float(i), ~2.0, fals&quot;
 &amp; &quot;e);\n\t    graph_setVertexSize(v, 0.95, 0.95);\n        end;\n\n\tgraph&quot;
 &amp; &quot;_redisplay(self.graphvbt);\n\n        self.matrix := array_new(self.n, &quot;
 &amp; &quot;ok);\n\tself.rowIndices := array_new(self.n, ok);\n    end,\n\n    Next&quot;
 &amp; &quot;Rotation =&gt; meth(self, i, string)\n    (* Forming the matrix of rotatio&quot;
 &amp; &quot;ns.  The ith row of the matrix is string.\n       The 0th row does caus&quot;
 &amp; &quot;e an event, with string equal to the initial\n       string.\n    *)\n\n&quot;
 &amp; &quot;        self.matrix[i] := { vtx =&gt; array_new(self.n, ok),\n            &quot;
 &amp; &quot;                chars =&gt; string };\n        for j = 0 to self.n - 1 do\n&quot;
 &amp; &quot;            let v = graph_newVertex(self.graphvbt);\n            self.m&quot;
 &amp; &quot;atrix[i].vtx[j] := v;\n            graph_setVertexLabel(v, text_sub(str&quot;
 &amp; &quot;ing, j, 1));\n            graph_setVertexFont(v, self.vertexFont);\n   &quot;
 &amp; &quot;         graph_setVertexBorder(v, 0.05);\n\t    if i is 0 then\n  \t   &quot;
 &amp; &quot;     graph_setVertexColor(v, stringColor);\n                graph_setVe&quot;
 &amp; &quot;rtexLabelColor(v, stringLabelColor);\n                graph_moveVertex(&quot;
 &amp; &quot;v, float(j), ~2.0, false);\n                graph_moveVertex(v, float(j&quot;
 &amp; &quot;), 0.0, true);\n\t    else\n  \t        graph_setVertexColor(v, matrixC&quot;
 &amp; &quot;olor);\n                graph_setVertexLabelColor(v, matrixLabelColor);&quot;
 &amp; &quot;\n                graph_moveVertex(v, float((j+1) % self.n),\n         &quot;
 &amp; &quot;                           float(i-1), false);\n                graph_m&quot;
 &amp; &quot;oveVertex(v, float(((j+1) % self.n) - 1),\n                            &quot;
 &amp; &quot;        float(i), true);\n\t    end;\n\t    graph_setVertexSize(v, 0.95&quot;
 &amp; &quot;, 0.95);\n        end;\n\n\tif i is 0 then\n   \t    zeus_animate(self.&quot;
 &amp; &quot;graphvbt, 0.0, 1.0);\n\telse\n   \t    zeus_animate(self.graphvbt, 0.0,&quot;
 &amp; &quot; 0.75);\n\t    graph_moveVertexOnPath(self.matrix[i].vtx[self.n - 1],\n&quot;
 &amp; &quot;\t\t    \t           makeDippingPath(~1.0, float(self.n - 1),\n        &quot;
 &amp; &quot;                                           float(i), 2.0));\n\t    zeus&quot;
 &amp; &quot;_animate(self.graphvbt, 0.75, 1.0);\n\tend;\n\n\tlet v = graph_newVerte&quot;
 &amp; &quot;x(self.graphvbt);\n\tself.rowIndices[i] := v;\n\tgraph_setVertexLabel(v&quot;
 &amp; &quot;, fmt_int(i));&quot;;

CONST E67_2 =
   &quot;\n\tgraph_setVertexFont(v, self.vertexFont);\n\tgraph_setVertexColor(v,&quot;
 &amp; &quot; otherIndexColor);\n\tgraph_setVertexLabelColor(v, otherIndexLabelColor&quot;
 &amp; &quot;);\n\tgraph_moveVertex(v, float(self.n), float(i), false);\n\tgraph_set&quot;
 &amp; &quot;VertexSize(v, 0.95, 0.95);\n\tgraph_redisplay(self.graphvbt);\n    end,&quot;
 &amp; &quot;\n\n    RotationsSorted =&gt; meth(self, rotations, rowIndex)\n    (* The &quot;
 &amp; &quot;matrix of rotations, in sorted order; rowIndex is the index\n       whe&quot;
 &amp; &quot;re the original string landed.\n    *)\n        let moved = array_new(s&quot;
 &amp; &quot;elf.n, false),\n            newMatrix = array_new(self.n, ok);\n\n     &quot;
 &amp; &quot;   for i = 0 to self.n-1 do\n            for j = 0 to self.n-1 do\n    &quot;
 &amp; &quot;            if not(moved[j]) and\n                   text_equal(rotatio&quot;
 &amp; &quot;ns[i],\n                              self.matrix[j].chars)\n          &quot;
 &amp; &quot;      then\n\t\t    newMatrix[i] := self.matrix[j];\n\t\t    moved[j] :&quot;
 &amp; &quot;= true;\n\t\t    for k = 0 to self.n-1 do\n\t\t\tlet v = newMatrix[i].v&quot;
 &amp; &quot;tx[k];\n\t\t\tif j &gt; i then\n\t\t\t    graph_vertexToBack(v);\n        &quot;
 &amp; &quot;                else\n                            graph_vertexToFront(v&quot;
 &amp; &quot;);\n\t\t        end;\n\t\t\tgraph_moveVertex(v, float(k), float(i), tru&quot;
 &amp; &quot;e);\n\t            end;\n\t\t    exit;\n\t\tend;\n\t    end;\n\tend;\n\n&quot;
 &amp; &quot;\tself.matrix := newMatrix;\n\tzeus_animate(self.graphvbt, 0.0, 2.0);\n&quot;
 &amp; &quot;\n\tself.rowIndex := rowIndex;\n\tlet v = graph_newVertex(self.graphvbt&quot;
 &amp; &quot;);\n\tself.rowIndexVtx := v;\n\tgraph_setVertexShape(v, \&quot;ellipse\&quot;);\n&quot;
 &amp; &quot;\tgraph_setVertexLabel(v, fmt_int(self.rowIndex));\n\tgraph_setVertexFo&quot;
 &amp; &quot;nt(v, self.vertexFont);\n\tgraph_setVertexColor(v, rowIndexColor);\n\tg&quot;
 &amp; &quot;raph_setVertexLabelColor(v, rowIndexLabelColor);\n\tgraph_setVertexBord&quot;
 &amp; &quot;er(v, 0.05);\n\tgraph_moveVertex(v, float(self.n), float(rowIndex), fal&quot;
 &amp; &quot;se);\n\tgraph_setVertexSize(v, 0.95, 0.95);\n\tgraph_redisplay(self.gra&quot;
 &amp; &quot;phvbt);\t\n    end,\n\n    PermuteDone =&gt; meth(self, lastchars, rowInde&quot;
 &amp; &quot;x)\n    (* Done with first phase of compression.  The permuted string (&quot;
 &amp; &quot;last column\n       of the sorted matrix of rotations) is lastchars.  T&quot;
 &amp; &quot;he row index of the\n       original string in the matrix is rowIndex.\n&quot;
 &amp; &quot;    *)\n\n\tself.xlast.chars := self.xlast.chars &amp; &quot;;

CONST E67_3 =
   &quot;lastchars;\n\tfor ii = 0 to self.n - 1 do\n\t    let i = (self.n - 1) -&quot;
 &amp; &quot; ii;\n            let v = graph_newVertex(self.graphvbt),\n\t        w &quot;
 &amp; &quot;= self.matrix[i].vtx[self.n-1];\n\n\t    graph_vertexToBack(v);\n      &quot;
 &amp; &quot;      graph_setVertexLabel(v, text_sub(lastchars, i, 1));\n            &quot;
 &amp; &quot;graph_setVertexFont(v, self.vertexFont);\n            graph_setVertexCo&quot;
 &amp; &quot;lor(v, duplColor);\n            graph_setVertexLabelColor(v, duplLabelC&quot;
 &amp; &quot;olor);\n            graph_setVertexBorder(v, 0.05);\n            graph_&quot;
 &amp; &quot;moveVertex(v, float(self.n - 1), float(i), false);\n\t    graph_setVert&quot;
 &amp; &quot;exSize(v, 0.95, 0.95);\n\n\t    graph_vertexToFront(w);\n            gr&quot;
 &amp; &quot;aph_moveVertex(w, float(i), float(self.n + 1), true);\n\n            se&quot;
 &amp; &quot;lf.xlast.vtx[i+self.alphalen] := w;\n            self.matrix[i].vtx[sel&quot;
 &amp; &quot;f.n - 1] := v;\n\tend;\n\n    \tzeus_animate(self.graphvbt, 0.0, 2.0 (*&quot;
 &amp; &quot;!!*));\n    end,\n\n    StartEncode =&gt; meth(self, alphabet)\n    (* Rea&quot;
 &amp; &quot;dy to start encoding the permuted string using alphabet.\n    *)\n     &quot;
 &amp; &quot;   for i = 0 to self.alphalen - 1 do\n\t    graph_setVertexSize(self.xl&quot;
 &amp; &quot;ast.vtx[i], 0.95, 0.95);\n            graph_moveVertex(self.xlast.vtx[i&quot;
 &amp; &quot;],\n                             float(i - self.alphalen),\n           &quot;
 &amp; &quot;                  float(self.n + 1), true);\n\tend;\n\n\tzeus_animate(s&quot;
 &amp; &quot;elf.graphvbt, 0.0, 1.0);\n\n\tfor i = 0 to self.n - 1 do\n\t    let v =&quot;
 &amp; &quot; self.xlast.vtx[i + self.alphalen];\n            graph_setVertexColor(v&quot;
 &amp; &quot;, alphaColor);\n            graph_setVertexLabelColor(v, alphaLabelColo&quot;
 &amp; &quot;r);\n\tend;\n\tgraph_redisplay(self.graphvbt);\n    end,\n\n    EncodeN&quot;
 &amp; &quot;extChar =&gt; meth(self, i, c)\n    (* About to find the code for characte&quot;
 &amp; &quot;r number i in the permuted string.\n       The character value is c.\n &quot;
 &amp; &quot;   *)\n\tlet v = graph_newVertex(self.graphvbt);\n\tself.codeSearchArro&quot;
 &amp; &quot;w := v;\n\tgraph_setVertexFont(v, self.vertexFont);\n\tgraph_setVertexC&quot;
 &amp; &quot;olor(v, duplColor);\n\tgraph_setVertexLabelColor(v, duplLabelColor);\n\t&quot;
 &amp; &quot;graph_setVertexBorder(v, 0.05);\n\tgraph_setVertexSize(v, 0.95, 0.95);\n&quot;
 &amp; &quot;\tgraph_setVertexLabel(self.codeSearchArrow, text_new(1, c));\n  \tgrap&quot;
 &amp; &quot;h_moveVertex(self.co&quot;;

CONST E67_4 =
   &quot;deSearchArrow, float(i),\n                         float(self.n + 1), f&quot;
 &amp; &quot;alse);\n  \tgraph_moveVertex(self.codeSearchArrow, float(i),\n         &quot;
 &amp; &quot;                float(self.n + 2), true);\n\tzeus_animate(self.graphvbt&quot;
 &amp; &quot;, 0.0, 1.0);\n\n        let v = graph_newVertex(self.graphvbt);\n      &quot;
 &amp; &quot;  self.codes.vtx[i] := v;\n        graph_setVertexFont(v, self.vertexFo&quot;
 &amp; &quot;nt);\n        graph_setVertexColor(v, codesColor);\n        graph_setVe&quot;
 &amp; &quot;rtexLabelColor(v, codesHiliteLabelColor);\n        graph_setVertexBorde&quot;
 &amp; &quot;r(v, 0.12);\n        graph_moveVertex(v, float(i), float(self.n) + 3.25&quot;
 &amp; &quot;, false);\n        graph_setVertexLabel(v, \&quot;0\&quot;);\n\tgraph_setVertexSi&quot;
 &amp; &quot;ze(v, 0.95, 0.95);\n\tgraph_redisplay(self.graphvbt);\n    end,\n\n    &quot;
 &amp; &quot;EncodeDistinctCount =&gt; meth(self, i, k, n, c)\n    (* Found another dis&quot;
 &amp; &quot;tinct character at position k in (alphabet &amp; string) \n       while com&quot;
 &amp; &quot;puting the code corresponding to character i in (string).  The \n      &quot;
 &amp; &quot; number of distinct characters found so far is n.  The character value\n&quot;
 &amp; &quot;       is c.\n    *)\n  \tgraph_moveVertex(self.codeSearchArrow, float(&quot;
 &amp; &quot;k - self.alphalen),\n                         float(self.n + 2), true);&quot;
 &amp; &quot;\n\tzeus_animate(self.graphvbt, 0.0, 1.0);\n\tgraph_setVertexLabel(self&quot;
 &amp; &quot;.codes.vtx[i], fmt_int(n));\n        graph_redisplay(self.graphvbt);\n &quot;
 &amp; &quot;   end,\n\n    EncodeFoundCode =&gt; meth(self, i, k, code, c)\n    (* Fou&quot;
 &amp; &quot;nd that the code for character i in (string) is code; the closest\n    &quot;
 &amp; &quot;   previous occurrence of the same character was at position k in\n    &quot;
 &amp; &quot;   (alphabet &amp; string).  The character value is c. \n    *)\n  \tgraph_&quot;
 &amp; &quot;moveVertex(self.codeSearchArrow, float(k - self.alphalen),\n           &quot;
 &amp; &quot;              float(self.n + 2), true);\n\tzeus_animate(self.graphvbt, &quot;
 &amp; &quot;0.0, 0.75);\n\tgraph_moveVertex(self.codeSearchArrow, float(k - self.al&quot;
 &amp; &quot;phalen),\n\t\t\t float(self.n + 1), true);\n\tzeus_animate(self.graphvb&quot;
 &amp; &quot;t, 0.75, 1.0);\n\tgraph_removeVertex(self.xlast.vtx[k]);\n\tself.xlast.&quot;
 &amp; &quot;vtx[k] := self.codeSearchArrow;\n\n\tself.codeSearchArrow := ok;\n\n\tl&quot;
 &amp; &quot;et w = self.codes.vtx[i];\n\tgraph_setVertexLabelColor(w, codesLabelCol&quot;
 &amp; &quot;or);\n\tgra&quot;;

CONST E67_5 =
   &quot;ph_setVertexBorder(w, 0.05);\n\n\tself.codes.array[i] := code;\n\n\tgra&quot;
 &amp; &quot;ph_redisplay(self.graphvbt);\t\n    end,\n\n    EncodeDone =&gt; meth(self&quot;
 &amp; &quot;, alphabet, codes, rowIndex)\n    (* End of encode phase; (codes, rowIn&quot;
 &amp; &quot;dex) are now ready to be compressed\n       by Huffman coding, arithmet&quot;
 &amp; &quot;ic coding, or whatever; not shown in this\n       animation.  \n    *)\n&quot;
 &amp; &quot;\tlet v = graph_newVertex(self.graphvbt);\n\tself.rowIndexGhostVtx := v&quot;
 &amp; &quot;;\n\tgraph_setVertexShape(v, \&quot;ellipse\&quot;);\n\tgraph_setVertexLabel(v, f&quot;
 &amp; &quot;mt_int(self.rowIndex));\n\tgraph_setVertexFont(v, self.vertexFont);\n\t&quot;
 &amp; &quot;graph_setVertexColor(v, duplColor);\n\tgraph_setVertexLabelColor(v, dup&quot;
 &amp; &quot;lLabelColor);\n\tgraph_setVertexBorder(v, 0.05);\n\tgraph_moveVertex(v,&quot;
 &amp; &quot; float(self.n), float(rowIndex), false);\n\tgraph_setVertexSize(v, 0.95&quot;
 &amp; &quot;, 0.95);\n\n\tlet w = self.rowIndexVtx;\n\tgraph_moveVertex(w, float(se&quot;
 &amp; &quot;lf.n), float(self.n) + 3.25, true);\n\n\tzeus_animate(self.graphvbt, 0.&quot;
 &amp; &quot;0, 1.0);\n    end,\n\n  };\n&quot;;

CONST E68 =
   &quot;@RedBlackTest\nRedBlackTest(Keys)@\n  @1 create a new, empty tree T@\n &quot;
 &amp; &quot; @2 foreach k in Keys do@\n    @3 create a new node n with key k@\n    &quot;
 &amp; &quot;@4 RedBlackInsert(T, n)@\n  end\nend\n@RedBlackTest\n\n@Insert\nInsert(&quot;
 &amp; &quot;T, n)@\n  @4 curr := root(T)@\n  @5 while curr is not the place to atta&quot;
 &amp; &quot;ch n do@\n    @7 if key(n) &lt; key(curr)@\n      then @8 curr &lt;- left(cur&quot;
 &amp; &quot;r)@\n      else @9 curr &lt;- right(curr)@\n    end\n  end\n  @11 if T has&quot;
 &amp; &quot; no root@\n    then @12 make n the new root of T@\n    else @13 make n &quot;
 &amp; &quot;the proper child of curr@\n  end\nend\n@Insert\n\n@RedBlackInsert\nRedB&quot;
 &amp; &quot;lackInsert(T, n)@\n  @1 Insert(T, n)@\n  @2 type(n) &lt;- Red@\n  @3 while&quot;
 &amp; &quot; n # root(T) and type(n) = Red@ do\n    @4 side &lt;- side of parent(n) w.&quot;
 &amp; &quot;r.t. parent(parent(n))@\n    @7 other &lt;- opposite side from \&quot;side\&quot;@\n&quot;
 &amp; &quot;    @8 y &lt;- n\'s uncle@\n    @9 if type(y) # Black@ then\n      @10 han&quot;
 &amp; &quot;dle Case 1@\n    else\n      @14 if the line from parent(parent(n)) to &quot;
 &amp; &quot;n is zig-zag@ then\n        @15 handle Case 2 (including Rotate(side))@&quot;
 &amp; &quot;\n      end\n      @17 handle Case 3 (including Rotate(other))@\n    en&quot;
 &amp; &quot;d\n  end\n  @20 type(root(T)) &lt;- Black@\nend\n@RedBlackInsert\n\n@Searc&quot;
 &amp; &quot;h\nSearch(T, k)@\n  @1 n &lt;- root(T)@\n  @2 while key(n) # k do@\n    @3&quot;
 &amp; &quot; if key(n) &lt; k@\n      then @4 n &lt;- left(n)@\n      else @5 n &lt;- right(&quot;
 &amp; &quot;n)@\n    end\n  end\n  @6 return n@\nend\n@Search\n\n@RedBlackDelete\nR&quot;
 &amp; &quot;edBlackDelete(T, n)@\n  @1 if n has &lt; 2 children@\n    then @2 splice &lt;&quot;
 &amp; &quot;- n@\n    else @3 splice &lt;- FindMin(right(n))@\n  end\n  @4 splice_chil&quot;
 &amp; &quot;d &lt;- SpliceOut(t, splice)@\n  @5 if splice # n@ then\n    @6 copy conte&quot;
 &amp; &quot;nts of splice node into n@\n  end\n  @7 if type(splice) = Black@ then\n&quot;
 &amp; &quot;    @8 RedBlackFixUp(T, splice_child)@\n  end\nend\n@RedBlackDelete\n\n&quot;
 &amp; &quot;@FindMin\nFindMin(n)@\n  @1 while left(n) # NIL do@\n    @2 n &lt;- left(n&quot;
 &amp; &quot;)@\n  end\n  @3 return n@\nend\n@FindMin\n\n@SpliceOut\nSpliceOut(T, n)&quot;
 &amp; &quot;@\n  @1 ch &lt;- \&quot;a child of n, or NIL if n has no children\&quot;@\n  @4 pare&quot;
 &amp; &quot;nt(ch) &lt;- parent(n)@\n  @6 if n = root(T)@ then\n    @7 root(T) &lt;- ch@\n&quot;
 &amp; &quot;  else\n    @8 make appropriate \&quot;down\&quot; pointer of parent(n) point to &quot;
 &amp; &quot;ch@\n  end\n  @11 return ch@\nend\n@SpliceO&quot;;

CONST E68_0 =
   &quot;ut\n\n@RedBlackFixUp\nRedBlackFixUp(T, n)@\nend\n@RedBlackFixUp\n&quot;;

CONST E69 =
   &quot;(* Copyright 1993 Digital Equipment Corporation.                       &quot;
 &amp; &quot;      *)\n(* Distributed only by permission.                           &quot;
 &amp; &quot;                *)\n(*                                                 &quot;
 &amp; &quot;                          *)\n(* Last modified on Thu Oct 14 17:07:55 P&quot;
 &amp; &quot;DT 1993 by heydon                   *)\n(*      modified on Tue Jul 27 &quot;
 &amp; &quot;16:25:00 PDT 1993 by rsanchez                 *)\n\n(* This view shows &quot;
 &amp; &quot;the total number of hops that each packet needs to traverse\n   to go f&quot;
 &amp; &quot;rom its source to its destination node. It is designed to show the\n   &quot;
 &amp; &quot;performance of the network on between 10 to 100 packets. *)  \n\nlet Ba&quot;
 &amp; &quot;ckGroundColor = color_named(\&quot;White\&quot;);\nlet MinHopsColor = color_named&quot;
 &amp; &quot;(\&quot;Pink\&quot;);\nlet CurrHopsColor = color_named(\&quot;Yellow\&quot;);\nlet LabelCol&quot;
 &amp; &quot;or = color_named(\&quot;Black\&quot;);\nlet CapColor = LabelColor;\nlet BorderCol&quot;
 &amp; &quot;or = LabelColor;\n\nlet BarWidth = 0.40;\nlet CapFactor = 0.025;\nlet G&quot;
 &amp; &quot;ap = 0.05;\nlet SouthInit = ~3.0;\nlet BorderSize = 0.05;\nlet ScaleFac&quot;
 &amp; &quot;tor = 1.5;\n\nlet XValR = proc(i) float(i) + (Gap+BarWidth)/2.0 end;\nl&quot;
 &amp; &quot;et XValL = proc(i) float(i) - (Gap+BarWidth)/2.0 end;\n\nlet StatString&quot;
 &amp; &quot;1 = \&quot; finished using shortest path\&quot;;\nlet StatString2 = \&quot; average sh&quot;
 &amp; &quot;ortest path utilization\&quot;;\n\nlet FontFromSize =\n  proc(g, sz)\n    gr&quot;
 &amp; &quot;aph_newFont(g, \&quot;Helvetica\&quot;, sz, \&quot;Roman\&quot;, \&quot;bold\&quot;, \&quot;*\&quot;)\n  end;\n&quot;
 &amp; &quot;\nlet MoveTextVertex =\n  proc(vtx, font, x, y, width, height)\n    gra&quot;
 &amp; &quot;ph_setVertexFont(vtx, font);\n    graph_moveVertex(vtx, x, y, false);\n&quot;
 &amp; &quot;    graph_setVertexSize(vtx, width, height);\n  end;\n\nlet MakeTextVer&quot;
 &amp; &quot;tex =\n  proc(vtx, font, x, y, width, height)\n    graph_setVertexColor&quot;
 &amp; &quot;(vtx, BackGroundColor);\n    graph_setVertexLabelColor(vtx, LabelColor)&quot;
 &amp; &quot;;\n    MoveTextVertex(vtx, font, x, y, width, height)\n  end;\n\nlet Mo&quot;
 &amp; &quot;veBarVertex =\n  proc(vtx, width, height, x)\n    graph_setVertexSize(v&quot;
 &amp; &quot;tx, width, height);\n    graph_moveVertex(vtx, x, height/2.0, false);\n&quot;
 &amp; &quot;  end;\n    \nlet MakeBarVertex =\n  proc(vtx, clr, width, height, x)\n&quot;
 &amp; &quot;    graph_setVertexBorder(vtx, BorderSize);\n    graph_setVertexBorderC&quot;
 &amp; &quot;olor(vtx, BorderCol&quot;;

CONST E69_0 =
   &quot;or); \n    graph_setVertexColor(vtx, clr);\n    MoveBarVertex(vtx, widt&quot;
 &amp; &quot;h, height, x)\n  end;\n\nlet MoveCapVertex =\n  proc(vtx, (*int*) x, (*&quot;
 &amp; &quot;int*) y, (*real*) height)\n    graph_setVertexSize(vtx, BarWidth, heigh&quot;
 &amp; &quot;t);\n    graph_moveVertex(vtx, XValR(x), float(y)+(height/2.0), false);&quot;
 &amp; &quot;\n  end;\n\nlet MakeCapVertex =\n  proc(vw, (*int*) x, (*int*) y, (*rea&quot;
 &amp; &quot;l*) height)\n    let vtx = graph_newVertex(vw.graphvbt);\n    graph_set&quot;
 &amp; &quot;VertexBorder(vtx, BorderSize);\n    graph_setVertexBorderColor(vtx, Bor&quot;
 &amp; &quot;derColor);\n    graph_setVertexColor(vtx, CapColor);\n    MoveCapVertex&quot;
 &amp; &quot;(vtx, x, y, height);\n    vtx\n  end;\n\nlet view =\n  {\n    graphvbt &quot;
 &amp; &quot;=&gt; graph_new(),\n    pktCnt =&gt; ok,\t(* total number of packets (from \&quot;&quot;
 &amp; &quot;StartPackets\&quot;) *)\n    maxHops =&gt; 0.0,\t(* current max number of hops &quot;
 &amp; &quot;(related to \&quot;north\&quot; *)\n    hopsT =&gt; ok,\t(* array of packets *)\n   &quot;
 &amp; &quot; caps =&gt; ok,\t\t(* array of caps *)\n    someDone =&gt; false,\t(* did any&quot;
 &amp; &quot; packets get absorbed this step? *)\n    doneMinCnt =&gt; 0,\t(* number do&quot;
 &amp; &quot;ne using shortest paths *)\n    doneCnt =&gt; 0,\t(* number of done packet&quot;
 &amp; &quot;s (= # of caps) *)\n    doneUtilSum =&gt; 0.0,\t(* sum of utilization rati&quot;
 &amp; &quot;os of absorbed packets *)\n    rescale =&gt; false,\t(* should world coord&quot;
 &amp; &quot;inates be scaled vertically? *)\n    fontSz =&gt; 0.55,\t(* label font siz&quot;
 &amp; &quot;e *)\n    vtxFont =&gt; ok,\t(* font used to display two rows of labels *)&quot;
 &amp; &quot;\n    labH =&gt; 1.0,\t(* vertical size of label vertex *)\n    yLab1 =&gt; ~&quot;
 &amp; &quot;1.0,\t(* \&quot;y\&quot; coordinate of first row of labels *)\n    yLab2 =&gt; ~2.0,&quot;
 &amp; &quot;\t(* \&quot;y\&quot; coordinate of second row of labels *)\n    label1 =&gt; ok,\t(*&quot;
 &amp; &quot; first text label *)\n    label2 =&gt; ok,\t(* second text label *)\n    (&quot;
 &amp; &quot;* world coordinates *)\n    west =&gt; ~1.0,\t(* readonly *)\n    south =&gt;&quot;
 &amp; &quot; SouthInit,\n    east =&gt;  meth(self) float(self.pktCnt) end,\n    north&quot;
 &amp; &quot; =&gt; meth(self) self.maxHops+self.capH + (self.south/SouthInit) end,\n  &quot;
 &amp; &quot;  capH =&gt;  meth(self) CapFactor * self.maxHops end,\n    mid =&gt;   meth(&quot;
 &amp; &quot;self) (self.west + self.east) / 2.0 end,\n    width =&gt; meth(self) self.&quot;
 &amp; &quot;east - self.west end,\n\n    StartGraph =&gt; meth (self, nodeCnt, maxQS, &quot;
 &amp; &quot;bounded, xMax, y&quot;;

CONST E69_1 =
   &quot;Max)\n      (* initialize graph window to be over empty space *)\n     &quot;
 &amp; &quot; graph_setWorld(self.graphvbt, ~10.0, ~9.0, 1.0, 0.0)\n    end,\n\n    &quot;
 &amp; &quot;StartPackets =&gt; meth (self, pktCnt)\n      self.pktCnt := pktCnt;\n    &quot;
 &amp; &quot;  self.vtxFont := FontFromSize(self.graphvbt, self.fontSz);\n\n      (*&quot;
 &amp; &quot; create packet bars *)\n      self.hopsT := array_new(pktCnt, ok);\n   &quot;
 &amp; &quot;   self.caps := array_new(pktCnt, ok);\n      for i = 0 to pktCnt-1 do\n&quot;
 &amp; &quot;        let vtx1 = graph_newVertex(self.graphvbt);\n\tMakeBarVertex(vtx&quot;
 &amp; &quot;1, CurrHopsColor, BarWidth, BorderSize, XValR(i));\n\n\tself.hopsT[i] :&quot;
 &amp; &quot;= {\n\t  minNumHops =&gt; ok,\t(* length of shortest path for this packet &quot;
 &amp; &quot;*)\n\t  curNumHops =&gt; 0,\t(* number of times this packet has moved *)\n&quot;
 &amp; &quot;\t  vmin =&gt; vtx1,\t\t(* vertex that grows each time packet moves *)\n\t&quot;
 &amp; &quot;}\n      end;\n\n      (* create labels *)\n      self.label1 := graph_&quot;
 &amp; &quot;newVertex(self.graphvbt);\n      MakeTextVertex(self.label1, self.vtxFo&quot;
 &amp; &quot;nt,\n        self.mid, self.yLab1, self.width, self.labH);\n      graph&quot;
 &amp; &quot;_setVertexLabel(self.label1, \&quot;0%\&quot; &amp; StatString1);\n\n      self.label&quot;
 &amp; &quot;2 := graph_newVertex(self.graphvbt);\n      MakeTextVertex(self.label2,&quot;
 &amp; &quot; self.vtxFont,\n        self.mid, self.yLab2, self.width, self.labH);\n&quot;
 &amp; &quot;      graph_setVertexLabel(self.label2, \&quot;0%\&quot; &amp; StatString2);\n    end&quot;
 &amp; &quot;,\n\n    NewPacket =&gt; meth (self, id, source, dest, fewestHops, name)\n&quot;
 &amp; &quot;      let pkt = self.hopsT[id];\n      pkt.minNumHops := fewestHops;\n &quot;
 &amp; &quot;     if float(fewestHops) &gt; self.maxHops then\n        self.maxHops := &quot;
 &amp; &quot;float(fewestHops)\n      end;\n      let vtx = graph_newVertex(self.gra&quot;
 &amp; &quot;phvbt);\n      MakeBarVertex(vtx, MinHopsColor, BarWidth, float(fewestH&quot;
 &amp; &quot;ops), XValL(id))\n    end,\n\n    EndPackets =&gt; meth (self)\n      grap&quot;
 &amp; &quot;h_setWorld(self.graphvbt,\n\tself.west, self.east, self.north, self.sou&quot;
 &amp; &quot;th);\n      graph_redisplay(self.graphvbt)\n    end,\n\n    MovePacket &quot;
 &amp; &quot;=&gt; meth(self, id, fromN, toN) \n      let pkt = self.hopsT[id];\n      &quot;
 &amp; &quot;pkt.curNumHops := pkt.curNumHops + 1;\n      MoveBarVertex(pkt.vmin, Ba&quot;
 &amp; &quot;rWidth, float(pkt.curNumHops), XValR(id));\n      if float(pkt.curNumHo&quot;
 &amp; &quot;ps) &gt; self&quot;;

CONST E69_2 =
   &quot;.maxHops then\n\tself.rescale := true;\n      end\n    end,\n\n    Abso&quot;
 &amp; &quot;rb =&gt; meth(self, id, (*unused*) dest)\n      let pkt = self.hopsT[id];\n&quot;
 &amp; &quot;      let v = MakeCapVertex(self, id, pkt.curNumHops, self.capH());\n  &quot;
 &amp; &quot;    self.caps[self.doneCnt] := { vtx =&gt; v, id =&gt; id };\n      self.done&quot;
 &amp; &quot;Cnt := self.doneCnt + 1;\n      if pkt.minNumHops is pkt.curNumHops the&quot;
 &amp; &quot;n\n        self.doneMinCnt := self.doneMinCnt + 1\n      end;\n      se&quot;
 &amp; &quot;lf.doneUtilSum := self.doneUtilSum +\n        (float(pkt.curNumHops) / &quot;
 &amp; &quot;float(pkt.minNumHops));\n      self.someDone := true\n    end,\n\n    S&quot;
 &amp; &quot;tep =&gt; meth (self)\n      let Percent = proc((*real*) num, (*int*) deno&quot;
 &amp; &quot;m)\n\tfmt_int(round((100.0 * num) / float(denom))) &amp; \&quot;%\&quot;\n      end;\n&quot;
 &amp; &quot;\n      (* update stats if necessary *)\n      if self.someDone then\n &quot;
 &amp; &quot;       self.someDone := false;\n        let val = Percent(float(self.do&quot;
 &amp; &quot;neMinCnt), self.doneCnt);\n        graph_setVertexLabel(self.label1, va&quot;
 &amp; &quot;l &amp; StatString1);\n        let val = Percent(self.doneUtilSum, self.don&quot;
 &amp; &quot;eCnt);\n        graph_setVertexLabel(self.label2, val &amp; StatString2);\n&quot;
 &amp; &quot;      end;\n\n      if self.rescale then\n\tself.rescale := false;\n\ts&quot;
 &amp; &quot;elf.maxHops := self.maxHops * ScaleFactor;\n\tself.south   := self.sout&quot;
 &amp; &quot;h   * ScaleFactor;\n\tself.fontSz  := self.fontSz  * ScaleFactor;\n\tse&quot;
 &amp; &quot;lf.labH    := self.labH    * ScaleFactor;\n\tself.yLab1   := self.yLab1&quot;
 &amp; &quot;   * ScaleFactor;\n\tself.yLab2   := self.yLab2   * ScaleFactor;\n\n   &quot;
 &amp; &quot;     (* reposition labels and caps *)\n        self.vtxFont := FontFrom&quot;
 &amp; &quot;Size(self.graphvbt, self.fontSz);\n\tMoveTextVertex(self.label1, self.v&quot;
 &amp; &quot;txFont,\n          self.mid, self.yLab1, self.width, self.labH);\n     &quot;
 &amp; &quot;   MoveTextVertex(self.label2, self.vtxFont,\n          self.mid, self.&quot;
 &amp; &quot;yLab2, self.width, self.labH);\n        for i = 0 to self.doneCnt - 1 d&quot;
 &amp; &quot;o\n\t  let obj = self.caps[i];\n          let id = obj.id;\n          l&quot;
 &amp; &quot;et y = self.hopsT[id].curNumHops;\n          MoveCapVertex(obj.vtx, id,&quot;
 &amp; &quot; y, self.capH())\n        end;\n\n        (* double height of world coo&quot;
 &amp; &quot;rdinates *)\n        graph_setWorld(self.graphvbt, \n\t  self.west, sel&quot;
 &amp; &quot;f.east, s&quot;;

CONST E69_3 =
   &quot;elf.north, self.south);\n      end;\n\n      graph_redisplay(self.graph&quot;
 &amp; &quot;vbt)\n    end\n  };\n&quot;;

CONST E70 =
   &quot;@Parse\nPROCEDURE Parse ()@\n\n    @1 state := &lt;initial state&gt;@\n    @2&quot;
 &amp; &quot; token := Scan ()@\n    LOOP\n       @3 CASE LookUp (state, token) OF@\n&quot;
 &amp; &quot;       @4 | Action.Shift (new_state) =&gt;@\n           @5 PUSH state@\n  &quot;
 &amp; &quot;         @6 state := new_state@\n           @7 token := Scan ()@\n\n   &quot;
 &amp; &quot;    @8 | Action.Goto (new_state) =&gt;@\n           @9 PUSH state@\n      &quot;
 &amp; &quot;     @10 state := new_state@\n\n       @11 | Action.Reduce (p) =&gt;@\n   &quot;
 &amp; &quot;         where p is \&quot;lhs -&gt; x0 x1 ... xn\&quot;\n            @12 POP n stat&quot;
 &amp; &quot;es@\n            @13 (GOTO, state) := LookUp (top_of_stack, p.lhs)@\n  &quot;
 &amp; &quot;          @14 PUSH state@\n\n       @15 | Action.Accept =&gt;@\n          &quot;
 &amp; &quot;  @16 EXIT@\n\n       @17 | Action.Error  =&gt;@\n            @18 ERROR@\n&quot;
 &amp; &quot;            @19 EXIT@\n       END;\n    END;\n @20 END Parse@\n\n@Parse&quot;
 &amp; &quot;\n\n&quot;;

CONST E71 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:37:06 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Stri&quot;
 &amp; &quot;ngSearch.evt.\n;*******************************************************&quot;
 &amp; &quot;*************\n\n(VBox\n  (Rim\n    (Pen 2)\n    (HBox\n      (VBox (Gl&quot;
 &amp; &quot;ue 4) (Shape (Height + Inf) (Button %clear \&quot;CLEAR\&quot;)) (Glue 4))\n     &quot;
 &amp; &quot; (Glue 4)\n      (VBox\n        (Boolean =TRUE %alg (Text LeftAlign \&quot;A&quot;
 &amp; &quot;lgorithm events\&quot;))\n        (Boolean =FALSE %zeus (Text LeftAlign \&quot;Ze&quot;
 &amp; &quot;us events\&quot;))\n        (Boolean =TRUE %args (Text LeftAlign \&quot;Display a&quot;
 &amp; &quot;rgs to events\&quot;)))\n      Fill))\n  (Bar 1)\n  (Shape (ShadowSize 0) (H&quot;
 &amp; &quot;eight 200 + INF) (TextEdit ReadOnly %transcript)))\n&quot;;

CONST E72 =
   &quot;(* Copyright (C) 1994, Digital Equipment Corporation                   &quot;
 &amp; &quot;      *)\n(* All rights reserved.                                      &quot;
 &amp; &quot;                *)\n(* See the file COPYRIGHT for a full description.  &quot;
 &amp; &quot;                          *)\n(*                                       &quot;
 &amp; &quot;                                    *)\n(* Last modified on Mon Jan  9 &quot;
 &amp; &quot;12:04:09 PST 1995 by najork                   *)\n(*      modified on F&quot;
 &amp; &quot;ri Aug 19 15:40:47 PDT 1994 by heydon                   *)\n\n(* BigTre&quot;
 &amp; &quot;e.obl -- tree view for Union-Find designed for showing large trees *)\n&quot;
 &amp; &quot;\nlet NodeBgColor       = color_named(\&quot;Green\&quot;);\nlet NodeFgColor     &quot;
 &amp; &quot;  = color_named(\&quot;Black\&quot;);\nlet NormalEdgeColor   = color_named(\&quot;Blac&quot;
 &amp; &quot;k\&quot;);\nlet HiliteEdgeColor   = color_named(\&quot;Red\&quot;);\nlet RankBarBgColo&quot;
 &amp; &quot;r    = color_named(\&quot;Red\&quot;);\nlet RankBarFgColor    = color_named(\&quot;Bla&quot;
 &amp; &quot;ck\&quot;);\n\n(* Hilite colors *)\nlet SelectHiLiColor   = color_named(\&quot;Or&quot;
 &amp; &quot;ange\&quot;);\nlet FoundHiLiColor    = color_named(\&quot;Blue\&quot;);\nlet NodeHilit&quot;
 &amp; &quot;eBgColor = color_named(\&quot;Red\&quot;);\n\nlet NodeSz  = 1.0;\nlet Margin  = 5&quot;
 &amp; &quot;.0;           (* in mm *)\nlet VGap    = NodeSz * 1.0;  (* vertical gap&quot;
 &amp; &quot; between levels *)\nlet HGap    = NodeSz * 0.2;  (* horizontal gap betw&quot;
 &amp; &quot;een siblings *)\nlet RankH   = NodeSz * 0.25; (* height of rank bars *)&quot;
 &amp; &quot;\nlet RankW   = NodeSz * 1.0;  (* width of each rank unit *)\nlet RankG&quot;
 &amp; &quot;ap = NodeSz * 0.25; (* gap between root and rank bars *)\nlet RankY   =&quot;
 &amp; &quot; RankGap + ((NodeSz + RankH)/ 2.0);\n\n(* The \&quot;VGap\&quot; is the distance &quot;
 &amp; &quot;between the bottoms of nodes on level \&quot;i\&quot;\n   and the tops of nodes o&quot;
 &amp; &quot;n level \&quot;i+1\&quot;. The \&quot;HGap\&quot; is the gap between the\n   right edge of &quot;
 &amp; &quot;a node and the left edge of its right sibling. *)\n\nlet BorderWidth   &quot;
 &amp; &quot;= NodeSz * 0.05;\nlet ThinEdgeWidth = NodeSz * 0.05;\nlet FatEdgeWidth &quot;
 &amp; &quot; = NodeSz * 0.2;\nlet FoundHiLiSz   = NodeSz * 0.08;\nlet SelectHiLiSz &quot;
 &amp; &quot; = NodeSz * 0.20;\n\n(* Node Object (to be cloned) ====================&quot;
 &amp; &quot;========================= *)\n\nlet Node = {\n  v: Vertex =&gt; ok,       &quot;
 &amp; &quot; (* The Vertex *)\n  e: Edge =&gt; ok,       \t  (* The Edge to the parent&quot;
 &amp; &quot; *)\n  parent&quot;;

CONST E72_0 =
   &quot;: Node =&gt; ok,     (* parent node *)\n  children: Node =&gt; ok,   (* leftm&quot;
 &amp; &quot;ost child node *)\n  height: Int =&gt; 0, \t  (* height of tree rooted at &quot;
 &amp; &quot;this node *)\n  x: Real =&gt; ok,          (* x-coordinate of this node *)&quot;
 &amp; &quot;\n  next =&gt; ok,       \t  (* ids of next and previous siblings *)\n  pr&quot;
 &amp; &quot;ev =&gt; ok,\n  rank: Int =&gt; 0,\n  rankBar: Vertex =&gt; ok,  (* the vertex o&quot;
 &amp; &quot;f this node\'s rank bar (if any) *)\n\n  lastChild =&gt; meth(parent: Node&quot;
 &amp; &quot;): Node,\n  (* Returns the rightmost child of \&quot;parent\&quot;, or \&quot;ok\&quot; if &quot;
 &amp; &quot;\&quot;parent\&quot;\n     is a leaf. *)\n    var curr: Node = parent.children;\n&quot;
 &amp; &quot;    if curr isnot ok then\n      loop\n        if curr.next is ok then &quot;
 &amp; &quot;exit end;\n        curr := curr.next\n      end;\n      curr\n    else\n&quot;
 &amp; &quot;      ok\n    end\n  end,\n\n  incHeightToRoot =&gt; meth(parent, child: N&quot;
 &amp; &quot;ode): Ok,\n  (* the \&quot;child\&quot; of \&quot;parent\&quot; has just grown in height; g&quot;
 &amp; &quot;row \&quot;parent\&quot; and\n     all nodes on the path from it to the root of t&quot;
 &amp; &quot;he tree in height as\n     necessary. *)\n    if (child.height + 1) &gt; p&quot;
 &amp; &quot;arent.height then\n      parent.height := (child.height + 1);\n      if&quot;
 &amp; &quot; parent.parent isnot ok then\n        parent.parent.incHeightToRoot(par&quot;
 &amp; &quot;ent)\n      end\n    end;\n    ok\n  end,\n\n  addChild =&gt; meth(parent,&quot;
 &amp; &quot; rightOf, child: Node): Ok,\n  (* Adds child as a child of parent, inse&quot;
 &amp; &quot;rted to the right of \n     the child \&quot;rightOf\&quot;, which must be a chil&quot;
 &amp; &quot;d of parent, or as\n     the leftmost child if rightOf is ok *)\n    if&quot;
 &amp; &quot; rightOf is ok then\n      child.next := parent.children;\n      child.&quot;
 &amp; &quot;prev := ok;\n      if child.next isnot ok then child.next.prev := child&quot;
 &amp; &quot; end;\n      parent.children := child;\n    else\n      child.prev := r&quot;
 &amp; &quot;ightOf;\n      child.next := rightOf.next;\n      if (child.next isnot &quot;
 &amp; &quot;ok) then child.next.prev := child end;\n      rightOf.next := child;\n &quot;
 &amp; &quot;   end;\n    child.parent := parent;\n    parent.incHeightToRoot(child)&quot;
 &amp; &quot;;\n    ok\n  end,\n\n  updateHeight =&gt; meth(parent: Node): Ok,\n  (* up&quot;
 &amp; &quot;date the height of \&quot;parent\&quot; to be one greater than the maximum height&quot;
 &amp; &quot;s\n     of its children, or 0 if it has no children. *)\n    var maxHt:&quot;
 &amp; &quot; Int = ~1;\n    var &quot;;

CONST E72_1 =
   &quot;ch: Node = parent.children;\n    loop\n      if ch is ok then exit end;&quot;
 &amp; &quot;\n      if ch.height &gt; maxHt then maxHt := ch.height end;\n      ch := &quot;
 &amp; &quot;ch.next\n    end;\n    parent.height := (maxHt + 1);\n    ok\n  end,\n\n&quot;
 &amp; &quot;  decHeightToRoot =&gt; meth(parent: Node, oldChHeight: Int): Ok,\n  (* so&quot;
 &amp; &quot;me child of \&quot;parent\&quot; has just decreased in height from \&quot;oldChHeight\&quot;&quot;
 &amp; &quot;,\n     so update the height of the \&quot;parent\&quot; if necessary and those o&quot;
 &amp; &quot;f all\n     nodes on the path to the root. *)\n    if parent.height is &quot;
 &amp; &quot;(oldChHeight + 1) then\n      var oldParHeight: Int = parent.height;\n &quot;
 &amp; &quot;     parent.updateHeight();\n      if (parent.height &lt; oldParHeight) an&quot;
 &amp; &quot;d (parent.parent isnot ok) then\n        parent.parent.decHeightToRoot(&quot;
 &amp; &quot;oldParHeight)\n      end\n    end;\n    ok\n  end,\n\n  removeChild =&gt; &quot;
 &amp; &quot;meth(parent, child: Node): Ok,\n  (* removes child from parent, which m&quot;
 &amp; &quot;ust be its parent *)\n    if child.prev isnot ok\n      then child.prev&quot;
 &amp; &quot;.next := child.next;\n      else parent.children := child.next\n    end&quot;
 &amp; &quot;;\n    if child.next isnot ok then\n      child.next.prev := child.prev&quot;
 &amp; &quot;\n    end;\n    child.prev := ok;\n    child.next := ok;\n    parent.de&quot;
 &amp; &quot;cHeightToRoot(child.height);\n    ok\n  end,\n\n  isRightOf =&gt; meth(sel&quot;
 &amp; &quot;f, n: Node): Bool,\n  (* Returns \&quot;true\&quot; iff \&quot;self\&quot; is a right sibli&quot;
 &amp; &quot;ng of \&quot;n\&quot;. *)\n    var curr: Node = n.next;\n    loop\n      if (curr&quot;
 &amp; &quot; is self) or (curr is ok) then exit end;\n      curr := curr.next\n    &quot;
 &amp; &quot;end;\n    (curr is self)\n  end,\n\n  subtreeWidth =&gt; meth(self: Node):&quot;
 &amp; &quot; Real,\n  (* Returns the width of the subtree rooted at \&quot;self\&quot;. *)\n &quot;
 &amp; &quot;   if self.children is ok then\n      NodeSz\n    else\n      var res: &quot;
 &amp; &quot;Real = 0.0;\n      var ch: Node = self.children;\n      loop\n        r&quot;
 &amp; &quot;es := res + ch.subtreeWidth();\n        if ch.next is ok then exit end;&quot;
 &amp; &quot;\n        res := res + HGap;\n        ch := ch.next\n      end;\n      &quot;
 &amp; &quot;res\n    end\n  end,\n\n  position =&gt; meth(self: Node, level: Int, offs&quot;
 &amp; &quot;et: Real): Ok,\n    let depth: Real = - float(level) * (NodeSz + VGap);&quot;
 &amp; &quot;\n    graph_moveVertex(self.v, offset, depth, true);\n    self.x := off&quot;
 &amp; &quot;set;\n    ok\n  end,\n\n  &quot;;

CONST E72_2 =
   &quot;positionChildren =&gt; meth(self: Node, level: Int, offset: Real): Real,\n&quot;
 &amp; &quot;    var ch: Node = self.children;\n    var res: Real = offset;\n    loo&quot;
 &amp; &quot;p\n      if ch is ok then exit; end;\n      res := ch.positionSubtree(l&quot;
 &amp; &quot;evel, res);\n      if ch.next isnot ok then res := res + HGap; end;\n  &quot;
 &amp; &quot;    ch := ch.next;\n    end;\n    res;\n  end,\n\n  positionSubtree =&gt; &quot;
 &amp; &quot;meth(self: Node, level: Int, offset: Real): Real,\n  (* Reposition all &quot;
 &amp; &quot;nodes in the subtree rooted at \&quot;self\&quot;, with the leftmost\n     descen&quot;
 &amp; &quot;dant at \&quot;offset\&quot;, and the root at vertical position \&quot;level\&quot;.\n     &quot;
 &amp; &quot;Returns the x-coordinate of the rightmost descendant. *)\n    var res =&quot;
 &amp; &quot; offset;\n    if self.children is ok\n      then res := res + NodeSz;\n&quot;
 &amp; &quot;      else res := self.positionChildren(level+1, res);\n    end;\n    s&quot;
 &amp; &quot;elf.position(level, (res + offset) / 2.0);\n    res;\n  end,\n};\n\n(* &quot;
 &amp; &quot;EdgeList Object =======================================================&quot;
 &amp; &quot;= *)\n\nlet EdgeList = {\n  e: Edge =&gt; ok,\n  next: EdgeList =&gt; ok,\n};&quot;
 &amp; &quot;\n\n(* View Object ====================================================&quot;
 &amp; &quot;======== *)\n\nlet view: View = {\n\n  (* Data members ----------------&quot;
 &amp; &quot;----------------------------------------- *)\n\n  graphvbt =&gt; graph_new&quot;
 &amp; &quot;(),\n  graphW: Real =&gt; ok,          (* the width of the graphvbt *)\n  &quot;
 &amp; &quot;usesRanks: Bool =&gt; ok,       (* \&quot;usesRanks\&quot; arg to \&quot;Setup\&quot; event *)&quot;
 &amp; &quot;\n  nodeCnt: Int =&gt; ok,          (* number of nodes (not counting root)&quot;
 &amp; &quot; *)\n  height: Int =&gt; ok,           (* height of window *)\n  root: Nod&quot;
 &amp; &quot;e =&gt; ok,\n  last: Node =&gt; ok,\n  node: [Node] =&gt; ok,          (* array &quot;
 &amp; &quot;of nodes *)\n  newEdge: Edge =&gt; ok,         (* Edge added during a unit&quot;
 &amp; &quot;e method *)\n  bothRoots: Bool =&gt; ok,       (* are both nodes to \&quot;Unio&quot;
 &amp; &quot;n\&quot; roots? *)\n  upEdges: EdgeList =&gt; ok,     (* list of \&quot;StepUp\&quot; edg&quot;
 &amp; &quot;es *)\n  seenStepDown: Bool =&gt; ok,    (* any \&quot;StepDown\&quot; events after &quot;
 &amp; &quot;\&quot;Found\&quot;? *)\n  findVh: VertexHiLi =&gt; ok,\n  unionVh1: VertexHiLi =&gt; o&quot;
 &amp; &quot;k,\n  unionVh2: VertexHiLi =&gt; ok,\n  foundVh: VertexHiLi =&gt; ok,\n  firs&quot;
 &amp; &quot;tRootVh: VertexHiLi =&gt; ok,\n\n  (* The \&quot;height\&quot; field is the height o&quot;
 &amp; &quot;f the largest tree&quot;;

CONST E72_3 =
   &quot; that can fit in the\n     window; it is only ever increased. For \&quot;vie&quot;
 &amp; &quot;w: View\&quot;, the system maintains\n     the invariant: \&quot;view.root.height&quot;
 &amp; &quot; &lt;= view.height\&quot;. *)\n\n  (* Layout method ---------------------------&quot;
 &amp; &quot;----------------------------- *)\n\n  repositionAll =&gt; meth(self: View)&quot;
 &amp; &quot;: Ok,\n  (* Layout all nodes of the tree rooted at the virtual root nod&quot;
 &amp; &quot;e\n     \&quot;self.root\&quot;. *)\n    if self.root.children isnot ok then\n   &quot;
 &amp; &quot;   var childrenW: Real = 0.0;\n      var numCh: Int = 0;\n      var ch:&quot;
 &amp; &quot; Node = self.root.children;\n      loop\n        childrenW := childrenW&quot;
 &amp; &quot; + ch.subtreeWidth();\n        numCh := numCh + 1;\n        if ch.next &quot;
 &amp; &quot;is ok then exit end;\n        ch := ch.next\n      end;\n      var gap:&quot;
 &amp; &quot; Real = 0.0;\n      if numCh &gt; 1 then\n        gap := (self.graphW - ch&quot;
 &amp; &quot;ildrenW) / float(numCh - 1)\n      end;\n      ch := self.root.children&quot;
 &amp; &quot;;\n      var res: Real = - (NodeSz / 2.0);\n      loop\n      \tif ch i&quot;
 &amp; &quot;s ok then exit end;\n      \tres := ch.positionSubtree(0, res);\n      &quot;
 &amp; &quot;\tif ch.next isnot ok then res := res + gap end;\n      \tch := ch.next&quot;
 &amp; &quot;\n      end\n    end;\n    ok\n  end,\n\n  repositionRanks =&gt; meth(self&quot;
 &amp; &quot;: View): Ok,\n  (* Reposition the rank bar vertices of those nodes that&quot;
 &amp; &quot; are children of\n     \&quot;self.root\&quot;. This procedure just moves the nec&quot;
 &amp; &quot;essary vertices; it doesn\'t\n     animate them. *)\n    var ch = self.&quot;
 &amp; &quot;root.children;\n    loop\n      if (ch is ok) then exit end;\n      let&quot;
 &amp; &quot; rankX = graph_getVertexPosition(ch.rankBar)[0];\n      if (ch.x isnot &quot;
 &amp; &quot;rankX) then\n        graph_moveVertex(ch.rankBar, ch.x, RankY, true)\n &quot;
 &amp; &quot;     end;\n      ch := ch.next\n    end;\n    ok\n  end,\n\n  setWorld &quot;
 &amp; &quot;=&gt; meth(self: View): Ok,\n    let rad: Real = NodeSz / 2.0;\n    let ht&quot;
 &amp; &quot;: Real = (float(self.height) * (NodeSz + VGap)) - VGap;\n    var north:&quot;
 &amp; &quot; Real = rad;\n    if self.usesRanks then north := north + RankGap + Ran&quot;
 &amp; &quot;kH end;\n    graph_setWorld(self.graphvbt,\n      (* east = *) - rad, (&quot;
 &amp; &quot;* west = *) (- rad) + self.graphW,\n      (* north= *) north, (* south=&quot;
 &amp; &quot; *) rad + (- ht));\n    ok\n  end,\n\n  (* Setup ----------------------&quot;
 &amp; &quot;----------------&quot;;

CONST E72_4 =
   &quot;-------------------------- *)\n\n  Setup =&gt; meth(self: View): Ok,\n    &quot;
 &amp; &quot;graph_setMargin(self.graphvbt, Margin);\n    self.nodeCnt := 0;\n    se&quot;
 &amp; &quot;lf.root := clone(Node);\n    self.last := ok;\n    ok\n  end,\n\n  NewS&quot;
 &amp; &quot;et =&gt; meth(self: View, (*UNUSED*) nm: Text): Ok,\n    let v = graph_new&quot;
 &amp; &quot;Vertex(self.graphvbt);\n    graph_setVertexShape(v, \&quot;ellipse\&quot;);\n    &quot;
 &amp; &quot;graph_setVertexSize(v, NodeSz, NodeSz);\n    graph_setVertexLabelColor(&quot;
 &amp; &quot;v, NodeFgColor);\n    graph_setVertexBorder(v, BorderWidth);\n    graph&quot;
 &amp; &quot;_setVertexColor(v, NodeBgColor);\n    var n: Node = clone(Node);\n    s&quot;
 &amp; &quot;elf.nodeCnt := self.nodeCnt + 1;\n    n.v := v;\n    self.root.addChild&quot;
 &amp; &quot;(self.last, n);\n    self.last := n;\n    ok\n  end,\n\n  FinishedSets &quot;
 &amp; &quot;=&gt; meth(self: View, numSets: Int, usesRanks: Bool): Ok,\n    (* initial&quot;
 &amp; &quot;ize coordinate system *)\n    self.height := real_ceiling(math_log(floa&quot;
 &amp; &quot;t(numSets))) + 1;\n    self.graphW := (float(numSets) * (NodeSz + HGap)&quot;
 &amp; &quot;) - HGap;\n    self.usesRanks := usesRanks;\n    self.setWorld();\n\n  &quot;
 &amp; &quot;  (* initialize nodes *)\n    self.node := array_new(numSets, ok);\n   &quot;
 &amp; &quot; var curr: Node = self.root.children;\n    for i = 0 to numSets - 1 do\n&quot;
 &amp; &quot;      self.node[i] := curr;\n      curr := curr.next\n    end;\n    sel&quot;
 &amp; &quot;f.repositionAll();\n\n    (* initialize rank bars *)\n    if usesRanks &quot;
 &amp; &quot;then\n      for i = 0 to numSets - 1 do\n        let node = self.node[i&quot;
 &amp; &quot;];\n        let v = graph_newVertex(self.graphvbt);\n        node.rankB&quot;
 &amp; &quot;ar := v;\n      \tgraph_setVertexShape(v, \&quot;rectangle\&quot;);\n      \tgrap&quot;
 &amp; &quot;h_setVertexSize(v, RankW * 0.1, RankH);\n      \tgraph_setVertexBorderC&quot;
 &amp; &quot;olor(v, RankBarFgColor);\n      \tgraph_setVertexBorder(v, BorderWidth)&quot;
 &amp; &quot;;\n      \tgraph_setVertexColor(v, RankBarBgColor);\n        graph_move&quot;
 &amp; &quot;Vertex(v, node.x, RankY, false);\n      end\n    end;\n    zeus_animate&quot;
 &amp; &quot;(self.graphvbt, 0.0, 0.0);\n    ok\n  end,\n\n  (* Find events --------&quot;
 &amp; &quot;-------------------------------------------------- *)\n\n  StartFind =&gt;&quot;
 &amp; &quot; meth(self: View, id: Int): Ok,\n    self.findVh := graph_newVertexHiLi&quot;
 &amp; &quot;(self.node[id].v);\n    graph_setVertexHiLiColor(self.findVh, SelectHiL&quot;
 &amp; &quot;iColor);\n   &quot;;

CONST E72_5 =
   &quot; graph_setVertexHiLiBorder(self.findVh, SelectHiLiSz, SelectHiLiSz);\n &quot;
 &amp; &quot;   graph_redisplay(self.graphvbt);\n    ok\n  end,\n\n  EndFind =&gt; meth&quot;
 &amp; &quot;(self: View, id: Int): Ok,\n    graph_removeVertexHiLi(self.findVh);\n &quot;
 &amp; &quot;   graph_removeVertexHiLi(self.foundVh);\n    graph_redisplay(self.grap&quot;
 &amp; &quot;hvbt);\n    ok\n  end,\n\n  (* DoFind events --------------------------&quot;
 &amp; &quot;------------------------------ *)\n\n  StartDoFind =&gt; meth(self, id): O&quot;
 &amp; &quot;k,\n    ok\n  end,\n\n  StepUp =&gt; meth(self, child, parent): Ok,\n    (&quot;
 &amp; &quot;* make edge thick *)\n    let upEdge: Edge = self.node[child].e;\n    g&quot;
 &amp; &quot;raph_setEdgeWidth(upEdge, FatEdgeWidth);\n\n    (* add edge to up-edge &quot;
 &amp; &quot;list *)\n    var el: EdgeList = clone(EdgeList);\n    el.e := upEdge;\n&quot;
 &amp; &quot;    el.next := self.upEdges;\n    self.upEdges := el;\n    ok\n  end,\n&quot;
 &amp; &quot;\n  Found =&gt; meth(self, root): Ok,\n    self.foundVh := graph_newVertex&quot;
 &amp; &quot;HiLi(self.node[root].v);\n    graph_setVertexHiLiColor(self.foundVh, Fo&quot;
 &amp; &quot;undHiLiColor);\n    graph_setVertexHiLiBorder(self.foundVh, FoundHiLiSz&quot;
 &amp; &quot;, FoundHiLiSz);\n    graph_redisplay(self.graphvbt);\n    self.seenStep&quot;
 &amp; &quot;Down := false;\n    ok\n  end,\n\n  StepDown =&gt; meth(self: View, childI&quot;
 &amp; &quot;d, parentId: Int): Ok,\n    let child: Node = self.node[childId];\n    &quot;
 &amp; &quot;self.seenStepDown := true;\n    graph_setEdgeWidth(child.e, ThinEdgeWid&quot;
 &amp; &quot;th);\n    ok\n  end,\n\n  ChangeParent =&gt; meth(self: View, childId, par&quot;
 &amp; &quot;entId, rootId: Int): Ok,\n    let child: Node = self.node[childId];\n  &quot;
 &amp; &quot;  let parent: Node = self.node[parentId];\n    let root: Node = self.no&quot;
 &amp; &quot;de[rootId];\n\n    (* change tree structure *)\n    var rightOf: Node =&quot;
 &amp; &quot; parent;\n    if parent.children is child then rightOf := rightOf.prev &quot;
 &amp; &quot;end;\n    parent.removeChild(child);\n    root.addChild(rightOf, child)&quot;
 &amp; &quot;;\n\n    (* move the edge and subtree *)\n    graph_moveEdge(child.e, c&quot;
 &amp; &quot;hild.v, root.v, true);\n    self.repositionAll();\n    if self.usesRank&quot;
 &amp; &quot;s then self.repositionRanks() end;\n    zeus_animate(self.graphvbt, 0.0&quot;
 &amp; &quot;, 1.0);\n    ok\n  end,\n\n  EndDoFind =&gt; meth(self, id): Ok,\n    if n&quot;
 &amp; &quot;ot(self.seenStepDown) then\n      var curr: EdgeList = self.upEdges;\n &quot;
 &amp; &quot;     loop\n&quot;;

CONST E72_6 =
   &quot;        if curr is ok then exit end;\n        graph_setEdgeWidth(curr.e&quot;
 &amp; &quot;, ThinEdgeWidth);\n        curr := curr.next\n      end\n    end;\n    &quot;
 &amp; &quot;graph_redisplay(self.graphvbt);\n    ok\n  end,\n\n  (* Union events --&quot;
 &amp; &quot;------------------------------------------------------- *)\n\n  StartUn&quot;
 &amp; &quot;ion =&gt; meth(self: View, id1, id2: Int, bothRoots: Bool): Ok,\n    self.&quot;
 &amp; &quot;bothRoots := bothRoots;\n    self.unionVh1 := graph_newVertexHiLi(self.&quot;
 &amp; &quot;node[id1].v);\n    self.unionVh2 := graph_newVertexHiLi(self.node[id2].&quot;
 &amp; &quot;v);\n    graph_setVertexHiLiColor(self.unionVh1, SelectHiLiColor);\n   &quot;
 &amp; &quot; graph_setVertexHiLiColor(self.unionVh2, SelectHiLiColor);\n    graph_s&quot;
 &amp; &quot;etVertexHiLiBorder(self.unionVh1, SelectHiLiSz, SelectHiLiSz);\n    gra&quot;
 &amp; &quot;ph_setVertexHiLiBorder(self.unionVh2, SelectHiLiSz, SelectHiLiSz);\n   &quot;
 &amp; &quot; graph_redisplay(self.graphvbt);\n    self.newEdge := ok;\n    ok\n  en&quot;
 &amp; &quot;d,\n\n  FoundFirst =&gt; meth(self: View, root1: Int): Ok,\n    self.first&quot;
 &amp; &quot;RootVh := self.foundVh;\n    ok\n  end,\n\n  CompareRanks =&gt; meth(self:&quot;
 &amp; &quot; View, id1, id2: Int): Ok,\n    ok\n  end,\n\n  Unite =&gt; meth(self: Vie&quot;
 &amp; &quot;w, childId, parentId, pRank: Int): Ok,\n    let child: Node = self.node&quot;
 &amp; &quot;[childId];\n    let parent: Node = self.node[parentId];\n\n    (* creat&quot;
 &amp; &quot;e and animate the new edge *)\n    self.newEdge := graph_newEdge(child.&quot;
 &amp; &quot;v, parent.v);\n    child.e := self.newEdge;\n    graph_setEdgeWidth(sel&quot;
 &amp; &quot;f.newEdge, FatEdgeWidth);\n    graph_setEdgeColor(self.newEdge, HiliteE&quot;
 &amp; &quot;dgeColor);\n\n    (* update the graph structure *)\n    var rightOf: No&quot;
 &amp; &quot;de = ok;\n    if child.isRightOf(parent)\n      then rightOf := parent.&quot;
 &amp; &quot;lastChild()\n      else rightOf := ok\n    end;\n    self.root.removeCh&quot;
 &amp; &quot;ild(child);\n    parent.addChild(rightOf, child);\n\n    (* make coordi&quot;
 &amp; &quot;nate system larger if necessary *)\n    if self.root.height &gt; self.heig&quot;
 &amp; &quot;ht then\n      self.height := self.root.height;\n      self.setWorld();&quot;
 &amp; &quot;\n      graph_redisplay(self.graphvbt)\n    end;\n\n    (* animate the &quot;
 &amp; &quot;subtree motion *)\n    self.repositionAll();\n    if self.usesRanks the&quot;
 &amp; &quot;n\n      graph_removeVertex(child.rankBar);\n      graph_setVertexSize(&quot;
 &amp; &quot;pare&quot;;

CONST E72_7 =
   &quot;nt.rankBar, float(pRank) * RankW, RankH);\n      self.repositionRanks()&quot;
 &amp; &quot;\n    end;\n    zeus_animate(self.graphvbt, 0.0, 1.0);\n    ok\n  end,\n&quot;
 &amp; &quot;\n  EndUnion =&gt; meth(self): Ok,\n    if self.newEdge isnot ok then\n   &quot;
 &amp; &quot;   graph_setEdgeWidth(self.newEdge, ThinEdgeWidth);\n      graph_setEdg&quot;
 &amp; &quot;eColor(self.newEdge, NormalEdgeColor);\n    end;\n    graph_removeVerte&quot;
 &amp; &quot;xHiLi(self.unionVh1);\n    graph_removeVertexHiLi(self.unionVh2);\n    &quot;
 &amp; &quot;if not(self.bothRoots) then\n      graph_removeVertexHiLi(self.foundVh)&quot;
 &amp; &quot;;\n      graph_removeVertexHiLi(self.firstRootVh);\n    end;\n    graph&quot;
 &amp; &quot;_redisplay(self.graphvbt);\n    ok\n  end,\n};\n&quot;;

CONST E73 =
   &quot;(* Copyright (C) 1993, Digital Equipment Corporation                   &quot;
 &amp; &quot;      *)\n(* All rights reserved.                                      &quot;
 &amp; &quot;                *)\n(* See the file COPYRIGHT for a full description.  &quot;
 &amp; &quot;                          *)\n\n\nlet view = {\n  graphvbt =&gt; graph_new&quot;
 &amp; &quot;(),\n\n  myPlayer =&gt; ok,\n\n  activePlayer =&gt; ok,\n\n  makeNodeProc =&gt; &quot;
 &amp; &quot;proc (graphvbt, rawBoard)\n  { objects =&gt; \n     ( var res = [[(let v =&quot;
 &amp; &quot; graph_newVertex(graphvbt);\n                     graph_setVertexSize(v&quot;
 &amp; &quot;, 1.0, 1.0);\n                     graph_setVertexColor(v, color_rgb(1.&quot;
 &amp; &quot;0, 1.0 , 1.0));\n                     graph_setVertexBorder(v, 0.125);\n&quot;
 &amp; &quot;                     graph_setVertexBorderColor(v, color_rgb(0.0, 0.0, &quot;
 &amp; &quot;0.0));\n                     v),\n                   0.0,\n            &quot;
 &amp; &quot;       0.0\n                   ]];\n       for cellNum = 0 to 8 do\n   &quot;
 &amp; &quot;       if rawBoard[cellNum] isnot 2 then\n             let piece = grap&quot;
 &amp; &quot;h_newVertex(graphvbt);\n                graph_setVertexSize(piece, 0.25&quot;
 &amp; &quot;, 0.25);\n                if rawBoard[cellNum] is 0 then\n             &quot;
 &amp; &quot;      graph_setVertexColor(piece, color_rgb(0.0, 1.0, 0.0));\n         &quot;
 &amp; &quot;       else\n                   graph_setVertexColor(piece, color_rgb(0&quot;
 &amp; &quot;.0, 0.0, 1.0));\n                end;\n                res := res @ [[p&quot;
 &amp; &quot;iece, float((cellNum/3)-1) * 0.25, \n                                  &quot;
 &amp; &quot;   float((cellNum % 3)-1) * 0.25]]\n           end;\n        end;\n    &quot;
 &amp; &quot;    res;\n      ),\n    Move =&gt; \n      meth(self, Xbase, Ybase, animat&quot;
 &amp; &quot;e)\n         foreach object in self.objects do\n            graph_moveV&quot;
 &amp; &quot;ertex(object[0], Xbase + object[1], Ybase + object[2],\n               &quot;
 &amp; &quot; animate);\n         end;\n      end,\n\n     SetValue =&gt;\n       meth &quot;
 &amp; &quot;(self, newValue)\n         graph_setVertexBorderColor( self.objects[0][&quot;
 &amp; &quot;0],\n             color_hsv( ((float(newValue+10)) / 21.0) * 0.7, 1.0, &quot;
 &amp; &quot;1.0));\n       end,\n  }\n end,\n\n  treeDisplayParams =&gt; ok,\n\n  make&quot;
 &amp; &quot;TreeNode =&gt;\n     meth(self, dparams, initNode, NodeWidth, initX, initY&quot;
 &amp; &quot;, myKey, board)\n       let newNode =\n         {\n            key =&gt; m&quot;;

CONST E73_0 =
   &quot;yKey,\n            displayParameters =&gt; dparams,\n            node =&gt; i&quot;
 &amp; &quot;nitNode(dparams.graphvbt, board),\n            nodeWidth =&gt; NodeWidth,\n&quot;
 &amp; &quot;            width =&gt; NodeWidth,\n            leftx =&gt; initX,\n         &quot;
 &amp; &quot;   depth =&gt; 0,\n            vertex =&gt; ( let v = graph_newVertex(dparams&quot;
 &amp; &quot;.graphvbt);\n                        graph_setVertexSize(v, 0.0, 0.0 );&quot;
 &amp; &quot;\n                        v ),\n            children =&gt; [],\n          &quot;
 &amp; &quot;  childWidth =&gt; 0.0,\n            parent =&gt; ok,\n\n            xPos =&gt; &quot;
 &amp; &quot;initX + (NodeWidth / 2.0),\n            yPos =&gt; initY,\n\n            A&quot;
 &amp; &quot;ddChild =&gt;\n              meth(self, child)\n                self.child&quot;
 &amp; &quot;ren := self.children @ [child];\n                child.parent := self;\n&quot;
 &amp; &quot;                child.depth := self.depth + 1;\n(*** WAS:       child.y&quot;
 &amp; &quot;Pos := self.displayParameters.depth2Y()(self.depth+1);*)\n             &quot;
 &amp; &quot;   let d2Y = self.displayParameters.depth2Y;\n                child.yPo&quot;
 &amp; &quot;s := d2Y(self.depth+1);\n                if #(self.children) &gt; 1 then\n&quot;
 &amp; &quot;                  self.childWidth := self.childWidth +\n               &quot;
 &amp; &quot;       self.displayParameters.spacer;\n                end;\n          &quot;
 &amp; &quot;      child.SetLeftX(self.leftx + self.childWidth);\n                se&quot;
 &amp; &quot;lf.childWidth := self.childWidth + child.width;\n                let e &quot;
 &amp; &quot;= graph_newEdge(self.vertex, child.vertex);\n                graph_setE&quot;
 &amp; &quot;dgeWidth(e, self.displayParameters.edgeWidth);\n                if self&quot;
 &amp; &quot;.childWidth &gt; self.nodeWidth then\n                  self.width := self&quot;
 &amp; &quot;.childWidth;\n                  if self.parent isnot ok then\n         &quot;
 &amp; &quot;            self.parent.ChildWidthChange(self);\n                  end;&quot;
 &amp; &quot;\n                  self.xPos := self.leftx + (self.width / 2.0);\n    &quot;
 &amp; &quot;              self.MoveMe();\n                end; \n              end,&quot;
 &amp; &quot;\n\n            MoveMe =&gt;\n              meth(self)\n               var&quot;
 &amp; &quot; reSizeWorld = false;\n               if (self.xPos &gt; self.displayParam&quot;
 &amp; &quot;eters.WorldE) then\n                  self.displayParameters.WorldE := &quot;
 &amp; &quot;\n                      self.displayParameters.WorldE + \n &quot;;

CONST E73_1 =
   &quot;                     self.displayParameters.WorldStep;\n               &quot;
 &amp; &quot;   reSizeWorld := true;\n               end;\n               if (self.y&quot;
 &amp; &quot;Pos &gt; self.displayParameters.WorldS) then\n                  self.displ&quot;
 &amp; &quot;ayParameters.WorldS := \n                      self.displayParameters.W&quot;
 &amp; &quot;orldS + \n                      self.displayParameters.WorldStep;\n    &quot;
 &amp; &quot;              reSizeWorld := true;\n               end;\n              &quot;
 &amp; &quot; if reSizeWorld then\n                  graph_setWorld(self.displayPara&quot;
 &amp; &quot;meters.graphvbt, 0.0, \n                     self.displayParameters.Wor&quot;
 &amp; &quot;ldE, 0.0, \n                     self.displayParameters.WorldS);\n     &quot;
 &amp; &quot;             graph_setAspect(self.displayParameters.graphvbt,\n        &quot;
 &amp; &quot;             self.displayParameters.WorldS /\n                       se&quot;
 &amp; &quot;lf.displayParameters.WorldE);\n                  graph_redisplay(self.d&quot;
 &amp; &quot;isplayParameters.graphvbt);\n               end;\n               graph_&quot;
 &amp; &quot;moveVertex(self.vertex, self.xPos, self.yPos, true);\n               se&quot;
 &amp; &quot;lf.node.Move(self.xPos, self.yPos, true);\n              end,\n\n      &quot;
 &amp; &quot;      SetLeftX =&gt;\n              meth(self, newLeftX)\n               s&quot;
 &amp; &quot;elf.leftx := newLeftX;\n               var childX = self.leftx;\n      &quot;
 &amp; &quot;         foreach child in self.children do\n                  child.Set&quot;
 &amp; &quot;LeftX(childX);\n                  childX := childX + child.width + \n  &quot;
 &amp; &quot;                     self.displayParameters.spacer;\n               end&quot;
 &amp; &quot;;\n               self.xPos := self.leftx + (self.width / 2.0);\n      &quot;
 &amp; &quot;         self.MoveMe()\n              end,\n\n            ChildWidthCha&quot;
 &amp; &quot;nge =&gt;\n              meth(self, guiltyChild)\n                var chil&quot;
 &amp; &quot;dX = self.leftx;\n                foreach child in self.children do\n  &quot;
 &amp; &quot;                 if child.leftx isnot childX then\n                    &quot;
 &amp; &quot;  child.SetLeftX(childX);\n                   end;\n                   &quot;
 &amp; &quot;childX := childX + child.width +\n                      self.displayPar&quot;
 &amp; &quot;ameters.spacer;\n                end;\n                self.childWidth &quot;
 &amp; &quot;:= childX - (self.leftx +\n                    self.displa&quot;;

CONST E73_2 =
   &quot;yParameters.spacer);\n                if self.childWidth &gt; self.nodeWid&quot;
 &amp; &quot;th then\n                   self.width := self.childWidth;\n           &quot;
 &amp; &quot;       if self.parent isnot ok then\n                     self.parent.C&quot;
 &amp; &quot;hildWidthChange(self);\n                  end;\n                  self.&quot;
 &amp; &quot;xPos := self.leftx + (self.width / 2.0);\n                  self.MoveMe&quot;
 &amp; &quot;();\n                end;\n              end,                     \n   &quot;
 &amp; &quot;       };\n        graph_moveVertex(newNode.vertex, newNode.xPos, newNo&quot;
 &amp; &quot;de.yPos, false);\n        newNode.node.Move(newNode.xPos, newNode.yPos,&quot;
 &amp; &quot; false);\n        graph_redisplay(self.graphvbt);\n        newNode;\n  &quot;
 &amp; &quot;   end,\n\n  lastBoard =&gt; ok,\n\n  Init =&gt; \n    meth (self, player)\n &quot;
 &amp; &quot;     self.myPlayer := player;\n      self;\n    end,\n\n  Setup =&gt;\n   &quot;
 &amp; &quot; meth (self)\n      graph_setWorld(self.graphvbt, 0.0, 10.0, 0.0, 10.0)&quot;
 &amp; &quot;;\n      graph_setAspect(self.graphvbt, 1.0);\n      self.treeDisplayPa&quot;
 &amp; &quot;rams := { graphvbt =&gt; self.graphvbt,\n                                 &quot;
 &amp; &quot; depth2Y =&gt; proc (depth)\n                                             &quot;
 &amp; &quot;  float((2*depth)+1)\n                                             end,&quot;
 &amp; &quot;\n                                  edgeWidth =&gt; 0.1,\n                &quot;
 &amp; &quot;                  spacer =&gt; 0.25,\n                                  Wo&quot;
 &amp; &quot;rldE =&gt; 10.0,\n                                  WorldS =&gt; 10.0,\n     &quot;
 &amp; &quot;                             WorldStep =&gt; 3.0};\n      self.lastBoard :&quot;
 &amp; &quot;= ok;\n    end,\n\n  EvaluateNode =&gt;\n    meth (self, boardData)\n     &quot;
 &amp; &quot; if self.activePlayer is self.myPlayer then\n       var newNode = ok;\n&quot;
 &amp; &quot;       if self.lastBoard is ok then\n          newNode :=  self.makeTre&quot;
 &amp; &quot;eNode(self.treeDisplayParams, \n           self.makeNodeProc, 1.0, 0.0,&quot;
 &amp; &quot; 1.0, boardData[0], boardData[1]);\n       else\n          var parent =&quot;
 &amp; &quot; self.lastBoard;\n          newNode :=  self.makeTreeNode(self.treeDisp&quot;
 &amp; &quot;layParams, \n            self.makeNodeProc, 1.0, self.lastBoard.xPos - &quot;
 &amp; &quot;0.5, \n            self.lastBoard.yPos, boardData[0], boardData[1]);\n &quot;
 &amp; &quot;         self.lastBoard.AddChild(newNode);\n       end;\n       sel&quot;;

CONST E73_3 =
   &quot;f.lastBoard := newNode;\n       zeus_animate(self.graphvbt, 0.0, 1.0);\n&quot;
 &amp; &quot;      end;\n    end,\n\n  PlayerThinking =&gt;\n    meth (self, player, bo&quot;
 &amp; &quot;ardData)\n       self.activePlayer := player;\n       if self.activePla&quot;
 &amp; &quot;yer is self.myPlayer then\n         graph_clear(self.graphvbt);\n      &quot;
 &amp; &quot;   self.treeDisplayParams.WorldE := 10.0;\n         self.treeDisplayPar&quot;
 &amp; &quot;ams.WorldS := 10.0;\n         graph_setWorld(self.graphvbt, 0.0, 10.0, &quot;
 &amp; &quot;0.0, 10.0);\n         graph_setAspect(self.graphvbt, 1.0);\n         se&quot;
 &amp; &quot;lf.lastBoard := ok;\n       end;\n    end,\n\n   FinishedEvalNode =&gt;\n &quot;
 &amp; &quot;    meth (self, boardkey)\n       if self.activePlayer is self.myPlayer&quot;
 &amp; &quot; then\n         self.lastBoard := self.lastBoard.parent;\n       end;\n&quot;
 &amp; &quot;     end,\n\n   BoardValueUpdated =&gt;\n     meth (self, boardkey, newVal&quot;
 &amp; &quot;ue)\n       if self.activePlayer is self.myPlayer then\n         self.l&quot;
 &amp; &quot;astBoard.node.SetValue(newValue);\n         graph_redisplay(self.graphv&quot;
 &amp; &quot;bt);\n       end;\n     end,\n\n  }.Init(1);\n&quot;;

CONST E74 =
   &quot;; Copyright (C) 1992, Digital Equipment Corporation\n; All rights reser&quot;
 &amp; &quot;ved.\n; See the file COPYRIGHT for a full description.\n\n\n(Scale\n  (&quot;
 &amp; &quot;HScale 1)\n  (VScale 1)\n  (Rim\n    (Pen 10)\n    (VBox\n      (Radio\n&quot;
 &amp; &quot;        %data\n        (VBox\n          Fill\n          (Border\n      &quot;
 &amp; &quot;      (Pen 1)\n            (VBox\n              (Choice %random (Text \&quot;&quot;
 &amp; &quot;random\&quot;))\n              (Glue 2)\n              (Text \&quot;sample size\&quot;&quot;
 &amp; &quot;)\n              (Glue 2)\n              (HBox (Glue 2) (Numeric %N (Mi&quot;
 &amp; &quot;n 4) (Max 80) =16) (Glue 2))\n              (Glue 2)))\n          Fill\n&quot;
 &amp; &quot;          (Glue 5)\n          (Border\n            (Pen 1)\n           &quot;
 &amp; &quot; (VBox\n              (Choice %selected =TRUE (Text \&quot;selected\&quot;))\n   &quot;
 &amp; &quot;           (Glue 5)\n              (Radio\n                %selectedsiz&quot;
 &amp; &quot;e\n                (HBox\n                  (Glue 7)\n                 &quot;
 &amp; &quot; (Choice %selectedsmall =TRUE (Text \&quot;small\&quot;))\n                  (Cho&quot;
 &amp; &quot;ice %selectedlarge (Text \&quot;large\&quot;))))\n              (Glue 2)))\n     &quot;
 &amp; &quot;     Fill)))))\n&quot;;

CONST E75 =
   &quot;Source 100 50\nV11 100 150\nV12 100 250\nV13 100 350\nV14 100 450\nV15 &quot;
 &amp; &quot;100 550\nV16 100 650\nV17 100 750\nV18 100 850\nV19 100 950\nV20 200 50&quot;
 &amp; &quot;\nV21 200 150\nV22 200 250\nV23 200 350\nV24 200 450\nV25 200 550\nV26 &quot;
 &amp; &quot;200 650\nV27 200 750\nV28 200 850\nV29 200 950\nV30 300 50\nV31 300 150&quot;
 &amp; &quot;\nV32 300 250\nV33 300 350\nV34 300 450\nV35 300 550\nV36 300 650\nV37 &quot;
 &amp; &quot;300 750\nV38 300 850\nV39 300 950\nV40 400 50\nV41 400 150\nV42 400 250&quot;
 &amp; &quot;\nV43 400 350\nV44 400 450\nV45 400 550\nV46 400 650\nV47 400 750\nV48 &quot;
 &amp; &quot;400 850\nV49 400 950\nV50 500 50\nV51 500 150\nV52 500 250\nV53 500 350&quot;
 &amp; &quot;\nV54 500 450\nV55 500 550\nV56 500 650\nV57 500 750\nV58 500 850\nV59 &quot;
 &amp; &quot;500 950\nV60 600 50\nV61 600 150\nV62 600 250\nV63 600 350\nV64 600 450&quot;
 &amp; &quot;\nV65 600 550\nV66 600 650\nV67 600 750\nV68 600 850\nV69 600 950\nV70 &quot;
 &amp; &quot;700 50\nV71 700 150\nV72 700 250\nV73 700 350\nV74 700 450\nV75 700 550&quot;
 &amp; &quot;\nV76 700 650\nV77 700 750\nV78 700 850\nV79 700 950\nV80 800 50\nV81 8&quot;
 &amp; &quot;00 150\nV82 800 250\nV83 800 350\nV84 800 450\nV85 800 550\nV86 800 650&quot;
 &amp; &quot;\nV87 800 750\nV88 800 850\nV89 800 950\nV90 900 50\nV91 900 150\nV92 9&quot;
 &amp; &quot;00 250\nV93 900 350\nV94 900 450\nV95 900 550\nV96 900 650\nV97 900 750&quot;
 &amp; &quot;\nV98 900 850\nSink 900 950\n.\n&quot;;

CONST E76 =
   &quot;(* Copyright (C) 1994, Digital Equipment Corporation           *)\n(* A&quot;
 &amp; &quot;ll rights reserved.                                        *)\n(* See t&quot;
 &amp; &quot;he file COPYRIGHT for a full description.              *)\n\nMODULE Hul&quot;
 &amp; &quot;lAlgs;\n\nTYPE Point = RECORD x, y: INTEGER END;\n\nVAR p: REF ARRAY OF&quot;
 &amp; &quot; Point;\n    N: INTEGER;\n(* The input points are p[1] through p[N], wh&quot;
 &amp; &quot;ere N &gt;= 1.  \n   We are allowed to use p[0] to hold a sentinel.\n\n   &quot;
 &amp; &quot;Our task is to compute M, the number of vertices of the convex \n   hul&quot;
 &amp; &quot;l, and to permute the array p[1..N] to make p[1..M] be the hull \n   ve&quot;
 &amp; &quot;rtices in counterclockwise order, starting somewhere. \n\n   The input &quot;
 &amp; &quot;may include pairs of coincident points and triples of \n   collinear po&quot;
 &amp; &quot;ints.  Of two points that coincide, at most one is \n   a hull vertex. &quot;
 &amp; &quot; Of three distinct, collinear points, the middle \n   one is never a hu&quot;
 &amp; &quot;ll vertex. \n   \n   If the input points all coincide, M is 1.  If the &quot;
 &amp; &quot;input points \n   are all collinear but do not all coincide, M is 2. *)&quot;
 &amp; &quot;   \n\nTYPE AB = {Above, Below,  Left, Right,  On};\n\nPROCEDURE TestAB&quot;
 &amp; &quot;(old, new: Point): AB =\n(* Classify the point \&quot;new\&quot; with respect to &quot;
 &amp; &quot;a horizontal line\n   through the point \&quot;old\&quot;. *)\n  BEGIN\n    IF   &quot;
 &amp; &quot; new.y &lt; old.y THEN RETURN AB.Below\n    ELSIF new.y &gt; old.y THEN RETUR&quot;
 &amp; &quot;N AB.Above\n    ELSIF new.x &lt; old.x THEN RETURN AB.Left\n    ELSIF new.&quot;
 &amp; &quot;x &gt; old.x THEN RETURN AB.Right\n    ELSE RETURN AB.On\n    END;\n  END &quot;
 &amp; &quot;TestAB;\n\n                                 (* The three points:       &quot;
 &amp; &quot;    *)\nTYPE LR = {Left, Right,          (*  form a triangle.          &quot;
 &amp; &quot; *)\n           Back, Shaft, Front,   (*  collinear, but distinct.   *)&quot;
 &amp; &quot; \n           Tail, Head, DegenOff, (*  2 coincide, but not all 3. *)\n&quot;
 &amp; &quot;           DegenOn};             (*  all 3 points coincide.     *)\n\nP&quot;
 &amp; &quot;ROCEDURE TestLR(tail, head, new: Point): LR =\n(* Compute the relative &quot;
 &amp; &quot;orientation of a triple of points, from among \n   the nine possibiliti&quot;
 &amp; &quot;es.  In the seven cases where \&quot;tail\&quot; and \&quot;head\&quot; \n   do not coincid&quot;
 &amp; &quot;e, we classify \&quot;new\&quot; with respect to a vector from \n   \&quot;tail\&quot; to \&quot;&quot;
 &amp; &quot;he&quot;;

CONST E76_0 =
   &quot;ad\&quot;.  In the remaining two cases, we merely check \n   whether or not &quot;
 &amp; &quot;\&quot;new\&quot; coincides with the common value of \&quot;head\&quot; \n   and \&quot;tail\&quot;. &quot;
 &amp; &quot;*) \n  VAR area: INTEGER :=   (head.x - tail.x) * (new.y - tail.y)\n   &quot;
 &amp; &quot;                    - (head.y - tail.y) * (new.x - tail.x);\n      (* T&quot;
 &amp; &quot;he signed area of the parallelogram spanned by the vectors \n         f&quot;
 &amp; &quot;rom \&quot;tail\&quot; to \&quot;head\&quot; and from \&quot;tail\&quot; to \&quot;new\&quot;;  you can \n     &quot;
 &amp; &quot;    think of it either as a 3-by-3 determinant or as the norm \n       &quot;
 &amp; &quot;  of a vector cross product. *) \n  BEGIN\n    IF    area &gt; 0 THEN RETU&quot;
 &amp; &quot;RN LR.Left\n    ELSIF area &lt; 0 THEN RETURN LR.Right\n    ELSE\n      VA&quot;
 &amp; &quot;R (* The following are Manhattan distances. *)\n        distTailHead: I&quot;
 &amp; &quot;NTEGER:=ABS(head.x - tail.x) + ABS(head.y - tail.y);\n        distTailN&quot;
 &amp; &quot;ew: INTEGER := ABS(new.x - tail.x) + ABS(new.y - tail.y);\n        dist&quot;
 &amp; &quot;HeadNew: INTEGER := ABS(new.x - head.x) + ABS(new.y - head.y);\n       &quot;
 &amp; &quot; max: INTEGER := MAX(MAX(distTailHead, distTailNew), distHeadNew);\n   &quot;
 &amp; &quot;   BEGIN\n        IF    max = 0            THEN RETURN LR.DegenOn\n    &quot;
 &amp; &quot;    ELSIF distTailHead = 0   THEN RETURN LR.DegenOff\n        ELSIF dis&quot;
 &amp; &quot;tTailNew = 0    THEN RETURN LR.Tail\n        ELSIF distHeadNew = 0    T&quot;
 &amp; &quot;HEN RETURN LR.Head\n        ELSIF max = distTailHead THEN RETURN LR.Sha&quot;
 &amp; &quot;ft\n        ELSIF max = distTailNew  THEN RETURN LR.Front\n        ELSI&quot;
 &amp; &quot;F max = distHeadNew  THEN RETURN LR.Back\n        END;\n      END;\n   &quot;
 &amp; &quot; END;\n  END TestLR;\n\nPROCEDURE Swap(VAR p, q: Point) =\n  VAR t: Poi&quot;
 &amp; &quot;nt; BEGIN t := p; p := q; q := t END Swap;\n  \n@PackageWrap\nPROC Wrap&quot;
 &amp; &quot;(p: REF ARRAY[1..N] OF Point): INT@ =\nVAR grn: INT; BEGIN\n  @1 grn :=&quot;
 &amp; &quot; 1;@\n  @2 FOR blu := 2 TO N DO@\n    @3 CASE TestAB(p[grn], p[blu]) OF&quot;
 &amp; &quot;@\n    | @4 AB.Below@, @5 AB.Right@ =&gt; @6 grn := blu@\n    | @7 AB.Abov&quot;
 &amp; &quot;e@, @8 AB.Left@, @9 AB.On@ =&gt; \n    END;\n  @99 END; (* p[grn] is right&quot;
 &amp; &quot;most of lowest. *)@\n  @10 FOR purp := 1 TO N DO@\n    @11 Swap(p[grn],&quot;
 &amp; &quot; p[purp]);@\n    @98 (* p[1..purp] is prefix of the hull. *)@\n    @12 &quot;
 &amp; &quot;grn := 1;@\n    @13 FOR blu := purp + 1 TO N DO@\n      @14 CASE TestLR&quot;
 &amp; &quot;(p[pu&quot;;

CONST E76_1 =
   &quot;rp], p[grn], p[blu]) OF@\n      | @15 Right@, @16 Front@, @17 DegenOff@&quot;
 &amp; &quot; =&gt; @18 grn := blu@\n      | @19 Left@, @20 Tail@, @21 Shaft@, @22 Head&quot;
 &amp; &quot;@, @23 DegenOn@ =&gt; \n      END;\n    @97 END; (* p[grn] is furthest clo&quot;
 &amp; &quot;ckwise. *)@\n    @24 IF grn = 1@ THEN @25 RETURN purp@ END;\n  END;\n  &quot;
 &amp; &quot;@26 RETURN 0;@\n@27 END Wrap;@\n@PackageWrap\n\nPROCEDURE LessEq(s, t: &quot;
 &amp; &quot;Point): BOOLEAN =\n(* Using polar coordinates centered at p[0], the poi&quot;
 &amp; &quot;nt \&quot;s\&quot; is less \n   than or equal to the point \&quot;t\&quot; when either \n  &quot;
 &amp; &quot;     theta(s) &lt; theta(t)  or \n       theta(s) = theta(t)  and  r(s) &lt;=&quot;
 &amp; &quot; r(t).\n   By fiat, the point p[0], which has r(p[0]) = 0 and theta(p[0&quot;
 &amp; &quot;]) \n   undefined, is less than any other point. \n\n   Every point  q &quot;
 &amp; &quot; passed to this procedure with  theta(q)  defined,\n   that is, with  r&quot;
 &amp; &quot;(q) &gt; 0, will satisfy\n       0 &lt;= theta(q) &lt; 180,\n   and the followin&quot;
 &amp; &quot;g implementation depends on that.  *)\n  BEGIN\n    CASE TestLR(p[0], s&quot;
 &amp; &quot;, t) OF\n    | LR.Left, LR.Front, LR.Head  =&gt; RETURN TRUE\n    | LR.Rig&quot;
 &amp; &quot;ht, LR.Shaft, LR.Tail =&gt; RETURN FALSE\n    | LR.DegenOn, LR.DegenOff   &quot;
 &amp; &quot;  =&gt; RETURN TRUE\n    END; (* LR.Back can\'t happen. *)\n  END LessEq;\n&quot;
 &amp; &quot;\n@GrahamScan\nPROCEDURE GrahamScan(): INTEGER@ =\n  VAR min, M: INTEGE&quot;
 &amp; &quot;R;\n  BEGIN\n    @1 min := 1;@\n    @2 FOR i := 2 TO N DO@\n      @3 CA&quot;
 &amp; &quot;SE TestAB(p[min], p[i]) OF@\n      | @4 AB.Below@, @5 AB.Left@         &quot;
 &amp; &quot;=&gt; @6 min := i@\n      | @7 AB.Above@, @8 AB.Right@, @9 AB.On@ =&gt; \n   &quot;
 &amp; &quot;   END;\n    END;\n    @10 p[0] := p[min];@ (* p[0] is a copy of the le&quot;
 &amp; &quot;ftmost of the lowest. *)\n    @11 Sort();@\n    (* The segment p[1..N] &quot;
 &amp; &quot;consists of one or more copies of p[0] \n       followed by all points &quot;
 &amp; &quot;distinct from p[0], sorted by theta \n       from p[0] and, for equal t&quot;
 &amp; &quot;heta, sorted by r.  *) \n    @12 M := 1;@\n    @13 FOR i := 2 TO N DO@\n&quot;
 &amp; &quot;      @14 LOOP@ \n        @15 CASE TestLR(p[M-1], p[M], p[i]) OF@\n    &quot;
 &amp; &quot;    | @16 LR.Right@                      =&gt; @17 DEC(M);@\n        | @18&quot;
 &amp; &quot; LR.Left@, @19 LR.DegenOff@          =&gt; @20 EXIT;@\n        | @21 LR.Fr&quot;
 &amp; &quot;ont@, @22 LR.Head@, @23 LR.DegenOn@ =&gt; @24 DEC(M);@  @25 EXIT;@\n    &quot;;

CONST E76_2 =
   &quot;    END; (* LR.Back, LR.Tail, and LR.Shaft can\'t happen; LR.DegenOn *)&quot;
 &amp; &quot;\n      END;   (* and LR.DegenOff happen only at the start, when M = 1.&quot;
 &amp; &quot;   *)\n      @26 INC(M);@  @27 Swap(p[i], p[M]);@\n      (* p[1..M] is &quot;
 &amp; &quot;the convex hull of p[1..i]. *)\n    END;\n    @28 RETURN M;@\n  END Gra&quot;
 &amp; &quot;hamScan;\n@GrahamScan\n\nPROCEDURE Sort() =\n(* Sort the array p[1..N] &quot;
 &amp; &quot;into \&quot;LessEq\&quot; order.  This implementation\n   uses ShellSort. *)\n  V&quot;
 &amp; &quot;AR h: INTEGER := 1;  j: INTEGER;  v: Point;\n  BEGIN\n    REPEAT h := 3&quot;
 &amp; &quot; * h + 1 UNTIL h &gt; N;\n    REPEAT\n      h := h DIV 3;\n      FOR i := &quot;
 &amp; &quot;h + 1 TO N DO\n        v := p[i];  j := i;\n        WHILE j - h &gt;= 1 AN&quot;
 &amp; &quot;D NOT LessEq(p[j - h], v) DO\n          p[j] := p[j - h];  DEC(j, h);\n&quot;
 &amp; &quot;        END;\n        p[j] := v;\n      END;\n    UNTIL h = 1;\n  END S&quot;
 &amp; &quot;ort;\n\nBEGIN\nEND HullAlgs.\n&quot;;

CONST E77 =
   &quot;(* Copyright (C) 1994, Digital Equipment Corporation *)\n(* All rights &quot;
 &amp; &quot;reserved.                              *)\n(* See the file COPYRIGHT fo&quot;
 &amp; &quot;r a full description.    *)\n\nlet view = { \n\tgraphvbt =&gt; graph_new()&quot;
 &amp; &quot;,\n\tfont =&gt; ok,\n\tbinWidth =&gt; ok,\n        nBins =&gt; ok,\n\tcurrWt =&gt; &quot;
 &amp; &quot;ok,\n\tcurrVertex =&gt; ok,\n\n \tSetup =&gt; meth (self, nBins, nWts)\n\t   &quot;
 &amp; &quot;graph_setWorld(self.graphvbt, \n\t      ~2.0, float(nBins), 1.0, 0.0);\n&quot;
 &amp; &quot;\t   graph_setMargin(self.graphvbt, 2.0);\n\t   if (self.font is ok) th&quot;
 &amp; &quot;en\n\t     self.font := graph_newFont (self.graphvbt, \n\t        \&quot;Hel&quot;
 &amp; &quot;vetica\&quot;, 0.5, \&quot;Roman\&quot;, \&quot;Bold\&quot;, \&quot;*\&quot;) end;\n\t   end,\n\n\tNewWeig&quot;
 &amp; &quot;ht =&gt; meth (self, id, wt) \n\t   let v = graph_newVertex (self.graphvbt&quot;
 &amp; &quot;);\n\t   graph_setVertexSize(v, 1.0, wt);\n\t   graph_moveVertex(v, ~1.&quot;
 &amp; &quot;0, 0.5, false);\n\t   graph_setVertexFont(v, self.font);\n\t   graph_se&quot;
 &amp; &quot;tVertexBorder(v, 0.01);\n\t   graph_setVertexLabel(v, fmt_int(id));\n\t&quot;
 &amp; &quot;   graph_setVertexColor(v, color_rgb(0.5, 1.0, 0.5));\n\t   graph_setVe&quot;
 &amp; &quot;rtexLabelColor(v, color_rgb(0.0, 0.0, 0.0));\n\t   graph_redisplay(self&quot;
 &amp; &quot;.graphvbt);\n  \t   self.currVertex := v;\n\t   self.currWt := wt;\n\t &quot;
 &amp; &quot;  end,\n\n\tProbe =&gt; meth (self, id, wt) \n\t   ok;\n\t   end,\n\n\tPac&quot;
 &amp; &quot;k =&gt; meth (self, bin, total) \n\t   let xpos = 0.5 + float(bin);\n\t   &quot;
 &amp; &quot;let ypos = total - (float(self.currWt) / 2.0);\n\t   graph_moveVertex(s&quot;
 &amp; &quot;elf.currVertex, xpos, ypos, true);\n\t   graph_animate(self.graphvbt, 0&quot;
 &amp; &quot;.0, 1.0);\n\t   end,\n};\n&quot;;

CONST E78 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:37:06 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Binp&quot;
 &amp; &quot;ack.evt.\n;************************************************************&quot;
 &amp; &quot;********\n\n(VBox\n  (Rim\n    (Pen 2)\n    (HBox\n      (VBox (Glue 4)&quot;
 &amp; &quot; (Shape (Height + Inf) (Button %clear \&quot;CLEAR\&quot;)) (Glue 4))\n      (Glu&quot;
 &amp; &quot;e 4)\n      (VBox\n        (Boolean =TRUE %alg (Text LeftAlign \&quot;Algori&quot;
 &amp; &quot;thm events\&quot;))\n        (Boolean =FALSE %zeus (Text LeftAlign \&quot;Zeus ev&quot;
 &amp; &quot;ents\&quot;))\n        (Boolean =TRUE %args (Text LeftAlign \&quot;Display args t&quot;
 &amp; &quot;o events\&quot;)))\n      Fill))\n  (Bar 1)\n  (Shape (ShadowSize 0) (Height&quot;
 &amp; &quot; 200 + INF) (TextEdit ReadOnly %transcript)))\n&quot;;

CONST E79 =
   &quot;; Copyright (C) 1992, Digital Equipment Corporation\n; All rights reser&quot;
 &amp; &quot;ved.\n; See the file COPYRIGHT for a full description.\n\n(Scale\n  (HS&quot;
 &amp; &quot;cale 1)\n  (VScale 1)\n  (BgColor \&quot;White\&quot;)\n  (Rim\n    (Pen 10)\n   &quot;
 &amp; &quot; (HBox      \n      (VBox\n        (Text (Color \&quot;Red\&quot;) RightAlign \&quot;y&quot;
 &amp; &quot;: \&quot;)\n        (Text (Color \&quot;Green\&quot;) RightAlign \&quot;x: \&quot;)\n        (Te&quot;
 &amp; &quot;xt (Color \&quot;Blue\&quot;) RightAlign \&quot;j: \&quot;))\n      (VBox\n        (Text Ri&quot;
 &amp; &quot;ghtAlign %y \&quot;\&quot;)\n        (Text RightAlign %x \&quot;\&quot;)\n        (Text Rig&quot;
 &amp; &quot;htAlign %j \&quot;\&quot;)))))\n&quot;;

CONST E80 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:29:09 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Bres&quot;
 &amp; &quot;enham.evt.\n;**********************************************************&quot;
 &amp; &quot;**********\n\n(VBox\n  (Border (Pen 1)\n    (Shape\n      (Height 75 - &quot;
 &amp; &quot;25 + Inf)\n      (Viewport\n        (HBox\n          (Glue 4 + Inf)\n  &quot;
 &amp; &quot;        (VBox\n            (Glue 6)\n            (Shape (Height 16 + 0)&quot;
 &amp; &quot;\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n          &quot;
 &amp; &quot;                      \&quot;Code View events:   Stop? \&quot;) \n               &quot;
 &amp; &quot;     (Boolean %stopatCodeEvents =TRUE \&quot;\&quot;)\n                    (Glue &quot;
 &amp; &quot;10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n&quot;
 &amp; &quot;                    (Shape (Width 80) (Numeric %waitatCodeEvents =1 \n &quot;
 &amp; &quot;                                              (Min 0) (Max 100)))))\n  &quot;
 &amp; &quot;          (Glue 6)\n            (Shape (Height 16 + 0)\n              (&quot;
 &amp; &quot;HBox Fill (Shape (Width + 0) (Height + 0) \n                           &quot;
 &amp; &quot;     \&quot;Setup:   Stop? \&quot;) \n                    (Boolean %stopAtSetup =&quot;
 &amp; &quot;TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (&quot;
 &amp; &quot;Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Widt&quot;
 &amp; &quot;h 80) (Numeric %waitAtSetup =1 \n                                      &quot;
 &amp; &quot;         (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shap&quot;
 &amp; &quot;e (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height &quot;
 &amp; &quot;+ 0) \n                                \&quot;NewLine:   Stop? \&quot;) \n       &quot;
 &amp; &quot;             (Boolean %stopAtNewLine =TRUE \&quot;\&quot;)\n                    (&quot;
 &amp; &quot;Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight:&quot;
 &amp; &quot; \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtNewLine =1 &quot;
 &amp; &quot;\n                                               (Min 0) (Max 100)))))\n&quot;
 &amp; &quot;            (Glue 6)\n            (Shape (Height 16 + 0)\n             &quot;
 &amp; &quot; (HBo&quot;;

CONST E80_0 =
   &quot;x Fill (Shape (Width + 0) (Height + 0) \n                              &quot;
 &amp; &quot;  \&quot;ErrorInit:   Stop? \&quot;) \n                    (Boolean %stopAtErrorI&quot;
 &amp; &quot;nit =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Sh&quot;
 &amp; &quot;ape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape &quot;
 &amp; &quot;(Width 80) (Numeric %waitAtErrorInit =1 \n                             &quot;
 &amp; &quot;                  (Min 0) (Max 100)))))\n            (Glue 6)\n        &quot;
 &amp; &quot;    (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0)&quot;
 &amp; &quot; (Height + 0) \n                                \&quot;ShowPixel:   Stop? \&quot;&quot;
 &amp; &quot;) \n                    (Boolean %stopAtShowPixel =TRUE \&quot;\&quot;)\n        &quot;
 &amp; &quot;            (Glue 10)\n                    (Shape (Width + 0) (Height +&quot;
 &amp; &quot; 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric %wait&quot;
 &amp; &quot;AtShowPixel =1 \n                                               (Min 0)&quot;
 &amp; &quot; (Max 100)))))\n            (Glue 6)\n            (Shape (Height 16 + 0&quot;
 &amp; &quot;)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n         &quot;
 &amp; &quot;                       \&quot;FindError:   Stop? \&quot;) \n                    (&quot;
 &amp; &quot;Boolean %stopAtFindError =TRUE \&quot;\&quot;)\n                    (Glue 10)\n  &quot;
 &amp; &quot;                  (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n      &quot;
 &amp; &quot;              (Shape (Width 80) (Numeric %waitAtFindError =1 \n        &quot;
 &amp; &quot;                                       (Min 0) (Max 100)))))\n         &quot;
 &amp; &quot;   (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox Fi&quot;
 &amp; &quot;ll (Shape (Width + 0) (Height + 0) \n                                \&quot;&quot;
 &amp; &quot;ChangeError:   Stop? \&quot;) \n                    (Boolean %stopAtChangeEr&quot;
 &amp; &quot;ror =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Sh&quot;
 &amp; &quot;ape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape &quot;
 &amp; &quot;(Width 80) (Numeric %waitAtChangeError =1 \n                           &quot;
 &amp; &quot;                    (Min 0) (Max 100)))))\n            (Glue 6)\n      &quot;
 &amp; &quot;      (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width + &quot;
 &amp; &quot;0) (Height + 0) \n                                \&quot;CompareError:   Sto&quot;
 &amp; &quot;p? \&quot;) \n                    (Boolean %stopAtCompareError =TRUE \&quot;\&quot;)\n&quot;
 &amp; &quot;        &quot;;

CONST E80_1 =
   &quot;            (Glue 10)\n                    (Shape (Width + 0) (Height +&quot;
 &amp; &quot; 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric %wait&quot;
 &amp; &quot;AtCompareError =1 \n                                               (Min&quot;
 &amp; &quot; 0) (Max 100)))))\n            (Glue 6)\n            (Shape (Height 16 &quot;
 &amp; &quot;+ 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n      &quot;
 &amp; &quot;                          \&quot;ShowNextPixel:   Stop? \&quot;) \n              &quot;
 &amp; &quot;      (Boolean %stopAtShowNextPixel =TRUE \&quot;\&quot;)\n                    (G&quot;
 &amp; &quot;lue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: &quot;
 &amp; &quot;\&quot;)\n                    (Shape (Width 80) (Numeric %waitAtShowNextPixe&quot;
 &amp; &quot;l =1 \n                                               (Min 0) (Max 100)&quot;
 &amp; &quot;))))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n       &quot;
 &amp; &quot;       (HBox Fill (Shape (Width + 0) (Height + 0) \n                   &quot;
 &amp; &quot;             \&quot;Move:   Stop? \&quot;) \n                    (Boolean %stopAt&quot;
 &amp; &quot;Move =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (S&quot;
 &amp; &quot;hape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape&quot;
 &amp; &quot; (Width 80) (Numeric %waitAtMove =1 \n                                 &quot;
 &amp; &quot;              (Min 0) (Max 100)))))\n            (Glue 6)\n          )\n&quot;
 &amp; &quot;          (Glue 4)\n          (VBox\n            (Glue 5)\n            &quot;
 &amp; &quot;(Shape (Width + 0) (Height 16 + 0) \&quot;Cts:\&quot;)\n            (Button %even&quot;
 &amp; &quot;tCounts\n              (VBox\n                (Glue 6)\n               &quot;
 &amp; &quot; (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n                      &quot;
 &amp; &quot;            (Text %ctOfSetup \&quot;0\&quot;)))\n                (Glue 6)\n      &quot;
 &amp; &quot;          (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n             &quot;
 &amp; &quot;                     (Text %ctOfNewLine \&quot;0\&quot;)))\n                (Glue&quot;
 &amp; &quot; 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n  &quot;
 &amp; &quot;                                (Text %ctOfErrorInit \&quot;0\&quot;)))\n        &quot;
 &amp; &quot;        (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height&quot;
 &amp; &quot; 16 + 0) \n                                  (Text %ctOfShowPixel \&quot;0\&quot;&quot;
 &amp; &quot;)))\n                (Glue 6)\n                (HBox Fill (Shape (Width&quot;
 &amp; &quot; + 0) (&quot;;

CONST E80_2 =
   &quot;Height 16 + 0) \n                                  (Text %ctOfFindError&quot;
 &amp; &quot; \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Shape &quot;
 &amp; &quot;(Width + 0) (Height 16 + 0) \n                                  (Text %&quot;
 &amp; &quot;ctOfChangeError \&quot;0\&quot;)))\n                (Glue 6)\n                (HB&quot;
 &amp; &quot;ox Fill (Shape (Width + 0) (Height 16 + 0) \n                          &quot;
 &amp; &quot;        (Text %ctOfCompareError \&quot;0\&quot;)))\n                (Glue 6)\n   &quot;
 &amp; &quot;             (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n          &quot;
 &amp; &quot;                        (Text %ctOfShowNextPixel \&quot;0\&quot;)))\n            &quot;
 &amp; &quot;    (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 &quot;
 &amp; &quot;+ 0) \n                                  (Text %ctOfMove \&quot;0\&quot;)))\n    &quot;
 &amp; &quot;            (Glue 3))))\n          Fill\n          (Glue 4 + Inf)\n    &quot;
 &amp; &quot;    )\n      )\n    )\n  )\n)\n&quot;;

CONST E81 =
   &quot;; Copyright (C) 1992, Digital Equipment Corporation\n; All rights reser&quot;
 &amp; &quot;ved.\n; See the file COPYRIGHT for a full description.\n\n(Scale\n  (HS&quot;
 &amp; &quot;cale 1)\n  (VScale 1)\n  (Rim\n    (Pen 10)\n    (Shape\n      (Width 4&quot;
 &amp; &quot;50 + Infinity)\n      (VBox\n        (HBox\n          (HBox (Text \&quot;i =&quot;
 &amp; &quot; \&quot;) (TextEdit ReadOnly (TurnMargin 0) %i))\n          (HBox (Text \&quot;j &quot;
 &amp; &quot;= \&quot;) (TextEdit ReadOnly (TurnMargin 0) %j)))\n        (HBox\n         &quot;
 &amp; &quot; (HBox (Text \&quot;v = \&quot;) (TextEdit ReadOnly (TurnMargin 0) %v))\n        &quot;
 &amp; &quot;  (HBox (Text \&quot;N = \&quot;) (TextEdit ReadOnly (TurnMargin 0) %N)))\n      &quot;
 &amp; &quot;  (HBox (Text \&quot;a = \&quot;) (TextEdit ReadOnly (TurnMargin 0) %a))))))\n&quot;;

CONST E82 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:29:09 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Maxf&quot;
 &amp; &quot;low.evt.\n;************************************************************&quot;
 &amp; &quot;********\n\n(VBox\n  (Border (Pen 1)\n    (Shape\n      (Height 75 - 25&quot;
 &amp; &quot; + Inf)\n      (Viewport\n        (HBox\n          (Glue 4 + Inf)\n    &quot;
 &amp; &quot;      (VBox\n            (Glue 6)\n            (Shape (Height 16 + 0)\n&quot;
 &amp; &quot;              (HBox Fill (Shape (Width + 0) (Height + 0) \n            &quot;
 &amp; &quot;                    \&quot;Code View events:   Stop? \&quot;) \n                 &quot;
 &amp; &quot;   (Boolean %stopatCodeEvents =TRUE \&quot;\&quot;)\n                    (Glue 10&quot;
 &amp; &quot;)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n &quot;
 &amp; &quot;                   (Shape (Width 80) (Numeric %waitatCodeEvents =1 \n  &quot;
 &amp; &quot;                                             (Min 0) (Max 100)))))\n   &quot;
 &amp; &quot;         (Glue 6)\n            (Shape (Height 16 + 0)\n              (H&quot;
 &amp; &quot;Box Fill (Shape (Width + 0) (Height + 0) \n                            &quot;
 &amp; &quot;    \&quot;Setup:   Stop? \&quot;) \n                    (Boolean %stopAtSetup =T&quot;
 &amp; &quot;RUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (W&quot;
 &amp; &quot;idth + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width&quot;
 &amp; &quot; 80) (Numeric %waitAtSetup =1 \n                                       &quot;
 &amp; &quot;        (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape&quot;
 &amp; &quot; (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height +&quot;
 &amp; &quot; 0) \n                                \&quot;HighlightPath:   Stop? \&quot;) \n  &quot;
 &amp; &quot;                  (Boolean %stopAtHighlightPath =TRUE \&quot;\&quot;)\n          &quot;
 &amp; &quot;          (Glue 10)\n                    (Shape (Width + 0) (Height + 0&quot;
 &amp; &quot;) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAt&quot;
 &amp; &quot;HighlightPath =1 \n                                               (Min &quot;
 &amp; &quot;0) (Max 100)))))\n            (Glue 6)\n            (Shape (Height 16 +&quot;
 &amp; &quot; 0)\n  &quot;;

CONST E82_0 =
   &quot;            (HBox Fill (Shape (Width + 0) (Height + 0) \n              &quot;
 &amp; &quot;                  \&quot;IncFlow:   Stop? \&quot;) \n                    (Boolean&quot;
 &amp; &quot; %stopAtIncFlow =TRUE \&quot;\&quot;)\n                    (Glue 10)\n           &quot;
 &amp; &quot;         (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n               &quot;
 &amp; &quot;     (Shape (Width 80) (Numeric %waitAtIncFlow =1 \n                   &quot;
 &amp; &quot;                            (Min 0) (Max 100)))))\n            (Glue 6)&quot;
 &amp; &quot;\n            (Shape (Height 16 + 0)\n              (HBox Fill (Shape (&quot;
 &amp; &quot;Width + 0) (Height + 0) \n                                \&quot;DecFlow:   &quot;
 &amp; &quot;Stop? \&quot;) \n                    (Boolean %stopAtDecFlow =TRUE \&quot;\&quot;)\n  &quot;
 &amp; &quot;                  (Glue 10)\n                    (Shape (Width + 0) (He&quot;
 &amp; &quot;ight + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric&quot;
 &amp; &quot; %waitAtDecFlow =1 \n                                               (Mi&quot;
 &amp; &quot;n 0) (Max 100)))))\n            (Glue 6)\n            (Shape (Height 16&quot;
 &amp; &quot; + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n     &quot;
 &amp; &quot;                           \&quot;ShowEdge:   Stop? \&quot;) \n                  &quot;
 &amp; &quot;  (Boolean %stopAtShowEdge =TRUE \&quot;\&quot;)\n                    (Glue 10)\n&quot;
 &amp; &quot;                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n    &quot;
 &amp; &quot;                (Shape (Width 80) (Numeric %waitAtShowEdge =1 \n       &quot;
 &amp; &quot;                                        (Min 0) (Max 100)))))\n        &quot;
 &amp; &quot;    (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox F&quot;
 &amp; &quot;ill (Shape (Width + 0) (Height + 0) \n                                \&quot;&quot;
 &amp; &quot;RemoveHighlight:   Stop? \&quot;) \n                    (Boolean %stopAtRemo&quot;
 &amp; &quot;veHighlight =TRUE \&quot;\&quot;)\n                    (Glue 10)\n               &quot;
 &amp; &quot;     (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                   &quot;
 &amp; &quot; (Shape (Width 80) (Numeric %waitAtRemoveHighlight =1 \n               &quot;
 &amp; &quot;                                (Min 0) (Max 100)))))\n            (Glu&quot;
 &amp; &quot;e 6)\n            (Shape (Height 16 + 0)\n              (HBox Fill (Sha&quot;
 &amp; &quot;pe (Width + 0) (Height + 0) \n                                \&quot;FinalRe&quot;
 &amp; &quot;sult:   Stop? \&quot;) \n                    (Boolean %stopAtFinalResult =TR&quot;
 &amp; &quot;UE \&quot;&quot;;

CONST E82_1 =
   &quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Width +&quot;
 &amp; &quot; 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (&quot;
 &amp; &quot;Numeric %waitAtFinalResult =1 \n                                       &quot;
 &amp; &quot;        (Min 0) (Max 100)))))\n            (Glue 6)\n          )\n     &quot;
 &amp; &quot;     (Glue 4)\n          (VBox\n            (Glue 5)\n            (Shap&quot;
 &amp; &quot;e (Width + 0) (Height 16 + 0) \&quot;Cts:\&quot;)\n            (Button %eventCoun&quot;
 &amp; &quot;ts\n              (VBox\n                (Glue 6)\n                (HBo&quot;
 &amp; &quot;x Fill (Shape (Width + 0) (Height 16 + 0) \n                           &quot;
 &amp; &quot;       (Text %ctOfSetup \&quot;0\&quot;)))\n                (Glue 6)\n           &quot;
 &amp; &quot;     (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n                  &quot;
 &amp; &quot;                (Text %ctOfHighlightPath \&quot;0\&quot;)))\n                (Glu&quot;
 &amp; &quot;e 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n &quot;
 &amp; &quot;                                 (Text %ctOfIncFlow \&quot;0\&quot;)))\n         &quot;
 &amp; &quot;       (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height &quot;
 &amp; &quot;16 + 0) \n                                  (Text %ctOfDecFlow \&quot;0\&quot;)))&quot;
 &amp; &quot;\n                (Glue 6)\n                (HBox Fill (Shape (Width + &quot;
 &amp; &quot;0) (Height 16 + 0) \n                                  (Text %ctOfShowE&quot;
 &amp; &quot;dge \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Sha&quot;
 &amp; &quot;pe (Width + 0) (Height 16 + 0) \n                                  (Tex&quot;
 &amp; &quot;t %ctOfRemoveHighlight \&quot;0\&quot;)))\n                (Glue 6)\n            &quot;
 &amp; &quot;    (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n                   &quot;
 &amp; &quot;               (Text %ctOfFinalResult \&quot;0\&quot;)))\n                (Glue 3&quot;
 &amp; &quot;))))\n          Fill\n          (Glue 4 + Inf)\n        )\n      )\n   &quot;
 &amp; &quot; )\n  )\n)\n&quot;;

CONST E83 =
   &quot;#| Copyright 1993 Digital Equipment Corporation.                       &quot;
 &amp; &quot;      |#\n#| Distributed only by permission.                           &quot;
 &amp; &quot;                |#\n#|                                                 &quot;
 &amp; &quot;                          |#\n#| Last modified on Sat Jul 17 14:45:54 P&quot;
 &amp; &quot;DT 1993 by heydon                   |#\n#|                             &quot;
 &amp; &quot;                                              |#\n#| Input form for the&quot;
 &amp; &quot; greedy packet-routing algorithm.                       |#\n\n(Rim (Pen&quot;
 &amp; &quot; 4)\n  (Macro Field BOA (name)\n    `(VBox\n       (Shape (Height + 0) &quot;
 &amp; &quot;(Text LeftAlign ,name))\n       (Glue 2)))\n  (Macro NamedChoice BOA (l&quot;
 &amp; &quot;abel var (init FALSE))\n    `(Choice %,var =,init CheckBox\n       (Tex&quot;
 &amp; &quot;t LeftAlign ,label)))\n  (Macro Value BOA (label var init (fill Fill) (&quot;
 &amp; &quot;min 1))\n    `(HBox ,fill\n        (Shape (Width + 0) (Text RightAlign &quot;
 &amp; &quot;,label))\n        (Numeric %,var =,init (Min ,min))))\n  (Macro Divider&quot;
 &amp; &quot; BOA ((g 4) (b 2))\n    `(VBox (Glue ,g) (Bar ,b) (Glue ,g)))\n  (Macro&quot;
 &amp; &quot; Bool BOA (label boolVar (init FALSE))\n    `(Boolean %,boolVar =,init &quot;
 &amp; &quot;(Text LeftAlign ,label)))\n  (VBox\n    (VBox\n      (Field \&quot;Network T&quot;
 &amp; &quot;opology:\&quot;)\n      (Radio %topology (VBox\n        (HBox\n          (Na&quot;
 &amp; &quot;medChoice \&quot;Grid:\&quot; grid TRUE) Fill\n          (Value  \&quot;W =\&quot; gWidth  &quot;
 &amp; &quot;4)\n          (Value \&quot; H =\&quot; gHeight 5 (Glue 0))\n        )\n        (&quot;
 &amp; &quot;HBox\n          (NamedChoice \&quot;Torus:\&quot; torus FALSE)\n          (Value &quot;
 &amp; &quot; \&quot;W =\&quot; tWidth  4)\n          (Value \&quot; H =\&quot; tHeight 5 (Glue 0))\n   &quot;
 &amp; &quot;     )\n        (HBox\n          (NamedChoice \&quot;Butterfly:\&quot; butterfly &quot;
 &amp; &quot;FALSE)\n          (Value  \&quot;Dimension =\&quot; butDim  3)\n        )\n      &quot;
 &amp; &quot;  (Glue 2)\n        (HBox\n          (NamedChoice \&quot;From File:\&quot; networ&quot;
 &amp; &quot;kFromFile FALSE)\n          (HBox\n            (Text RightAlign \&quot;Name &quot;
 &amp; &quot;=\&quot;)\n            (Frame Lowered (TypeIn ExpandOnDemand %networkFilenam&quot;
 &amp; &quot;e (BgColor \&quot;White\&quot;)))\n          )\n        )\n      )) \n    )\n    &quot;
 &amp; &quot;(Divider)\n    (VBox\n      (Field \&quot;Queue Size:\&quot;)\n      (HBox\n     &quot;
 &amp; &quot;   (Bool \&quot;Bounded?\&quot; bounded TRUE)\n        (Value \&quot;Maximum Size =\&quot; &quot;
 &amp; &quot;maxQueueSize 3)\n      )\n   &quot;;

CONST E83_0 =
   &quot; )\n    (Divider)\n    (VBox\n      (Field \&quot;Packet Sources:\&quot;)\n      &quot;
 &amp; &quot;(Radio %pktSources (VBox\n        (HBox\n          (NamedChoice \&quot;Rando&quot;
 &amp; &quot;m:\&quot; randomSrc TRUE)\n          (Value \&quot;Total =\&quot; pktsTotal 10)\n     &quot;
 &amp; &quot;   )\n        (HBox\n          (NamedChoice \&quot;Constant:\&quot; constantSrc)\n&quot;
 &amp; &quot;          (Value \&quot;Per Node =\&quot; pktsPerNode 1)\n        )\n        (Glu&quot;
 &amp; &quot;e 2)\n        (HBox\n          (NamedChoice \&quot;From File:\&quot; pktsFromFile&quot;
 &amp; &quot;)\n          (HBox\n            (Text RightAlign \&quot;Name =\&quot;)\n         &quot;
 &amp; &quot;   (Frame Lowered (TypeIn ExpandOnDemand %pktsFilename (BgColor \&quot;White&quot;
 &amp; &quot;\&quot;)))\n          )\n        )\n      ))\n    )\n    (Divider)\n    (VBo&quot;
 &amp; &quot;x\n      (Field \&quot;Outgoing Tie Resolution Heuristic:\&quot;)\n      (Radio %&quot;
 &amp; &quot;tieRes (VBox\n        (NamedChoice \&quot;First Match\&quot; firstMatch TRUE)\n  &quot;
 &amp; &quot;      (NamedChoice \&quot;Random\&quot; randomMatch FALSE)\n      ))\n    )\n    &quot;
 &amp; &quot;(Divider)\n    (VBox\n      (Field \&quot;Contention Resolution Heuristic:\&quot;&quot;
 &amp; &quot;)\n      (Radio %contentionRes (VBox\n        (NamedChoice \&quot;Furthest F&quot;
 &amp; &quot;irst\&quot; furthestFirst TRUE)\n        (NamedChoice \&quot;Random\&quot; randomFirst&quot;
 &amp; &quot;)\n      ))\n    )\n    (Divider)\n    (VBox\n      (Field \&quot;Random Num&quot;
 &amp; &quot;bers:\&quot;)\n      (Bool \&quot;Use Fixed Seed?\&quot; fixed)\n    )\n  )\n)\n&quot;;

CONST E84 =
   &quot;(* Copyright (C) 1994, Digital Equipment Corporation         *)\n(* All&quot;
 &amp; &quot; rights reserved.                                      *)\n(* See the f&quot;
 &amp; &quot;ile COPYRIGHT for a full description.            *)\n\n@Maxflow\nPROCED&quot;
 &amp; &quot;URE Maxflow =@\n\n  BEGIN\n@1  WHILE there is an augmenting path DO @\n&quot;
 &amp; &quot;@2    p := FindPath (flowChange); @\n@3    currentVertex := source; @\n&quot;
 &amp; &quot;@4    WHILE p # NIL DO  @\n@5      edge := List.Pop(p); @\n@6      IF e&quot;
 &amp; &quot;dge.from = currentVertex (* forward edge *) THEN @\n@7        edge.flow&quot;
 &amp; &quot; := edge.flow + flowChange; @\n@8        currentVertex := edge.to; @\n@&quot;
 &amp; &quot;9      ELSE (* back edge *) @\n@10       edge.flow := edge.flow - flowC&quot;
 &amp; &quot;hange; @\n@11       currentVertex := edge.from; @\n        END;\n      &quot;
 &amp; &quot;END;\n    END;\n  END Maxflow;\n\n\nPROCEDURE FindPath (VAR flowChange:&quot;
 &amp; &quot; REAL) : List.T ;\n\n(* returns a list of edges which when undirected f&quot;
 &amp; &quot;orm a \n   path from the source to the sink. Every forward edge\n   on &quot;
 &amp; &quot;this path has nonzero residual capacity \n   (i.e. capacity &gt; flow),\n &quot;
 &amp; &quot;  and every back edge on this path has positive flow.\n   Such a path i&quot;
 &amp; &quot;s called an augmenting path.\n   flowChange :=\n      minimun ( minimum&quot;
 &amp; &quot; residual capacity on forward edges,\n                minimum flow on b&quot;
 &amp; &quot;ack edges )\n*)\n\n@Maxflow\n&quot;;

CONST E85 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:29:09 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Shor&quot;
 &amp; &quot;testPath.evt.\n;*******************************************************&quot;
 &amp; &quot;*************\n\n(VBox\n  (Border (Pen 1)\n    (Shape\n      (Height 75&quot;
 &amp; &quot; - 25 + Inf)\n      (Viewport\n        (HBox\n          (Glue 4 + Inf)\n&quot;
 &amp; &quot;          (VBox\n            (Glue 6)\n            (Shape (Height 16 + &quot;
 &amp; &quot;0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n        &quot;
 &amp; &quot;                        \&quot;Code View events:   Stop? \&quot;) \n             &quot;
 &amp; &quot;       (Boolean %stopatCodeEvents =TRUE \&quot;\&quot;)\n                    (Glu&quot;
 &amp; &quot;e 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;&quot;
 &amp; &quot;)\n                    (Shape (Width 80) (Numeric %waitatCodeEvents =1 &quot;
 &amp; &quot;\n                                               (Min 0) (Max 100)))))\n&quot;
 &amp; &quot;            (Glue 6)\n            (Shape (Height 16 + 0)\n             &quot;
 &amp; &quot; (HBox Fill (Shape (Width + 0) (Height + 0) \n                         &quot;
 &amp; &quot;       \&quot;NewVertex:   Stop? \&quot;) \n                    (Boolean %stopAtN&quot;
 &amp; &quot;ewVertex =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                  &quot;
 &amp; &quot;  (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (S&quot;
 &amp; &quot;hape (Width 80) (Numeric %waitAtNewVertex =1 \n                        &quot;
 &amp; &quot;                       (Min 0) (Max 100)))))\n            (Glue 6)\n   &quot;
 &amp; &quot;         (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width&quot;
 &amp; &quot; + 0) (Height + 0) \n                                \&quot;NewEdge:   Stop?&quot;
 &amp; &quot; \&quot;) \n                    (Boolean %stopAtNewEdge =TRUE \&quot;\&quot;)\n       &quot;
 &amp; &quot;             (Glue 10)\n                    (Shape (Width + 0) (Height &quot;
 &amp; &quot;+ 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric %wai&quot;
 &amp; &quot;tAtNewEdge =1 \n                                               (Min 0) &quot;
 &amp; &quot;(Max 100)))))\n            (Glue 6)\n            (Shape (Height 16 + 0)&quot;
 &amp; &quot;\n   &quot;;

CONST E85_0 =
   &quot;           (HBox Fill (Shape (Width + 0) (Height + 0) \n               &quot;
 &amp; &quot;                 \&quot;StartFind:   Stop? \&quot;) \n                    (Boolea&quot;
 &amp; &quot;n %stopAtStartFind =TRUE \&quot;\&quot;)\n                    (Glue 10)\n        &quot;
 &amp; &quot;            (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n            &quot;
 &amp; &quot;        (Shape (Width 80) (Numeric %waitAtStartFind =1 \n              &quot;
 &amp; &quot;                                 (Min 0) (Max 100)))))\n            (Gl&quot;
 &amp; &quot;ue 6)\n            (Shape (Height 16 + 0)\n              (HBox Fill (Sh&quot;
 &amp; &quot;ape (Width + 0) (Height + 0) \n                                \&quot;Promot&quot;
 &amp; &quot;e:   Stop? \&quot;) \n                    (Boolean %stopAtPromote =TRUE \&quot;\&quot;&quot;
 &amp; &quot;)\n                    (Glue 10)\n                    (Shape (Width + 0&quot;
 &amp; &quot;) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Nu&quot;
 &amp; &quot;meric %waitAtPromote =1 \n                                             &quot;
 &amp; &quot;  (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape (Heig&quot;
 &amp; &quot;ht 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n&quot;
 &amp; &quot;                                \&quot;Consider:   Stop? \&quot;) \n             &quot;
 &amp; &quot;       (Boolean %stopAtConsider =TRUE \&quot;\&quot;)\n                    (Glue &quot;
 &amp; &quot;10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n&quot;
 &amp; &quot;                    (Shape (Width 80) (Numeric %waitAtConsider =1 \n   &quot;
 &amp; &quot;                                            (Min 0) (Max 100)))))\n    &quot;
 &amp; &quot;        (Glue 6)\n            (Shape (Height 16 + 0)\n              (HB&quot;
 &amp; &quot;ox Fill (Shape (Width + 0) (Height + 0) \n                             &quot;
 &amp; &quot;   \&quot;Traceback:   Stop? \&quot;) \n                    (Boolean %stopAtTrace&quot;
 &amp; &quot;back =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (S&quot;
 &amp; &quot;hape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape&quot;
 &amp; &quot; (Width 80) (Numeric %waitAtTraceback =1 \n                            &quot;
 &amp; &quot;                   (Min 0) (Max 100)))))\n            (Glue 6)\n       &quot;
 &amp; &quot;   )\n          (Glue 4)\n          (VBox\n            (Glue 5)\n      &quot;
 &amp; &quot;      (Shape (Width + 0) (Height 16 + 0) \&quot;Cts:\&quot;)\n            (Button&quot;
 &amp; &quot; %eventCounts\n              (VBox\n                (Glue 6)\n         &quot;
 &amp; &quot;       (H&quot;;

CONST E85_1 =
   &quot;Box Fill (Shape (Width + 0) (Height 16 + 0) \n                         &quot;
 &amp; &quot;         (Text %ctOfNewVertex \&quot;0\&quot;)))\n                (Glue 6)\n     &quot;
 &amp; &quot;           (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n            &quot;
 &amp; &quot;                      (Text %ctOfNewEdge \&quot;0\&quot;)))\n                (Glu&quot;
 &amp; &quot;e 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n &quot;
 &amp; &quot;                                 (Text %ctOfStartFind \&quot;0\&quot;)))\n       &quot;
 &amp; &quot;         (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Heigh&quot;
 &amp; &quot;t 16 + 0) \n                                  (Text %ctOfPromote \&quot;0\&quot;)&quot;
 &amp; &quot;))\n                (Glue 6)\n                (HBox Fill (Shape (Width &quot;
 &amp; &quot;+ 0) (Height 16 + 0) \n                                  (Text %ctOfCon&quot;
 &amp; &quot;sider \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (S&quot;
 &amp; &quot;hape (Width + 0) (Height 16 + 0) \n                                  (T&quot;
 &amp; &quot;ext %ctOfTraceback \&quot;0\&quot;)))\n                (Glue 3))))\n          Fil&quot;
 &amp; &quot;l\n          (Glue 4 + Inf)\n        )\n      )\n    )\n  )\n)\n&quot;;

CONST E86 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:29:09 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file DGra&quot;
 &amp; &quot;ph.evt.\n;*************************************************************&quot;
 &amp; &quot;*******\n\n(VBox\n  (Border (Pen 1)\n    (Shape\n      (Height 75 - 25 &quot;
 &amp; &quot;+ Inf)\n      (Viewport\n        (HBox\n          (Glue 4 + Inf)\n     &quot;
 &amp; &quot;     (VBox\n            (Glue 6)\n            (Shape (Height 16 + 0)\n &quot;
 &amp; &quot;             (HBox Fill (Shape (Width + 0) (Height + 0) \n             &quot;
 &amp; &quot;                   \&quot;Code View events:   Stop? \&quot;) \n                  &quot;
 &amp; &quot;  (Boolean %stopatCodeEvents =TRUE \&quot;\&quot;)\n                    (Glue 10)&quot;
 &amp; &quot;\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n  &quot;
 &amp; &quot;                  (Shape (Width 80) (Numeric %waitatCodeEvents =1 \n   &quot;
 &amp; &quot;                                            (Min 0) (Max 100)))))\n    &quot;
 &amp; &quot;        (Glue 6)\n            (Shape (Height 16 + 0)\n              (HB&quot;
 &amp; &quot;ox Fill (Shape (Width + 0) (Height + 0) \n                             &quot;
 &amp; &quot;   \&quot;Setup:   Stop? \&quot;) \n                    (Boolean %stopAtSetup =TR&quot;
 &amp; &quot;UE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Wi&quot;
 &amp; &quot;dth + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width &quot;
 &amp; &quot;80) (Numeric %waitAtSetup =1 \n                                        &quot;
 &amp; &quot;       (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape &quot;
 &amp; &quot;(Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + &quot;
 &amp; &quot;0) \n                                \&quot;AddEdge:   Stop? \&quot;) \n         &quot;
 &amp; &quot;           (Boolean %stopAtAddEdge =TRUE \&quot;\&quot;)\n                    (Gl&quot;
 &amp; &quot;ue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;&quot;
 &amp; &quot;)\n                    (Shape (Width 80) (Numeric %waitAtAddEdge =1 \n &quot;
 &amp; &quot;                                              (Min 0) (Max 100)))))\n  &quot;
 &amp; &quot;          (Glue 6)\n            (Shape (Height 16 + 0)\n              (&quot;
 &amp; &quot;HBox F&quot;;

CONST E86_0 =
   &quot;ill (Shape (Width + 0) (Height + 0) \n                                \&quot;&quot;
 &amp; &quot;MarkEdge:   Stop? \&quot;) \n                    (Boolean %stopAtMarkEdge =T&quot;
 &amp; &quot;RUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (W&quot;
 &amp; &quot;idth + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width&quot;
 &amp; &quot; 80) (Numeric %waitAtMarkEdge =1 \n                                    &quot;
 &amp; &quot;           (Min 0) (Max 100)))))\n            (Glue 6)\n            (Sh&quot;
 &amp; &quot;ape (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Heigh&quot;
 &amp; &quot;t + 0) \n                                \&quot;UnMarkEdge:   Stop? \&quot;) \n  &quot;
 &amp; &quot;                  (Boolean %stopAtUnMarkEdge =TRUE \&quot;\&quot;)\n             &quot;
 &amp; &quot;       (Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;&quot;
 &amp; &quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtUnMa&quot;
 &amp; &quot;rkEdge =1 \n                                               (Min 0) (Max&quot;
 &amp; &quot; 100)))))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n  &quot;
 &amp; &quot;            (HBox Fill (Shape (Width + 0) (Height + 0) \n              &quot;
 &amp; &quot;                  \&quot;MarkVertex:   Stop? \&quot;) \n                    (Bool&quot;
 &amp; &quot;ean %stopAtMarkVertex =TRUE \&quot;\&quot;)\n                    (Glue 10)\n     &quot;
 &amp; &quot;               (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n         &quot;
 &amp; &quot;           (Shape (Width 80) (Numeric %waitAtMarkVertex =1 \n          &quot;
 &amp; &quot;                                     (Min 0) (Max 100)))))\n           &quot;
 &amp; &quot; (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox Fill&quot;
 &amp; &quot; (Shape (Width + 0) (Height + 0) \n                                \&quot;Un&quot;
 &amp; &quot;MarkVertex:   Stop? \&quot;) \n                    (Boolean %stopAtUnMarkVer&quot;
 &amp; &quot;tex =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Sh&quot;
 &amp; &quot;ape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape &quot;
 &amp; &quot;(Width 80) (Numeric %waitAtUnMarkVertex =1 \n                          &quot;
 &amp; &quot;                     (Min 0) (Max 100)))))\n            (Glue 6)\n     &quot;
 &amp; &quot;       (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width +&quot;
 &amp; &quot; 0) (Height + 0) \n                                \&quot;NewTree:   Stop? \&quot;&quot;
 &amp; &quot;) \n                    (Boolean %stopAtNewTree =TRUE \&quot;\&quot;)\n          &quot;
 &amp; &quot;     &quot;;

CONST E86_1 =
   &quot;     (Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;W&quot;
 &amp; &quot;eight: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtNewTr&quot;
 &amp; &quot;ee =1 \n                                               (Min 0) (Max 100&quot;
 &amp; &quot;)))))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n      &quot;
 &amp; &quot;        (HBox Fill (Shape (Width + 0) (Height + 0) \n                  &quot;
 &amp; &quot;              \&quot;Highlight:   Stop? \&quot;) \n                    (Boolean %&quot;
 &amp; &quot;stopAtHighlight =TRUE \&quot;\&quot;)\n                    (Glue 10)\n           &quot;
 &amp; &quot;         (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n               &quot;
 &amp; &quot;     (Shape (Width 80) (Numeric %waitAtHighlight =1 \n                 &quot;
 &amp; &quot;                              (Min 0) (Max 100)))))\n            (Glue &quot;
 &amp; &quot;6)\n            (Shape (Height 16 + 0)\n              (HBox Fill (Shape&quot;
 &amp; &quot; (Width + 0) (Height + 0) \n                                \&quot;AddChild:&quot;
 &amp; &quot;   Stop? \&quot;) \n                    (Boolean %stopAtAddChild =TRUE \&quot;\&quot;)&quot;
 &amp; &quot;\n                    (Glue 10)\n                    (Shape (Width + 0)&quot;
 &amp; &quot; (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Num&quot;
 &amp; &quot;eric %waitAtAddChild =1 \n                                             &quot;
 &amp; &quot;  (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape (Heig&quot;
 &amp; &quot;ht 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n&quot;
 &amp; &quot;                                \&quot;RemoveChild:   Stop? \&quot;) \n          &quot;
 &amp; &quot;          (Boolean %stopAtRemoveChild =TRUE \&quot;\&quot;)\n                    &quot;
 &amp; &quot;(Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight&quot;
 &amp; &quot;: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtRemoveChil&quot;
 &amp; &quot;d =1 \n                                               (Min 0) (Max 100)&quot;
 &amp; &quot;))))\n            (Glue 6)\n          )\n          (Glue 4)\n          &quot;
 &amp; &quot;(VBox\n            (Glue 5)\n            (Shape (Width + 0) (Height 16 &quot;
 &amp; &quot;+ 0) \&quot;Cts:\&quot;)\n            (Button %eventCounts\n              (VBox\n&quot;
 &amp; &quot;                (Glue 6)\n                (HBox Fill (Shape (Width + 0)&quot;
 &amp; &quot; (Height 16 + 0) \n                                  (Text %ctOfSetup \&quot;&quot;
 &amp; &quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Shape (Wi&quot;
 &amp; &quot;dth + 0&quot;;

CONST E86_2 =
   &quot;) (Height 16 + 0) \n                                  (Text %ctOfAddEdg&quot;
 &amp; &quot;e \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Shape&quot;
 &amp; &quot; (Width + 0) (Height 16 + 0) \n                                  (Text &quot;
 &amp; &quot;%ctOfMarkEdge \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox&quot;
 &amp; &quot; Fill (Shape (Width + 0) (Height 16 + 0) \n                            &quot;
 &amp; &quot;      (Text %ctOfUnMarkEdge \&quot;0\&quot;)))\n                (Glue 6)\n       &quot;
 &amp; &quot;         (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n              &quot;
 &amp; &quot;                    (Text %ctOfMarkVertex \&quot;0\&quot;)))\n                (Gl&quot;
 &amp; &quot;ue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n&quot;
 &amp; &quot;                                  (Text %ctOfUnMarkVertex \&quot;0\&quot;)))\n   &quot;
 &amp; &quot;             (Glue 6)\n                (HBox Fill (Shape (Width + 0) (H&quot;
 &amp; &quot;eight 16 + 0) \n                                  (Text %ctOfNewTree \&quot;&quot;
 &amp; &quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Shape (Wi&quot;
 &amp; &quot;dth + 0) (Height 16 + 0) \n                                  (Text %ctO&quot;
 &amp; &quot;fHighlight \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fi&quot;
 &amp; &quot;ll (Shape (Width + 0) (Height 16 + 0) \n                               &quot;
 &amp; &quot;   (Text %ctOfAddChild \&quot;0\&quot;)))\n                (Glue 6)\n            &quot;
 &amp; &quot;    (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n                   &quot;
 &amp; &quot;               (Text %ctOfRemoveChild \&quot;0\&quot;)))\n                (Glue 3&quot;
 &amp; &quot;))))\n          Fill\n          (Glue 4 + Inf)\n        )\n      )\n   &quot;
 &amp; &quot; )\n  )\n)\n&quot;;

CONST E87 =
   &quot;(* Copyright (C) 1994, Digital Equipment Corporation                   &quot;
 &amp; &quot;      *)\n(* All rights reserved.                                      &quot;
 &amp; &quot;                *)\n(* See the file COPYRIGHT for a full description.  &quot;
 &amp; &quot;                          *)\n(*                                       &quot;
 &amp; &quot;                                    *)\n(* NodeDepth.obl - view of node&quot;
 &amp; &quot; depths.                                      *)\n(* Last modified on M&quot;
 &amp; &quot;on Jan  9 12:04:28 PST 1995 by najork                   *)\n(*      mod&quot;
 &amp; &quot;ified on Fri Aug 19 16:17:40 PDT 1994 by heydon                   *)\n(&quot;
 &amp; &quot;*      modified on Thu Jul 28 10:50:11 PDT 1994 by shillner            &quot;
 &amp; &quot;     *)\n\n(* Screen dimensions. *)\nlet North: Real = 1.0;\nlet South:&quot;
 &amp; &quot; Real = 0.0;\nlet West: Real = 0.0;\nlet East: Real = 1.0;\nlet Margin:&quot;
 &amp; &quot; Real = 5.0;\n\n(* Caption stuff. *)\nlet CaptionHeight   = 0.1;\nlet B&quot;
 &amp; &quot;ackgroundColor = color_named(\&quot;white\&quot;);\nlet FontSz          = 0.07;\n&quot;
 &amp; &quot;\n(* Bar settings. *)\nlet BarColor    = color_named(\&quot;magenta\&quot;);\nlet&quot;
 &amp; &quot; BorderColor = color_named(\&quot;black\&quot;);\nlet BorderWidth = 0.005;\nlet T&quot;
 &amp; &quot;extColor   = color_named(\&quot;black\&quot;);\nlet BarGap      = 0.02;\nlet Axis&quot;
 &amp; &quot;LabelHeight = 0.1;\nvar g = ok;\nvar labelFont = ok;\n\n(* Node Object &quot;
 &amp; &quot;============================================================= *)\n\nlet&quot;
 &amp; &quot; Node = {\n  parent: Node =&gt; ok,\n  children: Node =&gt; ok,\n  next: Node&quot;
 &amp; &quot; =&gt; ok,      (* Siblings. *)\n  prev: Node =&gt; ok,\n\n  (* Adds child as&quot;
 &amp; &quot; a child of parent, inserted to the right of \n     the child \&quot;rightOf&quot;
 &amp; &quot;\&quot;, which must be a child of parent, or as\n     the leftmost child if &quot;
 &amp; &quot;rightOf is ok *)\n  addChild =&gt; meth(parent, rightOf, child: Node)\n   &quot;
 &amp; &quot; if rightOf is ok then\n      child.next := parent.children;\n      chi&quot;
 &amp; &quot;ld.prev := ok;\n      if child.next isnot ok then child.next.prev := ch&quot;
 &amp; &quot;ild; end;\n      parent.children := child;\n    else\n      child.prev &quot;
 &amp; &quot;:= rightOf;\n      child.next := rightOf.next;\n      if child.next isn&quot;
 &amp; &quot;ot ok then child.next.prev := child; end;\n      rightOf.next := child;&quot;
 &amp; &quot;\n    end;\n  end,\n\n  (* removes child from parent, which must be its&quot;
 &amp; &quot; parent&quot;;

CONST E87_0 =
   &quot; *)\n  removeChild =&gt; meth(parent, child: Node)\n    if child.prev isno&quot;
 &amp; &quot;t ok\n      then child.prev.next := child.next;\n      else parent.chil&quot;
 &amp; &quot;dren := child.next;\n    end;\n    if child.next isnot ok then child.ne&quot;
 &amp; &quot;xt.prev := child.prev; end;\n    child.prev := ok;\n    child.next := o&quot;
 &amp; &quot;k;\n  end,\n\n  walk =&gt; meth(node: Node, bar: Bar)\n    bar.size := bar&quot;
 &amp; &quot;.size + 1.0;\n    var ch = node.children;\n    if bar.next is ok then\n&quot;
 &amp; &quot;      bar.next := clone(bar).init(bar.col + 1);\n    end;\n    var acc &quot;
 &amp; &quot;= 0;\n    var count = 0;\n    loop\n      if ch is ok then exit end;\n &quot;
 &amp; &quot;     let res = ch.walk(bar.next);\n      acc := acc + res.acc;\n      c&quot;
 &amp; &quot;ount := count + res.count;\n      ch := ch.next;\n    end;\n    {acc =&gt;&quot;
 &amp; &quot; acc + bar.col, count =&gt; count + 1};\n  end,\n\n};\n\n\n(* Bar Object =&quot;
 &amp; &quot;============================================================= *)\n\nlet&quot;
 &amp; &quot; Bar = {\n  size: Float =&gt; ok,\n  next: Bar =&gt; ok,\n  col: Int =&gt; ok,\n&quot;
 &amp; &quot;  v: Vertex =&gt; ok,\n  axisLabel: Vertex =&gt; ok,\n\n  init =&gt; meth(self: &quot;
 &amp; &quot;Bar, col: Int): Bar,\n    self.size := 0.0;\n    self.col := col;\n    &quot;
 &amp; &quot;self.next := ok;\n    if self.col &gt;= 0 then\n      self.v := graph_newV&quot;
 &amp; &quot;ertex(g);\n      graph_setVertexColor(self.v, BarColor);\n      graph_s&quot;
 &amp; &quot;etVertexBorderColor(self.v, BorderColor);\n      graph_setVertexBorder(&quot;
 &amp; &quot;self.v, BorderWidth);\n      graph_setVertexSize(self.v, 1.0, 0.0);\n  &quot;
 &amp; &quot;    graph_setVertexLabelColor(self.v, TextColor);\n      graph_setVerte&quot;
 &amp; &quot;xFont(self.v, labelFont);\n      graph_moveVertex(self.v, float(self.co&quot;
 &amp; &quot;l), 0.0, true);\n\n      self.axisLabel := graph_newVertex(g);\n      g&quot;
 &amp; &quot;raph_setVertexColor(self.axisLabel, BackgroundColor);\n      graph_setV&quot;
 &amp; &quot;ertexBorder(self.axisLabel, 0.0);\n      graph_setVertexLabelColor(self&quot;
 &amp; &quot;.axisLabel, TextColor);\n      graph_setVertexFont(self.axisLabel, labe&quot;
 &amp; &quot;lFont);\n    end;\n    self;\n  end,\n\n  clear =&gt; meth(self: Bar)\n   &quot;
 &amp; &quot; self.size := 0.0;\n    if self.next isnot ok then self.next.clear() en&quot;
 &amp; &quot;d;\n  end,\n\n  update =&gt; meth(self: Bar, maxHeight: Float, maxCols: In&quot;
 &amp; &quot;t,\n                 barGraph: BarGraph): ok,\n    let height = if self&quot;
 &amp; &quot;.size &gt; maxH&quot;;

CONST E87_1 =
   &quot;eight then self.size else maxHeight end;\n    let cols = if self.size i&quot;
 &amp; &quot;snot 0.0 then self.col else maxCols end;\n\n    if self.next isnot ok t&quot;
 &amp; &quot;hen self.next.update(height, cols, barGraph)\n    else barGraph.barCoun&quot;
 &amp; &quot;ts(height, cols + 1) end;\n\n    let shape = barGraph.barShape(math_sqr&quot;
 &amp; &quot;t(self.size), self.col);\n    if shape.h &gt; 0.0 then\n      graph_setVer&quot;
 &amp; &quot;texSize(self.v, shape.w, shape.h);\n      graph_moveVertex(self.v, shap&quot;
 &amp; &quot;e.x, shape.y, false);\n      graph_setVertexLabel(self.v, fmt_int(round&quot;
 &amp; &quot;(self.size)));\n\n      graph_setVertexSize(self.axisLabel, shape.w, Ax&quot;
 &amp; &quot;isLabelHeight);\n      graph_moveVertex(self.axisLabel, shape.x, \n    &quot;
 &amp; &quot;                   (shape.y - (0.5 * shape.h)) - (0.5 * AxisLabelHeight&quot;
 &amp; &quot;),\n                       false);\n      graph_setVertexLabel(self.axi&quot;
 &amp; &quot;sLabel, fmt_int(self.col));\n    else\n      graph_setVertexSize(self.v&quot;
 &amp; &quot;, 0.0, 0.0);\n      graph_setVertexSize(self.axisLabel, 0.0, 0.0);\n   &quot;
 &amp; &quot; end;\n  end,\n};\n\n(* BarGraph Object ===============================&quot;
 &amp; &quot;========================== *)\n\nlet BarGraph = {\n  west: Float =&gt; ok,&quot;
 &amp; &quot;\n  east: Float =&gt; ok,\n  north: Float =&gt; ok,\n  south: Float =&gt; ok,\n &quot;
 &amp; &quot; height: Float =&gt; ok,\n  width: Float =&gt; ok,\n  bar: Bar =&gt; ok,\n  colW&quot;
 &amp; &quot;idth: Float =&gt; ok,\n  unitHeight: Float =&gt; ok,\n  baseCol: Float =&gt; ok,&quot;
 &amp; &quot;\n  barWidth: Float =&gt; ok,\n\n  init =&gt; meth(self: BarGraph, west, east&quot;
 &amp; &quot;, north, south: Float,\n               bar: Bar): BarGraph,\n    self.w&quot;
 &amp; &quot;est := west;\n    self.east := east;\n    self.north := north;\n    sel&quot;
 &amp; &quot;f.south := south;\n    self.height := north - south;\n    self.width :=&quot;
 &amp; &quot; east - west;\n    self.bar := bar;\n    self;\n  end,\n\n  barCounts =&quot;
 &amp; &quot;&gt; meth(self: BarGraph, height: Float, cols: Int): ok,\n    self.colWidt&quot;
 &amp; &quot;h := self.width / float(cols);\n    self.unitHeight := (self.height - A&quot;
 &amp; &quot;xisLabelHeight) / math_sqrt(height);\n    self.baseCol := self.west + (&quot;
 &amp; &quot;0.5 * self.colWidth);\n    self.barWidth := self.colWidth - BarGap;\n  &quot;
 &amp; &quot;end,\n\n  barShape =&gt; meth(self: BarGraph, size: Float, col: Int): Shap&quot;
 &amp; &quot;e,\n    var shape = {w =&gt; ok, h =&gt; ok, x =&gt; ok, y =&gt; ok};\n\n    shape.&quot;
 &amp; &quot;w &quot;;

CONST E87_2 =
   &quot;:= self.barWidth;\n    shape.h := size * self.unitHeight;\n    shape.x &quot;
 &amp; &quot;:= self.baseCol + (self.colWidth * float(col));\n    shape.y := self.so&quot;
 &amp; &quot;uth + AxisLabelHeight + (0.5 * shape.h);\n    shape;\n  end,\n\n  updat&quot;
 &amp; &quot;e =&gt; meth(self: BarGraph)\n    self.bar.next.update(0.0, 0, self);\n  e&quot;
 &amp; &quot;nd,\n  \n};\n\n\n(* View Object =======================================&quot;
 &amp; &quot;====================== *)\n\nlet view = {\n\n  graphvbt =&gt; graph_new(),&quot;
 &amp; &quot;\n  counts =&gt; ok,\n  numSets =&gt; 0,\n  node =&gt; ok,\n  root: Node =&gt; ok,\n&quot;
 &amp; &quot;  bar: Bar =&gt; ok,\n  barGraph: BarGraph =&gt; ok,\n  height: Int =&gt; ok,\n &quot;
 &amp; &quot; width: Int =&gt; ok,\n  caption: Vertex =&gt; ok,\n\n  FinishedSets =&gt; meth(&quot;
 &amp; &quot;self: View, numSets: Int, usesRanks: Bool)\n    g := self.graphvbt;  (*&quot;
 &amp; &quot; Must be done before Bar.init(). *)\n    self.numSets := numSets;\n    &quot;
 &amp; &quot;self.root := clone(Node);\n    self.bar := clone(Bar).init(-1);\n    se&quot;
 &amp; &quot;lf.barGraph := clone(BarGraph).init(West, East, North,\n               &quot;
 &amp; &quot;                           South + CaptionHeight, self.bar);\n    self.&quot;
 &amp; &quot;node := array_new(numSets, ok);\n    labelFont := graph_newFont(self.gr&quot;
 &amp; &quot;aphvbt, \&quot;Helvetica\&quot;, FontSz,\n                               \&quot;Roman\&quot;&quot;
 &amp; &quot;, \&quot;bold\&quot;, \&quot;*\&quot;);\n\n    for i=0 to numSets-1 do\n      var node = cl&quot;
 &amp; &quot;one(Node);\n      self.root.addChild(ok, node);\n      self.node[i] := &quot;
 &amp; &quot;node;\n    end;\n\n    graph_setWorld(self.graphvbt, West, East, North,&quot;
 &amp; &quot; South);\n    graph_setMargin(self.graphvbt, Margin);\n    self.caption&quot;
 &amp; &quot; := graph_newVertex(self.graphvbt);\n    graph_moveVertex(self.caption,&quot;
 &amp; &quot; (West + East) / 2.0,\n                     South + (CaptionHeight / 2.&quot;
 &amp; &quot;0), false);\n    graph_setVertexSize(self.caption, East - West, Caption&quot;
 &amp; &quot;Height);\n    graph_setVertexColor(self.caption, BackgroundColor);\n   &quot;
 &amp; &quot; graph_setVertexFont(self.caption, labelFont);\n    graph_setVertexLabe&quot;
 &amp; &quot;l(self.caption, \&quot;\&quot;);\n    graph_setVertexLabelColor(self.caption, Tex&quot;
 &amp; &quot;tColor);\n    self.update();\n  end,\n\n  update =&gt; meth(self: View): o&quot;
 &amp; &quot;k,\n    self.bar.clear();\n    let res = self.root.walk(self.bar);\n   &quot;
 &amp; &quot; let avg = float(res.acc + 1) / float(self.numSets);\n    self.barGraph&quot;
 &amp; &quot;.update();\n &quot;;

CONST E87_3 =
   &quot;   graph_setVertexLabel(self.caption,\n                         \&quot;Avera&quot;
 &amp; &quot;ge Node Depth: \&quot; &amp;\n                          text_replaceAll(\&quot;d\&quot;, \&quot;&quot;
 &amp; &quot;0\&quot;,\n                                          text_sub(fmt_real(avg),&quot;
 &amp; &quot; 0, 4)));\n    graph_redisplay(self.graphvbt);\n  end,\n\n  ChangeParen&quot;
 &amp; &quot;t =&gt; meth(self: View, childId, parentId, rootId: Int)\n    let parent =&quot;
 &amp; &quot; self.node[parentId];\n    let child = self.node[childId];\n    let roo&quot;
 &amp; &quot;t = self.node[rootId];\n    \n    parent.removeChild(child);\n    root.&quot;
 &amp; &quot;addChild(ok, child);\n\n    self.update();\n    ok;\n  end,\n\n  Unite &quot;
 &amp; &quot;=&gt; meth(self: View, childId, parentId, pRank: Int)\n    let parent = se&quot;
 &amp; &quot;lf.node[parentId];\n    let child = self.node[childId];\n\n    self.roo&quot;
 &amp; &quot;t.removeChild(child);\n    parent.addChild(ok, child);\n\n    self.upda&quot;
 &amp; &quot;te();\n    ok;\n  end,\n\n};\n&quot;;

CONST E88 =
   &quot;; Copyright (C) 1992, Digital Equipment Corporation\n; All rights reser&quot;
 &amp; &quot;ved.\n; See the file COPYRIGHT for a full description.\n\n(VBox\n  (Glu&quot;
 &amp; &quot;e 10)\n  (Rim\n    (Pen 10)\n    (HBox\n      (VBox (Shape (Width + 0)(&quot;
 &amp; &quot;Height + 0) \&quot;Input: \&quot;) Fill)\n      (Border\n        (Shape\n        &quot;
 &amp; &quot;  (Width 180) (Height 50)\n          (TextEdit %input =\&quot;zeus = able + &quot;
 &amp; &quot;baker * (cat + dog)\&quot;)))\n      Fill))\n  (Glue 10))\n&quot;;

CONST E89 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:29:09 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file ZPap&quot;
 &amp; &quot;er.evt.\n;*************************************************************&quot;
 &amp; &quot;*******\n\n(VBox\n  (Border (Pen 1)\n    (Shape\n      (Height 75 - 25 &quot;
 &amp; &quot;+ Inf)\n      (Viewport\n        (HBox\n          (Glue 4 + Inf)\n     &quot;
 &amp; &quot;     (VBox\n            (Glue 6)\n            (Shape (Height 16 + 0)\n &quot;
 &amp; &quot;             (HBox Fill (Shape (Width + 0) (Height + 0) \n             &quot;
 &amp; &quot;                   \&quot;Code View events:   Stop? \&quot;) \n                  &quot;
 &amp; &quot;  (Boolean %stopatCodeEvents =TRUE \&quot;\&quot;)\n                    (Glue 10)&quot;
 &amp; &quot;\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n  &quot;
 &amp; &quot;                  (Shape (Width 80) (Numeric %waitatCodeEvents =1 \n   &quot;
 &amp; &quot;                                            (Min 0) (Max 100)))))\n    &quot;
 &amp; &quot;        (Glue 6)\n            (Shape (Height 16 + 0)\n              (HB&quot;
 &amp; &quot;ox Fill (Shape (Width + 0) (Height + 0) \n                             &quot;
 &amp; &quot;   \&quot;Init:   Stop? \&quot;) \n                    (Boolean %stopAtInit =TRUE&quot;
 &amp; &quot; \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Widt&quot;
 &amp; &quot;h + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80&quot;
 &amp; &quot;) (Numeric %waitAtInit =1 \n                                           &quot;
 &amp; &quot;    (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape (He&quot;
 &amp; &quot;ight 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) &quot;
 &amp; &quot;\n                                \&quot;Set:   Stop? \&quot;) \n                &quot;
 &amp; &quot;    (Boolean %stopAtSet =TRUE \&quot;\&quot;)\n                    (Glue 10)\n   &quot;
 &amp; &quot;                 (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n       &quot;
 &amp; &quot;             (Shape (Width 80) (Numeric %waitAtSet =1 \n               &quot;
 &amp; &quot;                                (Min 0) (Max 100)))))\n            (Glu&quot;
 &amp; &quot;e 6)\n          )\n          (Glue 4)\n          (VBox\n            (Gl&quot;
 &amp; &quot;ue 5)\n   &quot;;

CONST E89_0 =
   &quot;         (Shape (Width + 0) (Height 16 + 0) \&quot;Cts:\&quot;)\n            (But&quot;
 &amp; &quot;ton %eventCounts\n              (VBox\n                (Glue 6)\n      &quot;
 &amp; &quot;          (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n             &quot;
 &amp; &quot;                     (Text %ctOfInit \&quot;0\&quot;)))\n                (Glue 6)&quot;
 &amp; &quot;\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n     &quot;
 &amp; &quot;                             (Text %ctOfSet \&quot;0\&quot;)))\n                (&quot;
 &amp; &quot;Glue 3))))\n          Fill\n          (Glue 4 + Inf)\n        )\n      &quot;
 &amp; &quot;)\n    )\n  )\n)\n&quot;;

CONST E90 =
   &quot;(* Copyright 1993 Digital Equipment Corporation.                       &quot;
 &amp; &quot;      *)\n(* Distributed only by permission.                           &quot;
 &amp; &quot;                *)\n(*                                                 &quot;
 &amp; &quot;                          *)\n(* Last modified on Sat Oct 23 17:53:45 P&quot;
 &amp; &quot;DT 1993 by heydon                   *)\n(*      modified on Tue Jul 27 &quot;
 &amp; &quot;16:25:00 PDT 1993 by rsanchez                 *)\n\n(* This view shows &quot;
 &amp; &quot;the packets flowing along the edges. *)\n\nlet nodeColor = [color_named&quot;
 &amp; &quot;(\&quot;yellow\&quot;), color_named(\&quot;red\&quot;)];\nlet edgeColor = [color_named(\&quot;Bl&quot;
 &amp; &quot;ue\&quot;), color_named(\&quot;Orange\&quot;)];\nlet packetColor = [color_named(\&quot;Very&quot;
 &amp; &quot;LightGreen\&quot;), \n                   color_named(\&quot;VeryDarkGreen\&quot;)];\nl&quot;
 &amp; &quot;et labelColor = color_named(\&quot;Black\&quot;);\nlet packetDiscardColor = color&quot;
 &amp; &quot;_named(\&quot;DarkRed\&quot;);\nlet borderColor = color_named(\&quot;Black\&quot;);\nlet ba&quot;
 &amp; &quot;ckgroundColor = color_named(\&quot;White\&quot;);\n\nlet normal = 0;\nlet congest&quot;
 &amp; &quot;ed = 1;\n\nlet one = 0;\nlet two = 0;\nlet twoplus = 1;\n\nlet edgeWidt&quot;
 &amp; &quot;h = 0.1;\nlet borderWidth = 0.1;\n\nlet invisibleCP = proc(g, pt)\n  le&quot;
 &amp; &quot;t vtx = graph_newVertex(g);\n  graph_setVertexSize(vtx, 0.0, 0.0);\n  g&quot;
 &amp; &quot;raph_moveVertex(vtx, pt[0], pt[1], false);\n  vtx\nend;\n\nlet abs = pr&quot;
 &amp; &quot;oc (r) if r &lt; 0.0 then 0.0-r else r end end;\n\nlet MakeBezierPathProc &quot;
 &amp; &quot;= proc (cpp)\n  let x000 = cpp[0][0],  y000 = cpp[0][1],\n      x001 = &quot;
 &amp; &quot;cpp[1][0],  y001 = cpp[1][1],\n      x011 = cpp[2][0],  y011 = cpp[2][1&quot;
 &amp; &quot;],\n      x111 = cpp[3][0],  y111 = cpp[3][1];\n  proc (t)\n    let s =&quot;
 &amp; &quot; 1.0-t;\n    let sss = s*s*s,\n        sst = s*s*t*3.0,\n        stt = &quot;
 &amp; &quot;s*t*t*3.0,\n        ttt = t*t*t;\n    [(sss*x000) + (sst*x001) + (stt*x&quot;
 &amp; &quot;011) + (ttt*x111),\n     (sss*y000) + (sst*y001) + (stt*y011) + (ttt*y1&quot;
 &amp; &quot;11)]\n  end;\nend;\n\nlet Interp = proc (t,a,b) let s = 1.0-t; (a*s)+(b&quot;
 &amp; &quot;*t) end;\n\nlet MoveOnCurvedEdge = proc (vtx, cpp)\n  for i = 0 to 3 do&quot;
 &amp; &quot;\n    let j = if i &gt; 0 then i-1 else 0 end;\n    let t = float(i)/3.0;\n&quot;
 &amp; &quot;    graph_moveVertexOnPath(vtx, MakeBezierPathProc(\n      [[Interp(t,c&quot;
 &amp; &quot;pp[0][0],cpp[0][0]),Interp(t,cpp[0][1],cpp[0][1])],\n       [Interp(t,c&quot;
 &amp; &quot;pp[0][0],cpp[1][0]),&quot;;

CONST E90_0 =
   &quot;Interp(t,cpp[0][1],cpp[1][1])],\n       [Interp(t,cpp[i][0],cpp[j][0]),&quot;
 &amp; &quot;Interp(t,cpp[i][1],cpp[j][1])],\n       [Interp(t,cpp[i][0],cpp[i][0]),&quot;
 &amp; &quot;Interp(t,cpp[i][1],cpp[i][1])]]\n    ));\n  end;\nend;\n\n\nlet HashEnt&quot;
 &amp; &quot;ry =\n  {\n   key1 =&gt; ok,\n   key2 =&gt; ok,\n   value =&gt; ok,\n   next =&gt; &quot;
 &amp; &quot;ok,\n   };\n\nlet HashTable =\n  {\n    num =&gt; ok,\n    size =&gt; ok,\n  &quot;
 &amp; &quot;  table =&gt; ok,\n\n    curindex =&gt; ok,\n    curentry =&gt; ok,\n\n    creat&quot;
 &amp; &quot;e =&gt; meth(self, num)\n      self.num := num;\n      self.size := real_r&quot;
 &amp; &quot;ound(float(num)*math_log(float(num)));\n      self.table := array_new(s&quot;
 &amp; &quot;elf.size, ok);\n      self;\n    end,\n\n    getfirst =&gt; meth(self)\n  &quot;
 &amp; &quot;    self.curindex := 0;\n      self.curentry := ok;\n      loop\n      &quot;
 &amp; &quot;  if self.curindex is self.size then\n          exit;\n        else\n  &quot;
 &amp; &quot;        if self.table[self.curindex] isnot ok then\n            self.cu&quot;
 &amp; &quot;rentry := self.table[self.curindex];\n            exit;\n          end;&quot;
 &amp; &quot;\n          self.curindex := self.curindex + 1;\n        end;\n      en&quot;
 &amp; &quot;d;\n      if self.curentry isnot ok then\n        self.curentry.value;\n&quot;
 &amp; &quot;      else\n        ok;\n      end;\n    end,\n\n    getnext =&gt; meth(se&quot;
 &amp; &quot;lf)\n      if self.curentry isnot ok then\n        self.curentry := sel&quot;
 &amp; &quot;f.curentry.next;\n        loop\n          if self.curentry isnot ok the&quot;
 &amp; &quot;n\n            exit;\n          else\n            self.curindex := self&quot;
 &amp; &quot;.curindex + 1;\n            if self.curindex &lt; self.size then\n        &quot;
 &amp; &quot;      self.curentry := self.table[self.curindex];\n            else\n  &quot;
 &amp; &quot;            exit;\n            end;\n          end;\n        end;\n    &quot;
 &amp; &quot;    if self.curentry isnot ok then\n          self.curentry.value;\n   &quot;
 &amp; &quot;     else\n          ok;\n        end;\n      else\n        ok;\n      &quot;
 &amp; &quot;end;\n    end,\n\n    lookup =&gt; meth(self, key1, key2)\n      let index&quot;
 &amp; &quot; = ((key1 * self.size) + key2) % self.num;\n      if self.table[index] &quot;
 &amp; &quot;isnot ok then\n         var entry = self.table[index];\n         loop\n&quot;
 &amp; &quot;           if (entry is ok) orif\n              ((entry.key1 is key1) a&quot;
 &amp; &quot;nd (entry.key2 is key2)) then\n             exit;\n           else\n   &quot;
 &amp; &quot;          entry := entry.ne&quot;;

CONST E90_1 =
   &quot;xt;\n           end;\n         end;\n         if entry isnot ok then\n &quot;
 &amp; &quot;          entry.value;\n         else\n           ok;\n         end;\n &quot;
 &amp; &quot;     else\n        ok;\n      end;\n    end,\n\n    insert =&gt; meth(self&quot;
 &amp; &quot;, key1, key2, value)\n      let index = ((key1 * self.size) + key2) % s&quot;
 &amp; &quot;elf.num;\n      var newentry = clone(HashEntry);\n      newentry.key1 :&quot;
 &amp; &quot;= key1;\n      newentry.key2 := key2;\n      newentry.value := value;\n&quot;
 &amp; &quot;      newentry.next := ok;\n\n      if self.table[index] isnot ok then\n&quot;
 &amp; &quot;        var entry = self.table[index];\n        loop\n          if entr&quot;
 &amp; &quot;y.next is ok then\n            entry.next := newentry;\n            exi&quot;
 &amp; &quot;t;\n          else\n            entry := entry.next;\n          end;\n &quot;
 &amp; &quot;       end;\n      else\n        self.table[index] := newentry;\n      &quot;
 &amp; &quot;end;\n    end,\n  };\n\nlet StraightEdge =\n  {\n    g =&gt; ok,\n    e =&gt;&quot;
 &amp; &quot; ok,\n    v1 =&gt; ok,\n    v2 =&gt; ok,\n\n    create =&gt; meth (self, t, v1, &quot;
 &amp; &quot;v2)\n      self.g := t.g;\n      self.v1 := v1;\n      self.v2 := v2;\n&quot;
 &amp; &quot;      self.e := graph_newEdge(v1.v, v2.v);\n      graph_moveEdge(self.e&quot;
 &amp; &quot;, v1.v, v2.v, false);\n      graph_setEdgeColor(self.e, edgeColor[norma&quot;
 &amp; &quot;l]);\n      self\n    end,\n\n    initialWidth =&gt; meth(self, size)\n   &quot;
 &amp; &quot;   graph_setEdgeWidth(self.e, size/10.0);\n    end,\n\n    movePktAlong&quot;
 &amp; &quot;Edge =&gt; meth(self, fromN, pkt)\n      if fromN is self.v1.id then\n    &quot;
 &amp; &quot;    graph_moveVertex(pkt, self.v2.pos[0], self.v2.pos[1], true);\n     &quot;
 &amp; &quot; else\n        graph_moveVertex(pkt, self.v1.pos[0], self.v1.pos[1], tr&quot;
 &amp; &quot;ue);\n      end;\n    end,\n\n  };\n\nlet CurvedEdge =\n  {\n    g =&gt; o&quot;
 &amp; &quot;k,\n    e =&gt; ok,\n    v1 =&gt; ok,\n    v2 =&gt; ok,\n    cvv12 =&gt; [[ok,ok],[&quot;
 &amp; &quot;ok,ok],[ok,ok],[ok,ok]],\n    cpp12 =&gt; [[ok,ok],[ok,ok],[ok,ok],[ok,ok]&quot;
 &amp; &quot;],\n    cvv21 =&gt; [[ok,ok],[ok,ok],[ok,ok],[ok,ok]],\n    cpp21 =&gt; [[ok,&quot;
 &amp; &quot;ok],[ok,ok],[ok,ok],[ok,ok]],\n\n    create =&gt; meth (self, t, v1, v2, x&quot;
 &amp; &quot;1, y1, x2, y2)\n      self.g := t.g;\n      self.v1 := v1;\n      self.&quot;
 &amp; &quot;v2 := v2;\n      let cpt1 = [x1, y1];\n      let cpt2 = [x2, y2];\n    &quot;
 &amp; &quot;  self.cpp12 := [v1.pos, [x1,y1], [x2,y2], v2.pos];\n      self.cpp21 :&quot;
 &amp; &quot;= [v2.pos, [x2,y2], [x1,y1&quot;;

CONST E90_2 =
   &quot;], v1.pos];\n      var cpt1v = invisibleCP(self.g, [x1, y1]);\n      va&quot;
 &amp; &quot;r cpt2v = invisibleCP(self.g, [x2, y2]);\n      self.cvv12 := [v1.v, cp&quot;
 &amp; &quot;t1v, cpt2v, v2.v];\n      self.cvv21 := [v2.v, cpt2v, cpt1v, v1.v];\n  &quot;
 &amp; &quot;    self.e := graph_newEdge(v1.v, v2.v);\n      graph_moveEdgeBezier(se&quot;
 &amp; &quot;lf.e, v1.v, v2.v, cpt1v, cpt2v, false);\n      graph_setEdgeColor(self.&quot;
 &amp; &quot;e, edgeColor[normal]);\n      self\n    end,\n\n    initialWidth =&gt; met&quot;
 &amp; &quot;h(self, size)\n      graph_setEdgeWidth(self.e, size/10.0);\n    end,\n&quot;
 &amp; &quot;\n    movePktAlongEdge =&gt; meth(self, fromN, pkt)\n      if fromN is sel&quot;
 &amp; &quot;f.v1.id then\n        MoveOnCurvedEdge(pkt, self.cpp12);\n      else\n &quot;
 &amp; &quot;       MoveOnCurvedEdge(pkt, self.cpp21);\n      end;\n      ok\n    en&quot;
 &amp; &quot;d,\n\n  };\n\nlet Node =\n  {\n    g =&gt; ok,\n    v =&gt; ok,\n    qs =&gt; 0,&quot;
 &amp; &quot;\n    id =&gt; ok,\n    maxQS =&gt; ok,\n    bounded =&gt; ok,\n    pos =&gt; ok,\n&quot;
 &amp; &quot;    vpkts =&gt; ok,\n    pktsSize =&gt; ok,\n    pktsPos =&gt; ok,\n\n    pktOut&quot;
 &amp; &quot;Lst =&gt; [],\n    pktInLst =&gt; [],\n\n    incQS =&gt; meth(self)\n      self.&quot;
 &amp; &quot;qs := self.qs + 1;\n    end,\n\n    decQS =&gt; meth(self)\n      self.qs &quot;
 &amp; &quot;:= self.qs - 1;\n    end,\n\n    updQS =&gt; meth(self, qs)\n       self.q&quot;
 &amp; &quot;s := qs;\n    end,\n\n    getQS =&gt; meth(self) self.qs end,\n\n    creat&quot;
 &amp; &quot;e =&gt; meth(self, t, id, x, y)\n      self.g := t.g;\n      self.id := id&quot;
 &amp; &quot;;\n      self.maxQS := t.maxQS;\n      self.bounded := t.bounded;\n    &quot;
 &amp; &quot;  self.pos := [x, y];\n      self.v := graph_newVertex(self.g);\n      &quot;
 &amp; &quot;graph_moveVertex(self.v, x, y, false); \n      graph_setVertexShape(sel&quot;
 &amp; &quot;f.v, \&quot;ellipse\&quot;);\n      graph_setVertexColor(self.v, nodeColor[normal&quot;
 &amp; &quot;]); \n      self\n    end,\n\n    initialSize =&gt; meth(self, size)\n    &quot;
 &amp; &quot;  graph_setVertexSize(self.v, size, size);\n      graph_setVertexBorder&quot;
 &amp; &quot;(self.v, size/10.0);\n      graph_setVertexBorderColor(self.v, borderCo&quot;
 &amp; &quot;lor);\n      self.vpkts := graph_newVertex(self.g);\n      self.pktsSiz&quot;
 &amp; &quot;e := size/3.0;\n      self.pktsPos := [self.pos[0] - (size/9.0),\n\t\t &quot;
 &amp; &quot;      self.pos[1] + (size/9.0)];\n      graph_moveVertex( self.vpkts, s&quot;
 &amp; &quot;elf.pktsPos[0], \n                        self.pktsPos[1], false);\n   &quot;
 &amp; &quot;   graph_setVertexSize(s&quot;;

CONST E90_3 =
   &quot;elf.vpkts, 0.0, 0.0);\n      graph_setVertexBorder(self.vpkts, self.pkt&quot;
 &amp; &quot;sSize/5.0);\n      graph_setVertexBorderColor(self.vpkts, borderColor);&quot;
 &amp; &quot;\n    end,\n\n    updateNodeState =&gt; meth(self)\n      if (self.qs is 0&quot;
 &amp; &quot;) or (self.qs is 1) then\n        graph_setVertexColor(self.v, nodeColo&quot;
 &amp; &quot;r[normal]);\n\tgraph_setVertexSize(self.vpkts, 0.0, 0.0);\n      else\n&quot;
 &amp; &quot;        if (self.qs &gt;= self.maxQS) and self.bounded then\n          gra&quot;
 &amp; &quot;ph_setVertexColor(self.v, nodeColor[congested]);\n        else\n       &quot;
 &amp; &quot;   graph_setVertexColor(self.v, nodeColor[normal]);\n        end;\n    &quot;
 &amp; &quot;    graph_setVertexSize(self.vpkts, self.pktsSize, self.pktsSize);\n\ti&quot;
 &amp; &quot;f self.qs is 2 then\n\t  graph_setVertexColor(self.vpkts, packetColor[t&quot;
 &amp; &quot;wo]);\n        else\n\t  graph_setVertexColor(self.vpkts, packetColor[t&quot;
 &amp; &quot;woplus]);\n        end;\n      end;\n    end,\n\n    pktOut =&gt; meth(sel&quot;
 &amp; &quot;f, pkt, edge)\n      self.pktOutLst := self.pktOutLst @\n          [{pk&quot;
 &amp; &quot;t =&gt; pkt, edge =&gt; edge}];\n    end,\n\n    pktIn =&gt; meth(self, pkt, edg&quot;
 &amp; &quot;e)\n      self.pktInLst := self.pktInLst @\n          [{pkt =&gt; pkt, edg&quot;
 &amp; &quot;e =&gt; edge}];\n    end,\n  };\n\nlet Packet =\n  {\n    g =&gt; ok,\n    v &quot;
 &amp; &quot;=&gt; ok,\n    src =&gt; ok,\n    dst =&gt; ok,\n    pktPos =&gt; ok,\n    discardF&quot;
 &amp; &quot;lag =&gt; false,\n\n    create =&gt; meth(self, t, src, dst, name)\n      sel&quot;
 &amp; &quot;f.g := t.g;\n      self.src := src;\n      self.dst := dst;\n      self&quot;
 &amp; &quot;.v := graph_newVertex(self.g);\n      self.pktPos := [t.node(src).pos[0&quot;
 &amp; &quot;],\n\t\t      t.node(src).pos[1]];\n      graph_moveVertex( self.v, sel&quot;
 &amp; &quot;f.pktPos[0], self.pktPos[1], false);\n      graph_setVertexSize(self.v,&quot;
 &amp; &quot; t.nodeSize/3.0, t.nodeSize/3.0);\n      graph_setVertexBorder(self.v, &quot;
 &amp; &quot;(t.nodeSize/3.0)/5.0);\n      graph_setVertexBorderColor(self.v, border&quot;
 &amp; &quot;Color);\n      graph_setVertexColor(self.v,  packetColor[one]);\n      &quot;
 &amp; &quot;t.node(src).incQS();\n      self\n    end,\n\n    move =&gt; meth(self, t,&quot;
 &amp; &quot; fromN, toN)\n      let edge = t.edge(fromN, toN);\n      t.node(fromN)&quot;
 &amp; &quot;.pktOut(self, edge);\n      t.node(toN).pktIn(self, edge);\n      graph&quot;
 &amp; &quot;_vertexToFront(self.v);\n    end,\n\n    setDiscardReady =&gt; meth(self)\n&quot;
 &amp; &quot;      graph_se&quot;;

CONST E90_4 =
   &quot;tVertexColor(self.v, packetDiscardColor);\n      graph_vertexToFront(se&quot;
 &amp; &quot;lf.v);\n      self.discardFlag := true\n    end,\n\n    discard =&gt; meth&quot;
 &amp; &quot;(self, vw)\n      vw.node(self.dst).decQS();\n      graph_removeVertex(&quot;
 &amp; &quot;self.v);\n    end,\n\n  };\n\nlet view =\n  {\n    graphvbt =&gt; graph_ne&quot;
 &amp; &quot;w(),\n    g =&gt; meth (self) self.graphvbt end,\n\n    nodeCnt =&gt; ok,\n  &quot;
 &amp; &quot;  maxQS =&gt; ok,\n    bounded =&gt; ok,\n\n    nodeSize =&gt; 0.0,\n\n    verte&quot;
 &amp; &quot;xFont =&gt; ok,\n\n    nodeT =&gt; [],\n    edgeT =&gt; [],\n    pktT =&gt; [],\n\n&quot;
 &amp; &quot;    node =&gt; meth(self, id)\n      self.nodeT[id];\n    end,\n\n    edge&quot;
 &amp; &quot; =&gt; meth(self, id1, id2)\n      var res = self.edgeT.lookup(id1, id2);\n&quot;
 &amp; &quot;      if res is ok then\n        res := self.edgeT.lookup(id2, id1);\n &quot;
 &amp; &quot;     end;\n      res\n    end,\n\n    packet =&gt; meth(self, id)\n      s&quot;
 &amp; &quot;elf.pktT[id];\n    end,\n\n    StartGraph =&gt; meth (self, nodeCnt, maxQS&quot;
 &amp; &quot;, bounded, xMax, yMax)\n      (* Set the World *)\n      graph_setWorld&quot;
 &amp; &quot;(self.graphvbt, 0.0, xMax, yMax, 0.0);\n      self.vertexFont := graph_&quot;
 &amp; &quot;newFont(\n         self.graphvbt, \&quot;Helvetica\&quot;, 0.5, \&quot;Roman\&quot;, \&quot;bold&quot;
 &amp; &quot;\&quot;, \&quot;*\&quot;);\n\n      (* Initialize some variables *)\n      self.nodeCn&quot;
 &amp; &quot;t := nodeCnt;\n      self.maxQS := maxQS;\n      self.bounded := bounde&quot;
 &amp; &quot;d;\n      self.nodeT := array_new(nodeCnt, ok);\n      self.edgeT := Ha&quot;
 &amp; &quot;shTable.create(nodeCnt);\n   end,\n  \n    NewNode =&gt; meth (self, id, x&quot;
 &amp; &quot;, y)\n      self.nodeT[id] :=\n          clone(Node).create(self, id, x&quot;
 &amp; &quot;, y);\n    end,\n\n    NewStraightEdge =&gt; meth (self, id1, id2)\n      &quot;
 &amp; &quot;self.edgeT.insert(id1, id2,\n                        clone(StraightEdge&quot;
 &amp; &quot;).create( self,\n                                                    se&quot;
 &amp; &quot;lf.node(id1),\n                                                    self&quot;
 &amp; &quot;.node(id2)));\n    end,\n\n\n    NewCurvedEdge =&gt; meth (self, id1, id2,&quot;
 &amp; &quot; x1, y1, x2, y2)\n      self.edgeT.insert(id1, id2,\n                  &quot;
 &amp; &quot;      clone(CurvedEdge).create( self,\n                                &quot;
 &amp; &quot;                  self.node(id1),\n                                    &quot;
 &amp; &quot;              self.node(id2),\n                                        &quot;
 &amp; &quot;          x1, y1, x2, y2)&quot;;

CONST E90_5 =
   &quot;);\n    end,\n\n    NewLabel =&gt; meth (self, label, x, y)\n      let vl &quot;
 &amp; &quot;= graph_newVertex(self.graphvbt);\n      graph_setVertexFont(vl, self.v&quot;
 &amp; &quot;ertexFont);\n      graph_setVertexSize(vl, 0.5, 0.5);\n      graph_setV&quot;
 &amp; &quot;ertexColor(vl, backgroundColor);\n      graph_moveVertex(vl, x, y, fals&quot;
 &amp; &quot;e);\n      graph_setVertexLabel(vl, label);\n      graph_setVertexLabel&quot;
 &amp; &quot;Color(vl, labelColor);\n    end,\n\n    EndGraph =&gt; meth (self)\n      &quot;
 &amp; &quot;let distance = proc(pt1, pt2)\n        let dx = pt2[1] - pt1[1], dy = p&quot;
 &amp; &quot;t2[0] - pt1[0];\n        (dx * dx) + (dy * dy)\n      end;\n      var m&quot;
 &amp; &quot;inDst = ok;\n      if #(self.nodeT) &gt; 1 then\n\tminDst := distance(self&quot;
 &amp; &quot;.nodeT[0].pos, self.nodeT[1].pos);\n\tfor i = 0 to #(self.nodeT) - 1 do&quot;
 &amp; &quot;\n\t  let pos1 = self.nodeT[i].pos;\n\t  for j = (i + 1) to #(self.node&quot;
 &amp; &quot;T) - 1 do\n\t    let curDst = distance(pos1, self.nodeT[j].pos);\n\t   &quot;
 &amp; &quot; if curDst &lt; minDst then minDst := curDst end\n\t  end\n\tend;\n\tminDs&quot;
 &amp; &quot;t := math_sqrt(minDst);\n      else\n\tminDst := 1.0\n      end;\n     &quot;
 &amp; &quot; self.nodeSize := minDst/1.5;\n      for i = 0 to #(self.nodeT) - 1 do\n&quot;
 &amp; &quot;        self.nodeT[i].initialSize(self.nodeSize);\n      end;\n      va&quot;
 &amp; &quot;r edge = self.edgeT.getfirst();\n      if edge isnot ok then\n        e&quot;
 &amp; &quot;dge.initialWidth(self.nodeSize);\n        loop\n          edge := self.&quot;
 &amp; &quot;edgeT.getnext();\n          if edge is ok then\n            exit;\n    &quot;
 &amp; &quot;      else\n            edge.initialWidth(self.nodeSize);\n          en&quot;
 &amp; &quot;d;\n        end;\n      end;\n    end,\n\n    StartPackets =&gt; meth (sel&quot;
 &amp; &quot;f, pktCnt)\n      self.pktT := array_new(pktCnt, ok);\n    end,\n\n    &quot;
 &amp; &quot;NewPacket =&gt; meth (self, id, source, dest, fewestHops, name)\n      sel&quot;
 &amp; &quot;f.pktT[id] :=\n          clone(Packet).create(self, source, dest, name)&quot;
 &amp; &quot;;\n    end,\n\n    EndPackets =&gt; meth (self)\n      for i = 0 to #(self&quot;
 &amp; &quot;.nodeT) - 1 do\n        self.nodeT[i].updateNodeState();\n      end;\n &quot;
 &amp; &quot;     graph_redisplay(self.graphvbt);\n    end,\n\n    MovePacket =&gt; met&quot;
 &amp; &quot;h (self, id, fromN, toN)\n      self.packet(id).move(self, fromN, toN);&quot;
 &amp; &quot;\n    end,\n\n    QueueSizes =&gt; meth (self, queueSizes)\n      for i = &quot;
 &amp; &quot;0 to #(self.nodeT) - &quot;;

CONST E90_6 =
   &quot;1 do\n        self.nodeT[i].updQS(queueSizes[i]);\n        if #(self.no&quot;
 &amp; &quot;deT[i].pktOutLst) isnot 0 then\n          self.nodeT[i].updateNodeState&quot;
 &amp; &quot;();\n        end;\n      end;\n      graph_redisplay(self.graphvbt);\n &quot;
 &amp; &quot;     for i = 0 to #(self.nodeT) - 1 do\n        for j = 0 to #(self.nod&quot;
 &amp; &quot;eT[i].pktOutLst) - 1 do\n          self.nodeT[i].pktOutLst[j].edge.move&quot;
 &amp; &quot;PktAlongEdge(\n                   i, self.nodeT[i].pktOutLst[j].pkt.v);&quot;
 &amp; &quot;\n        end;\n        self.nodeT[i].pktOutLst := [];\n      end;\n   &quot;
 &amp; &quot;   zeus_animate(self.graphvbt, 0.0, 1.0);\n    end,\n\n    Absorb =&gt; me&quot;
 &amp; &quot;th(self, pktID, nodeID)\n      let pkt = self.packet(pktID);\n      pkt&quot;
 &amp; &quot;.setDiscardReady();\n    end,\n\n    Step =&gt; meth(self)\n      graph_re&quot;
 &amp; &quot;display(self.graphvbt);\n      for i = 0 to #(self.nodeT) - 1 do\n     &quot;
 &amp; &quot;   let pktIns = self.nodeT[i].pktInLst;\n\tfor j = 0 to #(pktIns) - 1 d&quot;
 &amp; &quot;o\n          let pkt = pktIns[j].pkt;\n\t  if pkt.discardFlag is true t&quot;
 &amp; &quot;hen\n\t    pkt.discard(self)\n          end\n        end;\n        self&quot;
 &amp; &quot;.nodeT[i].updateNodeState();\n        self.nodeT[i].pktInLst := [];\n  &quot;
 &amp; &quot;    end;\n      graph_redisplay(self.graphvbt);\n    end,      \n\n  };&quot;
 &amp; &quot;\n&quot;;

CONST E91 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:29:09 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Eucl&quot;
 &amp; &quot;id.evt.\n;*************************************************************&quot;
 &amp; &quot;*******\n\n(VBox\n  (Border (Pen 1)\n    (Shape\n      (Height 75 - 25 &quot;
 &amp; &quot;+ Inf)\n      (Viewport\n        (HBox\n          (Glue 4 + Inf)\n     &quot;
 &amp; &quot;     (VBox\n            (Glue 6)\n            (Shape (Height 16 + 0)\n &quot;
 &amp; &quot;             (HBox Fill (Shape (Width + 0) (Height + 0) \n             &quot;
 &amp; &quot;                   \&quot;Code View events:   Stop? \&quot;) \n                  &quot;
 &amp; &quot;  (Boolean %stopatCodeEvents =TRUE \&quot;\&quot;)\n                    (Glue 10)&quot;
 &amp; &quot;\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n  &quot;
 &amp; &quot;                  (Shape (Width 80) (Numeric %waitatCodeEvents =1 \n   &quot;
 &amp; &quot;                                            (Min 0) (Max 100)))))\n    &quot;
 &amp; &quot;        (Glue 6)\n            (Shape (Height 16 + 0)\n              (HB&quot;
 &amp; &quot;ox Fill (Shape (Width + 0) (Height + 0) \n                             &quot;
 &amp; &quot;   \&quot;SetupTriangle:   Stop? \&quot;) \n                    (Boolean %stopAtS&quot;
 &amp; &quot;etupTriangle =TRUE \&quot;\&quot;)\n                    (Glue 10)\n              &quot;
 &amp; &quot;      (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                  &quot;
 &amp; &quot;  (Shape (Width 80) (Numeric %waitAtSetupTriangle =1 \n                &quot;
 &amp; &quot;                               (Min 0) (Max 100)))))\n            (Glue&quot;
 &amp; &quot; 6)\n            (Shape (Height 16 + 0)\n              (HBox Fill (Shap&quot;
 &amp; &quot;e (Width + 0) (Height + 0) \n                                \&quot;SetupSqu&quot;
 &amp; &quot;are:   Stop? \&quot;) \n                    (Boolean %stopAtSetupSquare =TRU&quot;
 &amp; &quot;E \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Wid&quot;
 &amp; &quot;th + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 8&quot;
 &amp; &quot;0) (Numeric %waitAtSetupSquare =1 \n                                   &quot;
 &amp; &quot;            (Min 0) (Max 100)))))\n            (Glue 6)\n            (S&quot;
 &amp; &quot;hape (&quot;;

CONST E91_0 =
   &quot;Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0&quot;
 &amp; &quot;) \n                                \&quot;LineAL:   Stop? \&quot;) \n           &quot;
 &amp; &quot;         (Boolean %stopAtLineAL =TRUE \&quot;\&quot;)\n                    (Glue &quot;
 &amp; &quot;10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n&quot;
 &amp; &quot;                    (Shape (Width 80) (Numeric %waitAtLineAL =1 \n     &quot;
 &amp; &quot;                                          (Min 0) (Max 100)))))\n      &quot;
 &amp; &quot;      (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox&quot;
 &amp; &quot; Fill (Shape (Width + 0) (Height + 0) \n                               &quot;
 &amp; &quot; \&quot;Triangle:   Stop? \&quot;) \n                    (Boolean %stopAtTriangle&quot;
 &amp; &quot; =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape&quot;
 &amp; &quot; (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Wi&quot;
 &amp; &quot;dth 80) (Numeric %waitAtTriangle =1 \n                                 &quot;
 &amp; &quot;              (Min 0) (Max 100)))))\n            (Glue 6)\n            &quot;
 &amp; &quot;(Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (He&quot;
 &amp; &quot;ight + 0) \n                                \&quot;Quad:   Stop? \&quot;) \n     &quot;
 &amp; &quot;               (Boolean %stopAtQuad =TRUE \&quot;\&quot;)\n                    (G&quot;
 &amp; &quot;lue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: &quot;
 &amp; &quot;\&quot;)\n                    (Shape (Width 80) (Numeric %waitAtQuad =1 \n  &quot;
 &amp; &quot;                                             (Min 0) (Max 100)))))\n   &quot;
 &amp; &quot;         (Glue 6)\n            (Shape (Height 16 + 0)\n              (H&quot;
 &amp; &quot;Box Fill (Shape (Width + 0) (Height + 0) \n                            &quot;
 &amp; &quot;    \&quot;Shear:   Stop? \&quot;) \n                    (Boolean %stopAtShear =T&quot;
 &amp; &quot;RUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (W&quot;
 &amp; &quot;idth + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width&quot;
 &amp; &quot; 80) (Numeric %waitAtShear =1 \n                                       &quot;
 &amp; &quot;        (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape&quot;
 &amp; &quot; (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height +&quot;
 &amp; &quot; 0) \n                                \&quot;RotateTriangle:   Stop? \&quot;) \n &quot;
 &amp; &quot;                   (Boolean %stopAtRotateTriangle =TRUE \&quot;\&quot;)\n        &quot;
 &amp; &quot;        &quot;;

CONST E91_1 =
   &quot;    (Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;We&quot;
 &amp; &quot;ight: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtRotate&quot;
 &amp; &quot;Triangle =1 \n                                               (Min 0) (M&quot;
 &amp; &quot;ax 100)))))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n&quot;
 &amp; &quot;              (HBox Fill (Shape (Width + 0) (Height + 0) \n            &quot;
 &amp; &quot;                    \&quot;RotateLine:   Stop? \&quot;) \n                    (Bo&quot;
 &amp; &quot;olean %stopAtRotateLine =TRUE \&quot;\&quot;)\n                    (Glue 10)\n   &quot;
 &amp; &quot;                 (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n       &quot;
 &amp; &quot;             (Shape (Width 80) (Numeric %waitAtRotateLine =1 \n        &quot;
 &amp; &quot;                                       (Min 0) (Max 100)))))\n         &quot;
 &amp; &quot;   (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox Fi&quot;
 &amp; &quot;ll (Shape (Width + 0) (Height + 0) \n                                \&quot;&quot;
 &amp; &quot;RotateAngle:   Stop? \&quot;) \n                    (Boolean %stopAtRotateAn&quot;
 &amp; &quot;gle =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Sh&quot;
 &amp; &quot;ape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape &quot;
 &amp; &quot;(Width 80) (Numeric %waitAtRotateAngle =1 \n                           &quot;
 &amp; &quot;                    (Min 0) (Max 100)))))\n            (Glue 6)\n      &quot;
 &amp; &quot;      (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width + &quot;
 &amp; &quot;0) (Height + 0) \n                                \&quot;HighlightLine:   St&quot;
 &amp; &quot;op? \&quot;) \n                    (Boolean %stopAtHighlightLine =TRUE \&quot;\&quot;)&quot;
 &amp; &quot;\n                    (Glue 10)\n                    (Shape (Width + 0)&quot;
 &amp; &quot; (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Num&quot;
 &amp; &quot;eric %waitAtHighlightLine =1 \n                                        &quot;
 &amp; &quot;       (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape &quot;
 &amp; &quot;(Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + &quot;
 &amp; &quot;0) \n                                \&quot;HighlightAngle:   Stop? \&quot;) \n  &quot;
 &amp; &quot;                  (Boolean %stopAtHighlightAngle =TRUE \&quot;\&quot;)\n         &quot;
 &amp; &quot;           (Glue 10)\n                    (Shape (Width + 0) (Height + &quot;
 &amp; &quot;0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric %waitA&quot;
 &amp; &quot;tHigh&quot;;

CONST E91_2 =
   &quot;lightAngle =1 \n                                               (Min 0) &quot;
 &amp; &quot;(Max 100)))))\n            (Glue 6)\n            (Shape (Height 16 + 0)&quot;
 &amp; &quot;\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n          &quot;
 &amp; &quot;                      \&quot;Remove:   Stop? \&quot;) \n                    (Bool&quot;
 &amp; &quot;ean %stopAtRemove =TRUE \&quot;\&quot;)\n                    (Glue 10)\n         &quot;
 &amp; &quot;           (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n             &quot;
 &amp; &quot;       (Shape (Width 80) (Numeric %waitAtRemove =1 \n                  &quot;
 &amp; &quot;                             (Min 0) (Max 100)))))\n            (Glue 6&quot;
 &amp; &quot;)\n            (Shape (Height 16 + 0)\n              (HBox Fill (Shape &quot;
 &amp; &quot;(Width + 0) (Height + 0) \n                                \&quot;Step:   St&quot;
 &amp; &quot;op? \&quot;) \n                    (Boolean %stopAtStep =TRUE \&quot;\&quot;)\n       &quot;
 &amp; &quot;             (Glue 10)\n                    (Shape (Width + 0) (Height &quot;
 &amp; &quot;+ 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric %wai&quot;
 &amp; &quot;tAtStep =1 \n                                               (Min 0) (Ma&quot;
 &amp; &quot;x 100)))))\n            (Glue 6)\n          )\n          (Glue 4)\n    &quot;
 &amp; &quot;      (VBox\n            (Glue 5)\n            (Shape (Width + 0) (Heig&quot;
 &amp; &quot;ht 16 + 0) \&quot;Cts:\&quot;)\n            (Button %eventCounts\n              (&quot;
 &amp; &quot;VBox\n                (Glue 6)\n                (HBox Fill (Shape (Widt&quot;
 &amp; &quot;h + 0) (Height 16 + 0) \n                                  (Text %ctOfS&quot;
 &amp; &quot;etupTriangle \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox &quot;
 &amp; &quot;Fill (Shape (Width + 0) (Height 16 + 0) \n                             &quot;
 &amp; &quot;     (Text %ctOfSetupSquare \&quot;0\&quot;)))\n                (Glue 6)\n       &quot;
 &amp; &quot;         (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n              &quot;
 &amp; &quot;                    (Text %ctOfLineAL \&quot;0\&quot;)))\n                (Glue 6&quot;
 &amp; &quot;)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n    &quot;
 &amp; &quot;                              (Text %ctOfTriangle \&quot;0\&quot;)))\n           &quot;
 &amp; &quot;     (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16&quot;
 &amp; &quot; + 0) \n                                  (Text %ctOfQuad \&quot;0\&quot;)))\n   &quot;
 &amp; &quot;             (Glue 6)\n                (HBox Fill (Shape (Width + 0) (H&quot;
 &amp; &quot;eight 16 &quot;;

CONST E91_3 =
   &quot;+ 0) \n                                  (Text %ctOfShear \&quot;0\&quot;)))\n   &quot;
 &amp; &quot;             (Glue 6)\n                (HBox Fill (Shape (Width + 0) (H&quot;
 &amp; &quot;eight 16 + 0) \n                                  (Text %ctOfRotateTria&quot;
 &amp; &quot;ngle \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Sh&quot;
 &amp; &quot;ape (Width + 0) (Height 16 + 0) \n                                  (Te&quot;
 &amp; &quot;xt %ctOfRotateLine \&quot;0\&quot;)))\n                (Glue 6)\n                &quot;
 &amp; &quot;(HBox Fill (Shape (Width + 0) (Height 16 + 0) \n                       &quot;
 &amp; &quot;           (Text %ctOfRotateAngle \&quot;0\&quot;)))\n                (Glue 6)\n &quot;
 &amp; &quot;               (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n        &quot;
 &amp; &quot;                          (Text %ctOfHighlightLine \&quot;0\&quot;)))\n          &quot;
 &amp; &quot;      (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 1&quot;
 &amp; &quot;6 + 0) \n                                  (Text %ctOfHighlightAngle \&quot;&quot;
 &amp; &quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Shape (Wi&quot;
 &amp; &quot;dth + 0) (Height 16 + 0) \n                                  (Text %ctO&quot;
 &amp; &quot;fRemove \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill &quot;
 &amp; &quot;(Shape (Width + 0) (Height 16 + 0) \n                                  &quot;
 &amp; &quot;(Text %ctOfStep \&quot;0\&quot;)))\n                (Glue 3))))\n          Fill\n&quot;
 &amp; &quot;          (Glue 4 + Inf)\n        )\n      )\n    )\n  )\n)\n&quot;;

CONST E92 =
   &quot;  (Vertex a 0.2 0.5)\n  (Vertex b 0.5 0.8)\n  (Vertex c 0.8 0.5) \n  (V&quot;
 &amp; &quot;ertex d 0.2 0.2)\n  (Vertex e 0.8 0.2) \n  (Edge ba b a R)\n  (Edge cb &quot;
 &amp; &quot;c b R)\n  (Edge ac a c R)\n  (Edge ad a d R)\n  (Edge de d e R) \n  (Ed&quot;
 &amp; &quot;ge ec e c R)\n  (Edge dc d c R) \n  (Find a e 2)\n&quot;;

CONST E93 =
   &quot;@DFSTC\nPROCEDURE DFSTC(a: ARRAY OF ARRAY OF BOOLEAN; V: INTEGER) @=\n &quot;
 &amp; &quot; VAR now: INTEGER := -1;\n      val := NEW(REF ARRAY OF INTEGER, V);\n &quot;
 &amp; &quot;     current: INTEGER;\n\n  BEGIN\n    @7 FOR k := 0 TO V-1 DO @\n    @&quot;
 &amp; &quot;8   now := -1; current := k; @\n    @9   FOR j := V-1 DO val[j] := -1 E&quot;
 &amp; &quot;ND; @\n    @10     Visit(k) @\n         END;\n       END;\n  END DFSTC;&quot;
 &amp; &quot;\n@DFSTC\n\n  @VISIT\n  PROCEDURE Visit(k: INTEGER) @=\n    BEGIN\n    &quot;
 &amp; &quot;@1 INC(now); val[k] := now;@\n    @2 a[current, t] := TRUE; @\n    @3 F&quot;
 &amp; &quot;OR t := 0 TO V-1 DO @\n    @4  IF a[k, t] THEN @\n    @5    IF val[t] &lt;&quot;
 &amp; &quot; 0 THEN @\n    @6      Visit(t); @\n          END;\n        END;\n     &quot;
 &amp; &quot; END;\n    END Visit;\n  @VISIT\n\n&quot;;

CONST E94 =
   &quot;; Copyright (C) 1992, Digital Equipment Corporation\n; All rights reser&quot;
 &amp; &quot;ved.\n; See the file COPYRIGHT for a full description.\n\n\n(VBox \n  (&quot;
 &amp; &quot;Macro TB BOA (text)\n    `(Shape (Width 60) (Text RightAlign ,text)))\n&quot;
 &amp; &quot;  (Glue 10)\n  (HBox (TB \&quot;N: \&quot;) (Numeric (Min 1) (Max 1000) %N =50) F&quot;
 &amp; &quot;ill)\n  (Glue 10)\n  (HBox (TB \&quot;k: \&quot;) (Numeric (Min 1) (Max 1000) %k &quot;
 &amp; &quot;=5) Fill)\n  (Glue 10))\n&quot;;

CONST E95 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:37:06 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Subt&quot;
 &amp; &quot;ype.evt.\n;************************************************************&quot;
 &amp; &quot;********\n\n(VBox\n  (Rim\n    (Pen 2)\n    (HBox\n      (VBox (Glue 4)&quot;
 &amp; &quot; (Shape (Height + Inf) (Button %clear \&quot;CLEAR\&quot;)) (Glue 4))\n      (Glu&quot;
 &amp; &quot;e 4)\n      (VBox\n        (Boolean =TRUE %alg (Text LeftAlign \&quot;Algori&quot;
 &amp; &quot;thm events\&quot;))\n        (Boolean =FALSE %zeus (Text LeftAlign \&quot;Zeus ev&quot;
 &amp; &quot;ents\&quot;))\n        (Boolean =TRUE %args (Text LeftAlign \&quot;Display args t&quot;
 &amp; &quot;o events\&quot;)))\n      Fill))\n  (Bar 1)\n  (Shape (ShadowSize 0) (Height&quot;
 &amp; &quot; 200 + INF) (TextEdit ReadOnly %transcript)))\n&quot;;

CONST E96 =
   &quot;(* Copyright (C) 1994, Digital Equipment Corporation           *)\n(* A&quot;
 &amp; &quot;ll rights reserved.                                        *)\n(* See t&quot;
 &amp; &quot;he file COPYRIGHT for a full description.              *)\n\n@FirstFit\n&quot;
 &amp; &quot;void first_fit (B, N)@\nint B, N;\n{\n    int i, b, bin;\n    float wei&quot;
 &amp; &quot;ght, *bins, lost = 0.0;\n\n    @1 bins = (float *) malloc(B * sizeof (f&quot;
 &amp; &quot;loat));@\n    @2 for (b = 0; b &lt; B; b++) bins[b] := 0.0;@\n    @3 for (&quot;
 &amp; &quot;i = 0; i &lt; N; i++) {@\n        @4 weight = random_float () / 2.0;@\n   &quot;
 &amp; &quot;     for (@5 bin = 0@; \n             @6 (bin &lt; B) &amp;&amp; (bins[bin] + weig&quot;
 &amp; &quot;ht &gt; 1.0)@; \n             @7 bin++@) /*EMPTY*/;\n        @8 if (bin = &quot;
 &amp; &quot;B) @\n            @9 lost += weight;@\n        else\n            @10 bi&quot;
 &amp; &quot;ns[bin] += weight;@\n    }\n}\n@FirstFit\n&quot;;

CONST E97 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:37:06 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Sear&quot;
 &amp; &quot;chTree.evt.\n;*********************************************************&quot;
 &amp; &quot;***********\n\n(VBox\n  (Rim\n    (Pen 2)\n    (HBox\n      (VBox (Glue&quot;
 &amp; &quot; 4) (Shape (Height + Inf) (Button %clear \&quot;CLEAR\&quot;)) (Glue 4))\n      (&quot;
 &amp; &quot;Glue 4)\n      (VBox\n        (Boolean =TRUE %alg (Text LeftAlign \&quot;Alg&quot;
 &amp; &quot;orithm events\&quot;))\n        (Boolean =FALSE %zeus (Text LeftAlign \&quot;Zeus&quot;
 &amp; &quot; events\&quot;))\n        (Boolean =TRUE %args (Text LeftAlign \&quot;Display arg&quot;
 &amp; &quot;s to events\&quot;)))\n      Fill))\n  (Bar 1)\n  (Shape (ShadowSize 0) (Hei&quot;
 &amp; &quot;ght 200 + INF) (TextEdit ReadOnly %transcript)))\n&quot;;

CONST E98 =
   &quot;  TYPE\n    Type = OBJECT END;\n    TypeBot = Type BRANDED OBJECT END;\n&quot;
 &amp; &quot;    TypeTop = Type BRANDED OBJECT END;\n    TypeFun = Type BRANDED OBJE&quot;
 &amp; &quot;CT dom,rng: Type END;\n\n  VAR \n    trail: ARRAY [0..1000] OF RECORD l&quot;
 &amp; &quot;ft,rht: Type END;\n    top: INTEGER := -1;\n\n  PROCEDURE Notice(lft, r&quot;
 &amp; &quot;ht: Type) =\n  BEGIN\n    INC(top);\n    trail[top].lft := lft;\n    tr&quot;
 &amp; &quot;ail[top].rht := rht;\n  END Notice;\n\n  PROCEDURE Seen(lft, rht: Type)&quot;
 &amp; &quot;: BOOLEAN =\n  BEGIN\n    FOR i:=0 TO top DO\n      IF (trail[i].lft=lf&quot;
 &amp; &quot;t) AND (trail[i].rht=rht) THEN RETURN TRUE END;\n    END;\n    RETURN F&quot;
 &amp; &quot;ALSE;\n  END Seen;\n\n@In\n  PROCEDURE In(lft, rht: Type): BOOLEAN = @\n&quot;
 &amp; &quot;  BEGIN\n@1    IF Seen(lft, rht) @ THEN @12 RETURN TRUE @ END;\n@2    N&quot;
 &amp; &quot;otice(lft, rht); @\n@3    TYPECASE lft OF @\n@4    | TypeBot =&gt; RETURN &quot;
 &amp; &quot;TRUE; @\n@5    | TypeTop =&gt; RETURN ISTYPE(rht, TypeTop); @\n@6    | Typ&quot;
 &amp; &quot;eFun(lftFun) =&gt;\n       TYPECASE rht OF @\n@7        | TypeBot =&gt; RETUR&quot;
 &amp; &quot;N FALSE; @\n@8        | TypeTop =&gt; RETURN TRUE; @\n       | TypeFun(rht&quot;
 &amp; &quot;Fun) =&gt;\n          RETURN \n@10             In(rhtFun.dom, lftFun.dom) &quot;
 &amp; &quot;@ AND\n@11             In(lftFun.rng, rhtFun.rng); @\n       END;\n    &quot;
 &amp; &quot;END;\n  END In;\n@In\n&quot;;

CONST E99 =
   &quot;; Copyright (C) 1992, Digital Equipment Corporation                    &quot;
 &amp; &quot;     \n; All rights reserved.                                          &quot;
 &amp; &quot;            \n; See the file COPYRIGHT for a full description.         &quot;
 &amp; &quot;                   \n;                                                 &quot;
 &amp; &quot;                          \n; Last modified on Wed Jun 15 13:18:19 PDT &quot;
 &amp; &quot;1994 by heydon                   \n\n(Shape\n  (Width + 0)\n  (Height +&quot;
 &amp; &quot; 0)\n  (VBox\n    (Glue 10)\n    (HBox\n      Fill\n      (Shape (Width&quot;
 &amp; &quot; + 0) \&quot;Number of Nodes: \&quot;)\n      (Numeric %nodeCnt =10 (Min 1) (Max &quot;
 &amp; &quot;1000)))\n    (Glue 4)\n    (Ridge 2)\n    (Glue 4)\n    (VBox\n      (H&quot;
 &amp; &quot;Box Fill \&quot;Insertion Order:\&quot; Fill)\n      (Glue 4)\n      (Radio\n    &quot;
 &amp; &quot;    %inputtype\n        =rand\n        (HBox\n          Fill\n         &quot;
 &amp; &quot; (Choice %rand \&quot;Random\&quot;)\n          (Glue 6)\n          (Choice %inc &quot;
 &amp; &quot;\&quot;Increasing\&quot;)\n          (Glue 6)\n          (Choice %dec \&quot;Decreasin&quot;
 &amp; &quot;g\&quot;)\n          Fill)))\n    (Glue 4)\n    (Ridge 2)\n    (Glue 4)\n   &quot;
 &amp; &quot; (VBox\n      (HBox Fill \&quot;Deletion Order:\&quot; Fill)\n      (Glue 4)\n   &quot;
 &amp; &quot;   (Radio\n        %deletetype\n        =del_rand\n        (HBox\n     &quot;
 &amp; &quot;     Fill\n          (Choice %del_rand \&quot;Random\&quot;)\n          (Glue 6)\n&quot;
 &amp; &quot;          (Choice %del_inc \&quot;Increasing\&quot;)\n          (Glue 6)\n       &quot;
 &amp; &quot;   (Choice %del_dec \&quot;Decreasing\&quot;)\n          Fill)))\n    (Glue 4)\n &quot;
 &amp; &quot;   (Ridge 2)\n    (Glue 4)\n    (VBox\n      (HBox Fill \&quot;Random Sequen&quot;
 &amp; &quot;ce:\&quot; Fill)\n      (Glue 4)\n      (Radio\n        =randomRand\n       &quot;
 &amp; &quot; (HBox\n          Fill\n          (Choice %randomRand \&quot;Random\&quot;)\n    &quot;
 &amp; &quot;      (Glue 6)\n          (Choice %fixedRand \&quot;Fixed\&quot;)\n          Fill&quot;
 &amp; &quot;)))\n    (Glue 10)))\n    \n&quot;;

CONST E100 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:37:06 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Pars&quot;
 &amp; &quot;e.evt.\n;**************************************************************&quot;
 &amp; &quot;******\n\n(VBox\n  (Rim\n    (Pen 2)\n    (HBox\n      (VBox (Glue 4) (&quot;
 &amp; &quot;Shape (Height + Inf) (Button %clear \&quot;CLEAR\&quot;)) (Glue 4))\n      (Glue &quot;
 &amp; &quot;4)\n      (VBox\n        (Boolean =TRUE %alg (Text LeftAlign \&quot;Algorith&quot;
 &amp; &quot;m events\&quot;))\n        (Boolean =FALSE %zeus (Text LeftAlign \&quot;Zeus even&quot;
 &amp; &quot;ts\&quot;))\n        (Boolean =TRUE %args (Text LeftAlign \&quot;Display args to &quot;
 &amp; &quot;events\&quot;)))\n      Fill))\n  (Bar 1)\n  (Shape (ShadowSize 0) (Height 2&quot;
 &amp; &quot;00 + INF) (TextEdit ReadOnly %transcript)))\n&quot;;

CONST E101 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:37:06 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Unio&quot;
 &amp; &quot;nFind.evt.\n;**********************************************************&quot;
 &amp; &quot;**********\n\n(VBox\n  (Rim\n    (Pen 2)\n    (HBox\n      (VBox (Glue &quot;
 &amp; &quot;4) (Shape (Height + Inf) (Button %clear \&quot;CLEAR\&quot;)) (Glue 4))\n      (G&quot;
 &amp; &quot;lue 4)\n      (VBox\n        (Boolean =TRUE %alg (Text LeftAlign \&quot;Algo&quot;
 &amp; &quot;rithm events\&quot;))\n        (Boolean =FALSE %zeus (Text LeftAlign \&quot;Zeus &quot;
 &amp; &quot;events\&quot;))\n        (Boolean =TRUE %args (Text LeftAlign \&quot;Display args&quot;
 &amp; &quot; to events\&quot;)))\n      Fill))\n  (Bar 1)\n  (Shape (ShadowSize 0) (Heig&quot;
 &amp; &quot;ht 200 + INF) (TextEdit ReadOnly %transcript)))\n&quot;;

CONST E102 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:37:06 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Mini&quot;
 &amp; &quot;max.evt.\n;************************************************************&quot;
 &amp; &quot;********\n\n(VBox\n  (Rim\n    (Pen 2)\n    (HBox\n      (VBox (Glue 4)&quot;
 &amp; &quot; (Shape (Height + Inf) (Button %clear \&quot;CLEAR\&quot;)) (Glue 4))\n      (Glu&quot;
 &amp; &quot;e 4)\n      (VBox\n        (Boolean =TRUE %alg (Text LeftAlign \&quot;Algori&quot;
 &amp; &quot;thm events\&quot;))\n        (Boolean =FALSE %zeus (Text LeftAlign \&quot;Zeus ev&quot;
 &amp; &quot;ents\&quot;))\n        (Boolean =TRUE %args (Text LeftAlign \&quot;Display args t&quot;
 &amp; &quot;o events\&quot;)))\n      Fill))\n  (Bar 1)\n  (Shape (ShadowSize 0) (Height&quot;
 &amp; &quot; 200 + INF) (TextEdit ReadOnly %transcript)))\n&quot;;

CONST E103 =
   &quot;; Copyright (C) 1992, Digital Equipment Corporation\n; All rights reser&quot;
 &amp; &quot;ved.\n; See the file COPYRIGHT for a full description.\n\n(Rim\n  (Pen &quot;
 &amp; &quot;20)\n  (VBox\n    (HBox (Shape (Width + 0) \&quot;How many elements to sort?&quot;
 &amp; &quot;\&quot;) (Numeric %data))\n    (Glue 5)\n    (HBox\n      (Glue 24)\n      (&quot;
 &amp; &quot;Radio\n        (VBox\n          (Choice %random =TRUE (Text LeftAlign \&quot;&quot;
 &amp; &quot;Random\&quot;))\n          (Choice %increasing (Text LeftAlign \&quot;Increasing\&quot;&quot;
 &amp; &quot;))\n          (Choice %decreasing (Text LeftAlign \&quot;Decreasing\&quot;))))\n &quot;
 &amp; &quot;     Fill)))&quot;;

CONST E104 =
   &quot;; Copyright (C) 1992, Digital Equipment Corporation\n; All rights reser&quot;
 &amp; &quot;ved.\n; See the file COPYRIGHT for a full description.\n\n(VBox\n  (HBo&quot;
 &amp; &quot;x\n    (Shape (Width + 0) (Height + 0) \&quot;Probes: \&quot;)\n    (Shape (Width&quot;
 &amp; &quot; 60) (Numeric HideButtons  (Max 500000) %probeCount =0))\n    (Glue 6) &quot;
 &amp; &quot;\n    (Shape (Width + 0) (Height + 0)  \&quot;    Pattern: \&quot;)\n    (TextEdi&quot;
 &amp; &quot;t ReadOnly (Font \&quot;-*-courier-bold-r-*-*-*-180-*-*-*-*-*-*\&quot;)\n      %p&quot;
 &amp; &quot;attern =\&quot;\&quot;)\n    Fill)\n  (Shape (Height 100 + Inf) (Width 250 + Inf)&quot;
 &amp; &quot;\n    (TextEdit  ReadOnly (Font \&quot;-*-courier-bold-r-*-*-*-180-*-*-*-*-*&quot;
 &amp; &quot;-*\&quot;)\n      %text =\&quot;\&quot;)))\n&quot;;

CONST E105 =
   &quot;; Copyright (C) 1994, Digital Equipment Corporation                    &quot;
 &amp; &quot;     \n; All rights reserved.                                          &quot;
 &amp; &quot;            \n; See the file COPYRIGHT for a full description.         &quot;
 &amp; &quot;                   \n;                                                 &quot;
 &amp; &quot;                          \n; Last modified on Thu Aug 18 14:08:09 PDT &quot;
 &amp; &quot;1994 by heydon                   \n\n(Rim (Pen 10)\n  (VBox\n    (HBox\n&quot;
 &amp; &quot;      (Text RightAlign \&quot;Input:\&quot;)\n      (Glue 3)\n      (Radio %input&quot;
 &amp; &quot;From =randomInput\n        (HBox (ShadowSize 0)\n          (LinkButton &quot;
 &amp; &quot;(For randomPage)\n            (Choice (ShadowSize 1.5) %randomInput \&quot;R&quot;
 &amp; &quot;andom\&quot;))\n          (Glue 3)\n          (LinkButton (For filePage)\n  &quot;
 &amp; &quot;          (Choice (ShadowSize 1.5) %fileInput \&quot;From File\&quot;))\n        &quot;
 &amp; &quot;)\n      )\n      Fill\n    )\n    (Glue 5)\n    (TSplit %tsplit Flex (&quot;
 &amp; &quot;Which randomPage)\n      (VBox %randomPage\n  \t(HBox\n  \t  (VBox\n  \t&quot;
 &amp; &quot;    (Text RightAlign \&quot;# of Sets:\&quot;)\n  \t    (Glue 2)\n  \t    (Text R&quot;
 &amp; &quot;ightAlign \&quot;# of Unions:\&quot;)\n  \t  )\n  \t  (Glue 2)\n  \t  (VBox\n  \t&quot;
 &amp; &quot;    (Numeric %setCnt (Min 2) =20)\n  \t    (Glue 2)\n  \t    (Numeric %&quot;
 &amp; &quot;unionCnt (Min 0) =20)\n  \t  )\n  \t  Fill\n  \t)\n  \t(Glue 5)\n  \tRi&quot;
 &amp; &quot;dge\n  \t(Glue 5)\n  \t(HBox\n  \t  Fill\n  \t  (Boolean %fixedSeed \&quot;U&quot;
 &amp; &quot;se fixed random seed?\&quot;)\n  \t  Fill\n  \t)\n      )\n      (VBox %file&quot;
 &amp; &quot;Page\n  \t(DirMenu %dirMenu (For browser))\n  \t(Glue 4)\n  \t(Shape (H&quot;
 &amp; &quot;eight 60 + Inf)\n  \t  (Frame Lowered (BgColor \&quot;White\&quot;)\n  \t    (Fil&quot;
 &amp; &quot;eBrowser %browser ReadOnly (Suffixes \&quot;sx\&quot;))\n  \t  )\n  \t)\n  \t(Glu&quot;
 &amp; &quot;e 4)\n  \t(HBox\n  \t  \&quot;File:\&quot;\n  \t  (Frame Lowered (BgColor \&quot;White&quot;
 &amp; &quot;\&quot;)\n  \t    (Helper (For browser) FirstFocus)\n  \t  )\n  \t)\n      )&quot;
 &amp; &quot;   \n    )\n  )\n)\n&quot;;

CONST E106 =
   &quot;; Copyright (C) 1993, Digital Equipment Corporation\n; All rights reser&quot;
 &amp; &quot;ved.\n; See the file COPYRIGHT for a full description.\n\n(VBox\n (Bar)&quot;
 &amp; &quot;\n (HBox\n   (Glue 5)\n   (VBox\n     (Glue 5)\n     (Text Center \&quot;Pla&quot;
 &amp; &quot;yer A\&quot;)\n     (Glue 5)\n     (Radio %AHumanComp =AHuman\n       (VBox\n&quot;
 &amp; &quot;         (Choice %AHuman  (Text LeftAlign \&quot;Human\&quot;))\n         (Choice&quot;
 &amp; &quot; %AMinimax (Text LeftAlign \&quot;Minimax\&quot;))\n         (HBox (Glue 30)\n   &quot;
 &amp; &quot;        (VBox\n             (HBox (Text \&quot;Depth:\&quot;) (Glue 5)\n         &quot;
 &amp; &quot;      (Numeric (Min 1) (Max 10) %ADepth =3))\n               (VBox (Tex&quot;
 &amp; &quot;t LeftAlign \&quot;Heuristic:\&quot;)\n               (HBox (Glue 10)\n          &quot;
 &amp; &quot;        (Radio %AHexpawn =AHPTrivial\n                     (VBox\n     &quot;
 &amp; &quot;                   (Choice %AHPTrivial (Text LeftAlign \&quot;Trivial\&quot;))\n &quot;
 &amp; &quot;                       (Choice %AHPSmart (Text LeftAlign \&quot;Smart\&quot;))\n &quot;
 &amp; &quot;                       Fill\n                      )\n                 &quot;
 &amp; &quot;  )\n                 )\n               )\n              )\n           &quot;
 &amp; &quot; )\n         )\n      )\n   )\n  (Glue 5)                 \n  (Bar)\n  &quot;
 &amp; &quot;(Glue 5)\n(HBox\n  (VBox\n     (Glue 5)\n     (Text Center \&quot;Player B\&quot;&quot;
 &amp; &quot;)\n     (Glue 5)\n     (Radio %BHumanComp =BHuman\n       (VBox\n      &quot;
 &amp; &quot;   (Choice %BHuman  (Text LeftAlign \&quot;Human\&quot;))\n         (Choice %BMin&quot;
 &amp; &quot;imax (Text LeftAlign \&quot;Minimax\&quot;))\n         (HBox (Glue 30)\n         &quot;
 &amp; &quot;   (VBox\n              (HBox (Text \&quot;Depth:\&quot;) (Glue 5)\n             &quot;
 &amp; &quot;       (Numeric (Min 1) (Max 10) %BDepth =3))\n              (VBox (Tex&quot;
 &amp; &quot;t LeftAlign \&quot;Heuristic:\&quot;)\n              (HBox (Glue 10)\n           &quot;
 &amp; &quot;         (Radio %BHexpawn =BHPTrivial\n                      (VBox\n   &quot;
 &amp; &quot;                     (Choice %BHPTrivial (Text LeftAlign \&quot;Trivial\&quot;))\n&quot;
 &amp; &quot;                        (Choice %BHPSmart (Text LeftAlign \&quot;Smart\&quot;))\n&quot;
 &amp; &quot;                        Fill\n                      )\n                &quot;
 &amp; &quot;     )\n                 )\n               ))\n              )\n       &quot;
 &amp; &quot;     )\n         )\n      )\n   ) \n(Glue 5)\n))\n\n&quot;;

CONST E107 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:29:09 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Whee&quot;
 &amp; &quot;ler.evt.\n;************************************************************&quot;
 &amp; &quot;********\n\n(VBox\n  (Border (Pen 1)\n    (Shape\n      (Height 75 - 25&quot;
 &amp; &quot; + Inf)\n      (Viewport\n        (HBox\n          (Glue 4 + Inf)\n    &quot;
 &amp; &quot;      (VBox\n            (Glue 6)\n            (Shape (Height 16 + 0)\n&quot;
 &amp; &quot;              (HBox Fill (Shape (Width + 0) (Height + 0) \n            &quot;
 &amp; &quot;                    \&quot;Code View events:   Stop? \&quot;) \n                 &quot;
 &amp; &quot;   (Boolean %stopatCodeEvents =TRUE \&quot;\&quot;)\n                    (Glue 10&quot;
 &amp; &quot;)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n &quot;
 &amp; &quot;                   (Shape (Width 80) (Numeric %waitatCodeEvents =1 \n  &quot;
 &amp; &quot;                                             (Min 0) (Max 100)))))\n   &quot;
 &amp; &quot;         (Glue 6)\n            (Shape (Height 16 + 0)\n              (H&quot;
 &amp; &quot;Box Fill (Shape (Width + 0) (Height + 0) \n                            &quot;
 &amp; &quot;    \&quot;StartPermute:   Stop? \&quot;) \n                    (Boolean %stopAtS&quot;
 &amp; &quot;tartPermute =TRUE \&quot;\&quot;)\n                    (Glue 10)\n               &quot;
 &amp; &quot;     (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                   &quot;
 &amp; &quot; (Shape (Width 80) (Numeric %waitAtStartPermute =1 \n                  &quot;
 &amp; &quot;                             (Min 0) (Max 100)))))\n            (Glue 6&quot;
 &amp; &quot;)\n            (Shape (Height 16 + 0)\n              (HBox Fill (Shape &quot;
 &amp; &quot;(Width + 0) (Height + 0) \n                                \&quot;NextRotati&quot;
 &amp; &quot;on:   Stop? \&quot;) \n                    (Boolean %stopAtNextRotation =TRU&quot;
 &amp; &quot;E \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Wid&quot;
 &amp; &quot;th + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 8&quot;
 &amp; &quot;0) (Numeric %waitAtNextRotation =1 \n                                  &quot;
 &amp; &quot;             (Min 0) (Max 100)))))\n            (Glue 6)\n            (&quot;
 &amp; &quot;Shape &quot;;

CONST E107_0 =
   &quot;(Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + &quot;
 &amp; &quot;0) \n                                \&quot;RotationsSorted:   Stop? \&quot;) \n &quot;
 &amp; &quot;                   (Boolean %stopAtRotationsSorted =TRUE \&quot;\&quot;)\n       &quot;
 &amp; &quot;             (Glue 10)\n                    (Shape (Width + 0) (Height &quot;
 &amp; &quot;+ 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric %wai&quot;
 &amp; &quot;tAtRotationsSorted =1 \n                                               &quot;
 &amp; &quot;(Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape (Height&quot;
 &amp; &quot; 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n  &quot;
 &amp; &quot;                              \&quot;PermuteDone:   Stop? \&quot;) \n            &quot;
 &amp; &quot;        (Boolean %stopAtPermuteDone =TRUE \&quot;\&quot;)\n                    (G&quot;
 &amp; &quot;lue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: &quot;
 &amp; &quot;\&quot;)\n                    (Shape (Width 80) (Numeric %waitAtPermuteDone &quot;
 &amp; &quot;=1 \n                                               (Min 0) (Max 100)))&quot;
 &amp; &quot;))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n         &quot;
 &amp; &quot;     (HBox Fill (Shape (Width + 0) (Height + 0) \n                     &quot;
 &amp; &quot;           \&quot;StartEncode:   Stop? \&quot;) \n                    (Boolean %s&quot;
 &amp; &quot;topAtStartEncode =TRUE \&quot;\&quot;)\n                    (Glue 10)\n          &quot;
 &amp; &quot;          (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n              &quot;
 &amp; &quot;      (Shape (Width 80) (Numeric %waitAtStartEncode =1 \n              &quot;
 &amp; &quot;                                 (Min 0) (Max 100)))))\n            (Gl&quot;
 &amp; &quot;ue 6)\n            (Shape (Height 16 + 0)\n              (HBox Fill (Sh&quot;
 &amp; &quot;ape (Width + 0) (Height + 0) \n                                \&quot;Encode&quot;
 &amp; &quot;NextChar:   Stop? \&quot;) \n                    (Boolean %stopAtEncodeNextC&quot;
 &amp; &quot;har =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Sh&quot;
 &amp; &quot;ape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape &quot;
 &amp; &quot;(Width 80) (Numeric %waitAtEncodeNextChar =1 \n                        &quot;
 &amp; &quot;                       (Min 0) (Max 100)))))\n            (Glue 6)\n   &quot;
 &amp; &quot;         (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width&quot;
 &amp; &quot; + 0) (Height + 0) \n                                \&quot;EncodeDistinctCo&quot;
 &amp; &quot;unt:&quot;;

CONST E107_1 =
   &quot;   Stop? \&quot;) \n                    (Boolean %stopAtEncodeDistinctCount &quot;
 &amp; &quot;=TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape &quot;
 &amp; &quot;(Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Wid&quot;
 &amp; &quot;th 80) (Numeric %waitAtEncodeDistinctCount =1 \n                       &quot;
 &amp; &quot;                        (Min 0) (Max 100)))))\n            (Glue 6)\n  &quot;
 &amp; &quot;          (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Widt&quot;
 &amp; &quot;h + 0) (Height + 0) \n                                \&quot;EncodeFoundCode&quot;
 &amp; &quot;:   Stop? \&quot;) \n                    (Boolean %stopAtEncodeFoundCode =TR&quot;
 &amp; &quot;UE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Wi&quot;
 &amp; &quot;dth + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width &quot;
 &amp; &quot;80) (Numeric %waitAtEncodeFoundCode =1 \n                              &quot;
 &amp; &quot;                 (Min 0) (Max 100)))))\n            (Glue 6)\n         &quot;
 &amp; &quot;   (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) &quot;
 &amp; &quot;(Height + 0) \n                                \&quot;EncodeDone:   Stop? \&quot;&quot;
 &amp; &quot;) \n                    (Boolean %stopAtEncodeDone =TRUE \&quot;\&quot;)\n       &quot;
 &amp; &quot;             (Glue 10)\n                    (Shape (Width + 0) (Height &quot;
 &amp; &quot;+ 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric %wai&quot;
 &amp; &quot;tAtEncodeDone =1 \n                                               (Min &quot;
 &amp; &quot;0) (Max 100)))))\n            (Glue 6)\n            (Shape (Height 16 +&quot;
 &amp; &quot; 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n       &quot;
 &amp; &quot;                         \&quot;InitDecode:   Stop? \&quot;) \n                  &quot;
 &amp; &quot;  (Boolean %stopAtInitDecode =TRUE \&quot;\&quot;)\n                    (Glue 10)&quot;
 &amp; &quot;\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n  &quot;
 &amp; &quot;                  (Shape (Width 80) (Numeric %waitAtInitDecode =1 \n   &quot;
 &amp; &quot;                                            (Min 0) (Max 100)))))\n    &quot;
 &amp; &quot;        (Glue 6)\n            (Shape (Height 16 + 0)\n              (HB&quot;
 &amp; &quot;ox Fill (Shape (Width + 0) (Height + 0) \n                             &quot;
 &amp; &quot;   \&quot;StartDecode:   Stop? \&quot;) \n                    (Boolean %stopAtSta&quot;
 &amp; &quot;rtDecode =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                  &quot;
 &amp; &quot;  (Shap&quot;;

CONST E107_2 =
   &quot;e (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (W&quot;
 &amp; &quot;idth 80) (Numeric %waitAtStartDecode =1 \n                             &quot;
 &amp; &quot;                  (Min 0) (Max 100)))))\n            (Glue 6)\n        &quot;
 &amp; &quot;    (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0)&quot;
 &amp; &quot; (Height + 0) \n                                \&quot;DecodeNextCode:   Sto&quot;
 &amp; &quot;p? \&quot;) \n                    (Boolean %stopAtDecodeNextCode =TRUE \&quot;\&quot;)&quot;
 &amp; &quot;\n                    (Glue 10)\n                    (Shape (Width + 0)&quot;
 &amp; &quot; (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Num&quot;
 &amp; &quot;eric %waitAtDecodeNextCode =1 \n                                       &quot;
 &amp; &quot;        (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape&quot;
 &amp; &quot; (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height +&quot;
 &amp; &quot; 0) \n                                \&quot;DecodeDistinctCount:   Stop? \&quot;&quot;
 &amp; &quot;) \n                    (Boolean %stopAtDecodeDistinctCount =TRUE \&quot;\&quot;)&quot;
 &amp; &quot;\n                    (Glue 10)\n                    (Shape (Width + 0)&quot;
 &amp; &quot; (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Num&quot;
 &amp; &quot;eric %waitAtDecodeDistinctCount =1 \n                                  &quot;
 &amp; &quot;             (Min 0) (Max 100)))))\n            (Glue 6)\n            (&quot;
 &amp; &quot;Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Hei&quot;
 &amp; &quot;ght + 0) \n                                \&quot;DecodeFoundChar:   Stop? \&quot;&quot;
 &amp; &quot;) \n                    (Boolean %stopAtDecodeFoundChar =TRUE \&quot;\&quot;)\n  &quot;
 &amp; &quot;                  (Glue 10)\n                    (Shape (Width + 0) (He&quot;
 &amp; &quot;ight + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Numeric&quot;
 &amp; &quot; %waitAtDecodeFoundChar =1 \n                                          &quot;
 &amp; &quot;     (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape (H&quot;
 &amp; &quot;eight 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0)&quot;
 &amp; &quot; \n                                \&quot;DecodeDone:   Stop? \&quot;) \n        &quot;
 &amp; &quot;            (Boolean %stopAtDecodeDone =TRUE \&quot;\&quot;)\n                   &quot;
 &amp; &quot; (Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weigh&quot;
 &amp; &quot;t: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtDecodeDon&quot;
 &amp; &quot;e =&quot;;

CONST E107_3 =
   &quot;1 \n                                               (Min 0) (Max 100))))&quot;
 &amp; &quot;)\n            (Glue 6)\n            (Shape (Height 16 + 0)\n          &quot;
 &amp; &quot;    (HBox Fill (Shape (Width + 0) (Height + 0) \n                      &quot;
 &amp; &quot;          \&quot;StartReconstruct:   Stop? \&quot;) \n                    (Boolea&quot;
 &amp; &quot;n %stopAtStartReconstruct =TRUE \&quot;\&quot;)\n                    (Glue 10)\n &quot;
 &amp; &quot;                   (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n     &quot;
 &amp; &quot;               (Shape (Width 80) (Numeric %waitAtStartReconstruct =1 \n&quot;
 &amp; &quot;                                               (Min 0) (Max 100)))))\n &quot;
 &amp; &quot;           (Glue 6)\n            (Shape (Height 16 + 0)\n              &quot;
 &amp; &quot;(HBox Fill (Shape (Width + 0) (Height + 0) \n                          &quot;
 &amp; &quot;      \&quot;FirstChars:   Stop? \&quot;) \n                    (Boolean %stopAtF&quot;
 &amp; &quot;irstChars =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                 &quot;
 &amp; &quot;   (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (&quot;
 &amp; &quot;Shape (Width 80) (Numeric %waitAtFirstChars =1 \n                      &quot;
 &amp; &quot;                         (Min 0) (Max 100)))))\n            (Glue 6)\n &quot;
 &amp; &quot;           (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Wid&quot;
 &amp; &quot;th + 0) (Height + 0) \n                                \&quot;ConsiderChar: &quot;
 &amp; &quot;  Stop? \&quot;) \n                    (Boolean %stopAtConsiderChar =TRUE \&quot;&quot;
 &amp; &quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Width +&quot;
 &amp; &quot; 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (&quot;
 &amp; &quot;Numeric %waitAtConsiderChar =1 \n                                      &quot;
 &amp; &quot;         (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shap&quot;
 &amp; &quot;e (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height &quot;
 &amp; &quot;+ 0) \n                                \&quot;EqualChars:   Stop? \&quot;) \n    &quot;
 &amp; &quot;                (Boolean %stopAtEqualChars =TRUE \&quot;\&quot;)\n               &quot;
 &amp; &quot;     (Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;W&quot;
 &amp; &quot;eight: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtEqual&quot;
 &amp; &quot;Chars =1 \n                                               (Min 0) (Max &quot;
 &amp; &quot;100)))))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n   &quot;
 &amp; &quot;     &quot;;

CONST E107_4 =
   &quot;      (HBox Fill (Shape (Width + 0) (Height + 0) \n                    &quot;
 &amp; &quot;            \&quot;FinishCharRun:   Stop? \&quot;) \n                    (Boolean&quot;
 &amp; &quot; %stopAtFinishCharRun =TRUE \&quot;\&quot;)\n                    (Glue 10)\n     &quot;
 &amp; &quot;               (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n         &quot;
 &amp; &quot;           (Shape (Width 80) (Numeric %waitAtFinishCharRun =1 \n       &quot;
 &amp; &quot;                                        (Min 0) (Max 100)))))\n        &quot;
 &amp; &quot;    (Glue 6)\n            (Shape (Height 16 + 0)\n              (HBox F&quot;
 &amp; &quot;ill (Shape (Width + 0) (Height + 0) \n                                \&quot;&quot;
 &amp; &quot;StartResult:   Stop? \&quot;) \n                    (Boolean %stopAtStartRes&quot;
 &amp; &quot;ult =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Sh&quot;
 &amp; &quot;ape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape &quot;
 &amp; &quot;(Width 80) (Numeric %waitAtStartResult =1 \n                           &quot;
 &amp; &quot;                    (Min 0) (Max 100)))))\n            (Glue 6)\n      &quot;
 &amp; &quot;      (Shape (Height 16 + 0)\n              (HBox Fill (Shape (Width + &quot;
 &amp; &quot;0) (Height + 0) \n                                \&quot;ResultNextChar:   S&quot;
 &amp; &quot;top? \&quot;) \n                    (Boolean %stopAtResultNextChar =TRUE \&quot;\&quot;&quot;
 &amp; &quot;)\n                    (Glue 10)\n                    (Shape (Width + 0&quot;
 &amp; &quot;) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80) (Nu&quot;
 &amp; &quot;meric %waitAtResultNextChar =1 \n                                      &quot;
 &amp; &quot;         (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shap&quot;
 &amp; &quot;e (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height &quot;
 &amp; &quot;+ 0) \n                                \&quot;EndResult:   Stop? \&quot;) \n     &quot;
 &amp; &quot;               (Boolean %stopAtEndResult =TRUE \&quot;\&quot;)\n                 &quot;
 &amp; &quot;   (Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Wei&quot;
 &amp; &quot;ght: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtEndResu&quot;
 &amp; &quot;lt =1 \n                                               (Min 0) (Max 100&quot;
 &amp; &quot;)))))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n      &quot;
 &amp; &quot;        (HBox Fill (Shape (Width + 0) (Height + 0) \n                  &quot;
 &amp; &quot;              \&quot;Reveal:   Stop? \&quot;) \n                    (Boolean %sto&quot;
 &amp; &quot;pAt&quot;;

CONST E107_5 =
   &quot;Reveal =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    &quot;
 &amp; &quot;(Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Sha&quot;
 &amp; &quot;pe (Width 80) (Numeric %waitAtReveal =1 \n                             &quot;
 &amp; &quot;                  (Min 0) (Max 100)))))\n            (Glue 6)\n        &quot;
 &amp; &quot;  )\n          (Glue 4)\n          (VBox\n            (Glue 5)\n       &quot;
 &amp; &quot;     (Shape (Width + 0) (Height 16 + 0) \&quot;Cts:\&quot;)\n            (Button &quot;
 &amp; &quot;%eventCounts\n              (VBox\n                (Glue 6)\n          &quot;
 &amp; &quot;      (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n                 &quot;
 &amp; &quot;                 (Text %ctOfStartPermute \&quot;0\&quot;)))\n                (Glu&quot;
 &amp; &quot;e 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n &quot;
 &amp; &quot;                                 (Text %ctOfNextRotation \&quot;0\&quot;)))\n    &quot;
 &amp; &quot;            (Glue 6)\n                (HBox Fill (Shape (Width + 0) (He&quot;
 &amp; &quot;ight 16 + 0) \n                                  (Text %ctOfRotationsSo&quot;
 &amp; &quot;rted \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Sh&quot;
 &amp; &quot;ape (Width + 0) (Height 16 + 0) \n                                  (Te&quot;
 &amp; &quot;xt %ctOfPermuteDone \&quot;0\&quot;)))\n                (Glue 6)\n               &quot;
 &amp; &quot; (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n                      &quot;
 &amp; &quot;            (Text %ctOfStartEncode \&quot;0\&quot;)))\n                (Glue 6)\n&quot;
 &amp; &quot;                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n       &quot;
 &amp; &quot;                           (Text %ctOfEncodeNextChar \&quot;0\&quot;)))\n        &quot;
 &amp; &quot;        (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height&quot;
 &amp; &quot; 16 + 0) \n                                  (Text %ctOfEncodeDistinctC&quot;
 &amp; &quot;ount \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Sh&quot;
 &amp; &quot;ape (Width + 0) (Height 16 + 0) \n                                  (Te&quot;
 &amp; &quot;xt %ctOfEncodeFoundCode \&quot;0\&quot;)))\n                (Glue 6)\n           &quot;
 &amp; &quot;     (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n                  &quot;
 &amp; &quot;                (Text %ctOfEncodeDone \&quot;0\&quot;)))\n                (Glue 6&quot;
 &amp; &quot;)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n    &quot;
 &amp; &quot;                              (Text %ctOfInitDecode \&quot;0\&quot;)))\n         &quot;
 &amp; &quot;       (Gl&quot;;

CONST E107_6 =
   &quot;ue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n&quot;
 &amp; &quot;                                  (Text %ctOfStartDecode \&quot;0\&quot;)))\n    &quot;
 &amp; &quot;            (Glue 6)\n                (HBox Fill (Shape (Width + 0) (He&quot;
 &amp; &quot;ight 16 + 0) \n                                  (Text %ctOfDecodeNextC&quot;
 &amp; &quot;ode \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Sha&quot;
 &amp; &quot;pe (Width + 0) (Height 16 + 0) \n                                  (Tex&quot;
 &amp; &quot;t %ctOfDecodeDistinctCount \&quot;0\&quot;)))\n                (Glue 6)\n        &quot;
 &amp; &quot;        (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n               &quot;
 &amp; &quot;                   (Text %ctOfDecodeFoundChar \&quot;0\&quot;)))\n               &quot;
 &amp; &quot; (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0&quot;
 &amp; &quot;) \n                                  (Text %ctOfDecodeDone \&quot;0\&quot;)))\n &quot;
 &amp; &quot;               (Glue 6)\n                (HBox Fill (Shape (Width + 0) &quot;
 &amp; &quot;(Height 16 + 0) \n                                  (Text %ctOfStartRec&quot;
 &amp; &quot;onstruct \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill&quot;
 &amp; &quot; (Shape (Width + 0) (Height 16 + 0) \n                                 &quot;
 &amp; &quot; (Text %ctOfFirstChars \&quot;0\&quot;)))\n                (Glue 6)\n            &quot;
 &amp; &quot;    (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n                   &quot;
 &amp; &quot;               (Text %ctOfConsiderChar \&quot;0\&quot;)))\n                (Glue &quot;
 &amp; &quot;6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n   &quot;
 &amp; &quot;                               (Text %ctOfEqualChars \&quot;0\&quot;)))\n        &quot;
 &amp; &quot;        (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height&quot;
 &amp; &quot; 16 + 0) \n                                  (Text %ctOfFinishCharRun \&quot;&quot;
 &amp; &quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Shape (Wi&quot;
 &amp; &quot;dth + 0) (Height 16 + 0) \n                                  (Text %ctO&quot;
 &amp; &quot;fStartResult \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox &quot;
 &amp; &quot;Fill (Shape (Width + 0) (Height 16 + 0) \n                             &quot;
 &amp; &quot;     (Text %ctOfResultNextChar \&quot;0\&quot;)))\n                (Glue 6)\n    &quot;
 &amp; &quot;            (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n           &quot;
 &amp; &quot;                       (Text %ctOfEndResult \&quot;0\&quot;)))\n                (&quot;
 &amp; &quot;Glue &quot;;

CONST E107_7 =
   &quot;6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n   &quot;
 &amp; &quot;                               (Text %ctOfReveal \&quot;0\&quot;)))\n            &quot;
 &amp; &quot;    (Glue 3))))\n          Fill\n          (Glue 4 + Inf)\n        )\n &quot;
 &amp; &quot;     )\n    )\n  )\n)\n&quot;;

CONST E108 =
   &quot;MODULE CPAlgorithm;\n\nIMPORT Algorithm, CPAlgClass, R2, Math;\n\nTYPE &quot;
 &amp; &quot;\n  Link = REF RECORD\n    p:R2.T;\n    next: Link;\nEND;\n\nCONST MaxD&quot;
 &amp; &quot;istance = 1.0E30;\nVAR\n   min     : REAL    := 100.0;\n   h,z    : Lin&quot;
 &amp; &quot;k;\n   N: INTEGER := 0;\n\n@CheckforMin\nPROCEDURE CheckForMin (READONL&quot;
 &amp; &quot;Y p1, p2: R2.T) =@\n  BEGIN\n@5     IF (Dist(p1,p2) &lt; min) THEN @\n@10 &quot;
 &amp; &quot;       UpdateMin(p1,p2) @\n    END\n  END CheckForMin;\n@CheckforMin\n\n&quot;
 &amp; &quot;\n@FindClosestPair\nPROCEDURE FindClosestPair(VAR c: Link; N: INTEGER):&quot;
 &amp; &quot; Link =@\n  VAR\n    a, b, t1, t2: Link;\n    midX : REAL;\n    p1, p2,&quot;
 &amp; &quot; p3, p4: R2.T;\n\n  BEGIN\n@5     a := c;@\n@10     b := MiddleOfList(c&quot;
 &amp; &quot;,N);@\n@15     midX := b.p.x;@\n\n@20     t1 := FindClosestPair(a, N DI&quot;
 &amp; &quot;V 2);@\n@25     t2 := FindClosestPair(b, N - (N DIV 2));@\n\n@30     c &quot;
 &amp; &quot;:= Merge(t1, t2);@\n\n@35     a := c;@\n    REPEAT\n@40       IF ((ABS(&quot;
 &amp; &quot;a.p.x - midX) &lt; min) AND (p1 # z.p)) THEN@\n@45         CheckForMin(a.p&quot;
 &amp; &quot;, p1);@\n@50         CheckForMin(a.p, p2);@\n@55         CheckForMin(a.&quot;
 &amp; &quot;p, p3);@\n@60         CheckForMin(a.p, p4);@\n@65         p1 := p2; p2 &quot;
 &amp; &quot;:= p3; p3 := p4; p4 := a.p;@\n        END (* IF *);\n@70       a := a.n&quot;
 &amp; &quot;ext;@\n@75     UNTIL a = z;@\n\n@80     RETURN c;@\n  END FindClosestPa&quot;
 &amp; &quot;ir;\n@FindClosestPair\n\n@Main\nBEGIN (* main module: computes closest &quot;
 &amp; &quot;pair in given set of points *) @\n@5  InitializeListofPoints(h, N);@\n@&quot;
 &amp; &quot;10  SortByX(h, N);@\n@15  FindClosestPair(h, N);@\nEND CPAlgorithm.\n@M&quot;
 &amp; &quot;ain\n&quot;;

CONST E109 =
   &quot;(* Copyright (C) 1993, Digital Equipment Corporation                   &quot;
 &amp; &quot;      *)\n(* All rights reserved.                                      &quot;
 &amp; &quot;                *)\n(* See the file COPYRIGHT for a full description.  &quot;
 &amp; &quot;                          *)\n\n\n(*\nlet SHOW =\n  proc(t, x)\n    sys&quot;
 &amp; &quot;_printText(t &amp; \&quot; = \&quot;); \n    sys_print(x, 10); \n    sys_printText(\&quot;&quot;
 &amp; &quot;\\n\&quot;); \n    sys_printFlush();\n  end;\n*)\n\ntype Point = [2*Real];\n&quot;
 &amp; &quot;\n    let makeBezierPathProc = proc (cpp:[4*Point]):(Real)-&gt;Point,\n   &quot;
 &amp; &quot;     (*------------------------------------------------------------\n  &quot;
 &amp; &quot;         cpp = array of four control points [x,y]\n           Return a &quot;
 &amp; &quot;parametric procedure that traces the bezier curve\n           from cpp[&quot;
 &amp; &quot;0] to cpp[3] with control points cpp[1] and cpp[2].\n        ----------&quot;
 &amp; &quot;--------------------------------------------------*)\n        let x000 &quot;
 &amp; &quot;= cpp[0][0],  y000 = cpp[0][1],\n            x001 = cpp[1][0],  y001 = &quot;
 &amp; &quot;cpp[1][1],\n            x011 = cpp[2][0],  y011 = cpp[2][1],\n         &quot;
 &amp; &quot;   x111 = cpp[3][0],  y111 = cpp[3][1];\n        proc (t)\n            &quot;
 &amp; &quot;let s = 1.0-t;\n            let sss = s*s*s,\n                sst = s*s&quot;
 &amp; &quot;*t*3.0,\n                stt = s*t*t*3.0,\n                ttt = t*t*t;&quot;
 &amp; &quot;\n            [\n                (sss*x000) + (sst*x001) + (stt*x011) +&quot;
 &amp; &quot; (ttt*x111),\n                (sss*y000) + (sst*y001) + (stt*y011) + (t&quot;
 &amp; &quot;tt*y111)\n            ]\n        end;\n    end;\n\nlet max : (Int,Int)-&quot;
 &amp; &quot;&gt;Int =\n  proc(n, m)\n    if n &gt; m then n else m end\n  end;\n\nlet abs&quot;
 &amp; &quot; : (Real)-&gt;Real = \n  proc(x) \n    if x &gt; 0.0 then x else -x end \n  e&quot;
 &amp; &quot;nd;\n\nlet rec exp : (Int,Int)-&gt;Int =\n  proc(n, m)\n    if m&lt;=0 then 1&quot;
 &amp; &quot; else n * exp(n, m-1) end\n  end;\n\ntype Node = \n  Option typeBot:Ver&quot;
 &amp; &quot;tex, typeTop:Vertex, typeFun:Vertex end;\n\nlet nodeVertex : (Node) -&gt; &quot;
 &amp; &quot;Vertex  =\n  proc(node)\n    case node of\n      typeBot(bot) =&gt; bot,\n&quot;
 &amp; &quot;      typeTop(top) =&gt; top,\n      typeFun(fun) =&gt; fun\n    end;\n  end;&quot;
 &amp; &quot;\n\nlet edgeBezier: (Graph, Edge, Vertex, Vertex, Real, Bool)-&gt;Ok =\n  &quot;
 &amp; &quot;proc(g, e, v1, v2, scale, rightward)\n    let c1 = graph_newVertex(g);\n&quot;
 &amp; &quot;    let c2 = gr&quot;;

CONST E109_0 =
   &quot;aph_newVertex(g);\n    let v1p = graph_getVertexPosition(v1);\n    let &quot;
 &amp; &quot;v2p = graph_getVertexPosition(v2);\n\n    let v1x = v1p[0], v1y = v1p[1&quot;
 &amp; &quot;];\n    let v2x = v2p[0], v2y = v2p[1];\n\n    let dx = abs(v2x-v1x)*sc&quot;
 &amp; &quot;ale;\n    let dy = abs(v1y-v2y)*scale;\n\n    if rightward\n    then\n &quot;
 &amp; &quot;     if v1x &gt; v2x then\n        graph_moveVertex(c1, v1x+dx, v1y+dy, fa&quot;
 &amp; &quot;lse);\n        graph_moveVertex(c2, v2x+(dy-dx), v2y-dy, false);\n     &quot;
 &amp; &quot; else\n        graph_moveVertex(c1, v1x+(dy-dx), v1y+dy, false);\n     &quot;
 &amp; &quot;   graph_moveVertex(c2, v2x+dx, v2y-dy, false);\n      end;\n    else \n&quot;
 &amp; &quot;      if v1x &gt; v2x then\n        graph_moveVertex(c1, v1x-(dy-dx), v1y+&quot;
 &amp; &quot;dy, false);\n        graph_moveVertex(c2, v2x-dx, v2y-dy, false);\n    &quot;
 &amp; &quot;  else\n        graph_moveVertex(c1, v1x-dx, v1y+dy, false);\n        g&quot;
 &amp; &quot;raph_moveVertex(c2, v2x-(dy-dx), v2y-dy, false);\n      end;\n    end;\n&quot;
 &amp; &quot;    graph_moveEdgeBezier(e, v1, v2, c1, c2, false);\n  end;\n  \nlet tr&quot;
 &amp; &quot;avTrail: [Int] = array_new(100, -1);\nvar travTop: Int = -1;\n\nlet tra&quot;
 &amp; &quot;vNotice: (Int)-&gt;Ok =\n  proc(index)\n    travTop := travTop+1;\n    tra&quot;
 &amp; &quot;vTrail[travTop] := index;\n  end;\n\nlet travSeen: (Int)-&gt;Bool =\n  pro&quot;
 &amp; &quot;c(index)\n    var found = false;\n    for i = 0 to travTop do\n      if&quot;
 &amp; &quot; travTrail[i] is index then found:=true; exit end\n    end;\n    found;&quot;
 &amp; &quot;\n  end;\n\nlet rec depth1: (EvtObj, Int)-&gt;Int =\n  proc(s, nodeIndex)\n&quot;
 &amp; &quot;    if travSeen(nodeIndex) then 1\n    else\n      travNotice(nodeIndex&quot;
 &amp; &quot;);\n      case s.nodes[nodeIndex] of\n        typeBot(bot) =&gt; 1,\n     &quot;
 &amp; &quot;   typeTop(top) =&gt; 1,\n        typeFun(fun) =&gt; \n          let domDepth&quot;
 &amp; &quot; = depth1(s, s.doms[nodeIndex]);\n          let rngDepth = depth1(s, s.&quot;
 &amp; &quot;rngs[nodeIndex]);\n          1 + max(domDepth, rngDepth);\n      end\n &quot;
 &amp; &quot;   end \n  end;\n\nlet depth =\n  proc(s:EvtObj, nodeIndex:Int):Int,\n &quot;
 &amp; &quot;   travTop := -1;\n    depth1(s, nodeIndex);\n  end;\n\nlet rec layout1&quot;
 &amp; &quot; =\n  proc(s, nodeIndex, x, y, n, exp2n)\n    if travSeen(nodeIndex) th&quot;
 &amp; &quot;en ok\n    else\n      travNotice(nodeIndex);\n      let size = 1.0/flo&quot;
 &amp; &quot;at(s.depth);\n        case s.nodes[nodeIndex] of\n        typeBot(bot) &quot;
 &amp; &quot;=&gt; \n          gr&quot;;

CONST E109_1 =
   &quot;aph_setVertexSize(bot, size, size);\n          graph_moveVertex(bot, x/&quot;
 &amp; &quot;exp2n, y, false),\n        typeTop(top) =&gt; \n          graph_setVertexS&quot;
 &amp; &quot;ize(top, size, size);\n          graph_moveVertex(top, x/exp2n, y, fals&quot;
 &amp; &quot;e),\n        typeFun(fun) =&gt; \n          graph_setVertexSize(fun, size,&quot;
 &amp; &quot; size);\n          graph_moveVertex(fun, x/exp2n, y, false);\n         &quot;
 &amp; &quot; let displ = float(exp(2,n-2));\n          layout1(s, s.doms[nodeIndex]&quot;
 &amp; &quot;, x-displ, y+1.0, n-1, exp2n);\n          layout1(s, s.rngs[nodeIndex],&quot;
 &amp; &quot; x+displ, y+1.0, n-1, exp2n);\n          let vDom = nodeVertex(s.nodes[&quot;
 &amp; &quot;s.doms[nodeIndex]]);\n          let vRng = nodeVertex(s.nodes[s.rngs[no&quot;
 &amp; &quot;deIndex]]);\n          let eDom = s.edges[s.domEdges[nodeIndex]];\n    &quot;
 &amp; &quot;      let eRng = s.edges[s.rngEdges[nodeIndex]];\n          graph_moveE&quot;
 &amp; &quot;dge(eDom, fun, vDom, false);\n          graph_moveEdge(eRng, fun, vRng,&quot;
 &amp; &quot; false);\n          if nodeIndex &gt; s.doms[nodeIndex] then (* back dom e&quot;
 &amp; &quot;dge *)\n            (* --- edgeBezier(s.graphvbt, eDom, fun, vDom, 0.75&quot;
 &amp; &quot;, false) *)\n            edgeBezier(s.graphvbt, eDom, fun, vDom, 5.0*si&quot;
 &amp; &quot;ze, false);\n          elsif nodeIndex is s.doms[nodeIndex] then (* sel&quot;
 &amp; &quot;f-loop dom edge *)\n            let vDom1 = graph_newVertex(s.graphvbt)&quot;
 &amp; &quot;;\n            let vDomXY = graph_getVertexPosition(vDom);\n           &quot;
 &amp; &quot; graph_moveVertex(vDom1, \n              vDomXY[0]-(size/16.0), vDomXY[&quot;
 &amp; &quot;1]+(size/16.0), false);\n            edgeBezier(s.graphvbt, eDom, vDom1&quot;
 &amp; &quot;, fun, 175.0*size, false);\n          end;\n          if nodeIndex &gt; s.&quot;
 &amp; &quot;rngs[nodeIndex] then (* back rng edge *)\n            (* --- edgeBezier&quot;
 &amp; &quot;(s.graphvbt, eRng, fun, vRng, 0.75, true) *)\n            edgeBezier(s.&quot;
 &amp; &quot;graphvbt, eRng, fun, vRng, 5.0*size, true);\n          elsif nodeIndex &quot;
 &amp; &quot;is s.rngs[nodeIndex] then (* self-loop rng edge *)\n            let vRn&quot;
 &amp; &quot;g1 = graph_newVertex(s.graphvbt);\n            let vRngXY = graph_getVe&quot;
 &amp; &quot;rtexPosition(vRng);\n            graph_moveVertex(vRng1, \n            &quot;
 &amp; &quot;  vRngXY[0]+(size/16.0), vRngXY[1]+(size/16.0), false);\n            ed&quot;
 &amp; &quot;geBezier(s.graphvbt, eRng, vRng1, fun, 175.0*si&quot;;

CONST E109_2 =
   &quot;ze, true);\n          end;\n      end\n    end \n  end;\n\nlet layout =&quot;
 &amp; &quot;\n  proc(s, nodeIndex, x, y, n, exp2n)\n    travTop := -1;\n    layout1&quot;
 &amp; &quot;(s, nodeIndex, x, y, n, exp2n);\n  end;\n\nlet moveVToVI =\n  proc(s, v&quot;
 &amp; &quot;, vIndex)\n    let vTo = nodeVertex(s.nodes[vIndex]);\n    let vToXY = &quot;
 &amp; &quot;graph_getVertexPosition(vTo);\n    graph_moveVertex(v, vToXY[0], vToXY[&quot;
 &amp; &quot;1], true);\n  end;   \n\nlet moveVAlongEI =\n  proc(s, v, eIndex, vInde&quot;
 &amp; &quot;x, forward)\n    if eIndex&lt;0 then moveVToVI(s, v, vIndex);\n    else\n &quot;
 &amp; &quot;     let e = s.edges[eIndex];\n      let eCtrl = graph_getEdgeControls(&quot;
 &amp; &quot;e);\n      if #(eCtrl) is 0 then\n\tif forward then moveVToVI(s, v, vIn&quot;
 &amp; &quot;dex)\n\telse\n          let eVert = graph_getEdgeVertices(e);\n        &quot;
 &amp; &quot;  let vTo = eVert[0];\n          let vToXY = graph_getVertexPosition(vT&quot;
 &amp; &quot;o);\n          graph_moveVertex(v, vToXY[0], vToXY[1], true);\n\tend;\n&quot;
 &amp; &quot;      else\n\tlet tail = if forward then 0 else 1 end;\n\tlet head = if&quot;
 &amp; &quot; forward then 1 else 0 end;\n        let eVert = graph_getEdgeVertices(&quot;
 &amp; &quot;e);\n\tlet vTailXY = graph_getVertexPosition(eVert[tail]);\n\tlet vHead&quot;
 &amp; &quot;XY = graph_getVertexPosition(eVert[head]);\n\tlet cTailXY = graph_getVe&quot;
 &amp; &quot;rtexPosition(eCtrl[tail]);\n\tlet cHeadXY = graph_getVertexPosition(eCt&quot;
 &amp; &quot;rl[head]);\n\tlet p = makeBezierPathProc([vTailXY,cTailXY,cHeadXY,vHead&quot;
 &amp; &quot;XY]);\n        graph_moveVertexOnPath(v, p);\n      end\n    end\n  end&quot;
 &amp; &quot;;\n\nlet variance =\n  proc(s, subIndex, supIndex)\n    let xSub = floa&quot;
 &amp; &quot;t(s.depth)/6.0;\n    let xSup = float(s.depth)/10.0;\n    let y = ~1.5/&quot;
 &amp; &quot;float(s.depth);\n    let yLo = ~1.0/float(s.depth);\n    let yHi = ~2.0&quot;
 &amp; &quot;/float(s.depth);\n    if subIndex &lt; supIndex then (* covariant *)\n    &quot;
 &amp; &quot;  graph_moveVertex(s.varianceNW, -xSub, y, true);\n      graph_moveVert&quot;
 &amp; &quot;ex(s.varianceSW, -xSub, y, true);\n      graph_moveVertex(s.varianceNE,&quot;
 &amp; &quot; xSup, yHi, true);\n      graph_moveVertex(s.varianceSE, xSup, yLo, tru&quot;
 &amp; &quot;e);\n    else (* contravariant *)\n      graph_moveVertex(s.varianceNW,&quot;
 &amp; &quot; -xSup, yHi, true);\n      graph_moveVertex(s.varianceSW, -xSup, yLo, t&quot;
 &amp; &quot;rue);\n      graph_moveVertex(s.varianceNE, xSub, y, true);\n      grap&quot;
 &amp; &quot;h_moveVertex(s&quot;;

CONST E109_3 =
   &quot;.varianceSE, xSub, y, true);\n    end;\n  end;\n\nlet hiLiPair =\n  pro&quot;
 &amp; &quot;c(s, subIndex, supIndex, subLeadingEdgeIndex, supLeadingEdgeIndex,\n   &quot;
 &amp; &quot;   forward)\n    if subIndex &lt; supIndex then (* covariant *)\n      mov&quot;
 &amp; &quot;eVAlongEI(s, s.cursorW, subLeadingEdgeIndex, subIndex, forward);\n     &quot;
 &amp; &quot; moveVAlongEI(s, s.cursorE, supLeadingEdgeIndex, supIndex, forward);\n &quot;
 &amp; &quot;     graph_animate(s.graphvbt, 0.0, 2.0);\n    else (* contravariant *)&quot;
 &amp; &quot;\n      moveVAlongEI(s, s.cursorE, subLeadingEdgeIndex, subIndex, forwa&quot;
 &amp; &quot;rd);\n      moveVAlongEI(s, s.cursorW, supLeadingEdgeIndex, supIndex, f&quot;
 &amp; &quot;orward);\n      graph_animate(s.graphvbt, 0.0, 2.0);\n    end;\n  end;\n&quot;
 &amp; &quot;  \nlet hiLiPairColor =\n  proc(s, subIndex, supIndex, clr)\n    varian&quot;
 &amp; &quot;ce(s, subIndex, supIndex);\n    let c = color_named(clr);\n    graph_se&quot;
 &amp; &quot;tEdgeColor(s.cursorStem, c);\n    graph_setVertexHiLiColor(s.cursorWHiL&quot;
 &amp; &quot;i, c);\n    graph_setVertexHiLiColor(s.cursorEHiLi, c);\n    graph_anim&quot;
 &amp; &quot;ate(s.graphvbt, 0.0, 0.0);\n    graph_redisplay(s.graphvbt);\n  end;\n\n&quot;
 &amp; &quot;let view =\n\n{\ngraphvbt =&gt; graph_new(),\n\nnodes =&gt; array_new(50, ok)&quot;
 &amp; &quot;,\nedges =&gt; array_new(50, ok),\n\ndoms =&gt;  array_new(50, -1),\nrngs =&gt; &quot;
 &amp; &quot; array_new(50, -1),\ndomEdges =&gt;  array_new(50, -1),\nrngEdges =&gt;  arra&quot;
 &amp; &quot;y_new(50, -1),\n\ncursorW =&gt; ok,\ncursorWHiLi =&gt; ok,\ncursorE =&gt; ok,\nc&quot;
 &amp; &quot;ursorEHiLi =&gt; ok,\ncursorStem =&gt; ok,\n\nvarianceNW =&gt; ok,\nvarianceNE =&quot;
 &amp; &quot;&gt; ok,\nvarianceSW =&gt; ok,\nvarianceSE =&gt; ok,\nvarianceP =&gt; ok,\n\ndepth &quot;
 &amp; &quot;=&gt; 0,\n\nSetup =&gt; meth (s)\n  s.cursorW := graph_newVertex(s.graphvbt);&quot;
 &amp; &quot;\n  graph_setVertexShape(s.cursorW, \&quot;ellipse\&quot;);\n  s.cursorWHiLi := g&quot;
 &amp; &quot;raph_newVertexHiLi(s.cursorW);\n  s.cursorE := graph_newVertex(s.graphv&quot;
 &amp; &quot;bt);\n  graph_setVertexShape(s.cursorE, \&quot;ellipse\&quot;);\n  s.cursorEHiLi &quot;
 &amp; &quot;:= graph_newVertexHiLi(s.cursorE);\n  s.cursorStem := graph_newEdge(s.c&quot;
 &amp; &quot;ursorW,s.cursorE);\n  graph_setEdgeColor(s.cursorStem, color_named(\&quot;cy&quot;
 &amp; &quot;an\&quot;));\n  s.varianceNW := graph_newVertex(s.graphvbt);\n  s.varianceNE&quot;
 &amp; &quot; := graph_newVertex(s.graphvbt);\n  s.varianceSW := graph_newVertex(s.g&quot;
 &amp; &quot;raphvbt);\n  s.varianceSE := graph_newVertex(s.graphvbt);\n  s.variance&quot;
 &amp; &quot;P := graph_new&quot;;

CONST E109_4 =
   &quot;Polygon([s.varianceNE,s.varianceNW,s.varianceSW,s.varianceSE]);\n  grap&quot;
 &amp; &quot;h_setPolygonColor(s.varianceP, color_named(\&quot;cyan\&quot;));\nend,\n\nBegin =&quot;
 &amp; &quot;&gt; meth (s, lftRoot, rhtRoot)\n  let lftDepth = depth(s, lftRoot);\n  le&quot;
 &amp; &quot;t rhtDepth = depth(s, rhtRoot);\n  let n = max(lftDepth, rhtDepth);\n  &quot;
 &amp; &quot;let halfWidth = float(exp(2, n-1));\n  let width = 2.0*halfWidth;\n  le&quot;
 &amp; &quot;t margin = 3.0/float(n);\n  graph_setWorld(s.graphvbt, -(float(n)+margi&quot;
 &amp; &quot;n), float(n)+margin,\n    -margin, float(n-1)+margin);\n  s.depth := n;&quot;
 &amp; &quot;\n  graph_setVertexSize(s.cursorW, 0.15/float(n), 0.15/float(n));\n  gr&quot;
 &amp; &quot;aph_setVertexSize(s.cursorE, 0.15/float(n), 0.15/float(n));\n  graph_se&quot;
 &amp; &quot;tVertexHiLiBorder(s.cursorWHiLi, 0.8/float(n), 0.8/float(n));\n  graph_&quot;
 &amp; &quot;setVertexHiLiBorder(s.cursorEHiLi, 0.8/float(n), 0.8/float(n));\n  grap&quot;
 &amp; &quot;h_setVertexHiLiColor(s.cursorWHiLi, color_named(\&quot;cyan\&quot;));\n  graph_se&quot;
 &amp; &quot;tVertexHiLiColor(s.cursorEHiLi, color_named(\&quot;cyan\&quot;));\n  graph_setEdg&quot;
 &amp; &quot;eWidth(s.cursorStem, (1.0/float(n))*0.6);\n  layout(s, lftRoot, -halfWi&quot;
 &amp; &quot;dth, 0.0, n, width/float(n));\n  layout(s, rhtRoot, halfWidth, 0.0, n, &quot;
 &amp; &quot;width/float(n));\n  graph_redisplay(s.graphvbt);\nend,\n\nNewBot =&gt; met&quot;
 &amp; &quot;h (s, index)\n  let v = graph_newVertex(s.graphvbt);\n  graph_setVertex&quot;
 &amp; &quot;Shape(v, \&quot;ellipse\&quot;);\n  graph_setVertexColor(v, color_named(\&quot;PaleBlu&quot;
 &amp; &quot;eViolet\&quot;));\n  graph_setVertexLabel(v, \&quot;Bot\&quot;);\n  graph_setVertexLab&quot;
 &amp; &quot;elColor(v, color_named(\&quot;black\&quot;));\n  s.nodes[index] := option typeBot&quot;
 &amp; &quot; =&gt; v end;\nend,\n\nNewTop =&gt; meth (s, index)\n  let v = graph_newVerte&quot;
 &amp; &quot;x(s.graphvbt);\n  graph_setVertexShape(v, \&quot;ellipse\&quot;);\n  graph_setVer&quot;
 &amp; &quot;texColor(v, color_named(\&quot;PaleVioletRed\&quot;));\n  graph_setVertexLabel(v,&quot;
 &amp; &quot; \&quot;Top\&quot;);\n  graph_setVertexLabelColor(v, color_named(\&quot;black\&quot;));\n  &quot;
 &amp; &quot;s.nodes[index] := option typeTop =&gt; v end;\nend,\n\nNewFun =&gt; meth (s, &quot;
 &amp; &quot;index, domEdgeIndex, rngEdgeIndex)\n  let v = graph_newVertex(s.graphvb&quot;
 &amp; &quot;t);\n  graph_setVertexShape(v, \&quot;ellipse\&quot;);\n  graph_setVertexColor(v,&quot;
 &amp; &quot; color_named(\&quot;PaleGreen\&quot;));\n  graph_setVertexLabel(v, \&quot;-&gt;\&quot;);\n  gr&quot;
 &amp; &quot;aph_setVertexLabelColor(v, color_named(\&quot;black\&quot;));\n  s.nodes[index] :&quot;
 &amp; &quot;= option typeFun =&gt; v&quot;;

CONST E109_5 =
   &quot; end;\n\n  let eDom = graph_newEdge(v, v);\n  let eRng = graph_newEdge(&quot;
 &amp; &quot;v, v);\n  graph_setEdgeColor(eDom, color_named(\&quot;CadetBlue\&quot;));\n  grap&quot;
 &amp; &quot;h_setEdgeColor(eRng, color_named(\&quot;CadetBlue\&quot;));\n  s.edges[domEdgeInd&quot;
 &amp; &quot;ex] := eDom;\n  s.edges[rngEdgeIndex] := eRng;\n  s.domEdges[index] := &quot;
 &amp; &quot;domEdgeIndex;\n  s.rngEdges[index] := rngEdgeIndex;\nend,\n\nNewDomRng &quot;
 &amp; &quot;=&gt; meth (s, index, domIndex, rngIndex)\n  let v = nodeVertex(s.nodes[in&quot;
 &amp; &quot;dex]);\n  s.doms[index] := domIndex;\n  s.rngs[index] := rngIndex;\nend&quot;
 &amp; &quot;,\n\nNewLoop =&gt; meth (s, fromIndex, toIndex)\n  ok\nend,\n\nEnter =&gt; \n&quot;
 &amp; &quot;  meth (s, subIndex, supIndex, subLeadingEdgeIndex, supLeadingEdgeIndex&quot;
 &amp; &quot;)\n    hiLiPairColor(s, subIndex, supIndex, \&quot;cyan\&quot;);\n    hiLiPair(s,&quot;
 &amp; &quot; subIndex, supIndex, subLeadingEdgeIndex, supLeadingEdgeIndex, true);\n&quot;
 &amp; &quot;  end,\n\nExit =&gt; \n  meth (s, subIndex, supIndex, subLeadingEdgeIndex,&quot;
 &amp; &quot; supLeadingEdgeIndex, result)\n    if result then\n      hiLiPairColor(&quot;
 &amp; &quot;s, subIndex, supIndex, \&quot;green\&quot;);\n    else\n      hiLiPairColor(s, su&quot;
 &amp; &quot;bIndex, supIndex, \&quot;red\&quot;);\n    end;\n    hiLiPairColor(s, subIndex, s&quot;
 &amp; &quot;upIndex, \&quot;VeryPaleCyan\&quot;);\n    hiLiPair(s, subIndex, supIndex, subLea&quot;
 &amp; &quot;dingEdgeIndex, supLeadingEdgeIndex, false);\n  end,\n\nBotLessAnyOK =&gt; &quot;
 &amp; &quot;\n  meth (s, subIndex, supIndex, subLeadingEdgeIndex, supLeadingEdgeInd&quot;
 &amp; &quot;ex)\n    hiLiPairColor(s, subIndex, supIndex, \&quot;green\&quot;);\n  end,\n\nTo&quot;
 &amp; &quot;pLessTopOK =&gt; \n  meth (s, subIndex, supIndex, subLeadingEdgeIndex, sup&quot;
 &amp; &quot;LeadingEdgeIndex)\n    hiLiPairColor(s, subIndex, supIndex, \&quot;green\&quot;);&quot;
 &amp; &quot;\n  end,\n\nTopLessNonTopKO =&gt; \n  meth (s, subIndex, supIndex, subLead&quot;
 &amp; &quot;ingEdgeIndex, supLeadingEdgeIndex)\n    hiLiPairColor(s, subIndex, supI&quot;
 &amp; &quot;ndex, \&quot;red\&quot;);\n  end,\n\nFunLessBotKO =&gt; \n  meth (s, subIndex, supIn&quot;
 &amp; &quot;dex, subLeadingEdgeIndex, supLeadingEdgeIndex)\n    hiLiPairColor(s, su&quot;
 &amp; &quot;bIndex, supIndex, \&quot;red\&quot;);\n  end,\n\nFunLessTopOK =&gt; \n  meth (s, sub&quot;
 &amp; &quot;Index, supIndex, subLeadingEdgeIndex, supLeadingEdgeIndex)\n    hiLiPai&quot;
 &amp; &quot;rColor(s, subIndex, supIndex, \&quot;green\&quot;);\n  end,\n\nFunLessFun =&gt; \n  &quot;
 &amp; &quot;meth (s, subIndex, supIndex, subLeadingEdgeIndex, supLeadingEdgeIndex)\n&quot;
 &amp; &quot;    ok\n  end,\n\nSeenOK =&gt; \n  &quot;;

CONST E109_6 =
   &quot;meth (s, subIndex, supIndex)\n    hiLiPairColor(s, subIndex, supIndex, &quot;
 &amp; &quot;\&quot;Yellow\&quot;);\n  end,\n\nNotice =&gt; \n  meth (s, subIndex, supIndex)\n   &quot;
 &amp; &quot; hiLiPairColor(s, subIndex, supIndex, \&quot;BluishCyan\&quot;);\n  end,\n\nOK =&gt;&quot;
 &amp; &quot; \n  meth (s, subIndex, supIndex, subLeadingEdgeIndex, supLeadingEdgeIn&quot;
 &amp; &quot;dex)\n    graph_setPolygonColor(s.varianceP, color_named(\&quot;DarkGreen\&quot;)&quot;
 &amp; &quot;);\n    hiLiPairColor(s, subIndex, supIndex, \&quot;DarkGreen\&quot;);\n  end,\n\n&quot;
 &amp; &quot;KO =&gt; \n  meth (s, subIndex, supIndex, subLeadingEdgeIndex, supLeadingE&quot;
 &amp; &quot;dgeIndex)\n    graph_setPolygonColor(s.varianceP, color_named(\&quot;DarkRed&quot;
 &amp; &quot;\&quot;));\n    hiLiPairColor(s, subIndex, supIndex, \&quot;DarkRed\&quot;);\n  end,\n&quot;
 &amp; &quot;\n};\n\n&quot;;

CONST E110 =
   &quot;Source 500 500\nSink 500 500\n0 500 500\n1 500 500\n2 500 500\n3 500 50&quot;
 &amp; &quot;0\n4 500 500\n5 500 500\n6 500 500\n7 500 500\n8 500 500\n9 500 500\n10&quot;
 &amp; &quot; 500 500\n0 -&gt; 1 1.0\n1 -&gt; 2 1.0\n1 -&gt; 3 1.0\n3 -&gt; 4 1.0\n5 -&gt; 6 1.0\n7&quot;
 &amp; &quot; -&gt; 8 1.0\n8 -&gt; 9 1.0\n9 -&gt; 10 1.0\n.\n&quot;;

CONST E111 =
   &quot;; Copyright (C) 1993, Digital Equipment Corporation \n; All rights rese&quot;
 &amp; &quot;rved.                              \n; See the file COPYRIGHT for a ful&quot;
 &amp; &quot;l description.    \n\n(Shape\n  (Height + 0)\n  (VBox\n    (HBox\n     &quot;
 &amp; &quot; (Shape (Width + 0) (Text LeftAlign \&quot;String to compress: \&quot;))\n      (&quot;
 &amp; &quot;Frame Lowered (TypeIn %string =\&quot;abraca\&quot;)))\n    (Glue 2)\n    (HBox\n&quot;
 &amp; &quot;      (Shape (Width + 0) (Text LeftAlign \&quot;Alphabet: \&quot;))\n      (Frame&quot;
 &amp; &quot; Lowered (TypeIn %alphabet =\&quot;abcr\&quot;)))\n    (Glue 2)\n    (HBox\n     &quot;
 &amp; &quot; (Shape (Width + 999) (Boolean\n        %pause\n        (Text LeftAlign&quot;
 &amp; &quot; \&quot;Pause after each phase\&quot;))))\n    (Glue 2)\n    (HBox\n      (Shape &quot;
 &amp; &quot;(Width + 999) (Boolean\n        %finalOnly\n        (Text LeftAlign \&quot;F&quot;
 &amp; &quot;inal decompress phase only\&quot;))))))\n&quot;;

CONST E112 =
   &quot;(* Copyright 1993 Digital Equipment Corporation.                       &quot;
 &amp; &quot;      *)\n(* Distributed only by permission.                           &quot;
 &amp; &quot;                *)\n(*                                                 &quot;
 &amp; &quot;                          *)\n(* Last modified on Sat Oct 23 17:55:06 P&quot;
 &amp; &quot;DT 1993 by heydon                   *)\n\n(* View that traces the path &quot;
 &amp; &quot;of each packet. *)\n\nlet NormalNodeColor = color_named(\&quot;lightgray\&quot;);&quot;
 &amp; &quot;\nlet FullNodeColor = color_named(\&quot;red\&quot;);\nlet BorderColor = color_na&quot;
 &amp; &quot;med(\&quot;black\&quot;);\nlet EdgeColor = color_named(\&quot;blue\&quot;);\nlet Background&quot;
 &amp; &quot;Color = color_named(\&quot;white\&quot;);\nlet LabelColor = BorderColor;\n\nlet M&quot;
 &amp; &quot;axNumColors = 6;\nlet Color = [\n color_named(\&quot;red\&quot;),   color_named(\&quot;&quot;
 &amp; &quot;yellow\&quot;), color_named(\&quot;blue\&quot;),\n color_named(\&quot;purple\&quot;), color_name&quot;
 &amp; &quot;d(\&quot;darkgreen\&quot;), color_named(\&quot;brightorange\&quot;)];\n\nlet CantorPair =\n&quot;
 &amp; &quot;  proc((*int*) i, (*int*) j) (* : int *)\n    var m = i, n = j;\n    if&quot;
 &amp; &quot; i &gt; j then m := j; n := i end;\n    let k = m + n;\n    m + ((k * (k+1&quot;
 &amp; &quot;)) / 2)\n  end;\n\nlet MakeBezierPathProc = proc (cpp)\n(* ------------&quot;
 &amp; &quot;--------------------------\n   cpp = array of four control points [x,y]&quot;
 &amp; &quot;\n\n   Return a parametric procedure that traces the bezier curve from &quot;
 &amp; &quot;cpp[0] to\n   cpp[3] with control points cpp[1] and cpp[2].\n  --------&quot;
 &amp; &quot;----------------------------- *)\n  let x000 = cpp[0][0],  y000 = cpp[0&quot;
 &amp; &quot;][1],\n      x001 = cpp[1][0],  y001 = cpp[1][1],\n      x011 = cpp[2][&quot;
 &amp; &quot;0],  y011 = cpp[2][1],\n      x111 = cpp[3][0],  y111 = cpp[3][1];\n  p&quot;
 &amp; &quot;roc (t)\n      let s = 1.0 - t;\n      let ss = s * s, tt = t * t;\n   &quot;
 &amp; &quot;   let sss = s * ss,\n          sst = ss * t * 3.0,\n          stt = s &quot;
 &amp; &quot;* tt * 3.0,\n          ttt = t * tt;\n      [(sss * x000) + (sst * x001&quot;
 &amp; &quot;) + (stt * x011) + (ttt * x111),\n       (sss * y000) + (sst * y001) + &quot;
 &amp; &quot;(stt * y011) + (ttt * y111)]\n  end\nend;\n\nlet Interp = proc ((*real*&quot;
 &amp; &quot;) t, (*R2.T*) a,b) (* : R2.T *)\n(* Return the point a \&quot;t\&quot; fraction o&quot;
 &amp; &quot;f the way from \&quot;a\&quot; to \&quot;b\&quot;. *)\n  let s = 1.0 - t;\n  let Interp1 = &quot;
 &amp; &quot;proc((*real*) r1, r2) (* : real *) (r1*s)+(r2*t) end;\n  [Interp1(a[0],&quot;
 &amp; &quot; b[0]), Interp1(a[1], &quot;;

CONST E112_0 =
   &quot;b[1])]\nend;\n\nlet AnimateBezierEdge = proc(vv,cpp)\n(* --------------&quot;
 &amp; &quot;------------------------\n   vv = array of three vertexes\n   cpp = arr&quot;
 &amp; &quot;ay of four control points [x,y]\n\n   Assuming there is an edge from so&quot;
 &amp; &quot;me vertex to v[2] with control points v[0]\n   and v[1], this routine a&quot;
 &amp; &quot;nimates v[0]..v[2] so that the edge appears to draw\n   the bezier curv&quot;
 &amp; &quot;e given by the control points cpp. At time 0.0 the edge is a\n   dot at&quot;
 &amp; &quot; cpp[0]. At time 1.0 the edge is a bezier curve from cpp[0] to cpp[3]\n&quot;
 &amp; &quot;   with control points cpp[1] and cpp[2]. \n  -------------------------&quot;
 &amp; &quot;------------ *)\n  for i = 1 to 3 do\n      let j = i - 1;\n      let t&quot;
 &amp; &quot; = float(i)/3.0;\n      graph_moveVertexOnPath(vv[j],MakeBezierPathProc&quot;
 &amp; &quot;(\n        [cpp[0], Interp(t, cpp[0], cpp[1]), Interp(t, cpp[i], cpp[j]&quot;
 &amp; &quot;), cpp[i]]\n      ))\n  end\nend;\n\nlet Node = {\n  (*int*) id =&gt; ok,\t&quot;
 &amp; &quot;\t(* this node\'s unique id *)\n  (*GraphVBT.Vertex*) v =&gt; ok,\t(* the &quot;
 &amp; &quot;vertex for this graph node *)\n  (*R2.T*) pos =&gt; ok,\t\t(* node locatio&quot;
 &amp; &quot;n *)\n\n  init =&gt;\n    meth(self, (*graphvbt*) g, (*int*) id, (*real*) &quot;
 &amp; &quot;x, (*real*) y)\n      let vtx = graph_newVertex(g);\n      graph_setVer&quot;
 &amp; &quot;texShape(vtx, \&quot;ellipse\&quot;);\n      graph_setVertexColor(vtx, NormalNode&quot;
 &amp; &quot;Color);\n      graph_setVertexBorderColor(vtx, BorderColor);\n      gra&quot;
 &amp; &quot;ph_moveVertex(vtx, x, y, false);\n      self.id := id;\n      self.v :=&quot;
 &amp; &quot; vtx;\n      self.pos := [x, y];\n      self\n    end,\n\n  setSize =&gt;\n&quot;
 &amp; &quot;    meth(self, (*real*) size, (*real*) borderSz)\n      graph_setVertex&quot;
 &amp; &quot;Size(self.v, size, size);\n      graph_setVertexBorder(self.v, borderSz&quot;
 &amp; &quot;)\n    end\n}; (* Node *)\n\nlet Pkt = {\n  (*GraphVBT.Vertex*) v =&gt; ok&quot;
 &amp; &quot;,\t(* the vertex for this packet *)\n\n  init =&gt;\n    meth(self, (*grap&quot;
 &amp; &quot;hvbt*) g, (*int*) level, (*R2.T*) pos)\n      let vtx = graph_newVertex&quot;
 &amp; &quot;(g);\n      graph_setVertexShape(vtx, \&quot;ellipse\&quot;);\n      graph_setVer&quot;
 &amp; &quot;texColor(vtx, Color[level]);\n      graph_setVertexBorderColor(vtx, Bor&quot;
 &amp; &quot;derColor);\n      graph_moveVertex(vtx, pos[0], pos[1], false);\n      &quot;
 &amp; &quot;self.v := vtx;\n      self\n    end,\n\n  setSize =&gt;\n    meth(self, (*&quot;
 &amp; &quot;real*) size, &quot;;

CONST E112_1 =
   &quot;(*real*) borderSz)\n      graph_setVertexSize(self.v, size, size);\n   &quot;
 &amp; &quot;   graph_setVertexBorder(self.v, borderSz)\n    end\n}; (* Pkt *)\n\nle&quot;
 &amp; &quot;t Edge = {\n  (*R2.T*) startPos =&gt; ok,\t(* location of start point *)\n&quot;
 &amp; &quot;  (*Vertex*) endPt =&gt; ok,\t(* moved end point*)\n  (*Vertex*) c1 =&gt; ok,&quot;
 &amp; &quot;\t\t(* dummy control point 1 *)\n  (*Vertex*) c2 =&gt; ok,\t\t(* dummy con&quot;
 &amp; &quot;trol point 2 *)\n  (*Edge*) e =&gt; ok,\t\t(* the GraphVBT object for this&quot;
 &amp; &quot; edge *)\n\n  init =&gt;\n    meth(self, (*graphvbt*) g, (*int*) level, (*&quot;
 &amp; &quot;Node*) src, (*bool*) bezier)\n      let NewV = proc() (* : Vertex *)\n &quot;
 &amp; &quot;       let res = graph_newVertex(g);\n        graph_setVertexSize(res, &quot;
 &amp; &quot;0.0, 0.0);\n        graph_moveVertex(res, src.pos[0], src.pos[1], false&quot;
 &amp; &quot;);\n        res\n      end;\n      self.startPos := src.pos;\n      sel&quot;
 &amp; &quot;f.endPt := NewV();\n      self.e := graph_newEdge(src.v, self.endPt);\n&quot;
 &amp; &quot;      if bezier then\n        self.c1 := NewV();\n        self.c2 := Ne&quot;
 &amp; &quot;wV();\n        graph_moveEdgeBezier(self.e, src.v,self.endPt, self.c1,s&quot;
 &amp; &quot;elf.c2, false)\n      end;\n      graph_setEdgeColor(self.e, Color[leve&quot;
 &amp; &quot;l]);\n      self\n    end,\n\n  setSize =&gt;\n    meth(self, (*real*) wid&quot;
 &amp; &quot;th)\n      graph_setEdgeWidth(self.e, width)\n    end,\n\n  grow =&gt;\n  &quot;
 &amp; &quot;  meth(self, (*R2.T*) endPos)\n      graph_moveVertex(self.endPt, endPo&quot;
 &amp; &quot;s[0], endPos[1], true)\n    end,\n\n  growBezier =&gt;\n    meth(self, (*R&quot;
 &amp; &quot;2.T*) endPos, (*R2.T*) c1Pos, c2Pos)\n      AnimateBezierEdge(\n       &quot;
 &amp; &quot; [self.c1, self.c2, self.endPt],\n        [self.startPos, c1Pos, c2Pos,&quot;
 &amp; &quot; endPos])\n    end\n}; (* Edge *)\n\nlet EdgeEntry = {\n  (*int*) id =&gt;&quot;
 &amp; &quot; ok,\t\t(* unique identifier for this edge *)\n  (*Node*) end1 =&gt; ok,\t&quot;
 &amp; &quot;\t(* edge endpoint 1 *)\n  (*Node*) end2 =&gt; ok,\t\t(* edge endpoint 2 *&quot;
 &amp; &quot;)\n  (*Vertex*) c1 =&gt; ok,\t\t(* control point 1 (or \&quot;ok\&quot; if straight &quot;
 &amp; &quot;edge *)\n  (*Vertex*) c2 =&gt; ok,\t\t(* control point 2 (or \&quot;ok\&quot; if str&quot;
 &amp; &quot;aight edge *)\n  (*GraphVBT.Edge*) e =&gt; ok,\t(* the (thin blue) graph e&quot;
 &amp; &quot;dge *)\n  (*[Edge]*) edge =&gt; ok,\t(* array of NumColors Edge objects *)&quot;
 &amp; &quot;\n  (*EdgeEntry*) next =&gt; ok,\t(* pointer to next entry in hash table *&quot;
 &amp; &quot;)\n\n  init =&gt;\n    meth(sel&quot;;

CONST E112_2 =
   &quot;f, (*int*) id, (*Node*) src, dest, (*Vertex*) c1, c2)\n      self.id :=&quot;
 &amp; &quot; id;\n      self.end1 := src;\n      self.end2 := dest;\n      self.e :&quot;
 &amp; &quot;= graph_newEdge(src.v, dest.v);\n      if (c1 isnot ok) andif (c2 isnot&quot;
 &amp; &quot; ok) then\n        self.c1 := c1; self.c2 := c2;\n        graph_moveEdg&quot;
 &amp; &quot;eBezier(self.e, src.v, dest.v, c1, c2, false)\n      end;\n      graph_&quot;
 &amp; &quot;setEdgeColor(self.e, EdgeColor);\n      self.edge := array_new(MaxNumCo&quot;
 &amp; &quot;lors, ok);\n      self\n    end,\n\n  addEdge =&gt;\n    meth(self, (*grap&quot;
 &amp; &quot;hvbt*) g, (*int*) level, (*Node*) src, (*bool*) bezier)\n    (* If ther&quot;
 &amp; &quot;e is already an edge in this entry at level \&quot;level\&quot;, then return\n   &quot;
 &amp; &quot;    \&quot;ok\&quot;. Otherwise, create a new edge, install it in the entry, and &quot;
 &amp; &quot;return\n       it. *)\n      var res = self.edge[level];\n      if res &quot;
 &amp; &quot;is ok then\n        (* no edge on this level yet; create new Edge and a&quot;
 &amp; &quot;nimate it *)\n        res := clone(Edge).init(g, level, src, bezier);\n&quot;
 &amp; &quot;        self.edge[level] := res;\n        (* bring any other edges to f&quot;
 &amp; &quot;ront in reverse order *)\n        var i = (level - 1);\n        loop\n &quot;
 &amp; &quot;         if i &lt; 0 then exit end;\n          if self.edge[i] isnot ok th&quot;
 &amp; &quot;en\n            graph_edgeToFront(self.edge[i].e)\n          end;\n    &quot;
 &amp; &quot;      i := i - 1\n        end;\n        res\n      else\n        ok\n  &quot;
 &amp; &quot;    end\n    end\n}; (* EdgeEntry *)\n\nlet TableSize = 109;\n\nlet Tab&quot;
 &amp; &quot;leIterator = {\n  (*int*) bkt =&gt; ok,\t\t(* current bucket *)\n  (*[Edge&quot;
 &amp; &quot;Entry]*) bucket =&gt; ok,\t(* array of buckets *)\n  (*EdgeEntry*) entry =&quot;
 &amp; &quot;&gt; ok,\t(* current entry *)\n\n  init =&gt; meth(self, (*[EdgeEntry]*) buck&quot;
 &amp; &quot;et)\n    self.bkt := -1;\n    self.bucket := bucket;\n    self.entry :=&quot;
 &amp; &quot; ok;\n    self\n  end,\n\n  next =&gt;\n    meth(self) (* : EdgeEntry *)\n&quot;
 &amp; &quot;    (* Return the next EdgeEntry in the table, or \&quot;ok\&quot; if there are n&quot;
 &amp; &quot;one. *)\n      if self.entry isnot ok then self.entry := self.entry.nex&quot;
 &amp; &quot;t end;\n      loop\n        if self.entry isnot ok then exit end;\n    &quot;
 &amp; &quot;    self.bkt := self.bkt + 1;\n        if self.bkt &gt;= TableSize then ex&quot;
 &amp; &quot;it end;\n        self.entry := self.bucket[self.bkt]\n      end;\n     &quot;
 &amp; &quot; self.entry\n   &quot;;

CONST E112_3 =
   &quot; end\n}; (* TableIterator *)\n\nlet EdgeTable = {\n  (*[EdgeEntry] *) b&quot;
 &amp; &quot;ucket =&gt; ok,\t(* array of buckets *)\n\n  init =&gt; meth(self) self.bucke&quot;
 &amp; &quot;t := array_new(TableSize, ok); self end,\n  hash =&gt; meth(self, (*int*) &quot;
 &amp; &quot;val) val % TableSize end,\n\n  addEntry =&gt;\n    meth(self, (*Node*) src&quot;
 &amp; &quot;, dest, (*Vertex*) c1, c2) (* : EdgeEntry *)\n    (* Create and initial&quot;
 &amp; &quot;ize a new EdgeEntry and add it to \&quot;self\&quot;; return\n       the new Edge&quot;
 &amp; &quot;Entry. *)\n      let id = CantorPair(src.id, dest.id);\n      let bkt =&quot;
 &amp; &quot; self.hash(id);\n      var (*EdgeEntry*) entry = clone(EdgeEntry).init(&quot;
 &amp; &quot;id, src, dest, c1, c2);\n      entry.next := self.bucket[bkt];\n      s&quot;
 &amp; &quot;elf.bucket[bkt] := entry;\n      entry\n    end,\n\n  findEntry =&gt;\n   &quot;
 &amp; &quot; meth(self, (*int*) id) (* : EdgeEntry *)\n    (* Returns the EdgeEntry&quot;
 &amp; &quot; with identifier \&quot;id\&quot;, or \&quot;ok\&quot; if\n       there is no such entry. *&quot;
 &amp; &quot;)\n      var (*EdgeEntry*) entry = self.bucket[self.hash(id)];\n      l&quot;
 &amp; &quot;oop\n        if (entry is ok) orif (entry.id is id) then exit end;\n   &quot;
 &amp; &quot;     entry := entry.next\n      end;\n      entry\n    end,\n\n  iterat&quot;
 &amp; &quot;e =&gt;\n    meth(self) (* : TableIterator *)\n      clone(TableIterator).&quot;
 &amp; &quot;init(self.bucket)\n    end\n}; (* EdgeTable *)\n\nlet view = {\n  graph&quot;
 &amp; &quot;vbt =&gt; graph_new(),\n  (*bool*) bounded =&gt; false,\t(* bounded queue siz&quot;
 &amp; &quot;e?, set by StartGraph *)\n  (*[Node]*) node =&gt; ok,\t(* allocated by Sta&quot;
 &amp; &quot;rtGraph *)\n  (*font*) vertexFont =&gt; ok,\t(* set by StartGraph *)\n  (*&quot;
 &amp; &quot;real*) maxNodeSize =&gt; ok,\t(* set by EndGraph *)\n  (*real*) borderSize&quot;
 &amp; &quot; =&gt; ok,\t(* set by EndGraph *)\n  (*real*) minPktSize =&gt; ok,\t(* smalle&quot;
 &amp; &quot;st packet, set by StartPackets *)\n  (*real*) deltaPktSize =&gt; ok,\t(* p&quot;
 &amp; &quot;acket delta, set by StartPackets *)\n  (*int*) numColors =&gt; ok,\t(* num&quot;
 &amp; &quot;ber of colors, set by StartPackets *)\n  (*[Pkt]*) pkt =&gt; ok,\t\t(* all&quot;
 &amp; &quot;ocated by StartPackets *)\n  (*bool*) pktsMoved =&gt; false,\t(* did any p&quot;
 &amp; &quot;ackets move this step? *)\n\n  pktSize =&gt;\n    meth(self, (*int*) level&quot;
 &amp; &quot;)\n      self.minPktSize + (float(level) * self.deltaPktSize)\n    end,&quot;
 &amp; &quot;\n\n  StartGraph =&gt;\n    meth(self, nodeCnt, unused, bounded, (*real*) &quot;
 &amp; &quot;xMax, (*real*) yM&quot;;

CONST E112_4 =
   &quot;ax)\n      self.vertexFont := graph_newFont(self.graphvbt,\n        \&quot;H&quot;
 &amp; &quot;elvetica\&quot;, 0.5, \&quot;Roman\&quot;, \&quot;bold\&quot;, \&quot;*\&quot;);\n      graph_setWorld(sel&quot;
 &amp; &quot;f.graphvbt, 0.0, xMax, yMax, 0.0);\n      graph_setAspect(self.graphvbt&quot;
 &amp; &quot;, yMax / xMax);\n      self.bounded := bounded;\n      self.node := arr&quot;
 &amp; &quot;ay_new(nodeCnt, ok);\n      EdgeTable.init()\n    end,\n\n  NewNode =&gt;\n&quot;
 &amp; &quot;    meth(self, id, (*real*) x, (*real*) y)\n      self.node[id] := clon&quot;
 &amp; &quot;e(Node).init(self.graphvbt, id, x, y)\n    end,\n\n  NewStraightEdge =&gt;&quot;
 &amp; &quot;\n    meth(self, (*int*) id1, id2)\n      EdgeTable.addEntry(self.node[&quot;
 &amp; &quot;id1], self.node[id2], ok, ok)\n    end,\n\n  NewCurvedEdge =&gt;\n    meth&quot;
 &amp; &quot;(self, (*int*) id1, id2, (*real*) x1, y1, x2, y2)\n      let NewControl&quot;
 &amp; &quot; = proc((*real*) x, y)\n        let res = graph_newVertex(self.graphvbt&quot;
 &amp; &quot;);\n        graph_setVertexSize(res, 0.0, 0.0);\n        graph_moveVert&quot;
 &amp; &quot;ex(res, x, y, false);\n        res\n      end;\n      let c1 = NewContr&quot;
 &amp; &quot;ol(x1, y1);\n      let c2 = NewControl(x2, y2);\n      EdgeTable.addEnt&quot;
 &amp; &quot;ry(self.node[id1], self.node[id2], c1, c2)\n    end,\n\n  NewLabel =&gt; m&quot;
 &amp; &quot;eth (self, label, x, y)\n    let vl = graph_newVertex(self.graphvbt);\n&quot;
 &amp; &quot;    graph_setVertexFont(vl, self.vertexFont);\n    graph_setVertexSize(&quot;
 &amp; &quot;vl, 0.5, 0.5);\n    graph_setVertexColor(vl, BackgroundColor);\n    gra&quot;
 &amp; &quot;ph_moveVertex(vl, x, y, false);\n    graph_setVertexLabel(vl, label);\n&quot;
 &amp; &quot;    graph_setVertexLabelColor(vl, LabelColor);\n  end,\n\n  EndGraph =&gt;&quot;
 &amp; &quot;\n    meth(self)\n      let distance = proc(pt1, pt2)\n        let dx =&quot;
 &amp; &quot; pt2[1] - pt1[1], dy = pt2[0] - pt1[0];\n        (dx * dx) + (dy * dy)\n&quot;
 &amp; &quot;      end;\n      (* set \&quot;minDst\&quot; to minimum distance between nodes *&quot;
 &amp; &quot;)\n      var minDst = ok;\n      minDst := distance(self.node[0].pos, s&quot;
 &amp; &quot;elf.node[1].pos);\n      for i = 0 to #(self.node) - 1 do\n\tlet pos1 =&quot;
 &amp; &quot; self.node[i].pos;\n\tfor j = (i + 1) to #(self.node) - 1 do\n\t  let c&quot;
 &amp; &quot;urDst = distance(pos1, self.node[j].pos);\n\t  if curDst &lt; minDst then &quot;
 &amp; &quot;minDst := curDst end\n\tend\n      end;\n      minDst := math_sqrt(minD&quot;
 &amp; &quot;st);\n      (* set \&quot;maxNodeSize\&quot;, \&quot;borderSize\&quot;, \&quot;deltaPktSize\&quot;, \&quot;&quot;
 &amp; &quot;minPktSize\&quot; *)\n     &quot;;

CONST E112_5 =
   &quot; self.maxNodeSize := minDst * 0.7;\n      self.borderSize := self.maxNo&quot;
 &amp; &quot;deSize / 20.0;\n      (* set node sizes *)\n      for i = 0 to #(self.n&quot;
 &amp; &quot;ode) - 1 do\n\tself.node[i].setSize(self.maxNodeSize, self.borderSize *&quot;
 &amp; &quot; 1.5);\n      end;\n    end,\n\n  StartPackets =&gt;\n    meth(self, numPk&quot;
 &amp; &quot;ts)\n      let min = proc(i, j) if i &lt; j then i else j end end;\n      &quot;
 &amp; &quot;self.numColors := min(MaxNumColors, numPkts);\n      self.deltaPktSize &quot;
 &amp; &quot;:= self.maxNodeSize / (float(self.numColors)+3.0);\n      self.minPktSi&quot;
 &amp; &quot;ze := 1.5 * self.deltaPktSize;\n      self.pkt := array_new(numPkts, ok&quot;
 &amp; &quot;);\n      (* set edge widths *)\n      var it = EdgeTable.iterate();\t(&quot;
 &amp; &quot;* table iterator *)\n      var entry = ok;\t\t\t(* edge entry *)\n     &quot;
 &amp; &quot; let edgeWidth = self.minPktSize / 2.0;\n      loop\n        entry := i&quot;
 &amp; &quot;t.next();\n        if entry is ok then exit end;\n        graph_setEdge&quot;
 &amp; &quot;Width(entry.e, edgeWidth)\n      end\n    end,\n\n  NewPacket =&gt;\n    m&quot;
 &amp; &quot;eth(self, (*int*) id, (*int*) src, (*int*) dest, unused1, unused2)\n   &quot;
 &amp; &quot;   let level = id % self.numColors;\n      let pkt = clone(Pkt).init(se&quot;
 &amp; &quot;lf.graphvbt, level, self.node[src].pos);\n      pkt.setSize(self.pktSiz&quot;
 &amp; &quot;e(level), self.borderSize);\n      self.pkt[id] := pkt\n    end,\n\n  E&quot;
 &amp; &quot;ndPackets =&gt;\n    meth(self)\n      (* stack the packets from back to f&quot;
 &amp; &quot;ront *)\n      let n = #(self.pkt);\n      for i = 0 to self.numColors &quot;
 &amp; &quot;- 1 do\n        var j = (self.numColors - 1) - i;\n        loop\n      &quot;
 &amp; &quot;    if j &gt;= n then exit end;\n          graph_vertexToFront(self.pkt[j]&quot;
 &amp; &quot;.v);\n          j := j + self.numColors\n        end\n      end;\n     &quot;
 &amp; &quot; graph_redisplay(self.graphvbt)\n    end,\n\n  MovePacket =&gt;\n    meth(&quot;
 &amp; &quot;self, (*int*) id, (*int*) src, dest)\n      let pos = self.node[dest].p&quot;
 &amp; &quot;os;\n      let level = id % self.numColors;\n      self.pktsMoved := tr&quot;
 &amp; &quot;ue;\n      let entry = EdgeTable.findEntry(CantorPair(src, dest));\n   &quot;
 &amp; &quot;   let bezier = (entry.c1 isnot ok) and (entry.c2 isnot ok);\n      let&quot;
 &amp; &quot; edge = entry.addEdge(self.graphvbt, level, self.node[src], bezier);\n &quot;
 &amp; &quot;     if edge isnot ok then\n        edge.setSize(self.pktSize(level));\n&quot;
 &amp; &quot;    &quot;;

CONST E112_6 =
   &quot;    if not(bezier) then\n          graph_moveVertex(self.pkt[id].v, pos&quot;
 &amp; &quot;[0], pos[1], true);\n          edge.grow(pos)\n        else\n          &quot;
 &amp; &quot;var c1 = entry.c1, c2 = entry.c2, t = ok;\n          if src isnot entry&quot;
 &amp; &quot;.end1.id then\n            t := c1; c1 := c2; c2 := t\n          end;\n&quot;
 &amp; &quot;          let c1Pos = graph_getVertexPosition(c1);\n          let c2Pos&quot;
 &amp; &quot; = graph_getVertexPosition(c2);\n          graph_moveVertexOnPath(self.&quot;
 &amp; &quot;pkt[id].v, MakeBezierPathProc(\n            [self.node[src].pos, c1Pos,&quot;
 &amp; &quot; c2Pos, pos]));\n          edge.growBezier(pos, c1Pos, c2Pos)\n        &quot;
 &amp; &quot;end\n      end\n    end,\n\n  QueueSizes =&gt;\n    meth(self, (*UNUSED*) &quot;
 &amp; &quot;queueSizes)\n      if self.pktsMoved then\n        self.pktsMoved := fa&quot;
 &amp; &quot;lse;\n        zeus_animate(self.graphvbt, 0.0, 1.0)\n      end\n    end&quot;
 &amp; &quot;\n};\n&quot;;

CONST E113 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:37:06 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Sort&quot;
 &amp; &quot;.evt.\n;***************************************************************&quot;
 &amp; &quot;*****\n\n(VBox\n  (Rim\n    (Pen 2)\n    (HBox\n      (VBox (Glue 4) (S&quot;
 &amp; &quot;hape (Height + Inf) (Button %clear \&quot;CLEAR\&quot;)) (Glue 4))\n      (Glue 4&quot;
 &amp; &quot;)\n      (VBox\n        (Boolean =TRUE %alg (Text LeftAlign \&quot;Algorithm&quot;
 &amp; &quot; events\&quot;))\n        (Boolean =FALSE %zeus (Text LeftAlign \&quot;Zeus event&quot;
 &amp; &quot;s\&quot;))\n        (Boolean =TRUE %args (Text LeftAlign \&quot;Display args to e&quot;
 &amp; &quot;vents\&quot;)))\n      Fill))\n  (Bar 1)\n  (Shape (ShadowSize 0) (Height 20&quot;
 &amp; &quot;0 + INF) (TextEdit ReadOnly %transcript)))\n&quot;;

CONST E114 =
   &quot;; Copyright (C) 1992, Digital Equipment Corporation\n; All rights reser&quot;
 &amp; &quot;ved.\n; See the file COPYRIGHT for a full description.\n\n(Rim (Pen 10)&quot;
 &amp; &quot; \n  (Radio =fromSample (VBox \n    (Choice %fromSample (Text LeftAlign&quot;
 &amp; &quot; \&quot;Sample data file\&quot;))\n    (Glue 10)\n    (Choice %fromFile   (Text L&quot;
 &amp; &quot;eftAlign \&quot;Select data file:\&quot;))\n    (Glue 5) \n    (Border (Shape (He&quot;
 &amp; &quot;ight 100) (FileBrowser %graphdata))))))\n&quot;;

CONST E115 =
   &quot;(* Copyright (C) 1994, Digital Equipment Corporation                   &quot;
 &amp; &quot;      *)\n(* All rights reserved.                                      &quot;
 &amp; &quot;                *)\n(* See the file COPYRIGHT for a full description.  &quot;
 &amp; &quot;                          *)\n(*                                       &quot;
 &amp; &quot;                                    *)\n(* Last modified on Mon Jan  9 &quot;
 &amp; &quot;12:04:37 PST 1995 by najork                   *)\n(*      modified on F&quot;
 &amp; &quot;ri Aug 19 15:37:51 PDT 1994 by heydon                   *)\n(*      mod&quot;
 &amp; &quot;ified on Tue Jun 14 12:28:51 PDT 1994 by shillner                 *)\n\n&quot;
 &amp; &quot;(* Tree.obl -- tree view for Union-Find *)\n\nlet NodeBgColor       = c&quot;
 &amp; &quot;olor_named(\&quot;Green\&quot;);\nlet NodeFgColor       = color_named(\&quot;Black\&quot;);&quot;
 &amp; &quot;\nlet NormalEdgeColor   = color_named(\&quot;Black\&quot;);\nlet HiliteEdgeColor &quot;
 &amp; &quot;  = color_named(\&quot;Red\&quot;);\nlet RankBarBgColor    = color_named(\&quot;Red\&quot;)&quot;
 &amp; &quot;;\nlet RankBarFgColor    = color_named(\&quot;Black\&quot;);\n\n(* Hilite colors &quot;
 &amp; &quot;*)\nlet SelectHiLiColor   = color_named(\&quot;Orange\&quot;);\nlet DoFindUpHiLiC&quot;
 &amp; &quot;olor = color_named(\&quot;Red\&quot;);\nlet DoFindDnHiLiColor = color_named(\&quot;Pur&quot;
 &amp; &quot;ple\&quot;);\nlet FoundHiLiColor    = color_named(\&quot;Blue\&quot;);\nlet NodeHilite&quot;
 &amp; &quot;BgColor = color_named(\&quot;Red\&quot;);\n\nlet NodeSz  = 1.0;\nlet FontSz  = 0.&quot;
 &amp; &quot;4;\nlet Margin  = 5.0;           (* in mm *)\nlet VGap    = NodeSz * 1.&quot;
 &amp; &quot;0;  (* vertical gap between levels *)\nlet HGap    = NodeSz * 0.2;  (* &quot;
 &amp; &quot;horizontal gap between siblings *)\nlet RankH   = NodeSz * 0.25; (* hei&quot;
 &amp; &quot;ght of rank bars *)\nlet RankW   = NodeSz * 1.0;  (* width of each rank&quot;
 &amp; &quot; unit *)\nlet RankGap = NodeSz * 0.25; (* gap between root and rank bar&quot;
 &amp; &quot;s *)\nlet RankY   = RankGap + ((NodeSz + RankH)/ 2.0);\n\n(* The \&quot;VGap&quot;
 &amp; &quot;\&quot; is the distance between the bottoms of nodes on level \&quot;i\&quot;\n   and &quot;
 &amp; &quot;the tops of nodes on level \&quot;i+1\&quot;. The \&quot;HGap\&quot; is the gap between the&quot;
 &amp; &quot;\n   right edge of a node and the left edge of its right sibling. *)\n\n&quot;
 &amp; &quot;let BorderWidth   = NodeSz * 0.05;\nlet ThinEdgeWidth = NodeSz * 0.05;\n&quot;
 &amp; &quot;let FatEdgeWidth  = NodeSz * 0.2;\nlet FoundHiLiSz   = NodeSz * 0.08;\n&quot;
 &amp; &quot;let FindHiLiSz    = NodeSz * 0.14;\nlet SelectHiLiSz  = NodeSz * 0.20;\n&quot;
 &amp; &quot;\n(* Node Ob&quot;;

CONST E115_0 =
   &quot;ject (to be cloned) ============================================= *)\n\n&quot;
 &amp; &quot;let Node = {\n  v: Vertex =&gt; ok,        (* The Vertex *)\n  e: Edge =&gt; &quot;
 &amp; &quot;ok,       \t  (* The Edge to the parent *)\n  parent: Node =&gt; ok,     (&quot;
 &amp; &quot;* parent node *)\n  children: Node =&gt; ok,   (* leftmost child node *)\n&quot;
 &amp; &quot;  height: Int =&gt; 0, \t  (* height of tree rooted at this node *)\n  x: &quot;
 &amp; &quot;Real =&gt; ok,          (* x-coordinate of this node *)\n  next =&gt; ok,    &quot;
 &amp; &quot;   \t  (* ids of next and previous siblings *)\n  prev =&gt; ok,\n  rank: &quot;
 &amp; &quot;Int =&gt; 0,\n  rankBar: Vertex =&gt; ok,  (* the vertex of this node\'s rank&quot;
 &amp; &quot; bar (if any) *)\n\n  lastChild =&gt; meth(parent: Node): Node,\n  (* Retu&quot;
 &amp; &quot;rns the rightmost child of \&quot;parent\&quot;, or \&quot;ok\&quot; if \&quot;parent\&quot;\n     is&quot;
 &amp; &quot; a leaf. *)\n    var curr: Node = parent.children;\n    if curr isnot o&quot;
 &amp; &quot;k then\n      loop\n        if curr.next is ok then exit end;\n        &quot;
 &amp; &quot;curr := curr.next\n      end;\n      curr\n    else\n      ok\n    end\n&quot;
 &amp; &quot;  end,\n\n  incHeightToRoot =&gt; meth(parent, child: Node): Ok,\n  (* the&quot;
 &amp; &quot; \&quot;child\&quot; of \&quot;parent\&quot; has just grown in height; grow \&quot;parent\&quot; and\n&quot;
 &amp; &quot;     all nodes on the path from it to the root of the tree in height as&quot;
 &amp; &quot;\n     necessary. *)\n    if (child.height + 1) &gt; parent.height then\n &quot;
 &amp; &quot;     parent.height := (child.height + 1);\n      if parent.parent isnot&quot;
 &amp; &quot; ok then\n        parent.parent.incHeightToRoot(parent)\n      end\n   &quot;
 &amp; &quot; end;\n    ok\n  end,\n\n  addChild =&gt; meth(parent, rightOf, child: Nod&quot;
 &amp; &quot;e): Ok,\n  (* Adds child as a child of parent, inserted to the right of&quot;
 &amp; &quot; \n     the child \&quot;rightOf\&quot;, which must be a child of parent, or as\n&quot;
 &amp; &quot;     the leftmost child if rightOf is ok *)\n    if rightOf is ok then\n&quot;
 &amp; &quot;      child.next := parent.children;\n      child.prev := ok;\n      if&quot;
 &amp; &quot; child.next isnot ok then child.next.prev := child end;\n      parent.c&quot;
 &amp; &quot;hildren := child;\n    else\n      child.prev := rightOf;\n      child.&quot;
 &amp; &quot;next := rightOf.next;\n      if (child.next isnot ok) then child.next.p&quot;
 &amp; &quot;rev := child end;\n      rightOf.next := child;\n    end;\n    child.pa&quot;
 &amp; &quot;rent := parent;\n    parent.incHeightToRoot(child);\n    ok\n  end,\n\n&quot;
 &amp; &quot;  updateHeight =&gt;&quot;;

CONST E115_1 =
   &quot; meth(parent: Node): Ok,\n  (* update the height of \&quot;parent\&quot; to be on&quot;
 &amp; &quot;e greater than the maximum heights\n     of its children, or 0 if it ha&quot;
 &amp; &quot;s no children. *)\n    var maxHt: Int = ~1;\n    var ch: Node = parent.&quot;
 &amp; &quot;children;\n    loop\n      if ch is ok then exit end;\n      if ch.heig&quot;
 &amp; &quot;ht &gt; maxHt then maxHt := ch.height end;\n      ch := ch.next\n    end;\n&quot;
 &amp; &quot;    parent.height := (maxHt + 1);\n    ok\n  end,\n\n  decHeightToRoot &quot;
 &amp; &quot;=&gt; meth(parent: Node, oldChHeight: Int): Ok,\n  (* some child of \&quot;pare&quot;
 &amp; &quot;nt\&quot; has just decreased in height from \&quot;oldChHeight\&quot;,\n     so update&quot;
 &amp; &quot; the height of the \&quot;parent\&quot; if necessary and those of all\n     nodes&quot;
 &amp; &quot; on the path to the root. *)\n    if parent.height is (oldChHeight + 1)&quot;
 &amp; &quot; then\n      var oldParHeight: Int = parent.height;\n      parent.updat&quot;
 &amp; &quot;eHeight();\n      if (parent.height &lt; oldParHeight) and (parent.parent &quot;
 &amp; &quot;isnot ok) then\n        parent.parent.decHeightToRoot(oldParHeight)\n  &quot;
 &amp; &quot;    end\n    end;\n    ok\n  end,\n\n  removeChild =&gt; meth(parent, chil&quot;
 &amp; &quot;d: Node): Ok,\n  (* removes child from parent, which must be its parent&quot;
 &amp; &quot; *)\n    if child.prev isnot ok\n      then child.prev.next := child.ne&quot;
 &amp; &quot;xt;\n      else parent.children := child.next\n    end;\n    if child.n&quot;
 &amp; &quot;ext isnot ok then\n      child.next.prev := child.prev\n    end;\n    c&quot;
 &amp; &quot;hild.prev := ok;\n    child.next := ok;\n    parent.decHeightToRoot(chi&quot;
 &amp; &quot;ld.height);\n    ok\n  end,\n\n  isRightOf =&gt; meth(self, n: Node): Bool&quot;
 &amp; &quot;,\n  (* Returns \&quot;true\&quot; iff \&quot;self\&quot; is a right sibling of \&quot;n\&quot;. *)\n&quot;
 &amp; &quot;    var curr: Node = n.next;\n    loop\n      if (curr is self) or (cur&quot;
 &amp; &quot;r is ok) then exit end;\n      curr := curr.next\n    end;\n    (curr i&quot;
 &amp; &quot;s self)\n  end,\n\n  subtreeWidth =&gt; meth(self: Node): Real,\n  (* Retu&quot;
 &amp; &quot;rns the width of the subtree rooted at \&quot;self\&quot;. *)\n    if self.childr&quot;
 &amp; &quot;en is ok then\n      NodeSz\n    else\n      var res: Real = 0.0;\n    &quot;
 &amp; &quot;  var ch: Node = self.children;\n      loop\n        res := res + ch.su&quot;
 &amp; &quot;btreeWidth();\n        if ch.next is ok then exit end;\n        res := &quot;
 &amp; &quot;res + HGap;\n        ch := ch.next\n      end;\n      res\n    end\n  e&quot;
 &amp; &quot;nd,\n\n  position =&gt; meth(&quot;;

CONST E115_2 =
   &quot;self: Node, level: Int, offset: Real): Ok,\n    let depth: Real = - flo&quot;
 &amp; &quot;at(level) * (NodeSz + VGap);\n    graph_moveVertex(self.v, offset, dept&quot;
 &amp; &quot;h, true);\n    self.x := offset;\n    ok\n  end,\n\n  positionChildren &quot;
 &amp; &quot;=&gt; meth(self: Node, level: Int, offset: Real): Real,\n    var ch: Node &quot;
 &amp; &quot;= self.children;\n    var res: Real = offset;\n    loop\n      if ch is&quot;
 &amp; &quot; ok then exit; end;\n      res := ch.positionSubtree(level, res);\n    &quot;
 &amp; &quot;  if ch.next isnot ok then res := res + HGap; end;\n      ch := ch.next&quot;
 &amp; &quot;;\n    end;\n    res;\n  end,\n\n  positionSubtree =&gt; meth(self: Node, &quot;
 &amp; &quot;level: Int, offset: Real): Real,\n  (* Reposition all nodes in the subt&quot;
 &amp; &quot;ree rooted at \&quot;self\&quot;, with the leftmost\n     descendant at \&quot;offset\&quot;&quot;
 &amp; &quot;, and the root at vertical position \&quot;level\&quot;.\n     Returns the x-coor&quot;
 &amp; &quot;dinate of the rightmost descendant. *)\n    var res = offset;\n    if s&quot;
 &amp; &quot;elf.children is ok\n      then res := res + NodeSz;\n      else res := &quot;
 &amp; &quot;self.positionChildren(level+1, res);\n    end;\n    self.position(level&quot;
 &amp; &quot;, (res + offset) / 2.0);\n    res;\n  end,\n};\n\n(* EdgeList Object ==&quot;
 &amp; &quot;====================================================== *)\n\nlet EdgeLi&quot;
 &amp; &quot;st = {\n  e: Edge =&gt; ok,\n  next: EdgeList =&gt; ok,\n};\n\n(* View Object&quot;
 &amp; &quot; ============================================================ *)\n\nlet&quot;
 &amp; &quot; view: View = {\n\n  (* Data members ----------------------------------&quot;
 &amp; &quot;----------------------- *)\n\n  graphvbt =&gt; graph_new(),\n  graphW: Rea&quot;
 &amp; &quot;l =&gt; ok,          (* the width of the graphvbt *)\n  usesRanks: Bool =&gt;&quot;
 &amp; &quot; ok,       (* \&quot;usesRanks\&quot; arg to \&quot;Setup\&quot; event *)\n  nodeCnt: Int =&quot;
 &amp; &quot;&gt; ok,          (* number of nodes (not counting root) *)\n  height: Int&quot;
 &amp; &quot; =&gt; ok,           (* height of window *)\n  root: Node =&gt; ok,\n  last: &quot;
 &amp; &quot;Node =&gt; ok,\n  node: [Node] =&gt; ok,          (* array of nodes *)\n  new&quot;
 &amp; &quot;Edge: Edge =&gt; ok,         (* Edge added during a unite method *)\n  bot&quot;
 &amp; &quot;hRoots: Bool =&gt; ok,       (* are both nodes to \&quot;Union\&quot; roots? *)\n  l&quot;
 &amp; &quot;abelFont: Font =&gt; ok,       (* font for node labels *)\n  upEdges: Edge&quot;
 &amp; &quot;List =&gt; ok,     (* list of \&quot;StepUp\&quot; edges *)\n  seenStepDown: Bool =&gt;&quot;
 &amp; &quot; ok,    (* a&quot;;

CONST E115_3 =
   &quot;ny \&quot;StepDown\&quot; events after \&quot;Found\&quot;? *)\n  findVh: VertexHiLi =&gt; ok,&quot;
 &amp; &quot;\n  doFindVh: VertexHiLi =&gt; ok,\n  unionVh1: VertexHiLi =&gt; ok,\n  union&quot;
 &amp; &quot;Vh2: VertexHiLi =&gt; ok,\n  foundVh: VertexHiLi =&gt; ok,\n  firstRootVh: Ve&quot;
 &amp; &quot;rtexHiLi =&gt; ok,\n\n  (* The \&quot;height\&quot; field is the height of the large&quot;
 &amp; &quot;st tree that can fit in the\n     window; it is only ever increased. Fo&quot;
 &amp; &quot;r \&quot;view: View\&quot;, the system maintains\n     the invariant: \&quot;view.root&quot;
 &amp; &quot;.height &lt;= view.height\&quot;. *)\n\n  (* Layout method --------------------&quot;
 &amp; &quot;------------------------------------ *)\n\n  repositionAll =&gt; meth(self&quot;
 &amp; &quot;: View): Ok,\n  (* Layout all nodes of the tree rooted at the virtual r&quot;
 &amp; &quot;oot node\n     \&quot;self.root\&quot;. *)\n    if self.root.children isnot ok th&quot;
 &amp; &quot;en\n      var childrenW: Real = 0.0;\n      var numCh: Int = 0;\n      &quot;
 &amp; &quot;var ch: Node = self.root.children;\n      loop\n        childrenW := ch&quot;
 &amp; &quot;ildrenW + ch.subtreeWidth();\n        numCh := numCh + 1;\n        if c&quot;
 &amp; &quot;h.next is ok then exit end;\n        ch := ch.next\n      end;\n      v&quot;
 &amp; &quot;ar gap: Real = 0.0;\n      if numCh &gt; 1 then\n        gap := (self.grap&quot;
 &amp; &quot;hW - childrenW) / float(numCh - 1)\n      end;\n      ch := self.root.c&quot;
 &amp; &quot;hildren;\n      var res: Real = - (NodeSz / 2.0);\n      loop\n      \t&quot;
 &amp; &quot;if ch is ok then exit end;\n      \tres := ch.positionSubtree(0, res);\n&quot;
 &amp; &quot;      \tif ch.next isnot ok then res := res + gap end;\n      \tch := c&quot;
 &amp; &quot;h.next\n      end\n    end;\n    ok\n  end,\n\n  repositionRanks =&gt; met&quot;
 &amp; &quot;h(self: View): Ok,\n  (* Reposition the rank bar vertices of those node&quot;
 &amp; &quot;s that are children of\n     \&quot;self.root\&quot;. This procedure just moves t&quot;
 &amp; &quot;he necessary vertices; it doesn\'t\n     animate them. *)\n    var ch =&quot;
 &amp; &quot; self.root.children;\n    loop\n      if (ch is ok) then exit end;\n   &quot;
 &amp; &quot;   let rankX = graph_getVertexPosition(ch.rankBar)[0];\n      if (ch.x &quot;
 &amp; &quot;isnot rankX) then\n        graph_moveVertex(ch.rankBar, ch.x, RankY, tr&quot;
 &amp; &quot;ue)\n      end;\n      ch := ch.next\n    end;\n    ok\n  end,\n\n  set&quot;
 &amp; &quot;World =&gt; meth(self: View): Ok,\n    let rad: Real = NodeSz / 2.0;\n    &quot;
 &amp; &quot;let ht: Real = (float(self.height) * (NodeSz + VGap)) - VGap;\n    var &quot;
 &amp; &quot;north: Real = rad;\n  &quot;;

CONST E115_4 =
   &quot;  if self.usesRanks then north := north + RankGap + RankH end;\n    gra&quot;
 &amp; &quot;ph_setWorld(self.graphvbt,\n      (* east = *) - rad, (* west = *) (- r&quot;
 &amp; &quot;ad) + self.graphW,\n      (* north= *) north, (* south= *) rad + (- ht)&quot;
 &amp; &quot;);\n    ok\n  end,\n\n  (* Setup --------------------------------------&quot;
 &amp; &quot;-------------------------- *)\n\n  Setup =&gt; meth(self: View): Ok,\n    &quot;
 &amp; &quot;graph_setMargin(self.graphvbt, Margin);\n    self.nodeCnt := 0;\n    se&quot;
 &amp; &quot;lf.root := clone(Node);\n    self.last := ok;\n    self.labelFont := gr&quot;
 &amp; &quot;aph_newFont(self.graphvbt, \&quot;Helvetica\&quot;, FontSz,\n      \&quot;Roman\&quot;, \&quot;b&quot;
 &amp; &quot;old\&quot;, \&quot;*\&quot;);\n    ok\n  end,\n\n  NewSet =&gt; meth(self: View, nm: Text&quot;
 &amp; &quot;): Ok,\n    let v = graph_newVertex(self.graphvbt);\n    graph_setVerte&quot;
 &amp; &quot;xShape(v, \&quot;ellipse\&quot;);\n    graph_setVertexSize(v, NodeSz, NodeSz);\n &quot;
 &amp; &quot;   graph_setVertexFont(v, self.labelFont);\n    graph_setVertexLabel(v,&quot;
 &amp; &quot; nm);\n    graph_setVertexLabelColor(v, NodeFgColor);\n    graph_setVer&quot;
 &amp; &quot;texBorder(v, BorderWidth);\n    graph_setVertexColor(v, NodeBgColor);\n&quot;
 &amp; &quot;    var n: Node = clone(Node);\n    self.nodeCnt := self.nodeCnt + 1;\n&quot;
 &amp; &quot;    n.v := v;\n    self.root.addChild(self.last, n);\n    self.last := &quot;
 &amp; &quot;n;\n    ok\n  end,\n\n  FinishedSets =&gt; meth(self: View, numSets: Int, &quot;
 &amp; &quot;usesRanks: Bool): Ok,\n    (* initialize coordinate system *)\n    self&quot;
 &amp; &quot;.height := real_ceiling(math_log(float(numSets))) + 1;\n    self.graphW&quot;
 &amp; &quot; := (float(numSets) * (NodeSz + HGap)) - HGap;\n    self.usesRanks := u&quot;
 &amp; &quot;sesRanks;\n    self.setWorld();\n\n    (* initialize nodes *)\n    self&quot;
 &amp; &quot;.node := array_new(numSets, ok);\n    var curr: Node = self.root.childr&quot;
 &amp; &quot;en;\n    for i = 0 to numSets - 1 do\n      self.node[i] := curr;\n    &quot;
 &amp; &quot;  curr := curr.next\n    end;\n    self.repositionAll();\n\n    (* init&quot;
 &amp; &quot;ialize rank bars *)\n    if usesRanks then\n      for i = 0 to numSets &quot;
 &amp; &quot;- 1 do\n        let node = self.node[i];\n        let v = graph_newVert&quot;
 &amp; &quot;ex(self.graphvbt);\n        node.rankBar := v;\n      \tgraph_setVertex&quot;
 &amp; &quot;Shape(v, \&quot;rectangle\&quot;);\n      \tgraph_setVertexSize(v, RankW * 0.1, R&quot;
 &amp; &quot;ankH);\n      \tgraph_setVertexBorderColor(v, RankBarFgColor);\n      \t&quot;
 &amp; &quot;graph_setVertexBo&quot;;

CONST E115_5 =
   &quot;rder(v, BorderWidth);\n      \tgraph_setVertexColor(v, RankBarBgColor);&quot;
 &amp; &quot;\n        graph_moveVertex(v, node.x, RankY, false);\n      end\n    en&quot;
 &amp; &quot;d;\n    zeus_animate(self.graphvbt, 0.0, 0.0);\n    ok\n  end,\n\n  (* &quot;
 &amp; &quot;Find events ---------------------------------------------------------- &quot;
 &amp; &quot;*)\n\n  StartFind =&gt; meth(self: View, id: Int): Ok,\n    self.findVh :=&quot;
 &amp; &quot; graph_newVertexHiLi(self.node[id].v);\n    graph_setVertexHiLiColor(se&quot;
 &amp; &quot;lf.findVh, SelectHiLiColor);\n    graph_setVertexHiLiBorder(self.findVh&quot;
 &amp; &quot;, SelectHiLiSz, SelectHiLiSz);\n    ok\n  end,\n\n  EndFind =&gt; meth(sel&quot;
 &amp; &quot;f: View, id: Int): Ok,\n    graph_removeVertexHiLi(self.findVh);\n    g&quot;
 &amp; &quot;raph_removeVertexHiLi(self.foundVh);\n    graph_redisplay(self.graphvbt&quot;
 &amp; &quot;);\n    ok\n  end,\n\n  (* DoFind events ------------------------------&quot;
 &amp; &quot;-------------------------- *)\n\n  StartDoFind =&gt; meth(self, id): Ok,\n&quot;
 &amp; &quot;    self.doFindVh := graph_newVertexHiLi(self.node[id].v);\n    graph_s&quot;
 &amp; &quot;etVertexHiLiColor(self.doFindVh, DoFindUpHiLiColor);\n    graph_setVert&quot;
 &amp; &quot;exHiLiBorder(self.doFindVh, FindHiLiSz, FindHiLiSz);\n    graph_redispl&quot;
 &amp; &quot;ay(self.graphvbt);\n    self.upEdges := ok;\n    ok\n  end,\n\n  StepUp&quot;
 &amp; &quot; =&gt; meth(self, child, parent): Ok,\n    (* move vertex hilite up *)\n  &quot;
 &amp; &quot;  graph_moveVertexHiLi(self.doFindVh, self.node[parent].v, true);\n    &quot;
 &amp; &quot;zeus_animate(self.graphvbt, 0.0, 1.0);\n\n    (* make edge thick *)\n  &quot;
 &amp; &quot;  let upEdge = self.node[child].e;\n    graph_setEdgeWidth(upEdge, FatE&quot;
 &amp; &quot;dgeWidth);\n    graph_redisplay(self.graphvbt);\n\n    (* add edge to u&quot;
 &amp; &quot;p-edge list *)\n    var el: EdgeList = clone(EdgeList);\n    el.e := up&quot;
 &amp; &quot;Edge;\n    el.next := self.upEdges;\n    self.upEdges := el;\n    ok\n &quot;
 &amp; &quot; end,\n\n  Found =&gt; meth(self, root): Ok,\n    self.foundVh := graph_ne&quot;
 &amp; &quot;wVertexHiLi(self.node[root].v);\n    graph_setVertexHiLiColor(self.foun&quot;
 &amp; &quot;dVh, FoundHiLiColor);\n    graph_setVertexHiLiBorder(self.foundVh, Foun&quot;
 &amp; &quot;dHiLiSz, FoundHiLiSz);\n    graph_redisplay(self.graphvbt);\n    self.s&quot;
 &amp; &quot;eenStepDown := false;\n    ok\n  end,\n\n  StepDown =&gt; meth(self: View,&quot;
 &amp; &quot; childId, parentId: Int): Ok,\n    let child: Node = self.node[childId]&quot;
 &amp; &quot;;\n\n   &quot;;

CONST E115_6 =
   &quot; (* change hili color if necessary *)\n    if not(self.seenStepDown) th&quot;
 &amp; &quot;en\n      self.seenStepDown := true;\n      graph_setVertexHiLiColor(se&quot;
 &amp; &quot;lf.doFindVh, DoFindDnHiLiColor);\n    end;\n\n    (* move hilight down &quot;
 &amp; &quot;*)\n    graph_moveVertexHiLi(self.doFindVh, child.v, true);\n    zeus_a&quot;
 &amp; &quot;nimate(self.graphvbt, 0.0, 1.0);\n\n    (* make edge thin again *)\n   &quot;
 &amp; &quot; graph_setEdgeWidth(child.e, ThinEdgeWidth);\n    graph_redisplay(self.&quot;
 &amp; &quot;graphvbt);\n    ok\n  end,\n\n  ChangeParent =&gt; meth(self: View, childI&quot;
 &amp; &quot;d, parentId, rootId: Int): Ok,\n    let child: Node = self.node[childId&quot;
 &amp; &quot;];\n    let parent: Node = self.node[parentId];\n    let root: Node = s&quot;
 &amp; &quot;elf.node[rootId];\n\n    (* change tree structure *)\n    var rightOf: &quot;
 &amp; &quot;Node = parent;\n    if parent.children is child then rightOf := rightOf&quot;
 &amp; &quot;.prev end;\n    parent.removeChild(child);\n    root.addChild(rightOf, &quot;
 &amp; &quot;child);\n\n    (* move the edge and subtree *)\n    graph_moveEdge(chil&quot;
 &amp; &quot;d.e, child.v, root.v, true);\n    self.repositionAll();\n    if self.us&quot;
 &amp; &quot;esRanks then self.repositionRanks() end;\n    zeus_animate(self.graphvb&quot;
 &amp; &quot;t, 0.0, 1.0);\n    ok\n  end,\n\n  EndDoFind =&gt; meth(self, id): Ok,\n  &quot;
 &amp; &quot;  if not(self.seenStepDown) then\n      var curr: EdgeList = self.upEdg&quot;
 &amp; &quot;es;\n      loop\n        if curr is ok then exit end;\n        graph_se&quot;
 &amp; &quot;tEdgeWidth(curr.e, ThinEdgeWidth);\n        curr := curr.next\n      en&quot;
 &amp; &quot;d\n    end;\n    graph_removeVertexHiLi(self.doFindVh);\n    graph_redi&quot;
 &amp; &quot;splay(self.graphvbt);\n    ok\n  end,\n\n  (* Union events ------------&quot;
 &amp; &quot;--------------------------------------------- *)\n\n  StartUnion =&gt; met&quot;
 &amp; &quot;h(self: View, id1, id2: Int, bothRoots: Bool): Ok,\n    self.bothRoots &quot;
 &amp; &quot;:= bothRoots;\n    self.unionVh1 := graph_newVertexHiLi(self.node[id1].&quot;
 &amp; &quot;v);\n    self.unionVh2 := graph_newVertexHiLi(self.node[id2].v);\n    g&quot;
 &amp; &quot;raph_setVertexHiLiColor(self.unionVh1, SelectHiLiColor);\n    graph_set&quot;
 &amp; &quot;VertexHiLiColor(self.unionVh2, SelectHiLiColor);\n    graph_setVertexHi&quot;
 &amp; &quot;LiBorder(self.unionVh1, SelectHiLiSz, SelectHiLiSz);\n    graph_setVert&quot;
 &amp; &quot;exHiLiBorder(self.unionVh2, SelectHiLiSz, SelectHiLiSz);\n    graph_red&quot;;

CONST E115_7 =
   &quot;isplay(self.graphvbt);\n    self.newEdge := ok;\n    ok\n  end,\n\n  Fo&quot;
 &amp; &quot;undFirst =&gt; meth(self: View, root1: Int): Ok,\n    self.firstRootVh := &quot;
 &amp; &quot;self.foundVh;\n    ok\n  end,\n\n  CompareRanks =&gt; meth(self: View, id1&quot;
 &amp; &quot;, id2: Int): Ok,\n    ok\n  end,\n\n  Unite =&gt; meth(self: View, childId&quot;
 &amp; &quot;, parentId, pRank: Int): Ok,\n    let child: Node = self.node[childId];&quot;
 &amp; &quot;\n    let parent: Node = self.node[parentId];\n\n    (* create and anim&quot;
 &amp; &quot;ate the new edge *)\n    self.newEdge := graph_newEdge(child.v, parent.&quot;
 &amp; &quot;v);\n    child.e := self.newEdge;\n    graph_setEdgeWidth(self.newEdge,&quot;
 &amp; &quot; FatEdgeWidth);\n    graph_setEdgeColor(self.newEdge, HiliteEdgeColor);&quot;
 &amp; &quot;\n\n    (* update the graph structure *)\n    var rightOf: Node = ok;\n&quot;
 &amp; &quot;    if child.isRightOf(parent)\n      then rightOf := parent.lastChild(&quot;
 &amp; &quot;)\n      else rightOf := ok\n    end;\n    self.root.removeChild(child)&quot;
 &amp; &quot;;\n    parent.addChild(rightOf, child);\n\n    (* make coordinate syste&quot;
 &amp; &quot;m larger if necessary *)\n    if self.root.height &gt; self.height then\n &quot;
 &amp; &quot;     self.height := self.root.height;\n      self.setWorld();\n      gr&quot;
 &amp; &quot;aph_redisplay(self.graphvbt)\n    end;\n\n    (* animate the subtree mo&quot;
 &amp; &quot;tion *)\n    self.repositionAll();\n    if self.usesRanks then\n      g&quot;
 &amp; &quot;raph_removeVertex(child.rankBar);\n      graph_setVertexSize(parent.ran&quot;
 &amp; &quot;kBar, float(pRank) * RankW, RankH);\n      self.repositionRanks()\n    &quot;
 &amp; &quot;end;\n    zeus_animate(self.graphvbt, 0.0, 1.0);\n    ok\n  end,\n\n  E&quot;
 &amp; &quot;ndUnion =&gt; meth(self): Ok,\n    if self.newEdge isnot ok then\n      gr&quot;
 &amp; &quot;aph_setEdgeWidth(self.newEdge, ThinEdgeWidth);\n      graph_setEdgeColo&quot;
 &amp; &quot;r(self.newEdge, NormalEdgeColor);\n    end;\n    graph_removeVertexHiLi&quot;
 &amp; &quot;(self.unionVh1);\n    graph_removeVertexHiLi(self.unionVh2);\n    if no&quot;
 &amp; &quot;t(self.bothRoots) then\n      graph_removeVertexHiLi(self.foundVh);\n  &quot;
 &amp; &quot;    graph_removeVertexHiLi(self.firstRootVh);\n    end;\n    graph_redi&quot;
 &amp; &quot;splay(self.graphvbt);\n    ok\n  end,\n};\n&quot;;

CONST E116 =
   &quot;(* Copyright (C) 1993, Digital Equipment Corporation                   &quot;
 &amp; &quot;      *)\n(* All rights reserved.                                      &quot;
 &amp; &quot;                *)\n(* See the file COPYRIGHT for a full description.  &quot;
 &amp; &quot;                          *)\n\n\nlet view = {\n  graphvbt =&gt; graph_new&quot;
 &amp; &quot;(),\n\n  myPlayer =&gt; ok,\n\n  activePlayer =&gt; ok,\n\n  makeNodeProc =&gt; &quot;
 &amp; &quot;proc (graphvbt, rawBoard)\n  { objects =&gt; \n     ( var res = [[(let v =&quot;
 &amp; &quot; graph_newVertex(graphvbt);\n                     graph_setVertexSize(v&quot;
 &amp; &quot;, 1.0, 1.0);\n                     graph_setVertexColor(v, color_rgb(1.&quot;
 &amp; &quot;0, 1.0 , 1.0));\n                     graph_setVertexBorder(v, 0.125);\n&quot;
 &amp; &quot;                     graph_setVertexBorderColor(v, color_rgb(0.0, 0.0, &quot;
 &amp; &quot;0.0));\n                     v),\n                   0.0,\n            &quot;
 &amp; &quot;       0.0\n                   ]];\n       for cellNum = 0 to 8 do\n   &quot;
 &amp; &quot;       if rawBoard[cellNum] isnot 2 then\n             let piece = grap&quot;
 &amp; &quot;h_newVertex(graphvbt);\n                graph_setVertexSize(piece, 0.25&quot;
 &amp; &quot;, 0.25);\n                if rawBoard[cellNum] is 0 then\n             &quot;
 &amp; &quot;      graph_setVertexColor(piece, color_rgb(0.0, 1.0, 0.0));\n         &quot;
 &amp; &quot;       else\n                   graph_setVertexColor(piece, color_rgb(0&quot;
 &amp; &quot;.0, 0.0, 1.0));\n                end;\n                res := res @ [[p&quot;
 &amp; &quot;iece, float((cellNum / 3)-1) * 0.25, \n                                &quot;
 &amp; &quot;     float((cellNum % 3)-1) * 0.25]]\n           end;\n        end;\n  &quot;
 &amp; &quot;      res;\n      ),\n    Move =&gt; \n      meth(self, Xbase, Ybase, anim&quot;
 &amp; &quot;ate)\n         foreach object in self.objects do\n            graph_mov&quot;
 &amp; &quot;eVertex(object[0], Xbase + object[1], Ybase + object[2],\n             &quot;
 &amp; &quot;   animate);\n         end;\n      end,\n\n     SetValue =&gt;\n       met&quot;
 &amp; &quot;h (self, newValue)\n         graph_setVertexBorderColor( self.objects[0&quot;
 &amp; &quot;][0],\n             color_hsv( ((float(newValue+10)) / 21.0) * 0.7, 1.0&quot;
 &amp; &quot;, 1.0));\n       end,\n  }\n end,\n\n  treeDisplayParams =&gt; ok,\n\n  ma&quot;
 &amp; &quot;keTreeNode =&gt;\n     meth(self, dparams, initNode, NodeWidth, initX, ini&quot;
 &amp; &quot;tY, myKey, board)\n       let newNode =\n         {\n            key =&gt;&quot;;

CONST E116_0 =
   &quot; myKey,\n            displayParameters =&gt; dparams,\n            node =&gt;&quot;
 &amp; &quot; initNode(dparams.graphvbt, board),\n            nodeWidth =&gt; NodeWidth&quot;
 &amp; &quot;,\n            width =&gt; NodeWidth,\n            leftx =&gt; initX,\n      &quot;
 &amp; &quot;      depth =&gt; 0,\n            vertex =&gt; ( let v = graph_newVertex(dpar&quot;
 &amp; &quot;ams.graphvbt);\n                        graph_setVertexSize(v, 0.0, 0.0&quot;
 &amp; &quot; );\n                        v ),\n            children =&gt; [],\n       &quot;
 &amp; &quot;     childWidth =&gt; 0.0,\n            parent =&gt; ok,\n\n            xPos &quot;
 &amp; &quot;=&gt; initX + (NodeWidth /2.0),\n            yPos =&gt; initY,\n\n           &quot;
 &amp; &quot; AddChild =&gt;\n              meth(self, child)\n                self.chi&quot;
 &amp; &quot;ldren := self.children @ [child];\n                child.parent := self&quot;
 &amp; &quot;;\n                child.depth := self.depth + 1;\n(*** WAS:       chil&quot;
 &amp; &quot;d.yPos := self.displayParameters.depth2Y()(self.depth+1);*)\n          &quot;
 &amp; &quot;      let d2Y = self.displayParameters.depth2Y;\n                child.&quot;
 &amp; &quot;yPos := d2Y(self.depth+1);\n                if #(self.children) &gt; 1 the&quot;
 &amp; &quot;n\n                  self.childWidth := self.childWidth +\n            &quot;
 &amp; &quot;          self.displayParameters.spacer;\n                end;\n       &quot;
 &amp; &quot;         child.SetLeftX(self.leftx + self.childWidth);\n               &quot;
 &amp; &quot; self.childWidth := self.childWidth + child.width;\n                let&quot;
 &amp; &quot; e = graph_newEdge(self.vertex, child.vertex);\n                graph_s&quot;
 &amp; &quot;etEdgeWidth(e, self.displayParameters.edgeWidth);\n                if s&quot;
 &amp; &quot;elf.childWidth &gt; self.nodeWidth then\n                  self.width := s&quot;
 &amp; &quot;elf.childWidth;\n                  if self.parent isnot ok then\n      &quot;
 &amp; &quot;               self.parent.ChildWidthChange(self);\n                  e&quot;
 &amp; &quot;nd;\n                  self.xPos := self.leftx + (self.width / 2.0);\n &quot;
 &amp; &quot;                 self.MoveMe();\n                end; \n              e&quot;
 &amp; &quot;nd,\n\n            MoveMe =&gt;\n              meth(self)\n               &quot;
 &amp; &quot;var reSizeWorld = false;\n               if (self.xPos &gt; self.displayPa&quot;
 &amp; &quot;rameters.WorldE) then\n                  self.displayParameters.WorldE &quot;
 &amp; &quot;:= \n                      self.displayParameters.WorldE + \n&quot;;

CONST E116_1 =
   &quot;                      self.displayParameters.WorldStep;\n              &quot;
 &amp; &quot;    reSizeWorld := true;\n               end;\n               if (self.&quot;
 &amp; &quot;yPos &gt; self.displayParameters.WorldS) then\n                  self.disp&quot;
 &amp; &quot;layParameters.WorldS := \n                      self.displayParameters.&quot;
 &amp; &quot;WorldS + \n                      self.displayParameters.WorldStep;\n   &quot;
 &amp; &quot;               reSizeWorld := true;\n               end;\n             &quot;
 &amp; &quot;  if reSizeWorld then\n                  graph_setWorld(self.displayPar&quot;
 &amp; &quot;ameters.graphvbt, 0.0, \n                     self.displayParameters.Wo&quot;
 &amp; &quot;rldE, 0.0, \n                     self.displayParameters.WorldS);\n    &quot;
 &amp; &quot;              graph_setAspect(self.displayParameters.graphvbt,\n       &quot;
 &amp; &quot;              self.displayParameters.WorldS/\n                       se&quot;
 &amp; &quot;lf.displayParameters.WorldE);\n                  graph_redisplay(self.d&quot;
 &amp; &quot;isplayParameters.graphvbt);\n               end;\n               graph_&quot;
 &amp; &quot;moveVertex(self.vertex, self.xPos, self.yPos, true);\n               se&quot;
 &amp; &quot;lf.node.Move(self.xPos, self.yPos, true);\n              end,\n\n      &quot;
 &amp; &quot;      SetLeftX =&gt;\n              meth(self, newLeftX)\n               s&quot;
 &amp; &quot;elf.leftx := newLeftX;\n               var childX = self.leftx;\n      &quot;
 &amp; &quot;         foreach child in self.children do\n                  child.Set&quot;
 &amp; &quot;LeftX(childX);\n                  childX := childX + child.width + \n  &quot;
 &amp; &quot;                     self.displayParameters.spacer;\n               end&quot;
 &amp; &quot;;\n               self.xPos := self.leftx + (self.width / 2.0);\n      &quot;
 &amp; &quot;         self.MoveMe()\n              end,\n\n            ChildWidthCha&quot;
 &amp; &quot;nge =&gt;\n              meth(self, guiltyChild)\n                var chil&quot;
 &amp; &quot;dX = self.leftx;\n                foreach child in self.children do\n  &quot;
 &amp; &quot;                 if child.leftx isnot childX then\n                    &quot;
 &amp; &quot;  child.SetLeftX(childX);\n                   end;\n                   &quot;
 &amp; &quot;childX := childX + child.width +\n                      self.displayPar&quot;
 &amp; &quot;ameters.spacer;\n                end;\n                self.childWidth &quot;
 &amp; &quot;:= childX - (self.leftx +\n                    self.displa&quot;;

CONST E116_2 =
   &quot;yParameters.spacer);\n                if self.childWidth &gt; self.nodeWid&quot;
 &amp; &quot;th then\n                   self.width := self.childWidth;\n           &quot;
 &amp; &quot;       if self.parent isnot ok then\n                     self.parent.C&quot;
 &amp; &quot;hildWidthChange(self);\n                  end;\n                  self.&quot;
 &amp; &quot;xPos := self.leftx + (self.width / 2.0);\n                  self.MoveMe&quot;
 &amp; &quot;();\n                end;\n              end,                     \n   &quot;
 &amp; &quot;       };\n        graph_moveVertex(newNode.vertex, newNode.xPos, newNo&quot;
 &amp; &quot;de.yPos, false);\n        newNode.node.Move(newNode.xPos, newNode.yPos,&quot;
 &amp; &quot; false);\n        graph_redisplay(self.graphvbt);\n        newNode;\n  &quot;
 &amp; &quot;   end,\n\n  lastBoard =&gt; ok,\n\n  Init =&gt; \n    meth (self, player)\n &quot;
 &amp; &quot;     self.myPlayer := player;\n      self;\n    end,\n\n  Setup =&gt;\n   &quot;
 &amp; &quot; meth (self)\n      graph_setWorld(self.graphvbt, 0.0, 10.0, 0.0, 10.0)&quot;
 &amp; &quot;;\n      graph_setAspect(self.graphvbt, 1.0);\n      self.treeDisplayPa&quot;
 &amp; &quot;rams := { graphvbt =&gt; self.graphvbt,\n                                 &quot;
 &amp; &quot; depth2Y =&gt; proc (depth)\n                                             &quot;
 &amp; &quot;  float((2*depth)+1)\n                                             end,&quot;
 &amp; &quot;\n                                  edgeWidth =&gt; 0.1,\n                &quot;
 &amp; &quot;                  spacer =&gt; 0.25,\n                                  Wo&quot;
 &amp; &quot;rldE =&gt; 10.0,\n                                  WorldS =&gt; 10.0,\n     &quot;
 &amp; &quot;                             WorldStep =&gt; 3.0};\n      self.lastBoard :&quot;
 &amp; &quot;= ok;\n    end,\n\n  EvaluateNode =&gt;\n    meth (self, boardData)\n     &quot;
 &amp; &quot; if self.activePlayer is self.myPlayer then\n       var newNode = ok;\n&quot;
 &amp; &quot;       if self.lastBoard is ok then\n          newNode :=  self.makeTre&quot;
 &amp; &quot;eNode(self.treeDisplayParams, \n           self.makeNodeProc, 1.0, 0.0,&quot;
 &amp; &quot; 1.0, boardData[0], boardData[1]);\n       else\n          var parent =&quot;
 &amp; &quot; self.lastBoard;\n          newNode :=  self.makeTreeNode(self.treeDisp&quot;
 &amp; &quot;layParams, \n            self.makeNodeProc, 1.0, self.lastBoard.xPos - &quot;
 &amp; &quot;0.5, \n            self.lastBoard.yPos, boardData[0], boardData[1]);\n &quot;
 &amp; &quot;         self.lastBoard.AddChild(newNode);\n       end;\n       sel&quot;;

CONST E116_3 =
   &quot;f.lastBoard := newNode;\n       zeus_animate(self.graphvbt, 0.0, 1.0);\n&quot;
 &amp; &quot;      end;\n    end,\n\n  PlayerThinking =&gt;\n    meth (self, player, bo&quot;
 &amp; &quot;ardData)\n       self.activePlayer := player;\n       if self.activePla&quot;
 &amp; &quot;yer is self.myPlayer then\n         graph_clear(self.graphvbt);\n      &quot;
 &amp; &quot;   self.treeDisplayParams.WorldE := 10.0;\n         self.treeDisplayPar&quot;
 &amp; &quot;ams.WorldS := 10.0;\n         graph_setWorld(self.graphvbt, 0.0, 10.0, &quot;
 &amp; &quot;0.0, 10.0);\n         graph_setAspect(self.graphvbt, 1.0);\n         se&quot;
 &amp; &quot;lf.lastBoard := ok;\n       end;\n    end,\n\n   FinishedEvalNode =&gt;\n &quot;
 &amp; &quot;    meth (self, boardkey)\n       if self.activePlayer is self.myPlayer&quot;
 &amp; &quot; then\n         self.lastBoard := self.lastBoard.parent;\n       end;\n&quot;
 &amp; &quot;     end,\n\n   BoardValueUpdated =&gt;\n     meth (self, boardkey, newVal&quot;
 &amp; &quot;ue)\n       if self.activePlayer is self.myPlayer then\n         self.l&quot;
 &amp; &quot;astBoard.node.SetValue(newValue);\n         graph_redisplay(self.graphv&quot;
 &amp; &quot;bt);\n       end;\n     end,\n\n  }.Init(0);\n\n&quot;;

CONST E117 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:37:06 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file PQue&quot;
 &amp; &quot;ue.evt.\n;*************************************************************&quot;
 &amp; &quot;*******\n\n(VBox\n  (Rim\n    (Pen 2)\n    (HBox\n      (VBox (Glue 4) &quot;
 &amp; &quot;(Shape (Height + Inf) (Button %clear \&quot;CLEAR\&quot;)) (Glue 4))\n      (Glue&quot;
 &amp; &quot; 4)\n      (VBox\n        (Boolean =TRUE %alg (Text LeftAlign \&quot;Algorit&quot;
 &amp; &quot;hm events\&quot;))\n        (Boolean =FALSE %zeus (Text LeftAlign \&quot;Zeus eve&quot;
 &amp; &quot;nts\&quot;))\n        (Boolean =TRUE %args (Text LeftAlign \&quot;Display args to&quot;
 &amp; &quot; events\&quot;)))\n      Fill))\n  (Bar 1)\n  (Shape (ShadowSize 0) (Height &quot;
 &amp; &quot;200 + INF) (TextEdit ReadOnly %transcript)))\n&quot;;

CONST E118 =
   &quot;; Copyright (C) 1992, Digital Equipment Corporation\n; All rights reser&quot;
 &amp; &quot;ved.\n; See the file COPYRIGHT for a full description.\n\n(Scale\n  (HS&quot;
 &amp; &quot;cale 1)\n  (VScale 1)\n  (Rim\n    (Pen 10)\n    (HBox\n      (VBox\n  &quot;
 &amp; &quot;      (Text RightAlign \&quot;# of buckets: \&quot;)\n        (Text RightAlign \&quot;&quot;
 &amp; &quot;current item: \&quot;)\n        (Text RightAlign \&quot;comparing bucket #: \&quot;))\n&quot;
 &amp; &quot;      (VBox\n        (Frame Chiseled (Text %NBuckets \&quot;\&quot;))\n        (F&quot;
 &amp; &quot;rame Chiseled (Text %item \&quot;\&quot;))\n        (Frame Chiseled (Text %bucket&quot;
 &amp; &quot; \&quot;\&quot;))))))&quot;;

CONST E119 =
   &quot;; Copyright (C) 1994, Digital Equipment Corporation                    &quot;
 &amp; &quot;     \n; All rights reserved.                                          &quot;
 &amp; &quot;            \n; See the file COPYRIGHT for a full description.         &quot;
 &amp; &quot;                   \n\n(Radio\n  (VBox\n    (Glue 6)\n    (HBox\n      &quot;
 &amp; &quot;(Glue 10)\n      Fill\n      (Choice %sort =TRUE \&quot;Sorting\&quot;)\n      Fi&quot;
 &amp; &quot;ll)\n    (Glue 6)\n    (HBox\n      (Glue 10)\n      (Shape (Width + 0)&quot;
 &amp; &quot; \&quot;Number of items: \&quot;)\n      (Glue 5)\n      (Numeric (Min 1) (Max 10&quot;
 &amp; &quot;00) %N =15)\n      (Glue 10))\n    (Glue 8)\n    (Bar)\n    (Glue 8)\n &quot;
 &amp; &quot;   (HBox\n      (Glue 10)\n      Fill\n      (Choice %queue =FALSE \&quot;Pr&quot;
 &amp; &quot;iority Queue\&quot;)\n      Fill)\n    (Glue 6)\n    (HBox\n      (Glue 10)\n&quot;
 &amp; &quot;      (Shape (Width + 0) \&quot;Maximum queue size: \&quot;)\n      (Glue 5)\n   &quot;
 &amp; &quot;   (Numeric (Min 1) (Max 1000) %qSize =15)\n      (Glue 10)\n      Fill&quot;
 &amp; &quot;)\n    (Glue 6)\n    (HBox\n      (Glue 10)\n      (Shape (Width 60 + 0&quot;
 &amp; &quot; - 0) (Button %insert \&quot;Insert\&quot;))\n      (Glue 10)\n      (Numeric (Mi&quot;
 &amp; &quot;n 10) (Max 100) %inselt =20)\n      Fill)\n    (Glue 6)\n    (HBox (Glu&quot;
 &amp; &quot;e 10) (Shape (Width 60 + 0 - 0) (Button %remove \&quot;Remove\&quot;)) Fill)\n   &quot;
 &amp; &quot; (Glue 6)))\n&quot;;

CONST E120 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:37:06 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file PktR&quot;
 &amp; &quot;oute.evt.\n;***********************************************************&quot;
 &amp; &quot;*********\n\n(VBox\n  (Rim\n    (Pen 2)\n    (HBox\n      (VBox (Glue 4&quot;
 &amp; &quot;) (Shape (Height + Inf) (Button %clear \&quot;CLEAR\&quot;)) (Glue 4))\n      (Gl&quot;
 &amp; &quot;ue 4)\n      (VBox\n        (Boolean =TRUE %alg (Text LeftAlign \&quot;Algor&quot;
 &amp; &quot;ithm events\&quot;))\n        (Boolean =FALSE %zeus (Text LeftAlign \&quot;Zeus e&quot;
 &amp; &quot;vents\&quot;))\n        (Boolean =TRUE %args (Text LeftAlign \&quot;Display args &quot;
 &amp; &quot;to events\&quot;)))\n      Fill))\n  (Bar 1)\n  (Shape (ShadowSize 0) (Heigh&quot;
 &amp; &quot;t 200 + INF) (TextEdit ReadOnly %transcript)))\n&quot;;

CONST E121 =
   &quot;(* Copyright (C) 1994, Digital Equipment Corporation         *)\n(* All&quot;
 &amp; &quot; rights reserved.                                      *)\n(* See the f&quot;
 &amp; &quot;ile COPYRIGHT for a full description.            *)\n\n@UnbalancedTest\n&quot;
 &amp; &quot;PROCEDURE UnbalancedTest(insKey, delKey: ARRAY OF Key)@ =\n  VAR t: Tre&quot;
 &amp; &quot;e; n: Node; BEGIN\n    (* Insert \&quot;insKey\&quot; keys *)\n    @1 t.root := N&quot;
 &amp; &quot;IL@;\n    @2 FOR i := FIRST(insKey^) TO LAST(insKey^) DO@\n      @3 n :&quot;
 &amp; &quot;= NEW(Node, key := insKey[i])@;\n      @4 Insert(t, n)@\n    END;\n\n  &quot;
 &amp; &quot;  (* Delete \&quot;delKey\&quot; keys *)\n    @5 FOR i := FIRST(delKey^) TO LAST(&quot;
 &amp; &quot;delKey^) DO@\n      @6 n := Search(alg, delKey[i])@;\n      @7 Delete(a&quot;
 &amp; &quot;lg, n)@\n    END;\n  END UnbalancedTest;\n@UnbalancedTest\n\n@Insert\nP&quot;
 &amp; &quot;ROCEDURE Insert(t: Tree; n: Node)@ =\n  VAR temp, curr: Node; BEGIN\n  &quot;
 &amp; &quot;  @3 temp := t.root;@\n    @4 curr := NIL;@\n    @5 WHILE temp # NIL DO&quot;
 &amp; &quot;@\n      @6 curr := temp;@\n      @7 IF n.key &lt; curr.key@\n        THEN&quot;
 &amp; &quot; @8 temp := curr.left@\n        ELSE @9 temp := curr.right@\n      END\n&quot;
 &amp; &quot;    END;\n    @10 n.parent := curr;@\n    @11 IF curr = NIL@ THEN @12 t&quot;
 &amp; &quot;.root := n@ ELSE\n      @13 IF n.key &lt; curr.key@\n        THEN @14 curr&quot;
 &amp; &quot;.left := n@\n        ELSE @15 curr.right := n@\n      END\n    END\n  E&quot;
 &amp; &quot;ND Insert;\n@Insert\n\n@Search\nPROCEDURE Search(t: Tree; k: Key): Node&quot;
 &amp; &quot;@ =\n  VAR n: Node; BEGIN\n    @1 n := t.root@;\n    @2 WHILE n # NIL A&quot;
 &amp; &quot;ND n.key # key DO@\n      @3 IF key &lt; n.key@\n        THEN @4 n := n.le&quot;
 &amp; &quot;ft@\n        ELSE @5 n := n.right@\n      END\n    END;\n    @6 RETURN &quot;
 &amp; &quot;n@\n  END Search;\n@Search\n\n@Delete\nPROCEDURE Delete(t: Tree; n: Nod&quot;
 &amp; &quot;e)@ =\n  VAR splice: Node; BEGIN\n    (* Set \&quot;splice\&quot; to the node to &quot;
 &amp; &quot;splice out *)\n    @1 IF n.left = NIL OR n.right = NIL@\n      THEN @2 &quot;
 &amp; &quot;splice := n@\n      ELSE @3 splice := FindMin(n.right)@\n    END;\n\n  &quot;
 &amp; &quot;  (* Splice out \&quot;splice\&quot; node *)\n    @4 SpliceOut(t, splice)@;\n\n  &quot;
 &amp; &quot;  (* Replace \&quot;n\&quot; by \&quot;splice\&quot; if necessary *)\n    @5 IF splice # n@&quot;
 &amp; &quot; THEN\n      @6 n.key := splice.key@\n      (* &lt;&lt; copy other node field&quot;
 &amp; &quot;s here &gt;&gt; *)\n    END\n  END Delete;\n@Delete\n\n@FindMin\nPROCEDURE Fi&quot;
 &amp; &quot;ndMin(n: Node): Node@ =\n  BEGI&quot;;

CONST E121_0 =
   &quot;N\n    @1 WHILE n.left # NIL DO@\n      @2 n := n.left2@\n    END;\n   &quot;
 &amp; &quot; @3 RETURN n@\n  END FindMin;\n@FindMin\n\n@SpliceOut\nPROCEDURE Splice&quot;
 &amp; &quot;Out(t: Tree; n: Node)@ =\n  VAR ch: Node; BEGIN\n    (* Set \&quot;ch\&quot; to c&quot;
 &amp; &quot;hild of \&quot;n\&quot; or NIL *)\n    @1 IF n.left # NIL@\n      THEN @2 ch := n&quot;
 &amp; &quot;.left@\n      ELSE @3 ch := n.right@\n    END;\n\n    (* Update \&quot;up\&quot; &quot;
 &amp; &quot;pointer *)\n    @4 IF ch # NIL@ THEN\n      @5 ch.parent := n.parent@\n&quot;
 &amp; &quot;    END;\n\n    (* Update \&quot;down\&quot; pointers *)\n    @6 IF n.parent = NI&quot;
 &amp; &quot;L@ THEN\n      @7 t.root := ch@\n    ELSE\n      @8 IF n = n.parent.lef&quot;
 &amp; &quot;t@\n        THEN @9 n.parent.left := ch@\n        ELSE @10 n.parent.rig&quot;
 &amp; &quot;ht := ch@\n      END\n    END\n  END SpliceOut;\n@SpliceOut\n&quot;;

CONST E122 =
   &quot;(* Copyright (C) 1993, Digital Equipment Corporation                   &quot;
 &amp; &quot;      *)\n(* All rights reserved.                                      &quot;
 &amp; &quot;                *)\n(* See the file COPYRIGHT for a full description.  &quot;
 &amp; &quot;                          *)\n(*                                       &quot;
 &amp; &quot;                                    *)\n(* Last modified on Mon Jan  9 &quot;
 &amp; &quot;12:22:11 PST 1995 by najork                   *)\n(*      modified on W&quot;
 &amp; &quot;ed Oct 13 19:41:07 PDT 1993 by mann                     *)\n(*      mod&quot;
 &amp; &quot;ified on Mon Jul 19 11:59:36 PDT 1993 by perl                     *)\n\n&quot;
 &amp; &quot;let codesColor = color_named(\&quot;White\&quot;);\nlet codesLabelColor = color_n&quot;
 &amp; &quot;amed(\&quot;Black\&quot;);\nlet codesHiliteLabelColor = color_named(\&quot;DarkRed\&quot;);&quot;
 &amp; &quot;\nlet arrowColor = color_named(\&quot;DarkRed\&quot;);\nlet rowIndexColor = color&quot;
 &amp; &quot;_named(\&quot;Pink\&quot;);\nlet rowIndexLabelColor = color_named(\&quot;Black\&quot;);\nle&quot;
 &amp; &quot;t otherIndexColor = color_named(\&quot;White\&quot;);\nlet otherIndexLabelColor =&quot;
 &amp; &quot; color_named(\&quot;DarkGray\&quot;);\nlet alphaColor = color_named(\&quot;LightYellow&quot;
 &amp; &quot;\&quot;);\nlet alphaLabelColor = color_named(\&quot;Black\&quot;);\nlet initialColor =&quot;
 &amp; &quot; color_named(\&quot;DarkGray\&quot;);\nlet initialLabelColor = color_named(\&quot;Blac&quot;
 &amp; &quot;k\&quot;);\nlet shadowColor = color_named(\&quot;VerySlightlyLightGray\&quot;);\nlet s&quot;
 &amp; &quot;hadowLabelColor = color_named(\&quot;Black\&quot;);\nlet ghostColor = color_named&quot;
 &amp; &quot;(\&quot;White\&quot;);\nlet ghostLabelColor = color_named(\&quot;Gray\&quot;);\nlet duplCol&quot;
 &amp; &quot;or = color_named(\&quot;LightGray\&quot;);\nlet duplLabelColor = color_named(\&quot;Ve&quot;
 &amp; &quot;ryDarkGray\&quot;);\n(*let matrixColor = color_named(\&quot;VeryVeryLightGray\&quot;);&quot;
 &amp; &quot;*)\nlet matrixColor = color_named(\&quot;White\&quot;);\nlet matrixLabelColor = c&quot;
 &amp; &quot;olor_named(\&quot;RatherDarkGray\&quot;);\n\nlet charColorNames = [\&quot;VerySlightly&quot;
 &amp; &quot;LightQuiteVividRed\&quot;,\n                      \&quot;VerySlightlyDarkVividGre&quot;
 &amp; &quot;en\&quot;,\n                      \&quot;SlightlyLightVividBlue\&quot;,\n             &quot;
 &amp; &quot;         \&quot;ReddishVividOrange\&quot;,\n                      \&quot;VerySlightlyL&quot;
 &amp; &quot;ightPurple\&quot;,\n                      \&quot;VerySlightlyDarkVeryVividYellow\&quot;&quot;
 &amp; &quot;];\n\nlet charColors = foreach c in charColorNames map color_named(c) e&quot;
 &amp; &quot;nd;\n\nlet makeDippingPath = proc(startX, endX, y, dip)\n    proc(t)\n &quot;
 &amp; &quot;       [ (startX * (1.0 - t)) + (e&quot;;

CONST E122_0 =
   &quot;ndX * t),\n\t  y + (dip * (0.25 - ((t - 0.5) * (t - 0.5))))]\n    end\n&quot;
 &amp; &quot;end;\n\nlet interMatrixGap = 0.5;\nlet decodedY = ~2.0;\n\nlet view =\n&quot;
 &amp; &quot;  {\n    graphvbt =&gt; graph_new(),\n    vertexFont =&gt; ok,\n    last =&gt; {&quot;
 &amp; &quot;chars =&gt; ok, vtx =&gt; ok},\n    first =&gt; {chars =&gt; ok, vtx =&gt; ok},\n    p&quot;
 &amp; &quot;endingMoves =&gt; ok,\n    n =&gt; 0,\n    colorIndex =&gt; -1,\n    rowIndices &quot;
 &amp; &quot;=&gt; ok,\n    rowIndex =&gt; ok,\n    rowIndexVtx =&gt; ok,\n    matrix1 =&gt; ok,&quot;
 &amp; &quot;\n    matrix2 =&gt; ok,\n    m1X =&gt; ok,\n    rotations =&gt; ok,\n\n    Rotat&quot;
 &amp; &quot;ionsSorted =&gt; meth(self, rotations, rowIndex)\n    (* The matrix of rot&quot;
 &amp; &quot;ations, in sorted order; rowIndex is the index\n       where the origin&quot;
 &amp; &quot;al string landed.\n    *)\n\tself.rotations := rotations;\n        self&quot;
 &amp; &quot;.n := #(rotations);\n\tself.m1X := -(float(self.n) + interMatrixGap);\n&quot;
 &amp; &quot;\tself.rowIndex := rowIndex;\n\n\tlet north = decodedY - 1.0,\n        &quot;
 &amp; &quot;    south = float(self.n),\n            west = self.m1X - 1.0,\n       &quot;
 &amp; &quot;     east = float(self.n) + 1.0;\n\tgraph_setWorld(self.graphvbt, west,&quot;
 &amp; &quot; east, north, south);\n\tgraph_setAspect(self.graphvbt, (south - north)&quot;
 &amp; &quot; / (east - west));\n\tgraph_setPixelSizeDivisor(self.graphvbt,\n       &quot;
 &amp; &quot;                           round(east - west),\n\t\t\t          round(s&quot;
 &amp; &quot;outh - north));\n\n        self.vertexFont := graph_newFont(self.graphv&quot;
 &amp; &quot;bt, \&quot;Helvetica\&quot;,\n                                         0.5, \&quot;Rom&quot;
 &amp; &quot;an\&quot;, \&quot;bold\&quot;, \&quot;*\&quot;);\n    end,    \n\n    DecodeDone =&gt; meth(self, t&quot;
 &amp; &quot;, rowIndex)\n\t(* Create gray copies of sorted matrix but don\'t displa&quot;
 &amp; &quot;y yet *)\n\tself.matrix1 := array_new(self.n, ok);\n\tself.matrix2 := a&quot;
 &amp; &quot;rray_new(self.n, ok);\n\tfor i = 0 to self.n - 1 do\n\t    self.matrix1&quot;
 &amp; &quot;[i] := array_new(self.n, ok);\n\t    self.matrix2[i] := array_new(self.&quot;
 &amp; &quot;n, ok);\n\t    let t = self.rotations[i];\n\t    for j = 0 to self.n - &quot;
 &amp; &quot;1 do\n\t\tlet v1 = graph_newVertex(self.graphvbt);\n\t\tgraph_setVertex&quot;
 &amp; &quot;Label(v1, text_sub(t, j, 1));\n\t\tgraph_setVertexFont(v1, self.vertexF&quot;
 &amp; &quot;ont);\n\t\tgraph_setVertexColor(v1, matrixColor);\n\t\tgraph_setVertexL&quot;
 &amp; &quot;abelColor(v1, matrixLabelColor);\n\t\tgraph_setVertexBorder(v1, 0.05);\n&quot;
 &amp; &quot;\n\t\tlet v2 = graph_newVertex(self.graphvbt);&quot;;

CONST E122_1 =
   &quot;\n\t\tgraph_setVertexLabel(v2, text_sub(t, j, 1));\n\t\tgraph_setVertex&quot;
 &amp; &quot;Font(v2, self.vertexFont);\n\t\tgraph_setVertexColor(v2, matrixColor);\n&quot;
 &amp; &quot;\t\tgraph_setVertexLabelColor(v2, matrixLabelColor);\n\t\tgraph_setVert&quot;
 &amp; &quot;exBorder(v2, 0.05);\n\t        graph_vertexToBack(v2);\n\n\t\tgraph_mov&quot;
 &amp; &quot;eVertex(v1, self.m1X + float(j), float(i), false);\n\t\tgraph_moveVerte&quot;
 &amp; &quot;x(v2, float(j), float(i), false);\n\t\tgraph_setVertexSize(v1, 0.0, 0.0&quot;
 &amp; &quot;);\n\t\tgraph_setVertexSize(v2, 0.0, 0.0);\n\n\t\tself.matrix1[i][j] :=&quot;
 &amp; &quot; v1;\n\t\tself.matrix2[i][j] := v2;\n\t    end;\n        end;\n\n\t(* C&quot;
 &amp; &quot;reate and display decoded lastchars *)\n        self.last.chars := t;\n&quot;
 &amp; &quot;        self.last.vtx := array_new(self.n, ok);\n        for i = 0 to s&quot;
 &amp; &quot;elf.n - 1 do\n            let v = graph_newVertex(self.graphvbt);\n    &quot;
 &amp; &quot;        self.last.vtx[i] := v;\n            graph_setVertexLabel(v, tex&quot;
 &amp; &quot;t_sub(t, i, 1));\n            graph_setVertexFont(v, self.vertexFont);\n&quot;
 &amp; &quot;            graph_setVertexColor(v, initialColor);\n            graph_s&quot;
 &amp; &quot;etVertexLabelColor(v, initialLabelColor);\n            graph_setVertexB&quot;
 &amp; &quot;order(v, 0.05);\n            graph_moveVertex(v, float(i), decodedY, fa&quot;
 &amp; &quot;lse);\n\t    graph_setVertexSize(v, 0.95, 0.95);\n        end;\n\tgraph&quot;
 &amp; &quot;_redisplay(self.graphvbt);\n    end,\n\n    StartReconstruct =&gt; meth(se&quot;
 &amp; &quot;lf, lastchars, rowIndex)\n    (* Start of phase where we reconstruct th&quot;
 &amp; &quot;e original string from\n       lastchars and rowIndex.\n     *)\n\t(* M&quot;
 &amp; &quot;ove lastchars into a column *)\n        for i = 0 to self.n - 1 do\n   &quot;
 &amp; &quot;         let v = self.last.vtx[i];\n\t    graph_setVertexColor(self.las&quot;
 &amp; &quot;t.vtx[i], initialColor);\n\t    graph_setVertexLabelColor(self.last.vtx&quot;
 &amp; &quot;[i], initialLabelColor);\n            graph_moveVertex(v, self.m1X + fl&quot;
 &amp; &quot;oat(self.n - 1), float(i), true);\n\t    let old = self.matrix1[i][self&quot;
 &amp; &quot;.n - 1];\n\t    self.matrix1[i][self.n - 1] := v;\n(****\n\t    let w =&quot;
 &amp; &quot; graph_newVertex(self.graphvbt);\n            graph_moveVertex(w, float&quot;
 &amp; &quot;(i), decodedY, false);\n\t    graph_setVertexLabel(w, text_sub(self.las&quot;
 &amp; &quot;t.chars, i, 1));\n\t    graph_setVertexSize(w, 0.95, 0.95);\n\t    grap&quot;
 &amp; &quot;h_setVertexColor(w, ghostCo&quot;;

CONST E122_2 =
   &quot;lor);\n            graph_setVertexLabelColor(w, ghostLabelColor);\n    &quot;
 &amp; &quot;        graph_setVertexFont(w, self.vertexFont);\n            graph_set&quot;
 &amp; &quot;VertexBorder(w, 0.05);\n****)\n\n            zeus_animate(self.graphvbt&quot;
 &amp; &quot;, float(i)/float(self.n),\n                         (float(i)+1.0)/floa&quot;
 &amp; &quot;t(self.n));\n\t    graph_removeVertex(old);\n        end;\n    end,\n\n&quot;
 &amp; &quot;    Reveal =&gt; meth(self, which)\n        (* Reveal one gray copy of sor&quot;
 &amp; &quot;ted matrix *)\n\tfor i = 0 to self.n - 1 do\n\t    for j = 0 to self.n &quot;
 &amp; &quot;- 1 do\n\t\tif which is 1 then\n\t\t    graph_setVertexSize(self.matrix&quot;
 &amp; &quot;1[i][j], 0.95, 0.95);\n\t\telse\n\t\t    graph_setVertexSize(self.matri&quot;
 &amp; &quot;x2[i][j], 0.95, 0.95);\n\t        end;\n\t    end;\n\tend;\n\tgraph_red&quot;
 &amp; &quot;isplay(self.graphvbt);\n    end,\n\n    FirstChars =&gt; meth(self, t)\n  &quot;
 &amp; &quot;  (* Declare sorted firstchars array. *)\n\tself.first.chars := t;\n\ts&quot;
 &amp; &quot;elf.first.vtx := array_new(self.n, ok);\n        self.pendingMoves := [&quot;
 &amp; &quot;];\n        let tmp = array_new(self.n, ok);\n        for i = 0 to self&quot;
 &amp; &quot;.n-1 do\n            let v = graph_newVertex(self.graphvbt);\n         &quot;
 &amp; &quot;   graph_moveVertex(v, self.m1X + float(self.n-1), float(i), false);\n\t&quot;
 &amp; &quot;    graph_setVertexLabel(v, text_sub(self.last.chars, i, 1));\n\t    gr&quot;
 &amp; &quot;aph_setVertexSize(v, 0.95, 0.95);\n\t    graph_setVertexColor(v, initia&quot;
 &amp; &quot;lColor);\n            graph_setVertexLabelColor(v, initialLabelColor);\n&quot;
 &amp; &quot;            graph_setVertexFont(v, self.vertexFont);\n            graph&quot;
 &amp; &quot;_setVertexBorder(v, 0.05);\n            graph_setVertexColor(self.last.&quot;
 &amp; &quot;vtx[i], shadowColor);\n            graph_setVertexLabelColor(self.last.&quot;
 &amp; &quot;vtx[i], shadowLabelColor);\n            tmp[i] := v;\n         end;\n  &quot;
 &amp; &quot;       let moved = array_new(self.n, false);\n         for i = 0 to sel&quot;
 &amp; &quot;f.n-1 do\n             for j = 0 to self.n-1 do\n                 if no&quot;
 &amp; &quot;t(moved[j]) and\n                    (text_char(t, i) is text_char(self&quot;
 &amp; &quot;.last.chars, j))\n                 then\n                     graph_ver&quot;
 &amp; &quot;texToFront(tmp[j]);\n                     graph_moveVertex(tmp[j], 0.0,&quot;
 &amp; &quot; float(i), true);\n\t\t     let old = self.matrix2[i][0];\n            &quot;
 &amp; &quot;         self.m&quot;;

CONST E122_3 =
   &quot;atrix2[i][0] := tmp[j];\n\t\t     self.first.vtx[i] := tmp[j];\n       &quot;
 &amp; &quot;              moved[j] := true;\n                     zeus_animate(self&quot;
 &amp; &quot;.graphvbt,\n                         (float(i)) / 2.0,\n               &quot;
 &amp; &quot;          (float(i)+1.0) / 2.0 );\n\t\t     graph_removeVertex(old);\n &quot;
 &amp; &quot;                    exit;\n                 end;\n             end;\n  &quot;
 &amp; &quot;       end;\n    end,\n\n    ConsiderChar =&gt; meth(self, i)\n    (* Abou&quot;
 &amp; &quot;t to look for match for element i for firstchars *)\n\tself.colorIndex &quot;
 &amp; &quot;:= (self.colorIndex + 1) % #(charColors);\n\tlet c = charColors[self.co&quot;
 &amp; &quot;lorIndex];\n\n\tfor m = 0 to self.n - 1 do\n\t    let v = self.matrix2[&quot;
 &amp; &quot;i][m];\n\t    if m is 0 then\n\t\tgraph_setVertexColor(v, c);\n\t    el&quot;
 &amp; &quot;se\n\t\tgraph_setVertexLabelColor(v, c);\n\t    end;\n\tend;\n\tgraph_r&quot;
 &amp; &quot;edisplay(self.graphvbt);\n    end,\n\n    EqualChars =&gt; meth(self, i, j&quot;
 &amp; &quot;)\n    (* Decided element i of firstchars matches element j of lastchar&quot;
 &amp; &quot;s. *)\n\tlet c = charColors[self.colorIndex];\n\n\tfor m = 0 to self.n &quot;
 &amp; &quot;- 1 do\n\t    let v = self.matrix1[j][m];\n\t    if m is self.n - 1 the&quot;
 &amp; &quot;n\n\t\tgraph_setVertexColor(v, c);\n\t    else\n\t\tgraph_setVertexLabe&quot;
 &amp; &quot;lColor(v, c);\n\t    end;\n\tend;\n\tgraph_redisplay(self.graphvbt);\n &quot;
 &amp; &quot;   end,\n\n    FinishCharRun =&gt; meth(self)\n    (* Done with a run of i&quot;
 &amp; &quot;dentical chars in firstchar column. *)\n\tfor i = 0 to self.n - 1 do\n\t&quot;
 &amp; &quot;    for m = 0 to self.n - 2 do\n\t\tgraph_setVertexLabelColor(self.matr&quot;
 &amp; &quot;ix1[i][m],\n\t\t\t\t\t  matrixLabelColor);\n\t\tgraph_setVertexLabelCol&quot;
 &amp; &quot;or(self.matrix2[i][(self.n - 1) - m],\n\t\t  \t\t          matrixLabelC&quot;
 &amp; &quot;olor);\n\t    end;\n\tend;\n\tgraph_redisplay(self.graphvbt);\n    end,&quot;
 &amp; &quot;\n\n    StartResult =&gt; meth(self)\n    (* Setup to pick off result char&quot;
 &amp; &quot;s. *)\n        (* Hide gray sorted matrices *)\n\tfor i = 0 to self.n -&quot;
 &amp; &quot; 1 do\n\t    for j = 0 to self.n - 2 do\n\t\tgraph_removeVertex(self.ma&quot;
 &amp; &quot;trix1[i][j]);\n\t\tgraph_removeVertex(self.matrix2[i][(self.n - 1) - j]&quot;
 &amp; &quot;);\n\t    end;\n\tend;\n\tzeus_animate(self.graphvbt, 0.0, 0.5);\n\n   &quot;
 &amp; &quot;     (* Put in row indices *)\n\tself.rowIndices := array_new(self.n, f&quot;
 &amp; &quot;alse);\n\tfor i = 0 to self.n - 1 do\n\t    let v = graph_newVertex(se&quot;;

CONST E122_4 =
   &quot;lf.graphvbt);\n\t    self.rowIndices[i] := v;\n\t    graph_setVertexLab&quot;
 &amp; &quot;el(v, fmt_int(i));\n\t    graph_setVertexFont(v, self.vertexFont);\n\t &quot;
 &amp; &quot;   graph_setVertexColor(v, otherIndexColor);\n\t    graph_setVertexLabe&quot;
 &amp; &quot;lColor(v, otherIndexLabelColor);\n\t    graph_moveVertex(v, ~2.0 - inte&quot;
 &amp; &quot;rMatrixGap, float(i), false);\n\t    graph_setVertexSize(v, 0.95, 0.95)&quot;
 &amp; &quot;;\n\tend;\n\tzeus_animate(self.graphvbt, 0.5, 1.0);\n\n\t(* Mark the re&quot;
 &amp; &quot;membered one *)\n        let v = graph_newVertex(self.graphvbt);\n\tsel&quot;
 &amp; &quot;f.rowIndexVtx := v;\n\tgraph_setVertexLabel(v, fmt_int(self.rowIndex));&quot;
 &amp; &quot;\n\tgraph_setVertexFont(v, self.vertexFont);\n\tgraph_setVertexColor(v,&quot;
 &amp; &quot; rowIndexColor);\n\tgraph_setVertexLabelColor(v, rowIndexLabelColor);\n&quot;
 &amp; &quot;\tgraph_setVertexShape(v, \&quot;ellipse\&quot;);\n\tgraph_setVertexBorder(v, 0.0&quot;
 &amp; &quot;5);\n\tgraph_moveVertex(v, ~2.0 - interMatrixGap,\n\t                 f&quot;
 &amp; &quot;loat(self.rowIndex), false);\n\tgraph_vertexToFront(v);\n\tgraph_setVer&quot;
 &amp; &quot;texSize(v, 0.95, 0.95);\n\tzeus_animate(self.graphvbt, 1.0, 1.5);\n    &quot;
 &amp; &quot;end,\n\n    ResultNextChar =&gt; meth(self, pos, k)\n    (* Pick off the p&quot;
 &amp; &quot;os\'th element of firstchars and put into the\n       k\'th position in&quot;
 &amp; &quot; the result string. *)\n       if pos is self.rowIndex then\n\t    (* J&quot;
 &amp; &quot;ust gray out the extra copy of the last character *)\n    \t    let v =&quot;
 &amp; &quot; self.last.vtx[self.rowIndex];\n\t    graph_setVertexColor(v, ghostColo&quot;
 &amp; &quot;r);\n\t    graph_setVertexLabelColor(v, ghostLabelColor);\n       else\n&quot;
 &amp; &quot;           let sv1 = self.last.vtx[pos];\n           self.last.vtx[pos]&quot;
 &amp; &quot; := graph_newVertex(self.graphvbt);\n           let sv2 = self.first.vt&quot;
 &amp; &quot;x[pos];\n           self.first.vtx[pos] := graph_newVertex(self.graphvb&quot;
 &amp; &quot;t);\n           graph_moveVertex(self.last.vtx[pos], ~1.0 - interMatrix&quot;
 &amp; &quot;Gap,\n                            float(pos), false);\n           graph&quot;
 &amp; &quot;_setVertexLabel(self.last.vtx[pos],\n                                te&quot;
 &amp; &quot;xt_sub(self.last.chars, pos, 1));\n           graph_setVertexSize(self.&quot;
 &amp; &quot;last.vtx[pos], 0.95, 0.95);\n           graph_setVertexColor(self.last.&quot;
 &amp; &quot;vtx[pos], ghostColor);\n           graph_setVertexLabelColor(self.last.&quot;
 &amp; &quot;vtx[pos], ghostL&quot;;

CONST E122_5 =
   &quot;abelColor);\n           graph_setVertexFont(self.last.vtx[pos], self.ve&quot;
 &amp; &quot;rtexFont);\n           graph_setVertexBorder(self.last.vtx[pos], 0.05);&quot;
 &amp; &quot;\n           graph_moveVertex(self.first.vtx[pos], 0.0, float(pos), fal&quot;
 &amp; &quot;se);\n           graph_setVertexLabel(self.first.vtx[pos],\n           &quot;
 &amp; &quot;                     text_sub(self.first.chars, pos, 1));\n           g&quot;
 &amp; &quot;raph_setVertexSize(self.first.vtx[pos], 0.95, 0.95);\n           graph_&quot;
 &amp; &quot;setVertexColor(self.first.vtx[pos], ghostColor);\n           graph_setV&quot;
 &amp; &quot;ertexLabelColor(self.first.vtx[pos], ghostLabelColor);\n           grap&quot;
 &amp; &quot;h_setVertexFont(self.first.vtx[pos], self.vertexFont);\n           grap&quot;
 &amp; &quot;h_setVertexBorder(self.first.vtx[pos], 0.05);\n\n           graph_verte&quot;
 &amp; &quot;xToFront(sv1);\n           graph_vertexToFront(sv2);\n           graph_&quot;
 &amp; &quot;moveVertex(sv1, float(k-1), float(self.rowIndex),\n                    &quot;
 &amp; &quot;        true);\n           graph_moveVertex(sv2, float(k), float(self.r&quot;
 &amp; &quot;owIndex),\n                            true);\n       end;\n       zeus&quot;
 &amp; &quot;_animate(self.graphvbt, 0.0, 1.0);\n    end,\n\n    EndResult =&gt; meth(s&quot;
 &amp; &quot;elf)\n    (* Done. *)\n        (* Put last character into place. *)\n\t&quot;
 &amp; &quot;for i = 0 to self.n - 1 do\n\t    graph_setVertexColor(self.rowIndices[&quot;
 &amp; &quot;i], ghostColor);\n   \t    graph_setVertexLabelColor(self.rowIndices[i]&quot;
 &amp; &quot;, ghostLabelColor);\n        end;\n\tgraph_setVertexColor(self.rowIndex&quot;
 &amp; &quot;Vtx, ghostColor);\n\tgraph_setVertexLabelColor(self.rowIndexVtx, ghostL&quot;
 &amp; &quot;abelColor);\n\tgraph_redisplay(self.graphvbt);\n    end\n\n  };\n&quot;;

CONST E123 =
   &quot;@Parse\nPROCEDURE Parse ()@\n\n  @1 PUSH &lt;start symbol&gt;@\n  @2 token :=&quot;
 &amp; &quot; Scan ()@\n\n  @13 WHILE stack not empty DO@\n     @3 stack_top := Pop &quot;
 &amp; &quot;()@\n     @4 IF (stack_top is a terminal) THEN@\n        @5 IF (stack_t&quot;
 &amp; &quot;op = token)@\n           @6 THEN token := Scan ()@\n           @7 ELSE &quot;
 &amp; &quot;ERROR@\n        END\n     @8 ELSE@\n        @9 p := LookUp (token, stac&quot;
 &amp; &quot;k_top)@\n          where p is \&quot;stack_top ::= x1 x2 ... Xn\&quot;\n        @&quot;
 &amp; &quot;10 IF (p # NIL)@\n            @11 THEN PUSH xn ... x2 x1@\n            &quot;
 &amp; &quot;@12 ELSE ERROR@\n        END\n     END\n  END\n@Parse\n\n\n\n&quot;;

CONST E124 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:29:09 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file Stri&quot;
 &amp; &quot;ngSearch.evt.\n;*******************************************************&quot;
 &amp; &quot;*************\n\n(VBox\n  (Border (Pen 1)\n    (Shape\n      (Height 75&quot;
 &amp; &quot; - 25 + Inf)\n      (Viewport\n        (HBox\n          (Glue 4 + Inf)\n&quot;
 &amp; &quot;          (VBox\n            (Glue 6)\n            (Shape (Height 16 + &quot;
 &amp; &quot;0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n        &quot;
 &amp; &quot;                        \&quot;Code View events:   Stop? \&quot;) \n             &quot;
 &amp; &quot;       (Boolean %stopatCodeEvents =TRUE \&quot;\&quot;)\n                    (Glu&quot;
 &amp; &quot;e 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;&quot;
 &amp; &quot;)\n                    (Shape (Width 80) (Numeric %waitatCodeEvents =1 &quot;
 &amp; &quot;\n                                               (Min 0) (Max 100)))))\n&quot;
 &amp; &quot;            (Glue 6)\n            (Shape (Height 16 + 0)\n             &quot;
 &amp; &quot; (HBox Fill (Shape (Width + 0) (Height + 0) \n                         &quot;
 &amp; &quot;       \&quot;Setup:   Stop? \&quot;) \n                    (Boolean %stopAtSetup&quot;
 &amp; &quot; =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape&quot;
 &amp; &quot; (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Wi&quot;
 &amp; &quot;dth 80) (Numeric %waitAtSetup =1 \n                                    &quot;
 &amp; &quot;           (Min 0) (Max 100)))))\n            (Glue 6)\n            (Sh&quot;
 &amp; &quot;ape (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Heigh&quot;
 &amp; &quot;t + 0) \n                                \&quot;Probe:   Stop? \&quot;) \n       &quot;
 &amp; &quot;             (Boolean %stopAtProbe =TRUE \&quot;\&quot;)\n                    (Gl&quot;
 &amp; &quot;ue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;&quot;
 &amp; &quot;)\n                    (Shape (Width 80) (Numeric %waitAtProbe =1 \n   &quot;
 &amp; &quot;                                            (Min 0) (Max 100)))))\n    &quot;
 &amp; &quot;        (Glue 6)\n            (Shape (Height 16 + 0)\n              (HB&quot;
 &amp; &quot;ox F&quot;;

CONST E124_0 =
   &quot;ill (Shape (Width + 0) (Height + 0) \n                                \&quot;&quot;
 &amp; &quot;Result:   Stop? \&quot;) \n                    (Boolean %stopAtResult =TRUE &quot;
 &amp; &quot;\&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (Width&quot;
 &amp; &quot; + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Width 80)&quot;
 &amp; &quot; (Numeric %waitAtResult =1 \n                                          &quot;
 &amp; &quot;     (Min 0) (Max 100)))))\n            (Glue 6)\n            (Shape (H&quot;
 &amp; &quot;eight 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Height + 0)&quot;
 &amp; &quot; \n                                \&quot;PartialMatch:   Stop? \&quot;) \n      &quot;
 &amp; &quot;              (Boolean %stopAtPartialMatch =TRUE \&quot;\&quot;)\n               &quot;
 &amp; &quot;     (Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;W&quot;
 &amp; &quot;eight: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtParti&quot;
 &amp; &quot;alMatch =1 \n                                               (Min 0) (Ma&quot;
 &amp; &quot;x 100)))))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n &quot;
 &amp; &quot;             (HBox Fill (Shape (Width + 0) (Height + 0) \n             &quot;
 &amp; &quot;                   \&quot;PartialMatchClear:   Stop? \&quot;) \n                 &quot;
 &amp; &quot;   (Boolean %stopAtPartialMatchClear =TRUE \&quot;\&quot;)\n                    (&quot;
 &amp; &quot;Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight:&quot;
 &amp; &quot; \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtPartialMatc&quot;
 &amp; &quot;hClear =1 \n                                               (Min 0) (Max&quot;
 &amp; &quot; 100)))))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n  &quot;
 &amp; &quot;            (HBox Fill (Shape (Width + 0) (Height + 0) \n              &quot;
 &amp; &quot;                  \&quot;CompleteMatch:   Stop? \&quot;) \n                    (B&quot;
 &amp; &quot;oolean %stopAtCompleteMatch =TRUE \&quot;\&quot;)\n                    (Glue 10)\n&quot;
 &amp; &quot;                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n    &quot;
 &amp; &quot;                (Shape (Width 80) (Numeric %waitAtCompleteMatch =1 \n  &quot;
 &amp; &quot;                                             (Min 0) (Max 100)))))\n   &quot;
 &amp; &quot;         (Glue 6)\n            (Shape (Height 16 + 0)\n              (H&quot;
 &amp; &quot;Box Fill (Shape (Width + 0) (Height + 0) \n                            &quot;
 &amp; &quot;    \&quot;SlideTo:   Stop? \&quot;) \n                    (Boolean %stopAtSlideT&quot;
 &amp; &quot;o =&quot;;

CONST E124_1 =
   &quot;TRUE \&quot;\&quot;)\n                    (Glue 10)\n                    (Shape (&quot;
 &amp; &quot;Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    (Shape (Widt&quot;
 &amp; &quot;h 80) (Numeric %waitAtSlideTo =1 \n                                    &quot;
 &amp; &quot;           (Min 0) (Max 100)))))\n            (Glue 6)\n            (Sh&quot;
 &amp; &quot;ape (Height 16 + 0)\n              (HBox Fill (Shape (Width + 0) (Heigh&quot;
 &amp; &quot;t + 0) \n                                \&quot;KMPSetup:   Stop? \&quot;) \n    &quot;
 &amp; &quot;                (Boolean %stopAtKMPSetup =TRUE \&quot;\&quot;)\n                 &quot;
 &amp; &quot;   (Glue 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Wei&quot;
 &amp; &quot;ght: \&quot;)\n                    (Shape (Width 80) (Numeric %waitAtKMPSetu&quot;
 &amp; &quot;p =1 \n                                               (Min 0) (Max 100)&quot;
 &amp; &quot;))))\n            (Glue 6)\n            (Shape (Height 16 + 0)\n       &quot;
 &amp; &quot;       (HBox Fill (Shape (Width + 0) (Height + 0) \n                   &quot;
 &amp; &quot;             \&quot;AddEdge:   Stop? \&quot;) \n                    (Boolean %sto&quot;
 &amp; &quot;pAtAddEdge =TRUE \&quot;\&quot;)\n                    (Glue 10)\n                &quot;
 &amp; &quot;    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n                    &quot;
 &amp; &quot;(Shape (Width 80) (Numeric %waitAtAddEdge =1 \n                        &quot;
 &amp; &quot;                       (Min 0) (Max 100)))))\n            (Glue 6)\n   &quot;
 &amp; &quot;       )\n          (Glue 4)\n          (VBox\n            (Glue 5)\n  &quot;
 &amp; &quot;          (Shape (Width + 0) (Height 16 + 0) \&quot;Cts:\&quot;)\n            (Bu&quot;
 &amp; &quot;tton %eventCounts\n              (VBox\n                (Glue 6)\n     &quot;
 &amp; &quot;           (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n            &quot;
 &amp; &quot;                      (Text %ctOfSetup \&quot;0\&quot;)))\n                (Glue &quot;
 &amp; &quot;6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n   &quot;
 &amp; &quot;                               (Text %ctOfProbe \&quot;0\&quot;)))\n             &quot;
 &amp; &quot;   (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 +&quot;
 &amp; &quot; 0) \n                                  (Text %ctOfResult \&quot;0\&quot;)))\n   &quot;
 &amp; &quot;             (Glue 6)\n                (HBox Fill (Shape (Width + 0) (H&quot;
 &amp; &quot;eight 16 + 0) \n                                  (Text %ctOfPartialMat&quot;
 &amp; &quot;ch \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox Fill (Shap&quot;
 &amp; &quot;e (Width + &quot;;

CONST E124_2 =
   &quot;0) (Height 16 + 0) \n                                  (Text %ctOfParti&quot;
 &amp; &quot;alMatchClear \&quot;0\&quot;)))\n                (Glue 6)\n                (HBox &quot;
 &amp; &quot;Fill (Shape (Width + 0) (Height 16 + 0) \n                             &quot;
 &amp; &quot;     (Text %ctOfCompleteMatch \&quot;0\&quot;)))\n                (Glue 6)\n     &quot;
 &amp; &quot;           (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n            &quot;
 &amp; &quot;                      (Text %ctOfSlideTo \&quot;0\&quot;)))\n                (Glu&quot;
 &amp; &quot;e 6)\n                (HBox Fill (Shape (Width + 0) (Height 16 + 0) \n &quot;
 &amp; &quot;                                 (Text %ctOfKMPSetup \&quot;0\&quot;)))\n        &quot;
 &amp; &quot;        (Glue 6)\n                (HBox Fill (Shape (Width + 0) (Height&quot;
 &amp; &quot; 16 + 0) \n                                  (Text %ctOfAddEdge \&quot;0\&quot;))&quot;
 &amp; &quot;)\n                (Glue 3))))\n          Fill\n          (Glue 4 + Inf&quot;
 &amp; &quot;)\n        )\n      )\n    )\n  )\n)\n&quot;;

CONST E125 =
   &quot;Source 50 500\nV2 400 500\nV3 700 500\nSink 950 500\nV4 250 300\nV5 550&quot;
 &amp; &quot; 300\nV6 550 700\nV7 850 700\nSource -&gt; V2 1.9\nV2 -&gt; V3 2.4\nV3 -&gt; Sin&quot;
 &amp; &quot;k 1.1\nSource -&gt; V4 3.2\nV4 -&gt; V5 2.3\nV5 -&gt; V3 1.7\nV2 -&gt; V6 2.88\nV6 &quot;
 &amp; &quot;-&gt; V7 3.12\nV7 -&gt; Sink 1.98\n.\n&quot;;

BEGIN
END MentorBundle.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
