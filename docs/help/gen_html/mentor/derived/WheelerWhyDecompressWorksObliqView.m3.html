<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: mentor/derived/WheelerWhyDecompressWorksObliqView.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>mentor/derived/WheelerWhyDecompressWorksObliqView.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright (C) 1995, Digital Equipment Corporation.       
 All rights reserved.                                     
 See the file COPYRIGHT for a full description.           
                                                          
 Last modified on Fri Sep  8 15:48:12 PDT 1995 by najork  
      modified on Thu Feb  9 08:54:15 PST 1995 by kalsow  
 Last modified on Fri Dec  9 15:00:46 PST 1994 by mhb     
      modified on Sat Jun  4 16:24:49 1994 by heydon      
      modified on Tue Feb 16 16:31:40 PST 1993 by johnh   

<P>********************************************************************
<PRE>
      *  NOTE: This file is generated automatically from the event
      *        definition file Wheeler.evt.
      ********************************************************************


<P><PRE>&lt;* PRAGMA LL *&gt;

MODULE <module><implements><A HREF="WheelerWhyDecompressWorksObliqView.i3.html">WheelerWhyDecompressWorksObliqView</A></implements></module>;

&lt;*NOWARN*&gt; IMPORT <A HREF="../../m3core/src/text/TextConv.i3.html">TextConv</A>, <A HREF="../../obliqlibm3/src/ObLibM3.i3.html">ObLibM3</A>, <A HREF="../../obliqlibui/src/ObLibUI.i3.html">ObLibUI</A>, <A HREF="../../synloc/src/SynWr.i3.html">SynWr</A>, <A HREF="../../obliqrt/src/Obliq.i3.html">Obliq</A>;
&lt;*NOWARN*&gt; IMPORT <A HREF="../../obliqparse/src/ObliqParser.i3.html">ObliqParser</A>, <A HREF="../../libm3/src/rw/Rd.i3.html">Rd</A>, <A HREF="../../ui/src/split/Filter.i3.html">Filter</A>, <A HREF="WheelerViewClass.i3.html">WheelerViewClass</A>, <A HREF="../../libm3/src/fmtlex/Fmt.i3.html">Fmt</A>;
&lt;*NOWARN*&gt; IMPORT <A HREF="../../obliqlibanim/src/ObLibAnim.i3.html">ObLibAnim</A>, <A HREF="../../zeus/src/ZFmt.i3.html">ZFmt</A>, <A HREF="../../zeus/src/ZeusPanel.i3.html">ZeusPanel</A>, <A HREF="../../obliqrt/src/ObValue.i3.html">ObValue</A>, <A HREF="../../libm3/src/rw/TextWr.i3.html">TextWr</A>;
&lt;*NOWARN*&gt; IMPORT <A HREF="#x1">View</A>, <A HREF="../../ui/src/vbt/VBT.i3.html">VBT</A>, <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../src/wheeler/MiscFmt.i3.html">MiscFmt</A>, <A HREF="../../libm3/src/rw/TextRd.i3.html">TextRd</A>, <A HREF="../../vbtkit/src/vbtkitutils/Rsrc.i3.html">Rsrc</A>;

CONST
  ViewName =  &quot;WhyDecompressWorks.obl&quot;;

TYPE
  T = WheelerViewClass.T BRANDED OBJECT
        object  : Obliq.Val;
        env     : Obliq.Env;
        wr      : TextWr.T;
        swr     : SynWr.T;
        parser  : ObliqParser.T;
      OVERRIDES
        &lt;* LL.sup &lt; VBT.mu *&gt;
        startrun := Startrun;
        &lt;* LL.sup &lt; VBT.mu *&gt;
        oeStartPermute := StartPermute;
        oeNextRotation := NextRotation;
        oeRotationsSorted := RotationsSorted;
        oePermuteDone := PermuteDone;
        oeStartEncode := StartEncode;
        oeEncodeNextChar := EncodeNextChar;
        oeEncodeDistinctCount := EncodeDistinctCount;
        oeEncodeFoundCode := EncodeFoundCode;
        oeEncodeDone := EncodeDone;
        oeInitDecode := InitDecode;
        oeStartDecode := StartDecode;
        oeDecodeNextCode := DecodeNextCode;
        oeDecodeDistinctCount := DecodeDistinctCount;
        oeDecodeFoundChar := DecodeFoundChar;
        oeDecodeDone := DecodeDone;
        oeStartReconstruct := StartReconstruct;
        oeFirstChars := FirstChars;
        oeConsiderChar := ConsiderChar;
        oeEqualChars := EqualChars;
        oeFinishCharRun := FinishCharRun;
        oeStartResult := StartResult;
        oeResultNextChar := ResultNextChar;
        oeEndResult := EndResult;
        oeReveal := Reveal;
        &lt;* LL.sup = VBT.mu *&gt;
      END;
</PRE> OUTPUT and UPDATE event handling methods: 

<P><PRE>PROCEDURE <A NAME="StartPermute"><procedure>StartPermute</procedure></A> (view: T;  string, alphabet: TEXT) =
  &lt;* LL.sup &lt; VBT.mu *&gt;
  BEGIN
    IF FieldDefined(view.object, &quot;StartPermute&quot;) THEN
      Invoke (view, &quot;StartPermute&quot;, &quot;&quot;
      &amp; TextConv.Encode(string)
      &amp; &quot;,&quot;
      &amp; TextConv.Encode(alphabet)
      )
    END
  END StartPermute;
PROCEDURE <A NAME="NextRotation"><procedure>NextRotation</procedure></A> (view: T;  i: INTEGER; string: TEXT) =
  &lt;* LL.sup &lt; VBT.mu *&gt;
  BEGIN
    IF FieldDefined(view.object, &quot;NextRotation&quot;) THEN
      Invoke (view, &quot;NextRotation&quot;, &quot;&quot;
      &amp; Fmt.Int(i)
      &amp; &quot;,&quot;
      &amp; TextConv.Encode(string)
      )
    END
  END NextRotation;
PROCEDURE <A NAME="RotationsSorted"><procedure>RotationsSorted</procedure></A> (view: T;  rotations: MiscFmt.RefTextArray; rowIndex: INTEGER) =
  &lt;* LL.sup &lt; VBT.mu *&gt;
  BEGIN
    IF FieldDefined(view.object, &quot;RotationsSorted&quot;) THEN
      Invoke (view, &quot;RotationsSorted&quot;, &quot;&quot;
      &amp; MiscFmt.TextArray(rotations)
      &amp; &quot;,&quot;
      &amp; Fmt.Int(rowIndex)
      )
    END
  END RotationsSorted;
PROCEDURE <A NAME="PermuteDone"><procedure>PermuteDone</procedure></A> (view: T;  lastchars: TEXT; rowIndex: INTEGER) =
  &lt;* LL.sup &lt; VBT.mu *&gt;
  BEGIN
    IF FieldDefined(view.object, &quot;PermuteDone&quot;) THEN
      Invoke (view, &quot;PermuteDone&quot;, &quot;&quot;
      &amp; TextConv.Encode(lastchars)
      &amp; &quot;,&quot;
      &amp; Fmt.Int(rowIndex)
      )
    END
  END PermuteDone;
PROCEDURE <A NAME="StartEncode"><procedure>StartEncode</procedure></A> (view: T;  alphabet: TEXT) =
  &lt;* LL.sup &lt; VBT.mu *&gt;
  BEGIN
    IF FieldDefined(view.object, &quot;StartEncode&quot;) THEN
      Invoke (view, &quot;StartEncode&quot;, &quot;&quot;
      &amp; TextConv.Encode(alphabet)
      )
    END
  END StartEncode;
PROCEDURE <A NAME="EncodeNextChar"><procedure>EncodeNextChar</procedure></A> (view: T;  i: INTEGER; c: CHAR) =
  &lt;* LL.sup &lt; VBT.mu *&gt;
  BEGIN
    IF FieldDefined(view.object, &quot;EncodeNextChar&quot;) THEN
      Invoke (view, &quot;EncodeNextChar&quot;, &quot;&quot;
      &amp; Fmt.Int(i)
      &amp; &quot;,&quot;
      &amp; MiscFmt.Char(c)
      )
    END
  END EncodeNextChar;
PROCEDURE <A NAME="EncodeDistinctCount"><procedure>EncodeDistinctCount</procedure></A> (view: T;  i, k, n: INTEGER; c: CHAR) =
  &lt;* LL.sup &lt; VBT.mu *&gt;
  BEGIN
    IF FieldDefined(view.object, &quot;EncodeDistinctCount&quot;) THEN
      Invoke (view, &quot;EncodeDistinctCount&quot;, &quot;&quot;
      &amp; Fmt.Int(i)
      &amp; &quot;,&quot;
      &amp; Fmt.Int(k)
      &amp; &quot;,&quot;
      &amp; Fmt.Int(n)
      &amp; &quot;,&quot;
      &amp; MiscFmt.Char(c)
      )
    END
  END EncodeDistinctCount;
PROCEDURE <A NAME="EncodeFoundCode"><procedure>EncodeFoundCode</procedure></A> (view: T;  i, k, code: INTEGER; c: CHAR) =
  &lt;* LL.sup &lt; VBT.mu *&gt;
  BEGIN
    IF FieldDefined(view.object, &quot;EncodeFoundCode&quot;) THEN
      Invoke (view, &quot;EncodeFoundCode&quot;, &quot;&quot;
      &amp; Fmt.Int(i)
      &amp; &quot;,&quot;
      &amp; Fmt.Int(k)
      &amp; &quot;,&quot;
      &amp; Fmt.Int(code)
      &amp; &quot;,&quot;
      &amp; MiscFmt.Char(c)
      )
    END
  END EncodeFoundCode;
PROCEDURE <A NAME="EncodeDone"><procedure>EncodeDone</procedure></A> (view: T;  alphabet: TEXT; codes: MiscFmt.RefIntArray; rowIndex: INTEGER) =
  &lt;* LL.sup &lt; VBT.mu *&gt;
  BEGIN
    IF FieldDefined(view.object, &quot;EncodeDone&quot;) THEN
      Invoke (view, &quot;EncodeDone&quot;, &quot;&quot;
      &amp; TextConv.Encode(alphabet)
      &amp; &quot;,&quot;
      &amp; MiscFmt.IntArray(codes)
      &amp; &quot;,&quot;
      &amp; Fmt.Int(rowIndex)
      )
    END
  END EncodeDone;
PROCEDURE <A NAME="InitDecode"><procedure>InitDecode</procedure></A> (view: T;  alphabet: TEXT; codes: MiscFmt.RefIntArray; rowIndex: INTEGER) =
  &lt;* LL.sup &lt; VBT.mu *&gt;
  BEGIN
    IF FieldDefined(view.object, &quot;InitDecode&quot;) THEN
      Invoke (view, &quot;InitDecode&quot;, &quot;&quot;
      &amp; TextConv.Encode(alphabet)
      &amp; &quot;,&quot;
      &amp; MiscFmt.IntArray(codes)
      &amp; &quot;,&quot;
      &amp; Fmt.Int(rowIndex)
      )
    END
  END InitDecode;
PROCEDURE <A NAME="StartDecode"><procedure>StartDecode</procedure></A> (view: T;  ) =
  &lt;* LL.sup &lt; VBT.mu *&gt;
  BEGIN
    IF FieldDefined(view.object, &quot;StartDecode&quot;) THEN
      Invoke (view, &quot;StartDecode&quot;, &quot;&quot;
      )
    END
  END StartDecode;
PROCEDURE <A NAME="DecodeNextCode"><procedure>DecodeNextCode</procedure></A> (view: T;  i: INTEGER) =
  &lt;* LL.sup &lt; VBT.mu *&gt;
  BEGIN
    IF FieldDefined(view.object, &quot;DecodeNextCode&quot;) THEN
      Invoke (view, &quot;DecodeNextCode&quot;, &quot;&quot;
      &amp; Fmt.Int(i)
      )
    END
  END DecodeNextCode;
PROCEDURE <A NAME="DecodeDistinctCount"><procedure>DecodeDistinctCount</procedure></A> (view: T;  i, k, n: INTEGER) =
  &lt;* LL.sup &lt; VBT.mu *&gt;
  BEGIN
    IF FieldDefined(view.object, &quot;DecodeDistinctCount&quot;) THEN
      Invoke (view, &quot;DecodeDistinctCount&quot;, &quot;&quot;
      &amp; Fmt.Int(i)
      &amp; &quot;,&quot;
      &amp; Fmt.Int(k)
      &amp; &quot;,&quot;
      &amp; Fmt.Int(n)
      )
    END
  END DecodeDistinctCount;
PROCEDURE <A NAME="DecodeFoundChar"><procedure>DecodeFoundChar</procedure></A> (view: T;  i, k: INTEGER; c: CHAR) =
  &lt;* LL.sup &lt; VBT.mu *&gt;
  BEGIN
    IF FieldDefined(view.object, &quot;DecodeFoundChar&quot;) THEN
      Invoke (view, &quot;DecodeFoundChar&quot;, &quot;&quot;
      &amp; Fmt.Int(i)
      &amp; &quot;,&quot;
      &amp; Fmt.Int(k)
      &amp; &quot;,&quot;
      &amp; MiscFmt.Char(c)
      )
    END
  END DecodeFoundChar;
PROCEDURE <A NAME="DecodeDone"><procedure>DecodeDone</procedure></A> (view: T;  lastchars: TEXT; rowIndex: INTEGER) =
  &lt;* LL.sup &lt; VBT.mu *&gt;
  BEGIN
    IF FieldDefined(view.object, &quot;DecodeDone&quot;) THEN
      Invoke (view, &quot;DecodeDone&quot;, &quot;&quot;
      &amp; TextConv.Encode(lastchars)
      &amp; &quot;,&quot;
      &amp; Fmt.Int(rowIndex)
      )
    END
  END DecodeDone;
PROCEDURE <A NAME="StartReconstruct"><procedure>StartReconstruct</procedure></A> (view: T;  lastchars: TEXT; rowIndex: INTEGER) =
  &lt;* LL.sup &lt; VBT.mu *&gt;
  BEGIN
    IF FieldDefined(view.object, &quot;StartReconstruct&quot;) THEN
      Invoke (view, &quot;StartReconstruct&quot;, &quot;&quot;
      &amp; TextConv.Encode(lastchars)
      &amp; &quot;,&quot;
      &amp; Fmt.Int(rowIndex)
      )
    END
  END StartReconstruct;
PROCEDURE <A NAME="FirstChars"><procedure>FirstChars</procedure></A> (view: T;  t: TEXT) =
  &lt;* LL.sup &lt; VBT.mu *&gt;
  BEGIN
    IF FieldDefined(view.object, &quot;FirstChars&quot;) THEN
      Invoke (view, &quot;FirstChars&quot;, &quot;&quot;
      &amp; TextConv.Encode(t)
      )
    END
  END FirstChars;
PROCEDURE <A NAME="ConsiderChar"><procedure>ConsiderChar</procedure></A> (view: T;  i: INTEGER) =
  &lt;* LL.sup &lt; VBT.mu *&gt;
  BEGIN
    IF FieldDefined(view.object, &quot;ConsiderChar&quot;) THEN
      Invoke (view, &quot;ConsiderChar&quot;, &quot;&quot;
      &amp; Fmt.Int(i)
      )
    END
  END ConsiderChar;
PROCEDURE <A NAME="EqualChars"><procedure>EqualChars</procedure></A> (view: T;  i, j: INTEGER) =
  &lt;* LL.sup &lt; VBT.mu *&gt;
  BEGIN
    IF FieldDefined(view.object, &quot;EqualChars&quot;) THEN
      Invoke (view, &quot;EqualChars&quot;, &quot;&quot;
      &amp; Fmt.Int(i)
      &amp; &quot;,&quot;
      &amp; Fmt.Int(j)
      )
    END
  END EqualChars;
PROCEDURE <A NAME="FinishCharRun"><procedure>FinishCharRun</procedure></A> (view: T;  ) =
  &lt;* LL.sup &lt; VBT.mu *&gt;
  BEGIN
    IF FieldDefined(view.object, &quot;FinishCharRun&quot;) THEN
      Invoke (view, &quot;FinishCharRun&quot;, &quot;&quot;
      )
    END
  END FinishCharRun;
PROCEDURE <A NAME="StartResult"><procedure>StartResult</procedure></A> (view: T;  ) =
  &lt;* LL.sup &lt; VBT.mu *&gt;
  BEGIN
    IF FieldDefined(view.object, &quot;StartResult&quot;) THEN
      Invoke (view, &quot;StartResult&quot;, &quot;&quot;
      )
    END
  END StartResult;
PROCEDURE <A NAME="ResultNextChar"><procedure>ResultNextChar</procedure></A> (view: T;  pos, k: INTEGER) =
  &lt;* LL.sup &lt; VBT.mu *&gt;
  BEGIN
    IF FieldDefined(view.object, &quot;ResultNextChar&quot;) THEN
      Invoke (view, &quot;ResultNextChar&quot;, &quot;&quot;
      &amp; Fmt.Int(pos)
      &amp; &quot;,&quot;
      &amp; Fmt.Int(k)
      )
    END
  END ResultNextChar;
PROCEDURE <A NAME="EndResult"><procedure>EndResult</procedure></A> (view: T;  ) =
  &lt;* LL.sup &lt; VBT.mu *&gt;
  BEGIN
    IF FieldDefined(view.object, &quot;EndResult&quot;) THEN
      Invoke (view, &quot;EndResult&quot;, &quot;&quot;
      )
    END
  END EndResult;
PROCEDURE <A NAME="Reveal"><procedure>Reveal</procedure></A> (view: T;  i: INTEGER) =
  &lt;* LL.sup &lt; VBT.mu *&gt;
  BEGIN
    IF FieldDefined(view.object, &quot;Reveal&quot;) THEN
      Invoke (view, &quot;Reveal&quot;, &quot;&quot;
      &amp; Fmt.Int(i)
      )
    END
  END Reveal;

PROCEDURE <A NAME="RegisterView"><procedure>RegisterView</procedure></A> () =
  BEGIN
    ZeusPanel.RegisterView(New, &quot;WhyDecompressWorks.obl&quot;, &quot;Wheeler&quot;)
  END RegisterView;

PROCEDURE <A NAME="New"><procedure>New</procedure></A> (): View.T =
  BEGIN
    RETURN NEW(T).init(NIL)
  END New;

CONST
  ObliqStackSizeMultiplier = 8;

TYPE
  Closure = Thread.SizedClosure OBJECT
              view: T;
            OVERRIDES
              apply := ForkedStartrun;
            END;

PROCEDURE <A NAME="Startrun"><procedure>Startrun</procedure></A> (view: T) =
  &lt;* LL.sup &lt; VBT.mu *&gt;
  BEGIN
    EVAL
      Thread.Join(
        Thread.Fork(
          NEW(Closure, view := view,
              stackSize := ObliqStackSizeMultiplier * Thread.GetDefaultStackSize())));
  END Startrun;

PROCEDURE <A NAME="ForkedStartrun"><procedure>ForkedStartrun</procedure></A> (cl: Closure): REFANY =
  VAR rd: Rd.T; view := cl.view;
  BEGIN
    IF view.parser = NIL THEN
      view.wr := TextWr.New();
      view.swr := SynWr.New(view.wr);
      view.parser := ObliqParser.New(view.swr);
    END;
    view.object := NIL;
    TRY
      rd := Rsrc.Open(ViewName, ZeusPanel.GetPath());
      view.env := ParseRd(view.parser, ViewName, rd);
      WITH obj = Obliq.Lookup(&quot;view&quot;, view.env) DO
        IF NOT ISTYPE(obj, ObValue.ValObj) THEN
          ZeusPanel.ReportError(
            &quot;not an Obliq object in '&quot; &amp; ViewName &amp; &quot;'&quot;)
        ELSIF FieldDefined (obj, &quot;graphvbt&quot;) THEN
          WITH graphvbt =
            NARROW(Obliq.ObjectSelect(obj, &quot;graphvbt&quot;),
                   ObLibAnim.ValGraph).vbt DO
            LOCK VBT.mu DO
              EVAL Filter.Replace(view, graphvbt)
            END
          END;
          view.object := obj;
        ELSIF FieldDefined (obj, &quot;rectsvbt&quot;) THEN
          WITH rectsvbt =
            NARROW(Obliq.ObjectSelect(obj, &quot;rectsvbt&quot;),
                   ObLibAnim.ValRects).vbt DO
            LOCK VBT.mu DO
              EVAL Filter.Replace(view, rectsvbt)
            END
          END;
          view.object := obj;
        ELSIF FieldDefined (obj, &quot;formsvbt&quot;) THEN
          WITH formsvbt =
            NARROW(Obliq.ObjectSelect(obj, &quot;formsvbt&quot;),
                   ObLibUI.ValForm).vbt DO
            LOCK VBT.mu DO
              EVAL Filter.Replace(view, formsvbt)
            END
          END;
          view.object := obj;
        ELSE
          ZeusPanel.ReportError(
            &quot;cannot find 'graphvbt', 'rectsvbt', or 'formsvbt' in '&quot; &amp; ViewName &amp; &quot;'&quot;)
        END
      END
    EXCEPT
    | Rsrc.NotFound =&gt;
        ZeusPanel.ReportError(&quot;cannot find '&quot; &amp; ViewName &amp; &quot;'&quot;)
    | ObValue.Error (packet) =&gt; OblError(view, packet)
    | ObValue.Exception (packet) =&gt; OblException(view, packet)
    END;
    RETURN NIL;
  END ForkedStartrun;

PROCEDURE <A NAME="ParseRd"><procedure>ParseRd</procedure></A> (p: ObliqParser.T; name: TEXT; rd: Rd.T):
  Obliq.Env RAISES {ObValue.Error, ObValue.Exception} =
  VAR env := Obliq.EmptyEnv();
  BEGIN
    ObliqParser.ReadFrom(p, name, rd, TRUE);
    TRY
      LOOP
        EVAL ObliqParser.EvalPhrase(p, ObliqParser.ParsePhrase(p), env)
      END
    EXCEPT
      ObliqParser.Eof =&gt; (* clean exit of loop *)
    END;
    RETURN env
  END ParseRd;

PROCEDURE <A NAME="Invoke"><procedure>Invoke</procedure></A> (view: T; event, args: TEXT) =
  VAR
    exp    := &quot;view.&quot; &amp; event &amp; &quot;(&quot; &amp; args &amp; &quot;);&quot;;
    name   := &quot;Zeus Event &lt;&quot; &amp; event &amp; &quot;&gt;&quot;;
  BEGIN
    ObliqParser.ReadFrom (view.parser, name, TextRd.New(exp), FALSE);
    TRY
      EVAL Obliq.EvalTerm(ObliqParser.ParseTerm(view.parser), view.env)
    EXCEPT
    | ObliqParser.Eof =&gt; &lt;* ASSERT FALSE *&gt;
    | ObValue.Error (packet) =&gt; OblError(view, packet)
    | ObValue.Exception (packet) =&gt; OblException(view, packet)
    END
  END Invoke;

PROCEDURE <A NAME="FieldDefined"><procedure>FieldDefined</procedure></A> (object: Obliq.Val; event: TEXT): BOOLEAN =
  BEGIN
    TRY
      RETURN object # NIL AND Obliq.ObjectHas(object, event)
    EXCEPT
    | ObValue.Error =&gt;
    | ObValue.Exception =&gt;
    END;
    RETURN FALSE
  END FieldDefined;

PROCEDURE <A NAME="OblError"><procedure>OblError</procedure></A> (view: T; packet: ObValue.ErrorPacket) =
  BEGIN
    Obliq.ReportError(view.swr, packet);
    ZeusPanel.ReportError(
      &quot;Obliq error: &quot; &amp; TextWr.ToText(view.wr))
  END OblError;

PROCEDURE <A NAME="OblException"><procedure>OblException</procedure></A> (view: T; packet: ObValue.ExceptionPacket) =
  BEGIN
    Obliq.ReportException(view.swr, packet);
    ZeusPanel.ReportError(
      &quot;Obliq exception: &quot; &amp; TextWr.ToText(view.wr))
  END OblException;

BEGIN
  SynWr.Setup();
  ObliqParser.PackageSetup();
  ObLibM3.PackageSetup();
  ObLibUI.PackageSetup();
  ObLibAnim.PackageSetup();
  RegisterView ();
END WheelerWhyDecompressWorksObliqView.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface View is in:
</A><UL>
<LI><A HREF="../../juno-app/src/View.i3.html#0TOP0">juno-app/src/View.i3</A>
<LI><A HREF="../../zeus/src/View.i3.html#0TOP0">zeus/src/View.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
