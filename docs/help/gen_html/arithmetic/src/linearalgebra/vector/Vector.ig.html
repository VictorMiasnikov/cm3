<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: arithmetic/src/linearalgebra/vector/Vector.ig</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>arithmetic/src/linearalgebra/vector/Vector.ig</H2></A><HR>
<inInterface>
<PRE>GENERIC INTERFACE <genericInterface><A HREF="Vector.mg.html">Vector</A></genericInterface>(R);
</PRE><BLOCKQUOTE><EM> Arithmetic for Modula-3, see doc for details
<P>
   Abstract: Vector math </EM></BLOCKQUOTE><PRE>

FROM <A HREF="../../Arithmetic.i3.html">Arithmetic</A> IMPORT Error;

CONST Brand = R.Brand &amp; &quot;Vector&quot;;

TYPE
  (* text form: &quot;V6{a0,a1,a2,a3,a4,a5}&quot; *)
  TBody = ARRAY OF R.T;
  T = REF TBody;

  TVBody = ARRAY OF T;

PROCEDURE <A HREF="Vector.mg.html#New">New</A> (n: CARDINAL; ): T; (* make new vector with n components *)
PROCEDURE <A HREF="Vector.mg.html#NewZero">NewZero</A> (n: CARDINAL; ): T; (* make new zero vector with n
                                         components *)
PROCEDURE <A HREF="Vector.mg.html#NewUniform">NewUniform</A> (n: CARDINAL; x: R.T; ):
  T;                             (* vector with all components set to x *)
&lt;* INLINE *&gt;
PROCEDURE <A HREF="Vector.mg.html#FromArray">FromArray</A> (READONLY x: TBody; ): T;
PROCEDURE <A HREF="Vector.mg.html#FromVectorArray">FromVectorArray</A> (READONLY x: TVBody; ): T;
&lt;* INLINE *&gt;
PROCEDURE <A HREF="Vector.mg.html#FromScalar">FromScalar</A> (x: R.T; ): T;
&lt;* INLINE *&gt;
PROCEDURE <A HREF="Vector.mg.html#Copy">Copy</A> (x: T; ): T;
&lt;* INLINE *&gt;
PROCEDURE <A HREF="Vector.mg.html#Reverse">Reverse</A> (x: T; ): T;   (* reverse the order of the components *)

&lt;* INLINE *&gt;
PROCEDURE <A HREF="Vector.mg.html#IsZero">IsZero</A> (x: T; ): BOOLEAN;
&lt;* INLINE *&gt;
PROCEDURE <A HREF="Vector.mg.html#Equal">Equal</A> (x, y: T; ): BOOLEAN; (* x=y *)

&lt;* INLINE *&gt;
PROCEDURE <A HREF="Vector.mg.html#Add">Add</A> (x, y: T; ): T;    (* x+y *)
&lt;* INLINE *&gt;
PROCEDURE <A HREF="Vector.mg.html#Sub">Sub</A> (x, y: T; ): T;    (* x-y *)
&lt;* INLINE *&gt;
PROCEDURE <A HREF="Vector.mg.html#Neg">Neg</A> (x: T; ): T;       (* -x *)

&lt;* INLINE *&gt;
PROCEDURE <A HREF="Vector.mg.html#Scale">Scale</A> (x: T; y: R.T; ): T; (* x:=x*factor *)
&lt;* INLINE *&gt;
PROCEDURE <A HREF="Vector.mg.html#Inner">Inner</A> (x, y: T; ): R.T; (* &lt;x,y&gt; *)
&lt;* INLINE *&gt;
PROCEDURE <A HREF="Vector.mg.html#Dot">Dot</A> (x, y: T; ): R.T;  (* x^T*y *)
</PRE> should be generalized to finding an orthonormal basis of the space
   orthogonal to a given set of vectors
<P>
   PROCEDURE Cross(x,y:T;):T ; (* x x y  <PRE>*)

TYPE
  ApplyFtn = PROCEDURE (x: R.T; ) RAISES {Error};
  MapFtn = PROCEDURE (x: R.T; ): R.T RAISES {Error};
  ReduceFtn = PROCEDURE (x, y: R.T; ): R.T RAISES {Error};

PROCEDURE <A HREF="Vector.mg.html#Apply">Apply</A> (x: T; f: ApplyFtn; ) RAISES {Error};
PROCEDURE <A HREF="Vector.mg.html#Map">Map</A> (x: T; f: MapFtn; ): T RAISES {Error};
PROCEDURE <A HREF="Vector.mg.html#Reduce">Reduce</A> (x: T; f: ReduceFtn; init: R.T; ): R.T RAISES {Error};

PROCEDURE <A HREF="Vector.mg.html#ArithSeq">ArithSeq</A> (num: CARDINAL; from: R.T; by: R.T; ): T;
PROCEDURE <A HREF="Vector.mg.html#GeomSeq">GeomSeq</A> (num: CARDINAL; from: R.T; by: R.T; ): T;
PROCEDURE <A HREF="Vector.mg.html#RecursiveSeq">RecursiveSeq</A> (num: CARDINAL; from: R.T; by: MapFtn; ): T
  RAISES {Error};

END Vector.
</PRE>
</inInterface>
<PRE>























</PRE>
</BODY>
</HTML>
