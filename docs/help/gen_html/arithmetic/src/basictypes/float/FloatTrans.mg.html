<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: arithmetic/src/basictypes/float/FloatTrans.mg</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>arithmetic/src/basictypes/float/FloatTrans.mg</H2></A><HR>
<inModule>
<PRE>GENERIC MODULE <genericModule><A HREF="FloatTrans.ig.html">FloatTrans</A></genericModule>();
</PRE><BLOCKQUOTE><EM>*Arithmetic for Modula-3, see doc for details
<P>
Abstract: Generic wrapper routines for (mainly) transcendent functions
<P>
          It was xReal32.m3 by Harry George
          Initially implemented a wrappers on Math, but
          need an assembler rendition.
<P>
12/15/95  Harry George   Initial version, via wrappers on Math
<P>
</EM></BLOCKQUOTE><PRE>

IMPORT <A HREF="../../../../libm3/src/arith/POSIX/Math.i3.html">Math</A>;

&lt;* UNUSED *&gt;
CONST
  Module = &quot;FloatTrans.&quot;;

PROCEDURE <A NAME="Abs"><procedure>Abs</procedure></A> (x: T; ): T =
  BEGIN
    RETURN ABS(x);
  END Abs;

PROCEDURE <A NAME="AbsSqr"><procedure>AbsSqr</procedure></A> (x: T; ): T =
  BEGIN
    RETURN x * x;
  END AbsSqr;
</PRE>---- Exponential and Logarithm functions ----

<P><PRE>PROCEDURE <A NAME="Exp"><procedure>Exp</procedure></A> (x: T; ): T =
  (* returns E^x. *)
  BEGIN
    RETURN FLOAT(Math.exp(FLOAT(x, LONGREAL)), T);
  END Exp;

PROCEDURE <A NAME="Expm1"><procedure>Expm1</procedure></A> (x: T; ): T =
  (* returns (E^x)-1, even for small x. *)
  BEGIN
    RETURN FLOAT(Math.expm1(FLOAT(x, LONGREAL)), T);
  END Expm1;

PROCEDURE <A NAME="Ln"><procedure>Ln</procedure></A> (x: T; ): T =
  (* returns the natural logarithm of x (base E). *)
  BEGIN
    RETURN FLOAT(Math.log(FLOAT(x, LONGREAL)), T);
  END Ln;

PROCEDURE <A NAME="Ln1p"><procedure>Ln1p</procedure></A> (x: T; ): T =
  (* returns log(1+x), even for small x. *)
  BEGIN
    RETURN FLOAT(Math.log1p(FLOAT(x, LONGREAL)), T);
  END Ln1p;

PROCEDURE <A NAME="Lg"><procedure>Lg</procedure></A> (x: T; ): T =
  (* returns the base 10 logarithm of x. *)
  BEGIN
    RETURN FLOAT(Math.log10(FLOAT(x, LONGREAL)), T);
  END Lg;

PROCEDURE <A NAME="Lb"><procedure>Lb</procedure></A> (x: T; ): T =
  (* returns the base 2 logarithm of x. *)
  BEGIN
    RETURN
      FLOAT(Math.log(FLOAT(x, LONGREAL)), T) / FLOAT(Math.log(2.0D0), T);
  END Lb;

PROCEDURE <A NAME="Log"><procedure>Log</procedure></A> (x, y: T; ): T =
  (* returns the base y logarithm of x. *)
  BEGIN
    RETURN FLOAT(Math.log(FLOAT(x, LONGREAL)), T) / FLOAT(
             Math.log(FLOAT(y, LONGREAL)), T);
  END Log;

PROCEDURE <A NAME="Pow"><procedure>Pow</procedure></A> (x, y: T; ): T =
  (* returns x^y. *)
  BEGIN
    RETURN FLOAT(Math.pow(FLOAT(x, LONGREAL), FLOAT(y, LONGREAL)), T);
  END Pow;

PROCEDURE <A NAME="SqRt"><procedure>SqRt</procedure></A> (x: T; ): T =
  (* returns the square root of x. *)
  BEGIN
    RETURN FLOAT(Math.sqrt(FLOAT(x, LONGREAL)), T);
  END SqRt;
</PRE>---- Trigonometric functions ----

<P>
<P><PRE>PROCEDURE <A NAME="Cos"><procedure>Cos</procedure></A> (x: T; ): T =
  (* returns the cosine of x radians. *)
  BEGIN
    RETURN FLOAT(Math.cos(FLOAT(x, LONGREAL)), T);
  END Cos;

PROCEDURE <A NAME="Sin"><procedure>Sin</procedure></A> (x: T; ): T =
  (* returns the sine of x radians. *)
  BEGIN
    RETURN FLOAT(Math.sin(FLOAT(x, LONGREAL)), T);
  END Sin;

PROCEDURE <A NAME="Tan"><procedure>Tan</procedure></A> (x: T; ): T =
  (* returns the tangent of x radians. *)
  BEGIN
    RETURN FLOAT(Math.tan(FLOAT(x, LONGREAL)), T);
  END Tan;

PROCEDURE <A NAME="ArcCos"><procedure>ArcCos</procedure></A> (x: T; ): T =
  (* returns the arc cosine of x in radians. *)
  BEGIN
    RETURN FLOAT(Math.acos(FLOAT(x, LONGREAL)), T);
  END ArcCos;

PROCEDURE <A NAME="ArcSin"><procedure>ArcSin</procedure></A> (x: T; ): T =
  (* returns the arc sine of x in radians. *)
  BEGIN
    RETURN FLOAT(Math.asin(FLOAT(x, LONGREAL)), T);
  END ArcSin;

PROCEDURE <A NAME="ArcTan"><procedure>ArcTan</procedure></A> (x: T; ): T =
  (* returns the arc tangent of x in radians. *)
  BEGIN
    RETURN FLOAT(Math.atan(FLOAT(x, LONGREAL)), T);
  END ArcTan;

PROCEDURE <A NAME="ArcTan2"><procedure>ArcTan2</procedure></A> (y, x: T; ): T =
  (* returns the arc tangent of y/x in radians. *)
  BEGIN
    RETURN FLOAT(Math.atan2(FLOAT(y, LONGREAL), FLOAT(x, LONGREAL)), T);
  END ArcTan2;
</PRE>---- Hyperbolic trigonometric functions ----

<P>
<P><PRE>PROCEDURE <A NAME="CosH"><procedure>CosH</procedure></A> (x: T; ): T =
  (* returns the hyperbolic cosine of x. *)
  BEGIN
    RETURN FLOAT(Math.cosh(FLOAT(x, LONGREAL)), T);
  END CosH;

PROCEDURE <A NAME="SinH"><procedure>SinH</procedure></A> (x: T; ): T =
  (* returns the hyperbolic sine of x. *)
  BEGIN
    RETURN FLOAT(Math.sinh(FLOAT(x, LONGREAL)), T);
  END SinH;

PROCEDURE <A NAME="TanH"><procedure>TanH</procedure></A> (x: T; ): T =
  (* returns the hyperbolic tangent of x. *)
  BEGIN
    RETURN FLOAT(Math.tanh(FLOAT(x, LONGREAL)), T);
  END TanH;

PROCEDURE <A NAME="ArCosH"><procedure>ArCosH</procedure></A> (x: T; ): T =
  (* returns the inverse hyperbolic cosine of x *)
  BEGIN
    RETURN FLOAT(Math.acosh(FLOAT(x, LONGREAL)), T);
  END ArCosH;

PROCEDURE <A NAME="ArSinH"><procedure>ArSinH</procedure></A> (x: T; ): T =
  (* returns the inverse hyperbolic sine of x *)
  BEGIN
    RETURN FLOAT(Math.asinh(FLOAT(x, LONGREAL)), T);
  END ArSinH;

PROCEDURE <A NAME="ArTanH"><procedure>ArTanH</procedure></A> (x: T; ): T =
  (* returns the inverse hyperbolic tangent of x *)
  BEGIN
    RETURN FLOAT(Math.atanh(FLOAT(x, LONGREAL)), T);
  END ArTanH;

PROCEDURE <A NAME="Sgn"><procedure>Sgn</procedure></A> (x: T; ): T =
  BEGIN
    IF x &gt; Zero THEN
      RETURN One;
    ELSIF x &lt; Zero THEN
      RETURN MinusOne;
    ELSE
      RETURN Zero;
    END;
  END Sgn;

BEGIN
END FloatTrans.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
