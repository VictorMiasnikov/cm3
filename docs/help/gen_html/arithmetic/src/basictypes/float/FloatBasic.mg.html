<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: arithmetic/src/basictypes/float/FloatBasic.mg</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>arithmetic/src/basictypes/float/FloatBasic.mg</H2></A><HR>
<inModule>
<PRE>GENERIC MODULE <genericModule><A HREF="FloatBasic.ig.html">FloatBasic</A></genericModule>();
</PRE><BLOCKQUOTE><EM> Arithmetic for Modula-3, see doc for details
<P>
   Abstract: Generic wrapper routines for basic operations of float
   types </EM></BLOCKQUOTE><PRE>

IMPORT <A HREF="../../Arithmetic.i3.html">Arithmetic</A> AS Arith;

&lt;* UNUSED *&gt;
CONST
  Module = &quot;FloatBasic.&quot;;

PROCEDURE <A NAME="FromInteger"><procedure>FromInteger</procedure></A> (x: INTEGER; ): T =
  BEGIN
    RETURN FLOAT(x, T)
  END FromInteger;

PROCEDURE <A NAME="Add"><procedure>Add</procedure></A> (x, y: T; ): T =
  BEGIN
    RETURN x + y
  END Add;

PROCEDURE <A NAME="Sub"><procedure>Sub</procedure></A> (x, y: T; ): T =
  BEGIN
    RETURN x - y
  END Sub;

PROCEDURE <A NAME="Neg"><procedure>Neg</procedure></A> (x: T; ): T =
  BEGIN
    RETURN -x
  END Neg;

PROCEDURE <A NAME="Conj"><procedure>Conj</procedure></A> (x: T; ): T =
  BEGIN
    RETURN x
  END Conj;

PROCEDURE <A NAME="IsZero"><procedure>IsZero</procedure></A> (x: T; ): BOOLEAN =
  BEGIN
    RETURN x = Zero;
  END IsZero;

&lt;* INLINE *&gt;
PROCEDURE <A NAME="CheckDivisor"><procedure>CheckDivisor</procedure></A> (x: T; ) RAISES {Arith.Error} =
  BEGIN
    IF x = Zero THEN
      RAISE Arith.Error(NEW(Arith.ErrorDivisionByZero).init());
    END;
  END CheckDivisor;

PROCEDURE <A NAME="Mul"><procedure>Mul</procedure></A> (x, y: T; ): T =
  BEGIN
    RETURN x * y
  END Mul;

PROCEDURE <A NAME="Div"><procedure>Div</procedure></A> (x, y: T; ): T RAISES {Arith.Error} =
  BEGIN
    CheckDivisor(y);
    RETURN x / y
  END Div;

PROCEDURE <A NAME="Mod"><procedure>Mod</procedure></A> (&lt;* UNUSED *&gt; x: T; y: T; ): T RAISES {Arith.Error} =
  BEGIN
    CheckDivisor(y);
    RETURN Zero
  END Mod;

PROCEDURE <A NAME="DivMod"><procedure>DivMod</procedure></A> (x, y: T; ): QuotRem RAISES {Arith.Error} =
  BEGIN
    CheckDivisor(y);
    RETURN QuotRem{x / y, Zero}
  END DivMod;

PROCEDURE <A NAME="IntMod"><procedure>IntMod</procedure></A> (x, y: T; ): T RAISES {Arith.Error} =
  BEGIN
    CheckDivisor(y);
    RETURN x MOD y
  END IntMod;

PROCEDURE <A NAME="Rec"><procedure>Rec</procedure></A> (x: T; ): T RAISES {Arith.Error} =
  BEGIN
    CheckDivisor(x);
    RETURN One / x
  END Rec;

PROCEDURE <A NAME="ScaleInt"><procedure>ScaleInt</procedure></A> (x: T; y: INTEGER; ): T =
  BEGIN
    RETURN x * FLOAT(y, T)
  END ScaleInt;

BEGIN
END FloatBasic.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
