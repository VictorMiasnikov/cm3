<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: arithmetic/src/misc/lowlevel/WordEx.i3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>arithmetic/src/misc/lowlevel/WordEx.i3</H2></A><HR>
<inInterface>
<PRE>INTERFACE <interface><A HREF="WordEx.m3.html">WordEx</A></interface>;
</PRE><BLOCKQUOTE><EM> Arithmetic for Modula-3, see doc for details
<P>
   Abstract: Extensions to the Word module
<P>
   [These ought to be available in Word, and compiled in-line as with other
   Word functions.  Doing them as coded implementations is a stopgap.]
<P>
   3/16/96 Warren D.  Smith Initial version </EM></BLOCKQUOTE><PRE>

IMPORT <A HREF="../../../../m3core/src/word/Word.i3.html">Word</A>;

PROCEDURE <A HREF="WordEx.m3.html#PlusWithCarry">PlusWithCarry</A> (VALUE x, y: Word.T; VAR carry: BOOLEAN; ): Word.T;

PROCEDURE <A HREF="WordEx.m3.html#MinusWithBorrow">MinusWithBorrow</A> (VALUE x, y: Word.T; VAR borrow: BOOLEAN; ):
  Word.T;

PROCEDURE <A HREF="WordEx.m3.html#LeftShiftWithProbscosis">LeftShiftWithProbscosis</A>
  (VALUE x: Word.T; VALUE sh: CARDINAL; VAR probscosis: Word.T; ): Word.T;
</PRE><BLOCKQUOTE><EM> Perhaps also a version LeftShiftWithCarry, specializing this to sh=1,
   should be provided, to allow extra closeness to the hardware. </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="WordEx.m3.html#RightShiftWithProbscosis">RightShiftWithProbscosis</A>
  (VALUE x: Word.T; VALUE sh: CARDINAL; VAR probscosis: Word.T; ): Word.T;
</PRE><BLOCKQUOTE><EM> Perhaps also a version RightShiftWithCarry, specializing to sh=1, should
   be provided, to allow extra closeness to the hardware. </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="WordEx.m3.html#DoubleLengthMultiply">DoubleLengthMultiply</A> (VALUE x, y: Word.T; VAR lo, hi: Word.T; );

PROCEDURE <A HREF="WordEx.m3.html#HighTimes">HighTimes</A> (VALUE x, y: Word.T; ): Word.T;
</PRE><BLOCKQUOTE><EM> Returns the <CODE>hi</CODE> word in DoubleLengthMultiply(x,y, lo,hi), which was
   just implemented as lo := Word.Times(x,y); hi := HighTimes(x,y). </EM></BLOCKQUOTE><PRE>
</PRE> I have not written a DoubleLengthDivide workaround, but this absence is
   perhaps not so serious since many bignum packages, whose authors are
   lazy, implement division via multiplication and Newton algorithm, and
   modulus via division, multiplication and subtraction.  Similar remarks
   apply to sqrt.  Still, I think, since hardware provides this, the
   routine ought to be accessible to modula-3 programmers! 

<P><PRE>PROCEDURE <A HREF="WordEx.m3.html#PopCount">PopCount</A> (x: Word.T; ): [0 .. Word.Size];
</PRE><BLOCKQUOTE><EM> Returns number of 1s in binary representation of x </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="WordEx.m3.html#FindLeastSignifBit">FindLeastSignifBit</A> (x: Word.T; ): [-1 .. Word.Size - 1];
</PRE><BLOCKQUOTE><EM> Returns the index (in [0..Word.Size-1]) of the least significant bit of
   x that is 1.  But if x=0, returns -1. </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="WordEx.m3.html#FindMostSignifBit">FindMostSignifBit</A> (x: Word.T; ): [0 .. Word.Size];
</PRE><BLOCKQUOTE><EM> Returns the index (in [0..Word.Size-1]) of the most significant bit of x
   that is 1.  But if x=0, returns Word.Size. </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="WordEx.m3.html#Test">Test</A> ();
</PRE><BLOCKQUOTE><EM> Performs a series of assertions </EM></BLOCKQUOTE><PRE>

END WordEx.
</PRE>
</inInterface>
<PRE>























</PRE>
</BODY>
</HTML>
