<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: arithmetic/src/algebra/polynomial/Polynomial.ig</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>arithmetic/src/algebra/polynomial/Polynomial.ig</H2></A><HR>
<inInterface>
<PRE>GENERIC INTERFACE <genericInterface><A HREF="Polynomial.mg.html">Polynomial</A></genericInterface>(R, V, PI);
</PRE><BLOCKQUOTE><EM> Arithmetic for Modula-3, see doc for details </EM></BLOCKQUOTE><PRE>

CONST Brand = R.Brand &amp; &quot;Polynomial&quot;;

TYPE
  (* interpretation is: a[0] + a[1]*xi + a[2]* xi^2...a[n]*xi^n *)
  (* text form is: T4{a0,a1,a2,a3} *)
  TBody = PI.TBody;
  T = PI.T;
  QuotRem = PI.QuotRem;
</PRE>*
   It's not possible to obtain a pointer to a constant array.
   We can not turn T from a reference type to an array type,
   because the return type must be compatible to the input types.
<P>
CONST
  Zero    =  TBody{R.Zero};
  One     =  TBody{R.One};
*

<P><PRE>VAR
  Zero: T;                       (*CONST*)
  One : T;                       (*CONST*)

PROCEDURE <A HREF="Polynomial.mg.html#New">New</A> (degree: CARDINAL; ): T; (* make a poly for a0..an*)

CONST
  FromArray = V.FromArray;
  Copy      = V.Copy;

  IsZero  = PI.IsZero;
  Equal   = PI.Equal;
  Compare = PI.Compare;

  Add = PI.Add;
  Sub = PI.Sub;
  Neg = V.Neg;

  Scale = V.Scale;

  Mul    = PI.Mul;
  Div    = PI.Div;
  Mod    = PI.Mod;
  DivMod = PI.DivMod;

  Eval           = PI.Eval;
  Derive         = PI.Derive;
  EvalDerivative = PI.EvalDerivative;
  Compose        = PI.Compose;

END Polynomial.
</PRE>
</inInterface>
<PRE>























</PRE>
</BODY>
</HTML>
