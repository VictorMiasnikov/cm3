<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: stablegen/src/GenModuleCode.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>stablegen/src/GenModuleCode.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright (C) 1991, Digital Equipment Corporation 
 All rights reserved. 
 See the file COPYRIGHT for a full description. 
 Created by Susan Owicki, rewritten by Carsten Weich 
 Last modified on Tue Aug 27 11:23:17 PDT 1996 by najork  
      modified on Mon Jan 30 15:56:36 PST 1995 by kalsow  
      modified on Wed Jan  4 09:58:52 PST 1995 by chaiken 
      modified on Wed Sep 28 13:31:01 PDT 1994 by weich 

<P> Produce Modula-3 code for the stable object's implementation 

<P><PRE>MODULE <module><implements><A HREF="GenModuleCode.i3.html">GenModuleCode</A></implements></module>;

IMPORT <A HREF="../../libm3/src/atom/Atom.i3.html">Atom</A>, <A HREF="GenTypeCode.i3.html">GenTypeCode</A>, <A HREF="../../libm3/src/fmtlex/Fmt.i3.html">Fmt</A>, <A HREF="../../libm3/src/formatter/Formatter.i3.html">Formatter</A>, <A HREF="StablegenError.i3.html">StablegenError</A>, <A HREF="../../m3core/src/text/Text.i3.html">Text</A>,
       <A HREF="#x1">ImportList</A>, <A HREF="#x2">Type</A>, <A HREF="#x3">Value</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>;

&lt;* FATAL Wr.Failure*&gt;
</PRE> \subsection{Name preambles} The following constants are used to alter
   the user identifier where necessary.  <CODE>PreLogMeths</CODE> is inserted before
   the name of the updatemethod to get the name recording version of the
   method.  The replaying procedure has <CODE>PreReplayMeth</CODE> as first part of
   the name.
<P>
   To avoid name conflics between user arguments and arguments produced by
   the generator, <CODE>PreArgs</CODE> is inserted befor argument identifier.

<PRE>CONST
  PreLogMeths    = &quot;Log_&quot;;
  PreReplayMeths = &quot;Replay_&quot;;
  SuffArgs       = &quot;_arg&quot;;
</PRE> \subsection{Utility procedures and abreviations}
   All procedures that output code in this module use the <CODE>Formatter</CODE>
   module. The following abreviation is used by all procedures in order
   to get better readable program text:
<P>
<PRE>
         WITH Put    = Formatter.PutText,
              Nl     = Formatter.NewLine,
              Tab    = Formatter.Begin,
              EndTab = Formatter.End      DO
</PRE>
   Often used <CODE>Formatter</CODE>-procedure sequences are combined in the
   procdures <CODE>PutLine</CODE>.


<P><PRE>PROCEDURE <A NAME="PutLine"><procedure>PutLine</procedure></A> (fmtWr: Formatter.T; text: TEXT) =
  BEGIN
    Formatter.PutText(fmtWr, text);
    Formatter.NewLine(fmtWr, freshLine := FALSE);
  END PutLine;
</PRE> \subsection{Generate procedure calls}
   Several procedure calls are generated by the following procedures.
   <CODE>SuperCall()</CODE> generates a call to the original update method.
   <CODE>StableLogCall()</CODE> generates calls to procedures of the <CODE>StableLog</CODE>
   module.
<P>
   The parameters of type <CODE>Direction</CODE> determin wether the call is
   used in the logging procedure (<CODE>Direction.Log</CODE>) or in the
   replay procedures (<CODE>Direction.Replay</CODE>).


<P><PRE>TYPE Direction = {Replay, Log};

PROCEDURE <A NAME="SuperCall"><procedure>SuperCall</procedure></A> (f     : Formatter.T;
                     name  : Type.Qid;
                     method: ImportList.Method;
                     suffix: TEXT;
                     d     : Direction          ) =
  BEGIN
    WITH Put = Formatter.PutText DO
      Put(f, Atom.ToText(name.intf) &amp; &quot;.T.&quot;
               &amp; Atom.ToText(method.name));
      Put(f, &quot;(self&quot;);
      FOR i := 0 TO LAST(method.sig.formals^) DO
        WITH formals = method.sig.formals[i] DO
          Put(f, &quot;, &quot;);
          Put(f, Atom.ToText(formals.name) &amp; suffix);
          IF d = Direction.Replay
               AND ISTYPE(formals.type, Type.OpenArray) THEN
            Put(f, &quot;^&quot;)
          END;
        END;
      END;
      Put(f, &quot;)&quot;);
    END (*WITH*)
  END SuperCall;

PROCEDURE <A NAME="StableLogCall"><procedure>StableLogCall</procedure></A> (f      : Formatter.T;
                         proc   : TEXT;
                         varName: TEXT;
                         d      : Direction;
                         ranges                 := &quot;&quot;) =
  BEGIN
    WITH Put = Formatter.PutText DO
      IF d = Direction.Replay THEN
        Put(f, varName &amp; &quot; := StableLog.In&quot; &amp; proc &amp; &quot;(log&quot;
                 &amp; ranges &amp; &quot;);&quot;);
      ELSE
        Put(f, &quot;StableLog.Out&quot; &amp; proc &amp; &quot;(self.log, &quot;
                 &amp; varName &amp; ranges &amp; &quot;);&quot;);
      END (*IF*)
    END (*WITH*)
  END StableLogCall;
</PRE> \subsection{Procedure Header}
   Write <CODE>MODULE</CODE>..., imports (<CODE>ImportList.ToText()</CODE>) and the
   enumeration type <CODE>TYPE Methods</CODE> used to gather method codes
   (<CODE>EnumerateMethods()</CODE> below).

<PRE>PROCEDURE <A NAME="Header"><procedure>Header</procedure></A> (f         : Formatter.T;
                  implName  : TEXT;
                  methods   : ImportList.MethodList;
                  importList: ImportList.T           ) =
  BEGIN
    WITH Put    = Formatter.PutText,
         Nl     = Formatter.NewLine DO
      PutLine(f, &quot;(* This file was generated by the program stablegen *)&quot;);
      Nl(f, freshLine := FALSE);
      Put(f, &quot;MODULE &quot; &amp; implName &amp; &quot;;&quot;); Nl(f);
      Nl(f, freshLine := FALSE);
      Put(f, &quot;IMPORT &quot;);
      Put(f, ImportList.ToText(importList) &amp; &quot;;&quot;); Nl(f);
      Nl(f, freshLine := FALSE);
      Put(f, &quot;TYPE &quot;);  Nl(f);
      EnumerateMethods(f, methods);
      Nl(f, freshLine := FALSE);
    END
  END Header;

PROCEDURE <A NAME="EnumerateMethods"><procedure>EnumerateMethods</procedure></A> (f      : Formatter.T;
                            methods: ImportList.MethodList) =
  BEGIN
    WITH Put    = Formatter.PutText,
         Nl     = Formatter.NewLine,
         Tab    = Formatter.Begin,
         EndTab = Formatter.End      DO
      Put(f, &quot;  Methods = {&quot;); Tab(f);
      FOR i := LAST(methods^) TO 0 BY -1 DO
        IF i &lt; LAST(methods^) THEN Put(f, &quot;, &quot;); END;
        Formatter.Break(
          f, type := Formatter.BreakType.NonOptimal);
        Put(f, Atom.ToText(methods[i].name));
      END;
      Put(f, &quot;};&quot;); Nl(f);
      EndTab(f);
    END
  END EnumerateMethods;
</PRE> \subsection{Procedure Revealation}
   Generate the <CODE>REVEAL</CODE> of the stable
   subtype.  The opaque supertype revealed is from the generic interface
   which has to be instanciated from outside the stable generator.
<P>
   The necessary information passed is: <CODE>t</CODE> the object to be made stable,
   <CODE>f</CODE> the writer for the code output, <CODE>methods</CODE> the list of update
   methods.
<P>
   The code produced is a object type which is a subtype of the generic
   <CODE>Stable.T</CODE>.  Hidden fields are <CODE>nm</CODE>, the name of the stable object,
   <CODE>log</CODE> the log writer, <CODE>lm</CODE> the log manager object, <CODE>forceToDisk</CODE> the
   sync boolean.  Overridden methods are those from the generic interface
   and those from the user object.

<PRE>PROCEDURE <A NAME="Revealation"><procedure>Revealation</procedure></A> (f      : Formatter.T;
                       repName: TEXT;
                       methods: ImportList.MethodList) =
  BEGIN
    WITH Put    = Formatter.PutText,
         Nl     = Formatter.NewLine,
         Tab    = Formatter.Begin,
         EndTab = Formatter.End      DO
      Put(f, &quot;REVEAL &quot;); Nl(f);
      Put(f, &quot;  T = &quot;); Tab(f); Tab(f, 2);
      Put(f, repName);
      Put(f, &quot;.Public BRANDED OBJECT&quot;);
      Nl(f);
      Put(f, &quot;OVERRIDES&quot;);                          Nl(f);
      Put(f, &quot;replayLog:= ReplayLog;&quot;);  Nl(f);
      Nl(f);

      FOR i := 0 TO LAST(methods^) DO
        Nl(f, freshLine := FALSE);
        Put(f, Atom.ToText(methods[i].name) &amp; &quot; := &quot;);
        Put(f, PreLogMeths &amp; Atom.ToText(methods[i].name) &amp; &quot;;&quot;);
      END;
      EndTab(f);
      Nl(f, freshLine := FALSE);
      Put(f, &quot;END;&quot;);
      EndTab(f);
      Nl(f, freshLine := FALSE);
      Nl(f, freshLine := FALSE);
    END;
  END Revealation;
</PRE> \subsection{Procedure Surrogates}
   Produce methods that log their parameters and then start the
   methods of the (unstable) supertype. Output is written to the
   Formatter <CODE>f</CODE>, the name of the supertype is taken from the
   <CODE>type</CODE> (which is the unstable supertype). The log writing
   surrogate methods are produced for all methods listet in
   <CODE>methods</CODE>. <CODE>repName</CODE> is the name of the instantiated generic
   part of the generated code.
<P>
   A main <CODE>FOR</CODE> statement loops over all <CODE>methods</CODE>. The code
   generation is split amoung the procedures
   <CODE>GenTypeCode.ProcHeader()</CODE> (producing <CODE>PROCEDURE</CODE> header and
   variables), <CODE>SurrBody()</CODE> (procuding the statements) and
   <CODE>SurrErrors()</CODE> (producing error handling at the end).

<PRE>PROCEDURE <A NAME="Surrogates"><procedure>Surrogates</procedure></A> (f      : Formatter.T;
                      name   : Type.Qid;
                      repName: TEXT;
                      methods: ImportList.MethodList)
  RAISES {StablegenError.E} =
  BEGIN
    WITH Put    = Formatter.PutText,
         Nl     = Formatter.NewLine,
         Tab    = Formatter.Begin,
         EndTab = Formatter.End      DO
      FOR i := 0 TO LAST(methods^) DO
        WITH pname = PreLogMeths
                       &amp; Atom.ToText(methods[i].name) DO
          Nl(f, freshLine := FALSE);
          Tab(f, 2);
          GenTypeCode.ProcHeader(f, pname, methods[i].sig, &quot;_arg&quot;);
          PutLine(f, &quot; = &quot;);

          SurrBody(f, name, repName, methods[i]);
          SurrErrors(f);
          Put(f, &quot;END&quot;); (* matches IF self.lm... in SurrBody *)
          EndTab(f); Nl(f);
          Put(f, &quot;END &quot; &amp; pname &amp; &quot;;&quot;); (* matches BEGIN in SurrBody *)
          EndTab(f);
          Nl(f, freshLine := FALSE);
          Formatter.Flush(f);
        END;                     (*WITH*)
      END                        (*FOR*)
    END                          (*WITH*)
  END Surrogates;

PROCEDURE <A NAME="SurrErrors"><procedure>SurrErrors</procedure></A> (f: Formatter.T) =
  BEGIN
    WITH Nl     = Formatter.NewLine,
         Put    = Formatter.PutText,
         EndTab = Formatter.End      DO
      PutLine(f, &quot;EXCEPT&quot;);
      PutLine(f, &quot;  StableError.E(err) =&gt;&quot;);
      PutLine(f, &quot;    &lt;*NOWARN*&gt; StableError.Halt(&quot;);
      PutLine(f, &quot;              \&quot;can not flush log (\&quot;&amp; StableError.ToText(err) &quot;);
      PutLine(f, &quot;              &amp; \&quot;) in dir \&quot; &amp; self.nm);&quot;);
      Put(f, &quot;END&quot;);
      EndTab(f);
      Nl(f);
    END (*WITH*)
  END SurrErrors;
</PRE> \subsection{Procedure SurrBody}
   This procedure generates the statements of surrogate methods
   except the error handling <CODE>EXCEPT</CODE> part of it. Comments mark
   the three parts of this procedure. {\em Prolog:} Output the
   call to eventually reopen the log and the method number recording
   call. {\em Parameter saving:} Output recording calls for every
   parameter of the method. {\em Supercall} Output the call to
   the original update method. {\em Epilog:} Output the commit
   recording call and the log flushing call. The epilog is protected
   by a <CODE>TRY FINALLY</CODE> statement in case that the logged method
   raises an exception.

<PRE>PROCEDURE <A NAME="SurrBody"><procedure>SurrBody</procedure></A> (f      : Formatter.T;
                    name   : Type.Qid;
                    repName: TEXT;
                    method : ImportList.Method)
  RAISES {StablegenError.E} =
  BEGIN
    WITH Put    = Formatter.PutText,
         Nl     = Formatter.NewLine,
         Tab    = Formatter.Begin,
         EndTab = Formatter.End      DO
    (* Prolog *)
      Tab(f, 2);
      PutLine(f, &quot;BEGIN&quot;);
      Tab(f, 2);

    (* Just do Super call if no log manager *)
      PutLine(f, &quot;IF self.lm = NIL THEN&quot;);

      IF method.sig.result # NIL THEN Put(f, &quot;RETURN &quot;); END;
      SuperCall(f, name, method, SuffArgs, Direction.Log);
      EndTab(f); Nl(f);
      Tab(f, 2);
      PutLine(f, &quot;ELSE&quot;); (* IF self.lm... *)

      Tab(f, 2);
      PutLine(f, &quot;TRY&quot;);
      Put    (f, repName);
      PutLine(f, &quot;.ReOpenLog(self);&quot;);
      Put    (f, &quot;StableLog.OutCall(self.log, ORD(Methods.&quot;);
      PutLine(f, Atom.ToText(method.name) &amp; &quot;));&quot;);

    (* Generate all parameter saving calls *)
      FOR i := 0 TO LAST(method.sig.formals^) DO
        WITH formals = method.sig.formals[i] DO
          MarshalTypedVal(
            f, Atom.ToText(formals.name) &amp; SuffArgs,
            formals.type, Direction.Log, calling := TRUE);
          Nl(f);
        END;
      END;

    (* Do Super call *)
      Tab(f, 2);
      PutLine(f, &quot;TRY&quot;);
      IF method.sig.result # NIL THEN Put(f, &quot;RETURN &quot;); END;
      SuperCall(f, name, method, SuffArgs, Direction.Log);
      EndTab(f); Nl(f);

    (* Epilog *)
      Tab(f, 2);
      PutLine(f, &quot;FINALLY&quot;);
      PutLine(f, &quot;StableLog.OutCallEndMark(self.log);&quot;);
      Put(f, &quot;IF self.forceToDisk THEN self.flushLog() END&quot;);
      EndTab(f); Nl(f);
      Put(f, &quot;END&quot;);
      EndTab(f); Nl(f);
    END (*DO*)
  END SurrBody;
</PRE> \subsection{Procedure Dispatcher}
   This procedure generates the dispatcher <CODE>ReplayLog</CODE> which is
   called during recovery.  It reads the log (<CODE>StableLog.InCall</CODE>) in
   an endless loop and calls all replay procedures (<CODE>Replay_...</CODE>)
   accordingly. The loop exits only when an exception occurs during
   respooling. This happens at the end of the log reader.

<PRE>PROCEDURE <A NAME="Dispatcher"><procedure>Dispatcher</procedure></A> (f      : Formatter.T;
                      methods: ImportList.MethodList) =
  BEGIN
    WITH Put    = Formatter.PutText,
         Nl     = Formatter.NewLine,
         Tab    = Formatter.Begin,
         EndTab = Formatter.End      DO
      Put(f, &quot;\nPROCEDURE ReplayLog(o: T; log: Rd.T) =&quot;);
      Put(f, &quot;\n  BEGIN&quot;);
      Put(f, &quot;\n    TRY&quot;);
      Put(f, &quot;\n      LOOP&quot;);
      Tab(f, -1);
      Put(f,
        &quot;\n        CASE VAL(StableLog.&quot;
          &amp; &quot;InCall(log, ORD(LAST(Methods))), Methods) OF&quot;);
      FOR i := FIRST(methods^) TO LAST(methods^) DO
        Nl(f, freshLine := FALSE);
        Put(f, &quot;| Methods.&quot; &amp; Atom.ToText(methods[i].name)
                 &amp; &quot; =&gt; &quot;);
        Put(f, PreReplayMeths &amp; Atom.ToText(methods[i].name)
                 &amp; &quot;(o, log);&quot;);
      END;
      EndTab(f);
      Put(f, &quot;\n        END (*CASE*)&quot;);
      Put(f, &quot;\n      END (*LOOP*)&quot;);
      Put(f, &quot;\n    EXCEPT&quot;);
      Put(f, &quot;\n     ELSE&quot;);
      Put(f, &quot;\n    END;&quot;);
      Put(f, &quot;\n  END ReplayLog;\n\n&quot;);
    END
  END Dispatcher;
</PRE> \subsection{Procedure ReplayStubs}
   Generate on <CODE>f</CODE> for object <CODE>name</CODE> for each method in <CODE>methods</CODE>
   a replay stub procedure.
<P>
   The main <CODE>FOR</CODE>-loop steps through <CODE>methods</CODE>. The main steps
   performed for each such method is marked by comments below:
   {\em Generate procedure header} generates the header of the
   stub (parameters are always the same: <CODE>self</CODE> and <CODE>log</CODE>).
   {\em Variable Deklarations:} For each parameter of the
   update method one variable has to be declared (with the same
   type than the parameter). {\em Read in Values:} generate
   calls to read each such parameter from the log. {\em Super call:}
   Now the update method can be called (which is not a super call
   but looks exactly like one). Finally the <CODE>END</CODE> of the stub
   is generated.

<PRE>PROCEDURE <A NAME="ReplayStubs"><procedure>ReplayStubs</procedure></A> (f      : Formatter.T;
                       name   : Type.Qid;
                       methods: ImportList.MethodList)
  RAISES {StablegenError.E} =
  VAR varType: Type.T;
  BEGIN
    WITH Put    = Formatter.PutText,
         Nl     = Formatter.NewLine,
         Tab    = Formatter.Begin,
         EndTab = Formatter.End      DO
      FOR i := 0 TO LAST(methods^) DO
      (* Generate procedure header *)
        GenTypeCode.ProcHeader(
          f,
          PreReplayMeths &amp; Atom.ToText(methods[i].name),
          replaySig);
        Put(f, &quot;=\n&quot;);

      (* Variable Deklarations for parameter of method: *)
        WITH sig = methods[i].sig DO
          IF NUMBER(sig.formals^) &gt; 0 THEN
            Tab(f, 4);
            Put(f, &quot;  VAR&quot;);
            FOR j := 0 TO LAST(sig.formals^) DO
              WITH formals = sig.formals[j] DO
                TYPECASE formals.type OF
                | Type.OpenArray (oa) =&gt;
                    varType := oa.refArray
                ELSE
                  varType := formals.type;
                END;
                Nl(f);
                Put(
                  f, Atom.ToText(formals.name) &amp; SuffArgs
                       &amp; &quot;: &quot; &amp; GenTypeCode.ToText(varType)
                       &amp; &quot;;&quot;);
              END;
            END;
            EndTab(f);
          END;

      (* Read in values of parameters: *)
          Nl(f);
          Tab(f, 4);
          PutLine(f, &quot;  BEGIN&quot;);
          FOR j := 0 TO LAST(sig.formals^) DO
            WITH formals = sig.formals[j] DO
              MarshalTypedVal(
                f, Atom.ToText(formals.name) &amp; SuffArgs,
                formals.type, Direction.Replay, calling := TRUE);
              Nl(f)
            END
          END;
          PutLine(f, &quot;IF NOT StableLog.CheckCallEndMark(log) THEN&quot;);
          PutLine(f, &quot;  RAISE StableLog.Error&quot;);
          PutLine(f, &quot;END;&quot;);
        END; (*WITH*)

      (* Do Supercall *)
        Tab(f, 2);
        PutLine(f, &quot;TRY&quot;);
        IF methods[i].sig.result # NIL THEN Put(f, &quot;EVAL &quot;); END;
        SuperCall(f, name, methods[i], SuffArgs, Direction.Replay);

        EndTab(f);
        Nl(f);
        PutLine(f, &quot;EXCEPT ELSE&quot;);
        Put(f, &quot;END&quot;);

        (* End Procedure *)
        EndTab(f);
        Nl(f);
        Put(f, &quot;  END &quot; &amp; PreReplayMeths
                 &amp; Atom.ToText(methods[i].name) &amp; &quot;;\n\n&quot;);

      END (*FOR*)
    END (*WITH*)
  END ReplayStubs;
</PRE> \subsection{Procedure Checkpoint}
   Generate the call to the checkpointing procedure which is located
   in the generic part of the implementation.

<PRE>PROCEDURE <A NAME="Checkpoint"><procedure>Checkpoint</procedure></A> (f: Formatter.T; repName: TEXT) =
  BEGIN
    WITH Put = Formatter.PutText,
         Nl  = Formatter.NewLine  DO
      PutLine(f, &quot;PROCEDURE Checkpoint(o: T) RAISES {StableError.E} =&quot;);
      Nl(f);
      PutLine(f, &quot;  BEGIN&quot;);
      Nl(f);
      Put(f, &quot;    &quot;);
      Put(f, repName);
      PutLine(f, &quot;.Checkpoint(o)&quot;);
      PutLine(f, &quot;  END Checkpoint;&quot;);
      Nl(f, freshLine := FALSE);
    END
  END Checkpoint;
</PRE> \subsection{Marshalling Procedures}
   These procedures generate calls to the <CODE>StableLog</CODE> module to
   write or read a variable to or from the log.
   <CODE>MarshalTypedVal</CODE> is the main procedure which takes the
   name <CODE>varName</CODE> and type <CODE>t</CODE> of a variable.

<PRE>PROCEDURE <A NAME="MarshalTypedVal"><procedure>MarshalTypedVal</procedure></A> (fmtWr     : Formatter.T;
                           varName   : TEXT;
                           t         : Type.T;
                           d         : Direction;
                           calling   : BOOLEAN;
                           indexDepth                := 0)
  RAISES {StablegenError.E} =
  BEGIN
    WITH Put    = Formatter.PutText,
         Nl     = Formatter.NewLine,
         Tab    = Formatter.Begin,
         EndTab = Formatter.End      DO
      TYPECASE t OF
      | Type.Char =&gt; StableLogCall(fmtWr, &quot;Char&quot;, varName, d);
      | Type.UserDefined (ud) =&gt;
          IF t = Type.boolean THEN
            StableLogCall(fmtWr, &quot;Boolean&quot;, varName, d);
          ELSE
            Enumeration(fmtWr, varName, t, d, 0, LAST(ud.elts^));
          END
      | Type.Subrange (sub) =&gt;
          IF t = Type.integer THEN
            StableLogCall(fmtWr, &quot;Integer&quot;, varName, d);
          ELSIF t = Type.longint THEN
            StableLogCall(fmtWr, &quot;Longint&quot;, varName, d);
          ELSIF t = Type.cardinal THEN
            StableLogCall(fmtWr, &quot;Cardinal&quot;, varName, d);
          ELSIF t = Type.longcard THEN
            StableLogCall(fmtWr, &quot;Longcard&quot;, varName, d);
          ELSIF d = Direction.Log THEN       (* no value range check
                                                when writing *)
            IF sub.base = Type.longint THEN
              StableLogCall(fmtWr, &quot;Longint&quot;, varName, d);
            ELSE
              StableLogCall(fmtWr, &quot;Integer&quot;, varName, d);
            END
          ELSE
            SubRange(fmtWr, varName, t, d, sub.min, sub.max);
          END;
      | Type.Real =&gt; StableLogCall(fmtWr, &quot;Real&quot;, varName, d);
      | Type.LongReal =&gt;
          StableLogCall(fmtWr, &quot;Longreal&quot;, varName, d);
      | Type.Extended =&gt;
          StableLogCall(fmtWr, &quot;Extended&quot;, varName, d);
      | Type.Reference (r) =&gt;
          IF Type.MayBeRefAny(r) OR NOT Type.NamedType(r) THEN
            StableLogCall(fmtWr, &quot;Ref&quot;, varName, d);
          ELSE
            StableLogCall(fmtWr, &quot;Ref&quot;, varName, d);
          END;
      | Type.Array (a) =&gt;
          IF a.index = NIL THEN
            MarshalOpenArray(fmtWr, varName, t, d, calling, indexDepth);
          ELSE
            Tab(fmtWr, 2);
            PutLine(fmtWr, &quot;FOR i&quot; &amp; Fmt.Int(indexDepth) &amp; &quot; := FIRST(&quot;
                             &amp; GenTypeCode.ToText(a.index) &amp; &quot;) TO LAST(&quot;
                             &amp; GenTypeCode.ToText(a.index) &amp; &quot;) DO&quot;);
            MarshalTypedVal(
              fmtWr, varName &amp; &quot;[i&quot; &amp; Fmt.Int(indexDepth) &amp; &quot;]&quot;, a.element,
              d, calling, indexDepth + 1);
            EndTab(fmtWr); Nl(fmtWr);
            Put(fmtWr, &quot;END;&quot;);
          END;
      | Type.Packed (p) =&gt;
          MarshalTypedVal(fmtWr, varName, p.base, d, calling, indexDepth);
      | Type.Record (rec) =&gt;
          FOR i := 0 TO LAST(rec.fields^) DO
            MarshalTypedVal(
              fmtWr, varName &amp; &quot;.&quot; &amp; Atom.ToText(rec.fields[i].name),
              rec.fields[i].type, d, calling, indexDepth);
            IF i &lt; LAST(rec.fields^) THEN Nl(fmtWr) END
          END;
      | Type.Set (s) =&gt;
          IF d = Direction.Replay THEN
            PutLine(fmtWr, varName &amp; &quot;:=&quot; &amp; GenTypeCode.ToText(s) &amp; &quot;{};&quot;);
            Tab(fmtWr, 2);
            PutLine(fmtWr, &quot;FOR i&quot; &amp; Fmt.Int(indexDepth) &amp; &quot; := FIRST(&quot;
                             &amp; GenTypeCode.ToText(s.range) &amp; &quot;) TO LAST(&quot;
                             &amp; GenTypeCode.ToText(s.range) &amp; &quot;) DO&quot;);
            Tab(fmtWr, 2);
            PutLine(fmtWr, &quot;IF StableLog.InBoolean(log) THEN&quot;);
            Put(fmtWr, varName &amp; &quot; := &quot; &amp; varName &amp; &quot; + &quot;
                             &amp; GenTypeCode.ToText(s) &amp; &quot;{i&quot;
                             &amp; Fmt.Int(indexDepth) &amp; &quot;};&quot;);
            EndTab(fmtWr); Nl(fmtWr);
            Put(fmtWr, &quot;END&quot;)
          ELSE
            Tab(fmtWr, 2);
            PutLine(fmtWr, &quot;FOR i&quot; &amp; Fmt.Int(indexDepth) &amp; &quot; := FIRST(&quot;
                             &amp; GenTypeCode.ToText(s.range) &amp; &quot;) TO LAST(&quot;
                             &amp; GenTypeCode.ToText(s.range) &amp; &quot;) DO&quot;);
            Put(fmtWr, &quot;StableLog.OutBoolean(self.log, i&quot; &amp; Fmt.Int(indexDepth)
                             &amp; &quot; IN &quot; &amp; varName &amp; &quot;);&quot;);
          END;
          EndTab(fmtWr); Nl(fmtWr);
          Put(fmtWr, &quot;END;&quot;);
      | Type.Procedure =&gt;
          RAISE StablegenError.E(&quot;Can't have a procedure as argument or result &quot;
                              &amp; &quot;of a stable object method.&quot;);
      ELSE
        StablegenError.Fatal(&quot;runtime error in GenModuleCode&quot;);
      END (*TYPECASE*)
    END  (*WITH*)
  END MarshalTypedVal;

PROCEDURE <A NAME="SubRange"><procedure>SubRange</procedure></A> (fmtWr   : Formatter.T;
                    varName : TEXT;
                    t       : Type.Subrange;
                    d       : Direction;
                    min, max: Value.T) =
  BEGIN
    IF t = Type.longint OR t.base = Type.longint THEN
      WITH min = NARROW(min, Value.Longint).val,
           max = NARROW(max, Value.Longint).val DO
        StableLogCall(fmtWr, &quot;Longint&quot;, varName, d,
                      &quot;, 16_&quot; &amp; Fmt.LongUnsigned(min) &amp; &quot;, 16_&quot; &amp; Fmt.LongUnsigned(max));
      END
    ELSIF t = Type.integer OR t.base = Type.integer THEN
      WITH min = NARROW(min, Value.Integer).val,
           max = NARROW(max, Value.Integer).val DO
        StableLogCall(fmtWr, &quot;Integer&quot;, varName, d,
                      &quot;, 16_&quot; &amp; Fmt.Unsigned(min) &amp; &quot;, 16_&quot; &amp; Fmt.Unsigned(max));
      END
    ELSE
      TYPECASE t.base OF
      | Type.Enumeration =&gt;
        WITH min = NARROW(min, Value.Integer).val,
             max = NARROW(max, Value.Integer).val DO
          Enumeration(fmtWr, varName, t.base, d, min, max);
        END
      | Type.Subrange =&gt; SubRange(fmtWr, varName, t.base, d, min, max);
      ELSE
        StablegenError.Fatal(&quot;runtime error in GenModuleCode&quot;);
      END (*TYPECASE*)
    END (*IF*)
  END SubRange;

PROCEDURE <A NAME="Enumeration"><procedure>Enumeration</procedure></A> (fmtWr   : Formatter.T;
                       varName : TEXT;
                       t       : Type.Enumeration;
                       d       : Direction;
                       min, max: INTEGER           ) =
  BEGIN
    WITH Put = Formatter.PutText DO
      IF d = Direction.Replay THEN
        Put(fmtWr,
            varName &amp; &quot; := VAL(StableLog.InInteger(log, &quot;
              &amp; Fmt.Int(min) &amp; &quot;,&quot; &amp; Fmt.Int(max) &amp; &quot;), &quot;
              &amp; GenTypeCode.ToText(t) &amp; &quot;);&quot;);
      ELSE
        Put(fmtWr, &quot;StableLog.OutInteger(self.log, ORD(&quot;
                     &amp; varName &amp; &quot;));&quot;);
      END (*IF*)
    END (*WITH*)
  END Enumeration;

PROCEDURE <A NAME="MarshalOpenArray"><procedure>MarshalOpenArray</procedure></A> (f          : Formatter.T;
                            varName    : TEXT;
                            a          : Type.OpenArray;
                            d          : Direction;
                            calling    : BOOLEAN;
                            indexDepth : INTEGER)
  RAISES {StablegenError.E} =
  VAR
    nDimensions                        := a.openDimensions;
    aName, baseName, boundList: Text.T;
    component                 : Type.T;
  BEGIN
    WITH Put    = Formatter.PutText,
         Nl     = Formatter.NewLine,
         Tab    = Formatter.Begin,
         EndTab = Formatter.End      DO
      IF calling THEN            (* Must marshal/unmarshal
                                    array bounds *)
        IF d = Direction.Log THEN
          StableLogCall(
            f, &quot;Integer&quot;, &quot;NUMBER(&quot; &amp; varName &amp; &quot;)&quot;, d);
          Nl(f);
          aName := varName &amp; &quot;[0&quot;;
          FOR i := 2 TO nDimensions DO
            StableLogCall(
              f, &quot;Integer&quot;, &quot;NUMBER(&quot; &amp; aName &amp; &quot;])&quot;, d);
            Nl(f);
            aName := aName &amp; &quot;, 0&quot;;
          END;
          baseName := varName;
        ELSE
          Put(f, &quot;WITH n1 = StableLog.InInteger(log)&quot;);
          boundList := &quot;n1&quot;;
          FOR i := 2 TO nDimensions DO
            PutLine(f, &quot;,&quot;);
            Put(f, &quot;    n&quot; &amp; Fmt.Int(i)
                     &amp; &quot; = StableLog.InInteger(log)&quot;);
            boundList := boundList &amp; &quot;, n&quot; &amp; Fmt.Int(i);
          END;
          PutLine(f, &quot; DO&quot;);
          PutLine(f, &quot;  &quot; &amp; varName &amp; &quot; := NEW(&quot;
                       &amp; GenTypeCode.ToText(a.refArray)
                       &amp; &quot;, &quot; &amp; boundList &amp; &quot;);&quot;);
          PutLine(f, &quot;END;&quot;);
          baseName := varName &amp; &quot;^&quot;;
        END;
      ELSE
        IF d = Direction.Log THEN
          baseName := varName &amp; &quot;^&quot;;
        ELSE
          baseName := varName;
        END;
      END;

      (* Suppress actual data for &lt;*OUTPUT*&gt; params on
         call *)
      Tab(f, 2);
      PutLine(f, &quot;FOR n1 := 0 TO LAST(&quot; &amp; baseName &amp; &quot;) DO&quot;);
      aName := varName &amp; &quot;[n1&quot;;
      component := a.element;
      FOR i := 2 TO nDimensions DO
        Tab(f, 2);
        PutLine(f, &quot;FOR n&quot; &amp; Fmt.Int(i) &amp; &quot; := 0 TO LAST(&quot;
                     &amp; aName &amp; &quot;]) DO&quot;);
        aName := aName &amp; &quot;,  n&quot; &amp; Fmt.Int(i);
        component :=
          NARROW(component, Type.OpenArray).element;
      END;
      MarshalTypedVal(
        f, aName &amp; &quot;]&quot;, component, d, calling, indexDepth);
      FOR i := 1 TO nDimensions DO
        EndTab(f); Nl(f);
        Put(f, &quot;END;&quot;);      (* End FOR Loop *)
      END;
    END
  END MarshalOpenArray;
</PRE> \subsection{Define the signature of replay stubs}
   Since all replay stubs have the same signature, we provide a
   read only global variable <CODE>replaySig</CODE> that stores this signature.

<PRE>VAR
  replaySig: Type.Signature;
  replayFormals := NEW(REF ARRAY OF Type.Formal, 1);
  replayExcpt   := NEW(REF ARRAY OF Type.Exception, 1);
BEGIN
  replayFormals[0] :=
    NEW(
      Type.Formal, mode := Type.Mode.Value,
      name := Atom.FromText(&quot;log&quot;), default := NIL,
      type := NEW(Type.Object,
                  name := NEW(Type.Qid,
                              intf := Atom.FromText(&quot;Rd&quot;),
                              item := Atom.FromText(&quot;T&quot;))));
  replayExcpt[0] :=
    NEW(Type.Exception,
        qid :=
          NEW(Type.Qid, intf := Atom.FromText(&quot;StableLog&quot;),
              item := Atom.FromText(&quot;Error&quot;)), arg := NIL);
  replaySig.formals:= replayFormals;
  replaySig.result:= NIL;
  replaySig.raises:= replayExcpt;
END GenModuleCode.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface ImportList is in:
</A><UL>
<LI><A HREF="../../sharedobjgen/src/ImportList.i3.html#0TOP0">sharedobjgen/src/ImportList.i3</A>
<LI><A HREF="ImportList.i3.html#0TOP0">stablegen/src/ImportList.i3</A>
</UL>
<P>
<HR>
<A NAME="x2">interface Type is in:
</A><UL>
<LI><A HREF="../../cm3ide/src/nodes/Type.i3.html#0TOP0">cm3ide/src/nodes/Type.i3</A>
<LI><A HREF="../../m3front/src/types/Type.i3.html#0TOP0">m3front/src/types/Type.i3</A>
<LI><A HREF="../../sharedobjgen/src/Type.i3.html#0TOP0">sharedobjgen/src/Type.i3</A>
<LI><A HREF="Type.i3.html#0TOP0">stablegen/src/Type.i3</A>
<LI><A HREF="../../stubgen/src/Type.i3.html#0TOP0">stubgen/src/Type.i3</A>
</UL>
<P>
<HR>
<A NAME="x3">interface Value is in:
</A><UL>
<LI><A HREF="../../m3front/src/values/Value.i3.html#0TOP0">m3front/src/values/Value.i3</A>
<LI><A HREF="../../sharedobjgen/src/Value.i3.html#0TOP0">sharedobjgen/src/Value.i3</A>
<LI><A HREF="Value.i3.html#0TOP0">stablegen/src/Value.i3</A>
<LI><A HREF="../../stubgen/src/Value.i3.html#0TOP0">stubgen/src/Value.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
