<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: tcp/src/WIN32/TCPExtras.m3</TITLE>
</HEAD>
<BODY bgcolor="#eeeeee">
<A NAME="0TOP0">
<H2>tcp/src/WIN32/TCPExtras.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright (C) 1995, Digital Equipment Corporation. 
 All rights reserved. 
 Last modified on Tue Jun 27 15:08:05 PDT 1995 by steveg 

<P><PRE>UNSAFE MODULE <module><implements><A HREF="../common/TCPExtras.i3.html">TCPExtras</A></implements></module>;

IMPORT <A HREF="../../../m3core/src/C/Common/Ctypes.i3.html">Ctypes</A>, <A HREF="../common/IP.i3.html">IP</A>, <A HREF="../common/IPError.i3.html">IPError</A>, <A HREF="../common/TCP.i3.html">TCP</A>, <A HREF="TCPWin32.i3.html">TCPWin32</A>, <A HREF="#x1">WinSock</A>;

PROCEDURE <A NAME="LocalEndpoint"><procedure>LocalEndpoint</procedure></A> (conn: TCP.T): IP.Endpoint RAISES {IP.Error} =
  VAR
    addr : WinSock.struct_sockaddr_in;
    len  : Ctypes.int := BYTESIZE (addr);
    ep   : IP.Endpoint;
  BEGIN
    LOCK conn DO
      IF conn.closed THEN IPError.Raise (TCP.Closed); END;
      IF WinSock.getsockname (conn.sock, ADR (addr), ADR (len)) # 0 THEN
        IPError.RaiseUnexpected ();
      END;
    END;
    ep.addr := LOOPHOLE (addr.sin_addr, IP.Address);
    ep.port := WinSock.ntohs (addr.sin_port);
    RETURN ep;
  END LocalEndpoint;

PROCEDURE <A NAME="htons"><procedure>htons</procedure></A> (s: Ctypes.unsigned_short_int): Ctypes.unsigned_short_int =
  BEGIN
    RETURN WinSock.htons (s);
  END htons;

PROCEDURE <A NAME="ntohs"><procedure>ntohs</procedure></A> (s: Ctypes.unsigned_short_int): Ctypes.unsigned_short_int =
  BEGIN
    RETURN WinSock.ntohs (s);
  END ntohs;

BEGIN
END TCPExtras.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface WinSock is in:
</A><UL>
<LI><A HREF="../../../m3core/src/win32/WinSock.i3.html#0TOP0">m3core/src/win32/WinSock.i3</A>
<LI><A HREF="WinSock.i3.html#0TOP0">tcp/src/WIN32/WinSock.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
