<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: juno-machine/src/JunoRT.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>juno-machine/src/JunoRT.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright (C) 1992, Digital Equipment Corporation                         
 All rights reserved.                                                      
 See the file COPYRIGHT for a full description.                            
                                                                           
 Last modified on Tue Jan 28 11:01:06 PST 1997 by heydon                   
      modified on Sun Jun  5 15:47:38 PDT 1994 by gnelson                  
      modified on Sat Aug 22 22:10:45 PDT 1992 by myers                    
<PRE>&lt;* PRAGMA SPEC *&gt;

UNSAFE MODULE <module>JunoRT</module> EXPORTS <A HREF="JunoRT.i3.html"><implements>JunoRT</A></implements>, <A HREF="JunoArgs.i3.html"><implements>JunoArgs</A></implements>;

IMPORT <A HREF="JunoRTError.i3.html">JunoRTError</A>, <A HREF="JunoMarshal.i3.html">JunoMarshal</A>, <A HREF="JunoSolve.i3.html">JunoSolve</A>, <A HREF="#x1">JunoValue</A>, <A HREF="RTVal.i3.html">RTVal</A>;
IMPORT   <A HREF="QId.i3.html">QId</A>, <A HREF="../derived/QIdIntTbl.i3.html">QIdIntTbl</A>, <A HREF="JunoByteCode.i3.html">JunoByteCode</A> AS BC;
IMPORT <A HREF="../../libm3/src/atom/Atom.i3.html">Atom</A>, <A HREF="../../libm3/derived/RefIntTbl.i3.html">RefIntTbl</A>, <A HREF="../../m3core/src/word/Word.i3.html">Word</A>, <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>;
</PRE> For debugging output 
<PRE>IMPORT <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="../../libm3/src/fmtlex/Fmt.i3.html">Fmt</A>, <A HREF="JunoDisassem.i3.html">JunoDisassem</A>;
FROM <A HREF="../../libm3/src/rw/Stdio.i3.html">Stdio</A> IMPORT stderr;
&lt;* FATAL Wr.Failure, Thread.Alerted *&gt;
</PRE> ----------------------------- TABLE TYPE -------------------------------- 

<P><PRE>TYPE
  JVIntTbl = RefIntTbl.Default BRANDED &quot;JunoRT.JVIntTbl&quot; OBJECT OVERRIDES
    keyEqual := JVEqual;
    keyHash := JVHash
  END;

PROCEDURE <A NAME="JVEqual"><procedure>JVEqual</procedure></A>(&lt;*UNUSED*&gt; t: JVIntTbl; READONLY k1, k2: REFANY): BOOLEAN =
  BEGIN RETURN JunoValue.Equal(k1, k2) END JVEqual;

PROCEDURE <A NAME="JVHash"><procedure>JVHash</procedure></A>(&lt;*UNUSED*&gt; t: JVIntTbl; READONLY k: REFANY): Word.T =
  BEGIN RETURN JunoValue.Hash(k) END JVHash;
</PRE> ---------------------- VALUE/CODE TABLE OPERATIONS  --------------------- 

<P><PRE>VAR
  val_idx_tbl := NEW(JVIntTbl).init(sizeHint := 20);
  var_idx_tbl, code_idx_tbl, ext_idx_tbl :=
    NEW(QIdIntTbl.Default).init(sizeHint:=20);
  next_var_idx := 1;
  next_code_idx := 1;
  next_ext_idx := 0;
  procAttrs: REF ARRAY OF ProcAttr;
  extProcAttrs: REF ARRAY OF ProcAttr;

PROCEDURE <A NAME="GetValueIndex"><procedure>GetValueIndex</procedure></A>(val: JunoValue.T): CARDINAL =
  VAR res: INTEGER; BEGIN
    IF NOT val_idx_tbl.get(val, res) THEN
      res := next_var_idx;
      INC(next_var_idx);
      EVAL val_idx_tbl.put(val, res);
      VAR n := NUMBER(value_tbl^); BEGIN
        IF next_var_idx = n THEN
          VAR new := NEW(REF ARRAY OF JunoValue.T, 2 * n); BEGIN
            SUBARRAY(new^, 0, n) := value_tbl^;
            value_tbl := new
          END
        END
      END;
      value_tbl[res] := val
    END;
    RETURN res
  END GetValueIndex;

PROCEDURE <A NAME="GetVarIndex"><procedure>GetVarIndex</procedure></A>(md, nm: Atom.T): CARDINAL =
  VAR res: INTEGER; qid := NEW(QId.T, id0 := md, id1 := nm); BEGIN
    IF NOT var_idx_tbl.get(qid, res) THEN
      res := next_var_idx;
      INC(next_var_idx);
      EVAL var_idx_tbl.put(qid, res);
      VAR n := NUMBER(value_tbl^); BEGIN
        IF next_var_idx = n THEN
          VAR new := NEW(REF ARRAY OF JunoValue.T, 2 * n); BEGIN
            SUBARRAY(new^, 0, n) := value_tbl^;
            value_tbl := new
          END
        END
      END
    END;
    RETURN res
  END GetVarIndex;

PROCEDURE <A NAME="GetCodeIndex"><procedure>GetCodeIndex</procedure></A>(READONLY pa: ProcAttr): CARDINAL =
  VAR res: INTEGER; qid := NEW(QId.T, id0 := pa.modName, id1 := pa.name); BEGIN
    IF NOT code_idx_tbl.get(qid, res) THEN
      res := next_code_idx; INC(next_code_idx);
      EVAL code_idx_tbl.put(qid, res);
      VAR n := NUMBER(code_tbl^); BEGIN
        IF next_code_idx = n THEN
          VAR new := NEW(REF ARRAY OF ByteStream, 2 * n); BEGIN
            SUBARRAY(new^, 0, n) := code_tbl^;
            code_tbl := new
          END;
          VAR new := NEW(REF ARRAY OF ProcAttr, 2 * n); BEGIN
            SUBARRAY(new^, 0, n) := procAttrs^;
            procAttrs := new
          END
        END
      END
    END;
    procAttrs[res] := pa;
    RETURN res
  END GetCodeIndex;

PROCEDURE <A NAME="GetExtCodeIndex"><procedure>GetExtCodeIndex</procedure></A>(READONLY pa: ProcAttr): CARDINAL =
  VAR res: INTEGER; qid := NEW(QId.T, id0 := pa.modName, id1 := pa.name); BEGIN
    IF NOT ext_idx_tbl.get(qid, res) THEN
      res := next_ext_idx; INC(next_ext_idx);
      EVAL ext_idx_tbl.put(qid, res);
      VAR n := NUMBER(ext_code_tbl^); BEGIN
        IF next_ext_idx = n THEN
          VAR new := NEW(REF ARRAY OF ExternalCode, 2 * n); BEGIN
            SUBARRAY(new^, 0, n) := ext_code_tbl^;
            ext_code_tbl := new
          END;
          VAR new := NEW(REF ARRAY OF ProcAttr, 2 * n); BEGIN
            SUBARRAY(new^, 0, n) := extProcAttrs^;
            extProcAttrs := new
          END
        END
      END
    END;
    extProcAttrs[res] := pa;
    RETURN res
  END GetExtCodeIndex;

PROCEDURE <A NAME="GetProcAttr"><procedure>GetProcAttr</procedure></A>(s: CARDINAL): ProcAttr =
  BEGIN RETURN procAttrs[s] END GetProcAttr;

PROCEDURE <A NAME="GetExtProcAttr"><procedure>GetExtProcAttr</procedure></A>(s: CARDINAL): ProcAttr =
  BEGIN RETURN extProcAttrs[s] END GetExtProcAttr;
</PRE> ------------------------ STACK FRAME OPERATIONS  ------------------------ 

<P><PRE>TYPE
  CallState = RTVal.T OBJECT
    pc: PC;
    fp: CARDINAL;
    clIns: CARDINAL;
    nextAvail: CallState;
  END;
</PRE> A <CODE>CallState</CODE> encapsulates the state of the machine into an object
   that can be Push()ed onto the stack when a CALL bytecode is performed.
   The procedure <CODE>MakeCallState</CODE> must be used to create objects of this type,
   and <CODE>DisposeCallState</CODE> should be called to recycle them. 

<P><PRE>TYPE
  BytePtr = JunoMarshal.BytePtr;
  Real = JunoValue.Real;
  StackValue = RTVal.T;
</PRE> The values on the stack are of type <CODE>CallState</CODE> or one of
   the value types declared in the <CODE>RTVal</CODE> interface. 

<P><PRE>CONST
  InitialProc = 0;
  BaseFP = LAST(CARDINAL);
  NoTrapLoc = PC{InitialProc, 0};
  NoErrorCode = JunoRTError.Code.None;
</PRE> The <CODE>InitialProc</CODE> slot of the global code table is reserved by the
   run-time. The value <CODE>BaseFP</CODE> is a distinguished fp value for the base of
   the frame stack.  It must never be used for anything, and making it
   <CODE>LAST(CARDINAL)</CODE> ensures that it will cause problems if it is used.
<P>
   The value <CODE>NoErrorCode</CODE> is assigned to the <CODE>errorCode</CODE> field of an
   <CODE>ExecRes</CODE> record in the event of a non-error trap-code. 

<P><PRE>VAR
  (* state variables *)
  stackSize: CARDINAL := 10000;
  stack := NEW(REF ARRAY OF StackValue, stackSize);
  pc := PC{InitialProc, 0};		 (* program counter *)
  fp: CARDINAL := BaseFP;		 (* frame pointer (into stack) *)
  sp: CARDINAL := 0;			 (* stack pointer (into stack) *)
  ext_fp: CARDINAL;			 (* frame pointer for external proc *)
  cond: BOOLEAN;			 (* condition flag *)

VAR
  (* saved state *)
  saved_pc: PC;
  saved_fp, saved_sp: CARDINAL;
  saved_stack: REF ARRAY OF StackValue;
  saved_cond: BOOLEAN;

REVEAL
  <A NAME="Frame">Frame</A> = FramePublic BRANDED &quot;JunoRT.Frame&quot; OBJECT
    fp: CARDINAL;
    downF, upF: Frame;
  OVERRIDES
    down     := FrameDown;
    up       := FrameUp;
    getLocal := GetLocal;
    setLocal := SetLocal;
    pc       := GetPC;
    setPC    := SetPC
  END;

VAR
  topFrame: Frame;
  baseFrame: Frame;
</PRE> The <CODE>topFrame</CODE> and <CODE>baseFrame</CODE> variables are valid only after executing
   either the <CODE>ResetMachine</CODE> or <CODE>RecomputeFrames</CODE> procedure. 

<P><PRE>PROCEDURE <A NAME="FrameDown"><procedure>FrameDown</procedure></A>(f: Frame): Frame =
  BEGIN
    RETURN f.downF
  END FrameDown;

PROCEDURE <A NAME="FrameUp"><procedure>FrameUp</procedure></A>(f: Frame): Frame =
  BEGIN
    RETURN f.upF
  END FrameUp;

PROCEDURE <A NAME="GetLocal"><procedure>GetLocal</procedure></A>(f: Frame; i: INTEGER): JunoValue.T =
  BEGIN
    &lt;* ASSERT i # 0 *&gt;
    RETURN RTVal.ToJV(stack[f.fp + i])
  END GetLocal;

PROCEDURE <A NAME="SetLocal"><procedure>SetLocal</procedure></A>(f: Frame; i: INTEGER; v: JunoValue.T) =
  BEGIN
    &lt;* ASSERT i # 0 *&gt;
    stack[f.fp + i] := RTVal.FromJV(v)
  END SetLocal;

PROCEDURE <A NAME="GetPC"><procedure>GetPC</procedure></A>(f: Frame): PC =
  BEGIN
    IF f = topFrame
      THEN RETURN pc
      ELSE RETURN NARROW(stack[f.upF.fp], CallState).pc
    END
  END GetPC;

PROCEDURE <A NAME="SetPC"><procedure>SetPC</procedure></A>(f: Frame; newPC: PC) =
  BEGIN
    IF f = topFrame
      THEN pc := newPC
      ELSE NARROW(stack[f.upF.fp], CallState).pc := newPC
    END
  END SetPC;

PROCEDURE <A NAME="BaseFrame"><procedure>BaseFrame</procedure></A>(): Frame =
  BEGIN
    RETURN baseFrame
  END BaseFrame;

PROCEDURE <A NAME="TopFrame"><procedure>TopFrame</procedure></A>(): Frame =
  BEGIN
    RETURN topFrame
  END TopFrame;

PROCEDURE <A NAME="PushFrame"><procedure>PushFrame</procedure></A>(new_pc: PC; size: CARDINAL) =
  VAR st := MakeCallState(pc, fp); BEGIN
    WHILE sp + size + 1 &gt; stackSize DO EnlargeStack() END;
    &lt;* FATAL StackOverflow, PushedNIL *&gt;
    BEGIN
      FOR i := 1 TO size DO Push(RTVal.nil) END;
      Push(st)
    END;
    fp := sp - 1;
    topFrame.upF := NEW(Frame, downF := topFrame, upF := NIL, fp := fp);
    topFrame := topFrame.upF;
    pc := new_pc
  END PushFrame;

PROCEDURE <A NAME="PopFrame"><procedure>PopFrame</procedure></A>() =
</PRE><BLOCKQUOTE><EM> <CODE>PopFrame</CODE> pops the frame, but leaves any arguments on the stack, so
   that it appears to the code in the frame above that the procedure has
   genuinely returned. </EM></BLOCKQUOTE><PRE>
  VAR st: CallState := stack[fp]; BEGIN
    sp := fp;
    fp := st.fp;
    pc := st.pc;
    DisposeCallState(st);
    topFrame := topFrame.downF
  END PopFrame;

PROCEDURE <A NAME="RecomputeFrames"><procedure>RecomputeFrames</procedure></A>() =
</PRE><BLOCKQUOTE><EM> Create a new chain of stack frames corresponding to the current frames on
   the run-time stack beginning at <CODE>fp</CODE>. Set <CODE>topFrame</CODE> and <CODE>baseFrame</CODE> to
   the bottom and top stack frames, respectively. </EM></BLOCKQUOTE><PRE>
  VAR curr_fp := fp; BEGIN
    topFrame := NEW(Frame, downF := NIL, upF := NIL, fp := curr_fp);
    VAR f := topFrame; BEGIN
      WHILE curr_fp # BaseFP DO
        curr_fp := NARROW(stack[f.fp], CallState).fp;
        f.downF := NEW(Frame, upF := f, downF := NIL, fp := curr_fp);
        f := f.downF
      END;
      baseFrame := f
    END
  END RecomputeFrames;

EXCEPTION StackOverflow; PushedNIL;
</PRE> <CODE>StackOverflow</CODE> is raised in the event that pushing onto the stack would
   cause a stack overflow. <CODE>PushedNIL</CODE> is raised when the machine
   attempts to push Modula-3 <CODE>NIL</CODE> onto the stack. This indicates the use of
   an uninitialized variable, since unhinted variables are initialized to
   Modula-3 <CODE>NIL</CODE> by the <CODE>PUSHM3NIL</CODE> instruction at the start of every
   procedure. 

<P><PRE>PROCEDURE <A NAME="Push"><procedure>Push</procedure></A>(v: StackValue) RAISES { StackOverflow, PushedNIL } =
  BEGIN
    IF v = NIL THEN RAISE PushedNIL END;
    IF sp = stackSize THEN RAISE StackOverflow END;
    stack[sp] := v;
    INC(sp)
  END Push;

PROCEDURE <A NAME="Pop"><procedure>Pop</procedure></A>(): StackValue =
  BEGIN
    DEC(sp);
    RETURN stack[sp]
  END Pop;

PROCEDURE <A NAME="PopNum"><procedure>PopNum</procedure></A>(VAR (*INOUT*) err: BOOLEAN): RTVal.Real =
  BEGIN
    DEC(sp);
    TYPECASE stack[sp] OF
      NULL =&gt; (* SKIP *)
    | RTVal.Number (r) =&gt; RETURN r.val
    ELSE (* SKIP *)
    END;
    err := TRUE;
    RETURN 0.0
  END PopNum;

PROCEDURE <A NAME="PopText"><procedure>PopText</procedure></A>(VAR (*INOUT*) err: BOOLEAN): TEXT =
  BEGIN
    DEC(sp);
    TYPECASE stack[sp] OF
      NULL =&gt; (* SKIP *)
    | RTVal.Text (r)  =&gt; RETURN r.val
    ELSE (* SKIP *)
    END;
    err := TRUE;
    RETURN NIL
  END PopText;

PROCEDURE <A NAME="PopPair"><procedure>PopPair</procedure></A>(VAR (*INOUT*) err: BOOLEAN): RTVal.Pair =
  BEGIN
    DEC(sp);
    TYPECASE stack[sp] OF
      NULL =&gt; (* SKIP *)
    | RTVal.Pair (r)  =&gt; RETURN r
    ELSE (* SKIP *)
    END;
    err := TRUE;
    RETURN NIL
  END PopPair;

PROCEDURE <A NAME="InsertList"><procedure>InsertList</procedure></A>(l: RTVal.T; lSz, numBelow: CARDINAL)
  RAISES {StackOverflow} =
</PRE><BLOCKQUOTE><EM> Insert the <CODE>lSz</CODE> values of <CODE>l</CODE> onto the stack in order under the top
   <CODE>numBelow</CODE> elements. </EM></BLOCKQUOTE><PRE>
  VAR oldSp := sp; BEGIN
    IF sp + lSz &gt;= stackSize THEN RAISE StackOverflow END;
    INC(sp, lSz);
    SUBARRAY(stack^, sp - numBelow, numBelow) :=
      SUBARRAY(stack^, oldSp - numBelow, numBelow);
    VAR i := oldSp - numBelow; BEGIN
      WHILE l # RTVal.nil DO
      	VAR pr: RTVal.Pair := l; BEGIN
      	  stack[i] := pr.car;
      	  l := pr.cdr
      	END;
        INC(i)
      END
    END
  END InsertList;

PROCEDURE <A NAME="PopList"><procedure>PopList</procedure></A>(n: CARDINAL): RTVal.T =
</PRE><BLOCKQUOTE><EM> Pop and return the list of the top <CODE>n</CODE> elements of the stack, where the
   top of the stack becomes the last element of the list. </EM></BLOCKQUOTE><PRE>
  VAR
    res: RTVal.T := RTVal.nil;
  BEGIN
    FOR i := 1 TO n DO
      res := RTVal.FromPair(Pop(), res)
    END;
    RETURN res
  END PopList;
</PRE> The operations in the JunoArgs interface: 

<P><PRE>PROCEDURE <A NAME="ReadValue"><procedure>ReadValue</procedure></A>(i: CARDINAL): RTVal.T =
  BEGIN RETURN stack[ext_fp - i] END ReadValue;

PROCEDURE <A NAME="ReadInt"><procedure>ReadInt</procedure></A>(i: CARDINAL; VAR err: BOOLEAN): INTEGER =
  BEGIN
    TYPECASE stack[ext_fp - i] OF
      NULL =&gt; (* SKIP *)
    | RTVal.Number (n) =&gt; RETURN ROUND(n.val)
    ELSE (* SKIP *)
    END;
    err := TRUE;
    RETURN 0
  END ReadInt;

PROCEDURE <A NAME="ReadReal"><procedure>ReadReal</procedure></A>(i: CARDINAL; VAR err: BOOLEAN): JunoValue.Real =
  BEGIN
    TYPECASE stack[ext_fp - i] OF
      NULL =&gt; (* SKIP *)
    | RTVal.Number (n) =&gt; RETURN n.val
    ELSE (* SKIP *)
    END;
    err := TRUE;
    RETURN 0.0
  END ReadReal;

PROCEDURE <A NAME="ReadText"><procedure>ReadText</procedure></A>(i: CARDINAL; VAR err: BOOLEAN): TEXT =
  BEGIN
    TYPECASE stack[ext_fp - i] OF
      NULL =&gt; (* SKIP *)
    | RTVal.Text (t) =&gt; RETURN t.val
    ELSE (* SKIP *)
    END;
    err := TRUE;
    RETURN NIL
  END ReadText;

PROCEDURE <A NAME="ReadPair"><procedure>ReadPair</procedure></A>(i: CARDINAL; VAR err: BOOLEAN): RTVal.Pair =
  BEGIN
    TYPECASE stack[ext_fp - i] OF
      NULL =&gt; (* SKIP *)
    | RTVal.Pair (p) =&gt; RETURN p
    ELSE (* SKIP *)
    END;
    err := TRUE;
    RETURN NIL
  END ReadPair;

PROCEDURE <A NAME="WriteValue"><procedure>WriteValue</procedure></A>(i: CARDINAL; val: RTVal.T) =
  BEGIN stack[ext_fp - i] := val END WriteValue;

PROCEDURE <A NAME="WriteInt"><procedure>WriteInt</procedure></A>(i: CARDINAL; int: INTEGER) =
  BEGIN stack[ext_fp - i] := RTVal.FromInt(int) END WriteInt;

PROCEDURE <A NAME="WriteReal"><procedure>WriteReal</procedure></A>(i: CARDINAL; r: JunoValue.Real) =
  BEGIN stack[ext_fp - i] := RTVal.FromReal(r) END WriteReal;

PROCEDURE <A NAME="WriteText"><procedure>WriteText</procedure></A>(i: CARDINAL; t: TEXT) =
  BEGIN stack[ext_fp - i] := RTVal.FromText(t) END WriteText;

PROCEDURE <A NAME="PushValue"><procedure>PushValue</procedure></A>(v: RTVal.T) =
  &lt;* FATAL StackOverflow, PushedNIL *&gt;
  BEGIN Push(v) END PushValue;
</PRE> --------------------------- MACHINE STATE ------------------------------- 

<P><PRE>VAR (* CONST *)
  emptyFrame := NEW(Frame, downF := NIL, upF := NIL, fp := BaseFP);

PROCEDURE <A NAME="ResetMachine"><procedure>ResetMachine</procedure></A>() =
  BEGIN
    sp := 0;
    fp := BaseFP;
    pc := PC{InitialProc, 0};
    baseFrame := emptyFrame;
    topFrame := baseFrame
  END ResetMachine;

PROCEDURE <A NAME="Save"><procedure>Save</procedure></A>() =
  BEGIN
    saved_fp := fp;
    saved_sp := sp;
    saved_cond := cond;
    saved_pc := pc;
    saved_stack := NEW(REF ARRAY OF StackValue, NUMBER(stack^));
    saved_stack^ := stack^
  END Save;

PROCEDURE <A NAME="Restore"><procedure>Restore</procedure></A>() =
  BEGIN
    fp := saved_fp;
    sp := saved_sp;
    cond := saved_cond;
    pc := saved_pc;
    stack := NEW(REF ARRAY OF StackValue, NUMBER(saved_stack^));
    stack^ := saved_stack^
  END Restore;

PROCEDURE <A NAME="GetStackSize"><procedure>GetStackSize</procedure></A>(): CARDINAL =
  BEGIN
    RETURN stackSize
  END GetStackSize;

PROCEDURE <A NAME="EnlargeStack"><procedure>EnlargeStack</procedure></A>() =
  VAR newStack := NEW(REF ARRAY OF StackValue, NUMBER(stack^) * 2); BEGIN
    SUBARRAY(newStack^, 0, NUMBER(stack^)) := stack^;
    stack := newStack;
    stackSize := NUMBER(stack^)
  END EnlargeStack;
</PRE> -------------------------------- EXEC ----------------------------------- 

<P><PRE>TYPE
  Point = RECORD x, y: Real END;
  Segment = RECORD a, b: Point END;

PROCEDURE <A NAME="ExtractSegment"><procedure>ExtractSegment</procedure></A>(seg: RTVal.T; VAR (* OUT *) out: Segment):
    BOOLEAN =
</PRE><BLOCKQUOTE><EM> If <CODE>seg</CODE> is a pair of points, then set <CODE>out</CODE> to contain the four
   coordinates and return <CODE>FALSE</CODE>. Otherwise, return <CODE>TRUE</CODE>. </EM></BLOCKQUOTE><PRE>
  BEGIN
    TYPECASE seg OF
    | NULL =&gt; RETURN TRUE
    | RTVal.Pair (p) =&gt;
        IF ExtractPoint(p.car, out.a) THEN RETURN TRUE END;
        IF ExtractPoint(p.cdr, out.b) THEN RETURN TRUE END;
    ELSE RETURN TRUE
    END;
    RETURN FALSE
  END ExtractSegment;

PROCEDURE <A NAME="ExtractPoint"><procedure>ExtractPoint</procedure></A>(pt: RTVal.T; VAR (* OUT *) out: Point): BOOLEAN =
</PRE><BLOCKQUOTE><EM> If <CODE>pt</CODE> is a pair of real numbers, then set <CODE>out</CODE> to contain its
   coordinates and return <CODE>FALSE</CODE>. Otherwise, return <CODE>TRUE</CODE>. </EM></BLOCKQUOTE><PRE>
  BEGIN
    TYPECASE pt OF
    | NULL =&gt; RETURN TRUE
    | RTVal.Pair (p) =&gt;
        IF ExtractReal(p.car, out.x) THEN RETURN TRUE END;
        IF ExtractReal(p.cdr, out.y) THEN RETURN TRUE END;
    ELSE RETURN TRUE
    END;
    RETURN FALSE
  END ExtractPoint;

PROCEDURE <A NAME="ExtractReal"><procedure>ExtractReal</procedure></A>(r: RTVal.T; VAR (* OUT *) out: Real): BOOLEAN =
</PRE><BLOCKQUOTE><EM> If <CODE>r</CODE> is a number, set <CODE>out</CODE> to its value and return <CODE>FALSE</CODE>. Otherwise,
   return <CODE>TRUE</CODE>. </EM></BLOCKQUOTE><PRE>
  BEGIN
    TYPECASE r OF
    | NULL =&gt; RETURN TRUE
    | RTVal.Number (v) =&gt; out := v.val
    ELSE RETURN TRUE
    END;
    RETURN FALSE
  END ExtractReal;

PROCEDURE <A NAME="AppendClosure"><procedure>AppendClosure</procedure></A>(l1, l2: RTVal.T): RTVal.T =
</PRE><BLOCKQUOTE><EM> Return the result of appending the list <CODE>l2</CODE> to the end of the closure <CODE>l1</CODE>,
   or NIL if <CODE>l1</CODE> is not a list. </EM></BLOCKQUOTE><PRE>
  BEGIN
    IF ListLen(l1) = -1
      THEN RETURN NIL
      ELSE RETURN Append(l1, l2)
    END
  END AppendClosure;

PROCEDURE <A NAME="ListLen"><procedure>ListLen</procedure></A>(t: RTVal.T): INTEGER =
</PRE><BLOCKQUOTE><EM> Returns the length of the list <CODE>t</CODE>, or -1 if <CODE>t</CODE> is not a list. </EM></BLOCKQUOTE><PRE>
  VAR res := 0; BEGIN
    LOOP
      TYPECASE t OF
      | NULL =&gt; EXIT
      | RTVal.Pair (p) =&gt;
        INC(res);
        t := p.cdr
      ELSE EXIT
      END
    END;
    IF t = RTVal.nil
      THEN RETURN res
      ELSE RETURN -1
    END
  END ListLen;

PROCEDURE <A NAME="Append"><procedure>Append</procedure></A>(l1, l2: RTVal.T): RTVal.T =
</PRE><BLOCKQUOTE><EM> Requires <CODE>l1</CODE> and <CODE>l2</CODE> to be lists; returns the result of appending them. </EM></BLOCKQUOTE><PRE>
  BEGIN
    TYPECASE l1 OF &lt;* NOWARN *&gt;
      RTVal.Null =&gt; RETURN l2
    | RTVal.Pair (p) =&gt;
        RETURN RTVal.FromPair(p.car, Append(p.cdr, l2))
    END
  END Append;

VAR
  machine := NEW(MUTEX);
  isRunning := FALSE;
  intPending := FALSE;
  intSeen := NEW(Thread.Condition);

PROCEDURE <A NAME="Interrupt"><procedure>Interrupt</procedure></A>() =
</PRE><BLOCKQUOTE><EM> Send an interrupt; block until the machine signals that the interrupt has
   been seen. </EM></BLOCKQUOTE><PRE>
  BEGIN
    LOCK machine DO
      IF NOT isRunning THEN RETURN END;
      intPending := TRUE;
      WHILE intPending DO Thread.Wait(machine, intSeen) END
    END
  END Interrupt;

VAR instrCount: INTEGER;

PROCEDURE <A NAME="EtpLogExecStep"><procedure>EtpLogExecStep</procedure></A>(&lt;*UNUSED*&gt; bc: ByteCode) =
  BEGIN END EtpLogExecStep;

PROCEDURE <A NAME="EtpLogExecInstrCount"><procedure>EtpLogExecInstrCount</procedure></A>(&lt;*UNUSED*&gt; cnt: INTEGER) =
  BEGIN END EtpLogExecInstrCount;

PROCEDURE <A NAME="Exec"><procedure>Exec</procedure></A>(): ExecRes =
  VAR
    a: BytePtr := ADR(code_tbl[pc.proc][pc.offset]);
    bc: ByteCode;
    offset: JunoMarshal.Short;
    index, extSlot: CARDINAL;
    a_init: BytePtr;
    (* &quot;a_init&quot; always contains the value &quot;a&quot; had at the beginning of the
       instruction, so that the instruction can be restarted in case of a
       stack overflow.  See the &quot;EXCEPT&quot; clause below. *)
    a_ut: BytePtr;
    (* &quot;a_ut&quot; is the address of the most recent instruction that branches
       to its offset because one of its argument is an undefined term *)

  PROCEDURE HandleError(ec: JunoRTError.Code): ExecRes =
  (* Return a &quot;ExecRes&quot; in the &quot;TrapCode.Error&quot; case with error code &quot;ec&quot;. On
     entry to this routine, &quot;a&quot; should be pointing to the first byte of the
     instruction just after the one causing the error. *)
    VAR startLoc := ADR(code_tbl[pc.proc][0]); eLoc: PC; BEGIN
      pc.offset := a - startLoc;
      IF ec = JunoRTError.Code.UndefTerm
        THEN eLoc := PC{pc.proc, a_ut - startLoc}
        ELSE eLoc := PC{pc.proc, a_init - startLoc}
      END;
      RecomputeFrames();
      RETURN ExecRes{TrapCode.Error, eLoc, extSlot, ec}
    END HandleError;

  PROCEDURE HandleIntr(): ExecRes =
  &lt;* SPEC machine IN LL *&gt;
    BEGIN
      intPending := FALSE;
      Thread.Broadcast(intSeen);
      pc.offset := a - ADR(code_tbl[pc.proc][0]);
      RecomputeFrames();
      RETURN ExecRes{TrapCode.Interrupt, pc, extSlot, NoErrorCode}
    END HandleIntr;

  PROCEDURE MkName(m, n: Atom.T): TEXT =
    VAR res := Atom.ToText(n); BEGIN
      IF m # NIL THEN res := Atom.ToText(m) &amp; &quot;.&quot; &amp; res END;
      RETURN res
    END MkName;

  PROCEDURE MakeClosure(s: INTEGER) RAISES {StackOverflow}=
  (* Push an empty closure for slot &quot;s&quot; *)
    &lt;* FATAL PushedNIL *&gt;
    VAR nm: TEXT; BEGIN
      IF s &gt; 0
        THEN nm := MkName(procAttrs[s].modName, procAttrs[s].name)
        ELSE nm := MkName(extProcAttrs[-s].modName, extProcAttrs[-s].name)
      END;
      Push(RTVal.FromPair(
        RTVal.FromPair(RTVal.FromText(nm), RTVal.FromInt(s)),
        RTVal.nil))
    END MakeClosure;

  PROCEDURE DoCall(slot: CARDINAL) RAISES {StackOverflow} =
    &lt;* FATAL PushedNIL *&gt;
    VAR
      firstaddr := ADR(code_tbl[pc.proc][0]);
      iS := MakeCallState(
        pc := PC{proc := pc.proc, offset := a - firstaddr},
        fp := fp);
    BEGIN
      Push(iS);
      fp := sp - 1;   (* Do this here in case &quot;Push&quot; fails *)
      pc.proc := slot;
      pc.offset := 0;
      a := ADR(code_tbl[slot][0]);
      WITH sig = procAttrs[slot].sig DO
        IF sig.outs = 0 AND sig.inouts = 0 THEN
          RTVal.Mark()
        END
      END
    END DoCall;

  PROCEDURE DoExtCall(slot: CARDINAL) =
    BEGIN
      ext_fp := sp;
      extSlot := slot;
      cond := ext_code_tbl[slot].invoke();
    END DoExtCall;

  (* Exec *)
  BEGIN
   instrCount := 0;
   LOCK machine DO
     &lt;* ASSERT NOT isRunning *&gt;
     isRunning := TRUE
   END;
   TRY
    IF pc.proc = InitialProc THEN
      RecomputeFrames();
      RETURN ExecRes{TrapCode.NormalHalt, NoTrapLoc, 0, NoErrorCode}
    END;
    TRY
      LOOP
        a_init := a;
        bc := a^;
        INC(a);
        EtpLogExecStep(bc); INC(instrCount);
        CASE bc OF
        | BC.PUSHL =&gt;
            offset := JunoMarshal.ReadShort(a);
            Push(stack[fp + offset])
        | BC.POPL =&gt;
            offset := JunoMarshal.ReadShort(a);
            stack[fp + offset] := Pop()
        | BC.PUSHG =&gt;
            index := JunoMarshal.ReadULong(a);
            Push(RTVal.FromJV(value_tbl[index]))
        | BC.POPG =&gt;
            index := JunoMarshal.ReadULong(a);
            value_tbl[index] := RTVal.ToJV(Pop())
        | BC.INCSP =&gt;
            IF sp + a^ &gt;= stackSize THEN RAISE StackOverflow END;
            INC(sp, a^);
            INC(a)
        | BC.DECSP =&gt;
            DEC(sp, a^); INC(a)
        | BC.PUSHM3NIL =&gt;
            IF sp + a^ &gt;= stackSize THEN RAISE StackOverflow END;
            FOR i := 1 TO a^ DO stack[sp] := NIL; INC(sp) END;
            INC(a)
        | BC.PUSHNIL =&gt;
            Push(RTVal.nil)
        | BC.PUSHNUM =&gt;
            Push(RTVal.FromReal(JunoMarshal.ReadReal(a)))
        | BC.C_OFF =&gt;
            cond := FALSE
        | BC.C_ON =&gt;
            cond := TRUE
        | BC.JUMP =&gt;
            offset := JunoMarshal.ReadShort(a);
            IF offset &lt;= 0 THEN
              LOCK machine DO
                IF intPending THEN RETURN HandleIntr() END
              END
            END;
            INC(a, offset)
        | BC.TJUMP =&gt;
            offset := JunoMarshal.ReadShort(a);
            IF cond THEN INC(a, offset) END
        | BC.FJUMP =&gt;
            offset := JunoMarshal.ReadShort(a);
            IF NOT cond THEN INC(a, offset) END
        | BC.UJUMP =&gt;
            offset := JunoMarshal.ReadShort(a);
            IF NOT cond THEN
              DEC(sp);			 (* skip past single OUT parameter *)
              a_ut := a_init;		 (* set &quot;undef term&quot; address *)
              INC(a, offset)
            END
        | BC.CALL =&gt;
            LOCK machine DO
              IF intPending THEN
                RETURN HandleIntr()
              END
            END;
            DoCall(JunoMarshal.ReadULong(a))
        | BC.CALLEXT =&gt;
            DEC(instrCount);
            DoExtCall(JunoMarshal.ReadULong(a));
            IF NOT cond THEN
              RETURN HandleError(JunoRTError.Code.FailedExtProc)
            END
        | BC.RET =&gt;
            WITH sig = procAttrs[pc.proc].sig DO
              IF sig.outs = 0 AND sig.inouts = 0 THEN
                RTVal.Dispose()
              END
            END;
            sp := fp + 1;
            VAR s: CallState := Pop(); BEGIN
              pc := s.pc;
              fp := s.fp;
              DisposeCallState(s)
            END;
            IF pc.proc = InitialProc THEN
              RecomputeFrames();
              RETURN ExecRes{TrapCode.NormalHalt, NoTrapLoc, 0, NoErrorCode}
            END;
            a := ADR(code_tbl[pc.proc][pc.offset])
        | BC.ERROR =&gt;
            VAR ec := a^; BEGIN
              INC(a); RETURN HandleError(VAL(ec, JunoRTError.Code))
            END
        | BC.FERROR =&gt;
            IF cond THEN INC(a) ELSE
              VAR ec := a^; BEGIN
                INC(a); RETURN HandleError(VAL(ec, JunoRTError.Code))
              END
            END
        | BC.ADD =&gt;
            offset := JunoMarshal.ReadShort(a);
            VAR err := FALSE; t2, t1 := PopNum(err); BEGIN
              IF NOT err
                THEN Push(RTVal.FromReal(t1 + t2))
                ELSE a_ut := a_init; INC(a, offset)
              END
            END
        | BC.SUBTRACT =&gt;
            offset := JunoMarshal.ReadShort(a);
            VAR err := FALSE; t2, t1 := PopNum(err); BEGIN
              IF NOT err
                THEN Push(RTVal.FromReal(t1 - t2))
                ELSE a_ut := a_init; INC(a, offset)
              END
            END
        | BC.MULTIPLY =&gt;
            offset := JunoMarshal.ReadShort(a);
            VAR err := FALSE; t2, t1 := PopNum(err); BEGIN
              IF NOT err
                THEN Push(RTVal.FromReal(t1 * t2))
                ELSE a_ut := a_init; INC(a, offset)
              END
            END
        | BC.DIVIDE =&gt;
            offset := JunoMarshal.ReadShort(a);
            VAR err := FALSE; t2, t1 := PopNum(err); BEGIN
              IF NOT err AND t2 # 0.0
                THEN Push(RTVal.FromReal(t1 / t2))
                ELSE a_ut := a_init; INC(a, offset)
              END
            END
        | BC.DIV_ =&gt;
            offset := JunoMarshal.ReadShort(a);
            VAR err := FALSE; t2, t1 := PopNum(err); BEGIN
              IF NOT err AND t2 # 0.0
                THEN Push(RTVal.FromInt(FLOOR(t1 / t2)))
                ELSE a_ut := a_init; INC(a, offset)
              END
            END
        | BC.MOD_ =&gt;
            offset := JunoMarshal.ReadShort(a);
            VAR err := FALSE; t2, t1 := PopNum(err); BEGIN
              IF NOT err AND t2 # 0.0
                THEN Push(RTVal.FromReal(t1 MOD t2))
                ELSE a_ut := a_init; INC(a, offset)
              END
            END
        | BC.NEGATE =&gt;
            offset := JunoMarshal.ReadShort(a);
            VAR err := FALSE; t1 := PopNum(err); BEGIN
              IF NOT err
                THEN Push(RTVal.FromReal(-t1))
                ELSE a_ut := a_init; INC(a, offset)
              END
            END
        | BC.ABS_ =&gt;
            offset := JunoMarshal.ReadShort(a);
            VAR err := FALSE; t1 := PopNum(err); BEGIN
              IF NOT err
                THEN Push(RTVal.FromReal(ABS(t1)))
                ELSE a_ut := a_init; INC(a, offset)
              END
            END
        | BC.FLOOR_ =&gt;
            offset := JunoMarshal.ReadShort(a);
            VAR err := FALSE; t1 := PopNum(err); BEGIN
              IF NOT err
                THEN Push(RTVal.FromInt(FLOOR(t1)))
                ELSE a_ut := a_init; INC(a, offset)
              END
            END
        | BC.CEILING_ =&gt;
            offset := JunoMarshal.ReadShort(a);
            VAR err := FALSE; t1 := PopNum(err); BEGIN
              IF NOT err
                THEN Push(RTVal.FromInt(CEILING(t1)))
                ELSE a_ut := a_init; INC(a, offset)
              END
            END
        | BC.ROUND_ =&gt;
            offset := JunoMarshal.ReadShort(a);
            VAR err := FALSE; t1 := PopNum(err); BEGIN
              IF NOT err
                THEN Push(RTVal.FromInt(ROUND(t1)))
                ELSE a_ut := a_init; INC(a, offset)
              END
            END
        | BC.MAX_ =&gt;
            offset := JunoMarshal.ReadShort(a);
            VAR err := FALSE; t2, t1 := PopNum(err); BEGIN
              IF NOT err
                THEN Push(RTVal.FromReal(MAX(t1, t2)))
                ELSE a_ut := a_init; INC(a, offset)
              END
            END
        | BC.MIN_ =&gt;
            offset := JunoMarshal.ReadShort(a);
            VAR err := FALSE; t2, t1 := PopNum(err); BEGIN
              IF NOT err
                THEN Push(RTVal.FromReal(MIN(t1, t2)))
                ELSE a_ut := a_init; INC(a, offset)
              END
            END
        | BC.ATAN =&gt;
            offset := JunoMarshal.ReadShort(a);
            VAR err := FALSE; t2, t1 := PopNum(err); BEGIN
              IF NOT err
                THEN Push(RTVal.FromReal(JunoValue.Atan(t1, t2)))
                ELSE a_ut := a_init; INC(a, offset)
              END
            END
        | BC.SIN =&gt;
            offset := JunoMarshal.ReadShort(a);
            VAR err := FALSE; t1 := PopNum(err); BEGIN
              IF NOT err
                THEN Push(RTVal.FromReal(JunoValue.Sin(t1)))
                ELSE a_ut := a_init; INC(a, offset)
              END
            END
        | BC.COS =&gt;
            offset := JunoMarshal.ReadShort(a);
            VAR err := FALSE; t1 := PopNum(err); BEGIN
              IF NOT err
                THEN Push(RTVal.FromReal(JunoValue.Cos(t1)))
                ELSE a_ut := a_init; INC(a, offset)
              END
            END
        | BC.LN =&gt;
            offset := JunoMarshal.ReadShort(a);
            VAR err := FALSE; t1 := PopNum(err); BEGIN
              IF NOT err
                THEN Push(RTVal.FromReal(JunoValue.Ln(t1)))
                ELSE a_ut := a_init; INC(a, offset)
              END
            END
        | BC.EXP =&gt;
            offset := JunoMarshal.ReadShort(a);
            VAR err := FALSE; t1 := PopNum(err); BEGIN
              IF NOT err
                THEN Push(RTVal.FromReal(JunoValue.Exp(t1)))
                ELSE a_ut := a_init; INC(a, offset)
              END
            END
        | BC.REL =&gt;           (* Evaluate (x, y) REL ((ax, ay), (bx, by)) *)
            offset := JunoMarshal.ReadShort(a);
            VAR t2, t1 := Pop(); p: Point; s: Segment; BEGIN
              IF ExtractPoint(t1, p) OR ExtractSegment(t2, s) THEN
                a_ut := a_init;
                INC(a, offset)
              ELSE
                WITH a = s.a, b = s.b DO
                  Push(RTVal.FromPair(
                    RTVal.FromReal(a.x + (b.x-a.x)*p.x - (b.y-a.y)*p.y),
                    RTVal.FromReal(a.y + (b.x-a.x)*p.y + (b.y-a.y)*p.x)))
                END
              END
            END
        | BC.CAR =&gt;
            offset := JunoMarshal.ReadShort(a);
            VAR err := FALSE; pr := PopPair(err); BEGIN
              IF NOT err
                THEN Push(pr.car)
                ELSE a_ut := a_init; INC(a, offset)
              END
            END
        | BC.CDR =&gt;
            offset := JunoMarshal.ReadShort(a);
            VAR err := FALSE; pr := PopPair(err); BEGIN
              IF NOT err
                THEN Push(pr.cdr)
                ELSE a_ut := a_init; INC(a, offset)
              END
            END
        | BC.CAR_CDR =&gt;
            offset := JunoMarshal.ReadShort(a);
            (* This is the only place we test &quot;sp&quot; because this is the
               only bytecode that pops stuff off the stack and pushes
               even more stuff back *)
            IF sp = stackSize THEN
              VAR err := FALSE; pr := PopPair(err); BEGIN
            	IF NOT err
            	  THEN Push(pr.cdr); Push(pr.car)
            	  ELSE a_ut := a_init; INC(a, offset)
            	END
              END
            ELSE
              RAISE StackOverflow
            END
        | BC.CONS =&gt;
            VAR t2, t1 := Pop(); BEGIN
              Push(RTVal.FromPair(t1, t2))
            END
        | BC.LIST =&gt;
            Push(PopList(JunoMarshal.ReadUShort(a)))
        | BC.CONCAT =&gt;
            offset := JunoMarshal.ReadShort(a);
            VAR err := FALSE; t2, t1 := PopText(err); BEGIN
              IF NOT err
                THEN Push(RTVal.FromText(t1 &amp; t2))
                ELSE a_ut := a_init; INC(a, offset)
              END
            END
        | BC.IS_REAL =&gt;
            VAR t := stack[sp - 1]; BEGIN
              cond := t # NIL AND ISTYPE(t, RTVal.Number)
            END
        | BC.IS_INT =&gt;
            TYPECASE stack[sp - 1] OF
              NULL =&gt; cond := FALSE
            | RTVal.Number (n) =&gt; cond := (n.val = FLOAT(ROUND(n.val)))
            ELSE cond := FALSE
            END
        | BC.IS_TEXT =&gt;
            VAR t := stack[sp - 1]; BEGIN
              cond := t # NIL AND ISTYPE(t, RTVal.Text)
            END
        | BC.IS_PAIR =&gt;
            VAR t := stack[sp - 1]; BEGIN
              cond := t # NIL AND ISTYPE(t, RTVal.Pair)
            END
        | BC.EQUAL =&gt;
            VAR t2, t1 := Pop(); BEGIN
              cond := RTVal.Equal(t1, t2)
            END
        | BC.LESS =&gt;
            VAR err := FALSE; t2, t1 := PopNum(err); BEGIN
              cond := (NOT err) AND (t1 &lt; t2)
            END
        | BC.AT_MOST =&gt;
            VAR err := FALSE; t2, t1 := PopNum(err); BEGIN
              cond := (NOT err) AND (t1 &lt;= t2)
            END
        | BC.CONG =&gt;
            VAR t2, t1 := Pop(); s1, s2: Segment; BEGIN
              IF ExtractSegment(t1, s1) OR ExtractSegment(t2, s2) THEN
                cond := FALSE
              ELSE
                PROCEDURE LenSq(READONLY s: Segment): Real =
                  VAR dx := s.b.x - s.a.x; dy := s.b.y - s.a.y; BEGIN
                    RETURN dx * dx + dy * dy
                  END LenSq;
                CONST Epsilon = 2.0E-3;
                VAR len1 := LenSq(s1); len2 := LenSq(s2); BEGIN
                  cond := ABS(len2 - len1) &lt; Epsilon
                END
              END
            END
        | BC.PARA =&gt;
            VAR t2, t1 := Pop(); s1, s2: Segment; BEGIN
              IF ExtractSegment(t1, s1) OR ExtractSegment(t2, s2) THEN
                cond := FALSE
              ELSE
                CONST Epsilon = 1.0E-4;
                VAR
                  dx1 := s1.b.x - s1.a.x; dy1 := s1.b.y - s1.a.y;
                  dx2 := s2.b.x - s2.a.x; dy2 := s2.b.y - s2.a.y;
                BEGIN
                  cond := ABS(dx2 * dy1 - dx1 * dy2) &lt; Epsilon
                END
              END
            END
        | BC.HOR =&gt;
            VAR t2, t1 := Pop(); p1, p2: Point; BEGIN
              IF ExtractPoint(t1, p1) OR ExtractPoint(t2, p2)
                THEN cond := FALSE
                ELSE cond := p1.y = p2.y
              END
            END
        | BC.VER =&gt;
            VAR t2, t1 := Pop(); p1, p2: Point; BEGIN
              IF ExtractPoint(t1, p1) OR ExtractPoint(t2, p2)
                THEN cond := FALSE
                ELSE cond := p1.x = p2.x
              END
            END
        | BC.NEWCL =&gt;    MakeClosure(JunoMarshal.ReadULong(a))
        | BC.NEWEXTCL =&gt; MakeClosure(-JunoMarshal.ReadULong(a))
        | BC.CLOSE =&gt;
            VAR
              l := PopList(JunoMarshal.ReadUShort(a));
              cl := Pop();
              offset := JunoMarshal.ReadShort(a);
            BEGIN
              cl := AppendClosure(cl, l);
              IF cl # NIL
                THEN Push(cl)
                ELSE a_ut := a_init; INC(a, offset)
              END
            END
        | BC.APPLY =&gt;
            VAR
              outs := JunoMarshal.ReadUShort(a);
              inouts := JunoMarshal.ReadUShort(a);
              ins := JunoMarshal.ReadUShort(a);
              offset := JunoMarshal.ReadShort(a);
              clRec := UnpackClosure(Pop());
            BEGIN
              IF clRec.valid AND ins + clRec.argsLen = clRec.sig.ins
                 AND outs = clRec.sig.outs AND inouts = clRec.sig.inouts THEN
                NARROW(stack[fp], CallState).clIns := clRec.argsLen;
                InsertList(clRec.args, clRec.argsLen, ins);
                IF clRec.slot &gt; 0 THEN
                  DoCall(clRec.slot)
                ELSE
                  DoExtCall(-clRec.slot);
                  IF NOT cond THEN
                    RETURN HandleError(JunoRTError.Code.FailedExtProc)
                  END
                END
              ELSE
                a_ut := a_init;
                INC(a, offset)
              END
            END
        | BC.CLDECSP =&gt;
            DEC(sp, NARROW(stack[fp], CallState).clIns)
        | BC.SOLVE =&gt;
            DEC(instrCount);
            DoSolve(a)
        ELSE
            Wr.PutText(stderr, &quot;Fatal error in JunoRT.Exec:\n&quot;);
            Wr.PutText(stderr, &quot;  Unknown byte code &quot; &amp; Fmt.Int(bc) &amp; &quot;\n&quot;);
            pc.offset := a_init - ADR(code_tbl[pc.proc][0]);
            Wr.PutText(stderr, &quot;  PC = [&quot; &amp; PCToProcName(pc)
              &amp; &quot;, &quot; &amp; Fmt.Int(pc.offset) &amp; &quot;]\n\n&quot;);
            Wr.PutText(stderr, &quot;Procedure disassembly:\n&quot;);
            Wr.Flush(stderr);
            JunoDisassem.P(code_tbl[pc.proc], stderr);
            Wr.Flush(stderr);
            &lt;* ASSERT FALSE *&gt;
        END
      END
    EXCEPT
    | StackOverflow =&gt;
        pc.offset := a_init - ADR(code_tbl[pc.proc][0]);
        RecomputeFrames();
        RETURN ExecRes{TrapCode.StackOverflow, pc, 0, NoErrorCode}
    | PushedNIL =&gt;
        RETURN HandleError(JunoRTError.Code.UsedUninitialized)
    END
   FINALLY
    LOCK machine DO
      isRunning := FALSE
    END;
    EtpLogExecInstrCount(instrCount);
    RTVal.Dispose()
   END
  END Exec;

TYPE
  ClosureRec = RECORD
    valid: BOOLEAN;
    slot: INTEGER;
    args: JunoValue.T;
    argsLen: CARDINAL;
    sig: Sig;
  END;

PROCEDURE <A NAME="UnpackClosure"><procedure>UnpackClosure</procedure></A>(cl: RTVal.T): ClosureRec =
  VAR res: ClosureRec; BEGIN
    TYPECASE cl OF RTVal.Pair (p) =&gt;
      TYPECASE p.car OF RTVal.Pair (q) =&gt;
        TYPECASE q.cdr OF RTVal.Number (s) =&gt;
          res.slot := ROUND(s.val);
          IF (res.slot &gt; 0 AND res.slot &lt; next_code_idx) THEN
            res.sig := procAttrs[res.slot].sig
          ELSIF res.slot &lt;= 0 AND -res.slot &lt; next_ext_idx THEN
            res.sig := extProcAttrs[-res.slot].sig
          ELSE
            res.valid := FALSE; RETURN res
          END;
          res.argsLen := ListLen(p.cdr);
          IF res.argsLen &gt;= 0 THEN
            res.args := p.cdr;
            res.valid := TRUE;
            RETURN res
          END
        ELSE (*SKIP*)
        END
      ELSE (*SKIP*)
      END
    ELSE (*SKIP*)
    END;
    res.valid := FALSE;
    RETURN res
  END UnpackClosure;

PROCEDURE <A NAME="ExecFromSlot"><procedure>ExecFromSlot</procedure></A>(slot: CARDINAL; reset := TRUE): ExecRes =
  BEGIN
    IF reset THEN ResetMachine() END;
    PushFrame(PC{slot, 0}, size := 0);
    RETURN Exec()
  END ExecFromSlot;

PROCEDURE <A NAME="AttrsToProcName"><procedure>AttrsToProcName</procedure></A>(READONLY p: ProcAttr): TEXT =
  VAR res := Atom.ToText(p.name); BEGIN
    IF p.modName # NIL THEN res := Atom.ToText(p.modName) &amp; &quot;.&quot; &amp; res END;
    RETURN res
  END AttrsToProcName;

PROCEDURE <A NAME="PCToProcName"><procedure>PCToProcName</procedure></A>(READONLY pc: PC): TEXT =
  BEGIN RETURN AttrsToProcName(procAttrs[pc.proc]) END PCToProcName;

PROCEDURE <A NAME="ExtSlotToProcName"><procedure>ExtSlotToProcName</procedure></A>(slot: CARDINAL): TEXT =
  BEGIN RETURN AttrsToProcName(extProcAttrs[slot]) END ExtSlotToProcName;

PROCEDURE <A NAME="RunTimeError"><procedure>RunTimeError</procedure></A>(READONLY execRes: ExecRes): TEXT =
  BEGIN
    IF execRes.errorCode = JunoRTError.Code.FailedExtProc THEN
      RETURN &quot;Built-in procedure \&quot;&quot; &amp; ExtSlotToProcName(execRes.extSlot)
        &amp; &quot;\&quot; failed&quot;
    ELSE
      RETURN JunoRTError.names[execRes.errorCode]
    END
  END RunTimeError;

PROCEDURE <A NAME="TrapMessage"><procedure>TrapMessage</procedure></A>(READONLY execRes: ExecRes): TEXT =
  PROCEDURE Msg(prefix: TEXT; READONLY eRes: ExecRes): TEXT =
    BEGIN RETURN prefix &amp; &quot; in \&quot;&quot; &amp; PCToProcName(eRes.trapLoc) &amp; &quot;\&quot;&quot; END Msg;
  BEGIN
    CASE execRes.trapCode OF
      TrapCode.NormalHalt =&gt;    RETURN &quot;Execution completed successfully&quot;
    | TrapCode.BreakPoint =&gt;    RETURN Msg(&quot;Hit breakpoint&quot;, execRes)
    | TrapCode.Interrupt =&gt;     RETURN Msg(&quot;Juno stopped&quot;, execRes)
    | TrapCode.StackOverflow =&gt; RETURN Msg(&quot;Stack Overflow&quot;, execRes)
    | TrapCode.Error =&gt;
        RETURN Msg(&quot;Run-time error&quot;, execRes)
          &amp; &quot;:\n&quot; &amp; RunTimeError(execRes)
    END
  END TrapMessage;

VAR
  con := NEW(JunoSolve.Constraints, 100);
  var := NEW(JunoSolve.Vars, 100);

PROCEDURE <A NAME="DoSolve"><procedure>DoSolve</procedure></A>(VAR a: BytePtr) =
  VAR
    inouts := JunoMarshal.ReadUShort(a);
    ins := JunoMarshal.ReadUShort(a);
    nc := JunoMarshal.ReadUShort(a);
    nv := ins + inouts;
    params: CARDINAL := sp - nv;
    c: CARDINAL := 0;
  BEGIN
    (* check that &quot;con&quot; and &quot;var&quot; are large enough *)
    IF NUMBER(con^) &lt; nc THEN
      con := NEW(JunoSolve.Constraints, MAX(nc, 2 * NUMBER(con^)))
    END;
    IF NUMBER(var^) &lt; nv THEN
      var := NEW(JunoSolve.Vars, MAX(nv, 2 * NUMBER(var^)))
    END;

    (* create variables *)
    FOR i := 0 TO nv - 1 DO
      var[i] := JunoSolve.New(
        known := (i &gt;= inouts),
        val := stack[params + i])
    END;

    (* process constraints *)
    WHILE c &lt; nc DO
      VAR n: BC.ConRange := a^; x, y, z: JunoMarshal.Short; BEGIN
        INC(a);
        x := JunoMarshal.ReadUShort(a);
        IF n &lt; BC.REAL_C  THEN y := JunoMarshal.ReadUShort(a) END;
        IF n &lt; BC.EQUAL_C THEN z := JunoMarshal.ReadUShort(a) END;
        CASE n OF
        | BC.CONS_C =&gt; con[c] := JunoSolve.NewCons(var[x], var[y], var[z])
        | BC.SUM_C =&gt;  con[c] := JunoSolve.NewPlus(var[x], var[y], var[z])
        | BC.PROD_C =&gt; con[c] := JunoSolve.NewTimes(var[x], var[y], var[z])
        | BC.ATAN_C =&gt; con[c] := JunoSolve.NewAtan(var[x], var[y], var[z])
        | BC.EQUAL_C =&gt;con[c] := JunoSolve.NewEqual(var[x], var[y])
        | BC.SIN_C =&gt;  con[c] := JunoSolve.NewSin(var[x], var[y])
        | BC.COS_C =&gt;  con[c] := JunoSolve.NewCos(var[x], var[y])
        | BC.EXP_C =&gt;  con[c] := JunoSolve.NewExp(var[x], var[y])
        | BC.REAL_C =&gt; con[c] := JunoSolve.NewReal(var[x])
        | BC.TEXT_C =&gt; con[c] := JunoSolve.NewText(var[x])
        END;
        INC(c)
      END
    END;

    (* solve constraints *)
    cond := JunoSolve.P(SUBARRAY(con^, 0, nc));

    (* if successful, store results on the stack *)
    IF cond THEN
      FOR i := 0 TO inouts - 1 DO
        stack[params + i] := var[i].val
      END
    END;
    JunoSolve.Dispose();
    sp := sp - ins
  END DoSolve;
</PRE> ------------------ <CODE>CallState</CODE> OPERATIONS --------------------------- 

<P><PRE>VAR csAvail: CallState := NIL;

PROCEDURE <A NAME="MakeCallState"><procedure>MakeCallState</procedure></A>(pc: PC; fp: CARDINAL): CallState =
  VAR res: CallState; BEGIN
    IF csAvail = NIL THEN
      res := NEW(CallState)
    ELSE
      res := csAvail;
      csAvail := csAvail.nextAvail
    END;
    res.pc := pc;
    res.fp := fp;
    RETURN res
  END MakeCallState;

PROCEDURE <A NAME="DisposeCallState"><procedure>DisposeCallState</procedure></A>(st: CallState) =
  BEGIN
    st.nextAvail := csAvail;
    csAvail := st
  END DisposeCallState;

BEGIN
  value_tbl := NEW(REF ARRAY OF JunoValue.T, 1000);
  code_tbl := NEW(REF ARRAY OF ByteStream, 1000);
  procAttrs := NEW(REF ARRAY OF ProcAttr, 1000);
  ext_code_tbl := NEW(REF ARRAY OF ExternalCode, 100);
  extProcAttrs := NEW(REF ARRAY OF ProcAttr, 100);
  ResetMachine()
END JunoRT.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface JunoValue is in:
</A><UL>
<LI><A HREF="JunoValue.i3.html#0TOP0">juno-machine/src/JunoValue.i3</A>
<LI><A HREF="../../pkl-fonts/src/JunoValue.i3.html#0TOP0">pkl-fonts/src/JunoValue.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
