<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: juno-compiler/src/JunoASTUtils.i3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>juno-compiler/src/JunoASTUtils.i3</H2></A><HR>
<inInterface>
<PRE></PRE> Copyright (C) 1992, Digital Equipment Corporation                         
 All rights reserved.                                                      
 See the file COPYRIGHT for a full description.                            
                                                                           
 Last modified on Sun Oct 26 11:45:38 PST 1997 by heydon                   

<P> Miscellaneous transformations on JunoAST's. 

<P><PRE>INTERFACE <interface><A HREF="JunoASTUtils.m3.html">JunoASTUtils</A></interface>;

IMPORT <A HREF="#x1">JunoValue</A>, <A HREF="JunoAST.i3.html">JunoAST</A>;
</PRE> ====================== Id/QId/NearVar Conversions ======================= 

<P><PRE>PROCEDURE <A HREF="JunoASTUtils.m3.html#QIdFromNearVar">QIdFromNearVar</A>(v: JunoAST.NearVarLink): JunoAST.QId;
</PRE><BLOCKQUOTE><EM> Returns a new unqualified <CODE>JunoAST.QId</CODE> with the same identifier/index
   value as <CODE>v</CODE>. The <CODE>hint</CODE> and <CODE>frozen</CODE> information in <CODE>v</CODE> is lost. Requires
   <CODE>v # NIL</CODE>. </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="JunoASTUtils.m3.html#QIdFromIds">QIdFromIds</A>(mod, id: JunoAST.Id): JunoAST.QId;
</PRE><BLOCKQUOTE><EM> Create and return a qualified (<CODE>mod # JunoAST.NilId</CODE>) or unqualified (<CODE>mod
   = JunoAST.NilId</CODE>) <CODE>JunoAST.QId</CODE> for <CODE>&lt;mod&gt;.&lt;id&gt;</CODE> or <CODE>&lt;id&gt;</CODE>, respectively.
   The new <CODE>QId</CODE> has default <CODE>type</CODE> and <CODE>index</CODE>. </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="JunoASTUtils.m3.html#QIdFromTexts">QIdFromTexts</A>(mod, id: TEXT): JunoAST.QId;
</PRE><BLOCKQUOTE><EM> Equivalent to <CODE>QIdFromIds(Atom.FromText(mod), Atom.FromText(id))</CODE>. </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="JunoASTUtils.m3.html#QIdFromId">QIdFromId</A>(id: JunoAST.Id): JunoAST.QId;
</PRE><BLOCKQUOTE><EM> Create and return an unqualified <CODE>JunoAST.QId</CODE> <CODE>id</CODE>. The new <CODE>QId</CODE> has
   default <CODE>type</CODE> and <CODE>index</CODE>. </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="JunoASTUtils.m3.html#QIdFromText">QIdFromText</A>(t: TEXT): JunoAST.QId;
</PRE><BLOCKQUOTE><EM> Equivalent to <CODE>QIdFromId(Atom.FromText(t))</CODE>. </EM></BLOCKQUOTE><PRE>
</PRE> ====================== IdList Conversions =============================== 

<P><PRE>PROCEDURE <A HREF="JunoASTUtils.m3.html#IdListToNearVarList">IdListToNearVarList</A>(l: JunoAST.IdList): JunoAST.NearVarList;
</PRE><BLOCKQUOTE><EM> Return a new <CODE>JunoAST.NearVarList</CODE> containing the same identifier/index
   pairs as the list <CODE>l</CODE>. The <CODE>hint</CODE> in each element of the result is set to
   <CODE>JunoAST.NilExpr</CODE>. The order of the elements in the resulting list is the
   reverse of those in <CODE>l</CODE>. </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="JunoASTUtils.m3.html#IdListToQIdList">IdListToQIdList</A>(l: JunoAST.IdList): JunoAST.QIdList;
</PRE><BLOCKQUOTE><EM> Return a new <CODE>JunoAST.QIdList</CODE> containing the same (unqualified) names in
   <CODE>l</CODE> (in the same order). </EM></BLOCKQUOTE><PRE>
</PRE> ==================== Create New 1-Item Lists ============================ 

<P><PRE>PROCEDURE <A HREF="JunoASTUtils.m3.html#NewExprList">NewExprList</A>(e: JunoAST.Expr; bp: JunoAST.T := NIL): JunoAST.ExprList;
</PRE><BLOCKQUOTE><EM> Return a new, 1-item <CODE>JunoAST.ExprList</CODE> containing <CODE>e</CODE> with back pointer
   <CODE>bp</CODE>. </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="JunoASTUtils.m3.html#NewQIdList">NewQIdList</A>(qid: JunoAST.QId; bp: JunoAST.T := NIL): JunoAST.QIdList;
</PRE><BLOCKQUOTE><EM> Return a new, 1-item <CODE>JunoAST.QIdList</CODE> containing <CODE>qid</CODE> with back pointer
   <CODE>bp</CODE>. </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="JunoASTUtils.m3.html#NewIdList">NewIdList</A>(id: JunoAST.Id; index: INTEGER := 0): JunoAST.IdList;
</PRE><BLOCKQUOTE><EM> Return a new, 1-item <CODE>JunoAST.IdList</CODE> containing <CODE>id</CODE>, with index <CODE>index</CODE>.
</EM></BLOCKQUOTE><PRE>
</PRE> ======================== Membership Tests =============================== 

<P><PRE>PROCEDURE <A HREF="JunoASTUtils.m3.html#MemIdList">MemIdList</A>(id: JunoAST.Id; l: JunoAST.IdList): BOOLEAN;
</PRE><BLOCKQUOTE><EM> Return TRUE iff <CODE>id</CODE> is a member of the list <CODE>l</CODE>. </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="JunoASTUtils.m3.html#MemNearVarList">MemNearVarList</A>(id: JunoAST.Id; l: JunoAST.NearVarList):
  JunoAST.NearVarLink;
</PRE><BLOCKQUOTE><EM> If <CODE>id</CODE> is the name of one of the variables in <CODE>l</CODE>, return the
   corresponding <CODE>NearVarLink</CODE> of <CODE>l</CODE>. Otherwise, return NIL. </EM></BLOCKQUOTE><PRE>
</PRE> ======================= Operations on IdList's ========================== 

<P><PRE>PROCEDURE <A HREF="JunoASTUtils.m3.html#CopyIdList">CopyIdList</A>(l: JunoAST.IdList): JunoAST.IdList;
</PRE><BLOCKQUOTE><EM> Return a copy of the list <CODE>l</CODE>. This procedure is non-destructive. </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="JunoASTUtils.m3.html#ConcatIdLists">ConcatIdLists</A>(l1, l2: JunoAST.IdList): JunoAST.IdList;
</PRE><BLOCKQUOTE><EM> Return the result of concatenating the lists <CODE>l1</CODE> and <CODE>l2</CODE>. This procedure
   is non-destructive. </EM></BLOCKQUOTE><PRE>
</PRE> ===================== Operations on NearVarList's ======================= 

<P><PRE>PROCEDURE <A HREF="JunoASTUtils.m3.html#NearVarListUnion">NearVarListUnion</A>(l1, l2: JunoAST.NearVarList): JunoAST.NearVarList;
</PRE><BLOCKQUOTE><EM> Return a new <CODE>JunoAST.NearVarList</CODE> containing the union of the elements in
   <CODE>l1</CODE> and <CODE>l2</CODE>. The order of the resulting list is the reverse of <CODE>l1</CODE>
   concatenated with <CODE>l2</CODE>. </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="JunoASTUtils.m3.html#NearVarListCopy">NearVarListCopy</A>(l: JunoAST.NearVarList): JunoAST.NearVarList;
</PRE><BLOCKQUOTE><EM> Return a copy of <CODE>l</CODE>. Requires <CODE>l # NIL</CODE>. </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="JunoASTUtils.m3.html#ExtractHints">ExtractHints</A>(vars: JunoAST.NearVarList): JunoAST.Formula;
</PRE><BLOCKQUOTE><EM> Returns a conjunction of <CODE>Equals</CODE> and <CODE>Near</CODE> predicates containing one such
   predicate for each frozen or hinted variable in <CODE>vars</CODE>, respectively.
   Returns <CODE>TRUE</CODE> if all the <CODE>vars</CODE> are unhinted. Requires that
   <CODE>vars</CODE> is non-empty. </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="JunoASTUtils.m3.html#StripHints">StripHints</A>(vars: JunoAST.NearVarList): JunoAST.NearVarList;
</PRE><BLOCKQUOTE><EM> Returns a list containing the same variables as <CODE>vars</CODE>, but all variables
   in the resulting list are unhinted. The <CODE>evar</CODE> fields of the result
   variables are all set to <CODE>FALSE</CODE>. </EM></BLOCKQUOTE><PRE>
</PRE> ============================= MapArgs =================================== 

<P><PRE>TYPE Mappee = PROCEDURE(e: JunoAST.Expr): JunoAST.Expr;

PROCEDURE <A HREF="JunoASTUtils.m3.html#MapArgs">MapArgs</A>(expr: JunoAST.Expr; p: Mappee): JunoAST.Expr;
</PRE><BLOCKQUOTE><EM> If <CODE>expr</CODE> is of the form <CODE>f(t1,...,tn)</CODE>, where <CODE>f</CODE> is one of the predicates
   or functions described below, and the <CODE>t_i</CODE> are terms, then return a new
   expression <CODE>f(p(t1),...,p(tn))</CODE>. If <CODE>expr</CODE> is <CODE>TRUE</CODE> or <CODE>FALSE</CODE> (i.e., a
   <CODE>LitPred</CODE>), return <CODE>expr</CODE>. Signal a run-time error otherwise.
<P>
   The legal forms for <CODE>f</CODE> are:
<PRE>
         o a user-defined predicate or function (i.e., a &quot;JunoAST.Call&quot;);
         o predicates &quot;JunoAST.BuiltInUnaryPred&quot; or &quot;JunoAST.Relation&quot; (i.e., all
           &quot;JunoAST.BuiltInPred&quot;'s except &quot;And&quot;, &quot;Or&quot;, &quot;Not&quot;, and &quot;Exists&quot;); or
         o functions &quot;JunoAST.BuiltInFunc&quot;
</PRE>
   Hence, of all <CODE>JunoAST.Expr</CODE>'s, the only types that cause <CODE>MapArgs</CODE> to
   signal a run-time error are:
<PRE>
         o the compound formulas (&quot;And&quot;, &quot;Or&quot;, &quot;Not&quot;, &quot;Exists&quot;)
         o a grouped expression (i.e., a &quot;JunoAST.GroupedExpr&quot;);
         o &quot;AtomicExpr&quot; (i.e., &quot;LitValue&quot; and &quot;QId&quot;)
         o &quot;NormalForm&quot;
</EM></BLOCKQUOTE><PRE>
</PRE> ======================= Operations on JunoAST.Vars ====================== 

<P><PRE>PROCEDURE <A HREF="JunoASTUtils.m3.html#MemVars">MemVars</A>(qid: JunoAST.QId; READONLY vars: JunoAST.Vars): INTEGER;
</PRE><BLOCKQUOTE><EM> Return the index of <CODE>qid</CODE> -- which must be an unqualified local variable --
   in <CODE>vars</CODE>, or -1 if it does not occur. <CODE>qid</CODE> appears in <CODE>vars</CODE> if there is
   a <CODE>JunoAST.NearVarLink</CODE> in <CODE>vars</CODE> with the same <CODE>index</CODE> value. </EM></BLOCKQUOTE><PRE>
</PRE> ==================== Create New Special-Purpose AST's =================== 

<P><PRE>PROCEDURE <A HREF="JunoASTUtils.m3.html#NewNumber">NewNumber</A>(x: JunoValue.Real): JunoAST.Expr;
</PRE><BLOCKQUOTE><EM> Return a new expression that is a new <CODE>JunoAST.Number</CODE> if <CODE>x</CODE> is
   non-negative, or a new <CODE>JunoAST.UMinus</CODE> containing a new <CODE>JunoAST.Number</CODE>
   if <CODE>x</CODE> is negative. </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="JunoASTUtils.m3.html#NewPoint">NewPoint</A>(x, y: JunoValue.Real): JunoAST.Pair;
</PRE><BLOCKQUOTE><EM> Return a new AST that unparses to the expression <CODE>(xVal, yVal)</CODE>, where
   <CODE>xVal</CODE> and <CODE>yVal</CODE> are the expressions with values <CODE>x</CODE> and <CODE>y</CODE>,
   respectively, as created by <CODE>NewNumber</CODE> above. </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="JunoASTUtils.m3.html#NewASTFromValue">NewASTFromValue</A>(v: JunoValue.T): JunoAST.T;
</PRE><BLOCKQUOTE><EM> Return a new AST that unparses to the run-time value <CODE>v</CODE>. </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="JunoASTUtils.m3.html#NewAssign">NewAssign</A>(v: JunoAST.QId; e: JunoAST.Expr): JunoAST.Assign;
</PRE><BLOCKQUOTE><EM> Return the assignment <CODE>v := e</CODE>. </EM></BLOCKQUOTE><PRE>
</PRE> ============================ Miscellaneous ============================== 

<P><PRE>PROCEDURE <A HREF="JunoASTUtils.m3.html#Ungroup">Ungroup</A>(ast: JunoAST.T): JunoAST.T;
</PRE><BLOCKQUOTE><EM> Return the largest subtree of <CODE>ast</CODE> that is not a grouped command or
   grouped expression. </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="JunoASTUtils.m3.html#EqualQIds">EqualQIds</A>(qid1, qid2: JunoAST.QId): BOOLEAN;
</PRE><BLOCKQUOTE><EM> Return TRUE iff <CODE>qid1</CODE> and <CODE>qid2</CODE> have the same module name and identifier
   name. </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="JunoASTUtils.m3.html#FirstProcCall">FirstProcCall</A>(cmd: JunoAST.Cmd; qid: JunoAST.QId): JunoAST.ProcCall;
</PRE><BLOCKQUOTE><EM> Return the first procedure call command to the procedure named <CODE>qid</CODE> in the
   command <CODE>cmd</CODE>, or NIL if such a procedure call does not occur in <CODE>cmd</CODE>. </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="JunoASTUtils.m3.html#AlwaysDefined">AlwaysDefined</A>(e: JunoAST.Expr): BOOLEAN;
</PRE><BLOCKQUOTE><EM> Return TRUE iff <CODE>e</CODE> is an expression that is always defined. The basic
   expressions that are always defined are literals and qualified identifiers.
   In addition to these are: grouped expressions whose (body) expression is
   always defined, list expressions all of whose elements are always defined,
   pair expressions both of whose values are always defined, and call
   expressions to user-defined or external procedures all of whose IN
   parameters are always defined (except for the built-in user-defined
   <CODE>CLOSE</CODE> and <CODE>APPLY</CODE> procedures).
<P>
   Note: If this procedure is called before <CODE>e</CODE>'s atoms have been annotated by
   <CODE>JunoCompile.AnnotateAtoms</CODE>, it will return FALSE in some cases where it
   would return TRUE once the atoms had been annotated. </EM></BLOCKQUOTE><PRE>

END JunoASTUtils.
</PRE>
</inInterface>
<HR>
<A NAME="x1">interface JunoValue is in:
</A><UL>
<LI><A HREF="../../juno-machine/src/JunoValue.i3.html#0TOP0">juno-machine/src/JunoValue.i3</A>
<LI><A HREF="../../pkl-fonts/src/JunoValue.i3.html#0TOP0">pkl-fonts/src/JunoValue.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
