<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: juno-compiler/src/JunoCompile.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>juno-compiler/src/JunoCompile.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright (C) 1992, Digital Equipment Corporation                         
 All rights reserved.                                                      
 See the file COPYRIGHT for a full description.                            
                                                                           
 Last modified on Mon Jan 27 18:44:43 PST 1997 by heydon                   
      modified on Tue Feb 21 14:47:07 PST 1995 by gnelson                  
      modified on Fri Aug  7 21:54:03 PDT 1992 by myers                    

<P><PRE>MODULE <module>JunoCompile</module> EXPORTS <A HREF="JunoCompile.i3.html"><implements>JunoCompile</A></implements>, <A HREF="JunoCompileRep.i3.html"><implements>JunoCompileRep</A></implements>;

IMPORT <A HREF="BuiltInSlots.i3.html">BuiltInSlots</A>, <A HREF="JunoAST.i3.html">JunoAST</A>, <A HREF="JunoChkBNF.i3.html">JunoChkBNF</A>, <A HREF="JunoAssemble.i3.html">JunoAssemble</A>, <A HREF="JunoScope.i3.html">JunoScope</A>;
IMPORT   <A HREF="JunoUnparse.i3.html">JunoUnparse</A>, <A HREF="JunoCompileNF.i3.html">JunoCompileNF</A>;
FROM <A HREF="JunoCompileErr.i3.html">JunoCompileErr</A> IMPORT Error, ErrVal, Raise;
IMPORT <A HREF="../../juno-machine/src/JunoRT.i3.html">JunoRT</A>, <A HREF="../../juno-machine/src/JunoDisassem.i3.html">JunoDisassem</A>;
IMPORT <A HREF="StackTbl.i3.html">StackTbl</A>, <A HREF="JunoASTUtils.i3.html">JunoASTUtils</A> AS Utils;
IMPORT <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../libm3/derived/AtomIntTbl.i3.html">AtomIntTbl</A>;
</PRE> Note on Error Reporting:
<P>
   The procedure <CODE>JunoCompileErr.Raise</CODE> is used to report compilation errors.
   In general, the philosophy of the compiler is to report errors as soon as
   possible. When a command is compiled, there are roughly 4 stages:
<P>
<PRE>
         1) JunoChkBNF: check that the AST conforms to the grammar
         2) JunoCompile.AnnotateAtoms
         3) main compilation work
         4) JunoAssemble.Cmd: assemble AST into bytestream
</PRE>
   <CODE>JunoChkBNF</CODE> only reports errors to indicate that the AST does not conform
   to the Juno-2 grammar. This is necessary because the parser actually allows
   a superset of the grammar. Many of the compilation errors are reported by
   <CODE>AnnotateAtoms</CODE>, but some are also produced by the routines that do the
   compilation work. <CODE>JunoAssemble.Cmd</CODE> does not report any errors. 

<P><PRE>IMPORT <A HREF="../../libm3/src/atom/Atom.i3.html">Atom</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="../../libm3/src/rw/Rd.i3.html">Rd</A>, <A HREF="../../libm3/src/fmtlex/Lex.i3.html">Lex</A>, <A HREF="../../libm3/src/fmtlex/Fmt.i3.html">Fmt</A>, <A HREF="../../m3core/src/float/IEEE-default/FloatMode.i3.html">FloatMode</A>;
FROM <A HREF="../../libm3/src/rw/Stdio.i3.html">Stdio</A> IMPORT stderr;
&lt;* FATAL Wr.Failure, Thread.Alerted *&gt;
VAR debug := 0;
</PRE><BLOCKQUOTE><EM> = 0 =&gt; No debugging output,
<PRE>
      &gt;= 1 =&gt; Show when a pred, proc, or func is compiled
      &gt;= 2 =&gt; Show the predicate/command to be compiled
      &gt;= 3 =&gt; Show the command produced by the compilation
      &gt;= 4 =&gt; Show the disassembled version of the assembled command
</EM></BLOCKQUOTE><PRE>

VAR mu := NEW(MUTEX);
</PRE><BLOCKQUOTE><EM> The procedures exported by the <CODE>JunoCompile</CODE> interface
   are protected by <CODE>mu</CODE>. </EM></BLOCKQUOTE><PRE>

VAR varTbl := NEW(AtomIntTbl.Default);
</PRE><BLOCKQUOTE><EM> This table is reused in <CODE>AnnotateAtoms_NearVarList</CODE> to determine if the
   same variable appears more than once in an existential quantification or
   projection command. </EM></BLOCKQUOTE><PRE>

VAR (* CONST *)
  saveName := Atom.FromText(&quot;Save&quot;);
  restoreName := Atom.FromText(&quot;Restore&quot;);
</PRE> ============================ Declarations =============================== 

<P><PRE>VAR (* CONST *)
  dummy_mod := Atom.FromText(&quot;DUMMY_MOD&quot;);
  dummy_var := Atom.FromText(&quot;DUMMY_VAR&quot;);
  dummy_slot := JunoRT.GetVarIndex(dummy_mod, dummy_var);
  dummy_qid := NEW(JunoAST.QId, id0 := dummy_mod, id1 := dummy_var,
    type := JunoAST.IdType.Var, index := dummy_slot);
  dummy_assign := NEW(JunoAST.Assign, vars := Utils.NewQIdList(dummy_qid));

VAR (* CONST *)
  CompStackSize := 2 * Thread.GetDefaultStackSize();

TYPE
  CompClosure = Thread.SizedClosure OBJECT  (* Class only -- do not NEW *)
    error: BOOLEAN := FALSE;
    errVal: ErrVal;
  END;
</PRE> We fork a separate thread for compilations so as to use a larger thread
   stack. The closure in each case is a subtype of a <CODE>CompClosure</CODE>.
<P>
   The field <CODE>error</CODE> is true iff the compilation resulted in the exception
   <CODE>JunoCompileErr.Error</CODE>. In this case, <CODE>errVal</CODE> is the argument to the
   <CODE>Error</CODE> exception. 

<P>  <PRE>ExprClosure = CompClosure OBJECT
    expr: JunoAST.Expr;
    scp: JunoScope.T;
    pure: BOOLEAN;
    res: JunoRT.ByteStream;
  END;

PROCEDURE <A NAME="Expr"><procedure>Expr</procedure></A>(
    expr: JunoAST.Expr;
    scp: JunoScope.T;
    nm: JunoAST.Id;
    VAR (*OUT*) val_slot: CARDINAL;
    pure := FALSE):
    JunoRT.ByteStream RAISES {Error} =
  VAR cl: ExprClosure; BEGIN
    val_slot := dummy_slot;
    LOCK mu DO
      IF debug &gt; 0 THEN
	Wr.PutText(stderr, &quot;\nCompiling expression for \&quot;&quot;);
        Wr.PutText(stderr, Atom.ToText(nm) &amp; &quot;\&quot;...\n&quot;);
	Wr.Flush(stderr)
      END;
      cl := NEW(ExprClosure, stackSize := CompStackSize,
        expr := expr, scp := scp, pure := pure, apply := ExprApply);
      EVAL Thread.Join(Thread.Fork(cl));
      IF cl.error THEN RAISE Error(cl.errVal) END;
      DebugDisassemble(cl.res);
      RETURN cl.res
    END
  END Expr;

PROCEDURE <A NAME="ExprApply"><procedure>ExprApply</procedure></A>(cl: ExprClosure): REFANY =
  VAR tbl := NEW(StackTbl.T).init(); BEGIN
    TRY
      JunoChkBNF.Expr(cl.expr);
      AnnotateAtoms(cl.expr, tbl, cl.scp, ASTKind.Expr, cl.pure);
      dummy_assign.exprs := Utils.NewExprList(cl.expr);
      cl.res := JunoAssemble.Cmd(
    	Cmd(dummy_assign, cl.scp, tbl, annotate := FALSE),
    	cl.scp, temp_cnt := tbl.next_index - 1,
    	type := JunoAssemble.CmdType.Proc)
    EXCEPT
      Error (errVal) =&gt; cl.error := TRUE; cl.errVal := errVal
    END;
    RETURN NIL
  END ExprApply;

TYPE
  PredClosure = CompClosure OBJECT
    pred: JunoScope.Pred;
    scp: JunoScope.T;
  END;

PROCEDURE <A NAME="PredDecl"><procedure>PredDecl</procedure></A>(nm: JunoAST.Id; pred: JunoScope.Pred; scp: JunoScope.T)
    RAISES {Error} =
  VAR cl: PredClosure; BEGIN
    LOCK mu DO
      IF debug &gt; 0 THEN
	Wr.PutText(stderr, &quot;\nCompiling predicate \&quot;&quot;);
        Wr.PutText(stderr, Atom.ToText(nm) &amp; &quot;\&quot;...\n&quot;);
	Wr.Flush(stderr)
      END;
      cl := NEW(PredClosure, stackSize := CompStackSize,
        pred := pred, scp := scp, apply := PredApply);
      EVAL Thread.Join(Thread.Fork(cl));
      IF cl.error THEN RAISE Error(cl.errVal) END;
      DebugDisassemble(JunoRT.code_tbl[pred.index])
    END
  END PredDecl;

PROCEDURE <A NAME="PredApply"><procedure>PredApply</procedure></A>(cl: PredClosure): REFANY =
  BEGIN
    TRY
      WITH pred = cl.pred DO
      	(* Check for legality; convert to normal form *)
      	JunoChkBNF.Formula(pred.body);
      	AnnotateAtoms(pred.body, pred.tbl, cl.scp, ASTKind.Pred, pure := TRUE);
      	pred.normal_form := JunoCompileNF.Normalize(pred.body, pred.tbl);
      	IF debug &gt; 1 THEN
	  Wr.PutText(stderr, &quot;\n  Original Predicate:\n&quot;);
	  DebugUnparse(pred.body);
      	  Wr.PutText(stderr, &quot;\n  Normal Form:\n&quot;);
      	  DebugUnparse(pred.normal_form)
      	END;
      	(* Compile command and install in global code table *)
      	VAR cmd := NormalForm(pred.normal_form, cl.scp, pred.tbl); BEGIN
	  JunoRT.code_tbl[pred.index] := JunoAssemble.Cmd(cmd, cl.scp,
      	    temp_cnt := pred.tbl.next_index - 1,
      	    type := JunoAssemble.CmdType.Pred)
      	END
      END
    EXCEPT
      Error (errVal) =&gt; cl.error := TRUE; cl.errVal := errVal
    END;
    RETURN NIL
  END PredApply;

TYPE
  FuncClosure = CompClosure OBJECT
    func: JunoScope.Func;
    scp: JunoScope.T;
  END;

PROCEDURE <A NAME="FuncDecl"><procedure>FuncDecl</procedure></A>(nm: JunoAST.Id; func: JunoScope.Func; scp: JunoScope.T)
    RAISES {Error} =
  VAR cl: FuncClosure; BEGIN
    LOCK mu DO
      IF debug &gt; 0 THEN
	Wr.PutText(stderr, &quot;\nCompiling function \&quot;&quot;);
        Wr.PutText(stderr, Atom.ToText(nm) &amp; &quot;\&quot;...\n&quot;);
	Wr.Flush(stderr)
      END;
      cl := NEW(FuncClosure, stackSize := CompStackSize,
        func := func, scp := scp, apply := FuncApply);
      EVAL Thread.Join(Thread.Fork(cl));
      IF cl.error THEN RAISE Error(cl.errVal) END;
      DebugDisassemble(JunoRT.code_tbl[func.index])
    END
  END FuncDecl;

PROCEDURE <A NAME="FuncApply"><procedure>FuncApply</procedure></A>(cl: FuncClosure): REFANY =
  BEGIN
    TRY
      WITH func = cl.func DO
      	(* Check for legality; convert to normal form *)
      	JunoChkBNF.Formula(func.body);
      	AnnotateAtoms(func.body, func.tbl, cl.scp, ASTKind.Pred, pure := TRUE);
      	func.normal_form := JunoCompileNF.Normalize(func.body, func.tbl);
      	IF debug &gt; 1 THEN
	  Wr.PutText(stderr, &quot;\n  Original Predicate:\n&quot;);
	  DebugUnparse(func.body);
      	  Wr.PutText(stderr, &quot;\n  Normal Form:\n&quot;);
      	  DebugUnparse(func.normal_form)
      	END;
      	(* Compile command and install in global code table *)
      	CONST
          outSet = SET OF JunoScope.ArgKind{JunoScope.ArgKind.Out};
      	VAR
      	  outList := JunoScope.LocalArgs(func.formals, outSet);
	  cmd := NormalForm(func.normal_form, cl.scp, func.tbl,
      	    xtra_vars := Utils.IdListToNearVarList(outList));
      	BEGIN
	  JunoRT.code_tbl[func.index] := JunoAssemble.Cmd(cmd, cl.scp,
      	    temp_cnt := func.tbl.next_index - 1,
      	    type := JunoAssemble.CmdType.Func)
      	END
      END
    EXCEPT
      Error (errVal) =&gt; cl.error := TRUE; cl.errVal := errVal
    END;
    RETURN NIL
  END FuncApply;

TYPE
  ProcClosure = CompClosure OBJECT
    proc: JunoScope.Proc;
    scp: JunoScope.T;
    res: Result;
  END;

PROCEDURE <A NAME="ProcDecl"><procedure>ProcDecl</procedure></A>(nm: JunoAST.Id; proc: JunoScope.Proc; scp: JunoScope.T):
    JunoAST.Cmd RAISES {Error} =
  VAR cl: ProcClosure; BEGIN
    LOCK mu DO
      IF debug &gt; 0 THEN
	Wr.PutText(stderr, &quot;\nCompiling procedure \&quot;&quot;);
        Wr.PutText(stderr, Atom.ToText(nm) &amp; &quot;\&quot;...\n&quot;);
	Wr.Flush(stderr)
      END;
      cl := NEW(ProcClosure, stackSize := CompStackSize,
        proc := proc, scp := scp, apply := ProcApply);
      EVAL Thread.Join(Thread.Fork(cl));
      IF cl.error THEN RAISE Error(cl.errVal) END;
      DebugDisassemble(JunoRT.code_tbl[proc.index]);
      RETURN cl.res.cmd
    END
  END ProcDecl;

PROCEDURE <A NAME="ProcApply"><procedure>ProcApply</procedure></A>(cl: ProcClosure): REFANY =
  BEGIN
    TRY
      WITH proc = cl.proc DO
      	JunoChkBNF.TotalCmd(proc.body);
      	cl.res := Cmd(proc.body, cl.scp, proc.tbl);
      	JunoRT.code_tbl[proc.index] := JunoAssemble.Cmd(cl.res, cl.scp,
      	  temp_cnt := proc.tbl.next_index - 1,
      	  type := JunoAssemble.CmdType.Proc)
      END
    EXCEPT
      Error (errVal) =&gt;
        cl.error := TRUE;
        cl.errVal := errVal
    END;
    RETURN NIL
  END ProcApply;

PROCEDURE <A NAME="DebugDisassemble"><procedure>DebugDisassemble</procedure></A>(stream: JunoRT.ByteStream) =
  BEGIN
    IF debug &gt; 3 THEN
      Wr.PutText(stderr, &quot;\n  Assembled Command:\n&quot;);
      JunoDisassem.P(stream, stderr);
      Wr.Flush(stderr)
    END
  END DebugDisassemble;
</PRE> ========================== Annotate Atoms =============================== 

<P><PRE>TYPE ASTKind = { Pred, Expr, Cmd };

PROCEDURE <A NAME="AnnotateAtoms"><procedure>AnnotateAtoms</procedure></A>(
    ast: JunoAST.T;
    t: StackTbl.T;
    scp: JunoScope.T;
    kind: ASTKind;
    pure := FALSE)
  RAISES {Error} =
</PRE><BLOCKQUOTE><EM> Destructively annotate the index of every node in <CODE>ast</CODE> that has an index,
   and set the <CODE>bp</CODE> field of each node to point to itself (except
   <CODE>JunoAST.GroupedExpr</CODE> and <CODE>JunoAST.GroupedCmd</CODE> nodes). The <CODE>kind</CODE> argument
   indicates the top-level class of <CODE>ast</CODE>. The <CODE>ast</CODE> may contain query nodes.
<P>
   When a projected or existential variable is encountered, assign it the new
   index <CODE>t.next_index</CODE>, and push the variable onto the stack table. When a
   variable use <CODE>x</CODE> is encountered, it is assigned the index associated with
   <CODE>x</CODE> in <CODE>t</CODE>.
<P>
   Raises <CODE>Error</CODE> if <CODE>ast</CODE> contains a compilation error. Also raises <CODE>error</CODE>
   if <CODE>pure</CODE> is set and <CODE>ast</CODE> contains a reference to a procedure (according
   to <CODE>scp</CODE>). </EM></BLOCKQUOTE><PRE>

  PROCEDURE Pred0(ast: JunoAST.Formula) RAISES {Error} =
    BEGIN
      TYPECASE Utils.Ungroup(ast) OF &lt;* NOWARN *&gt;
      | JunoAST.LitPred =&gt; RETURN
      | JunoAST.And (e) =&gt; Pred0(e.f1); Pred0(e.f2)
      | JunoAST.Or (e) =&gt; Pred0(e.f1); Pred0(e.f2)
      | JunoAST.Not (e) =&gt; Pred0(e.f);
      | JunoAST.Exists (e) =&gt;
	  StackTbl.Mark(t);
          NearVarList(e.vars);
	  Pred0(e.f);
	  StackTbl.PopToMark(t)
      | JunoAST.BIUPred (e) =&gt; Expr0(e.e)
      | JunoAST.Relation (e) =&gt; Expr0(e.e1); Expr0(e.e2)
      | JunoAST.Call (c) =&gt;
          VAR ent := QIdInScope(c.name); pred: JunoScope.Pred; BEGIN
            TYPECASE ent OF
	      NULL =&gt; Raise(&quot;Undefined predicate&quot;, c)
            | JunoScope.Pred (p) =&gt; pred := p; c.normal_form := p.normal_form
            ELSE Raise(&quot;Not a predicate&quot;, c)
	    END;
	    (* Typecheck &quot;c&quot; *)
	    IF c.inouts.size # 0 THEN
	      Raise(&quot;Predicates don't have INOUT parameters&quot;, c)
	    ELSIF pred.in_cnt # c.ins.size THEN
	      Raise(&quot;Wrong number of IN parameters&quot;, c)
	    END
          END;
          LValueList(c.inouts);
          ExprList0(c.ins)
      END
    END Pred0;

  PROCEDURE QId0(qid: JunoAST.QId; lvalue: BOOLEAN) RAISES {Error} =
    BEGIN
      IF qid.id0 = JunoAST.NilId THEN
        VAR i := StackTbl.Lookup(t, qid.id1); BEGIN
          IF i # 0 THEN
            qid.type := JunoAST.IdType.Local;
            qid.index := i;
            RETURN
          END
        END
      END;
      (* Qualified id or unqualified non-local variable *)
      EVAL QIdInScope(qid);
      IF lvalue THEN
        CASE qid.type OF
          JunoAST.IdType.None, JunoAST.IdType.Const, JunoAST.IdType.Pred,
          JunoAST.IdType.Func, JunoAST.IdType.Proc, JunoAST.IdType.ExtProc =&gt;
            Raise(&quot;You can only assign values to variables&quot;, qid)
        ELSE (* SKIP *)
        END
      ELSE
        CASE qid.type OF
          JunoAST.IdType.None, JunoAST.IdType.Pred, JunoAST.IdType.Func =&gt;
            Raise(&quot;This is not a valid expression&quot;, qid)
        ELSE (* SKIP *)
        END
      END
    END QId0;

  PROCEDURE QIdInScope(qid: JunoAST.QId): JunoScope.Entity RAISES {Error} =
  (* Annotate the variable &quot;qid&quot; to be either a local variable, formal
     argument, constant, predicate, function, global variable, or procedure,
     depending on the type of entity it is bound to in &quot;scp&quot;. Also annotate
     the variable's index.

     Raises &quot;Error&quot; if &quot;qid&quot; is either an undeclared identifier or is an
     unqualified module name, or if &quot;pure&quot; is set and &quot;qid&quot; refers to a
     procedure.

     Return the entity associated with &quot;qid&quot; in &quot;scp&quot;. *)
    VAR
      unit: JunoScope.Entity;
      ent := JunoScope.LookupQId(scp, qid, unit);
    BEGIN
      TYPECASE ent OF &lt;* NOWARN *&gt;
        NULL =&gt;
          IF unit = NIL AND qid.id0 # JunoAST.NilId
	    THEN Raise(&quot;Undefined module&quot;, qid)
	    ELSE Raise(&quot;Undefined identifier&quot;, qid)
	  END
      | JunoScope.Mod =&gt; Raise(&quot;This identifies a module&quot;, qid)
      | JunoScope.LocalValue (local) =&gt;
          qid.type := JunoAST.IdType.Local;
          qid.index := local.offset
      | JunoScope.Const (const) =&gt;
          qid.type := JunoAST.IdType.Const;
          qid.index := const.index
      | JunoScope.Pred (pred) =&gt;
          qid.type := JunoAST.IdType.Pred;
          qid.index := pred.index
      | JunoScope.Func (func) =&gt;
          qid.type := JunoAST.IdType.Func;
          qid.index := func.index
      | JunoScope.Var (var) =&gt;
          qid.type := JunoAST.IdType.Var;
          qid.index := var.index
      | JunoScope.Proc (proc) =&gt;
          IF pure THEN
            Raise(&quot;You can't call a procedure in a constraint&quot;, qid)
          END;
          IF proc.external
            THEN qid.type := JunoAST.IdType.ExtProc
            ELSE qid.type := JunoAST.IdType.Proc
          END;
          qid.index := proc.index
      END;
      RETURN ent
    END QIdInScope;

  PROCEDURE CheckInCnts(c: JunoAST.T; nm: JunoAST.QId;
      realInoutCnt, realInCnt, inoutCnt, inCnt: CARDINAL)
      RAISES {Error} =
  (* Assume &quot;c&quot; is a &quot;JunoAST.Call&quot; or &quot;JunoAST.ProcCall&quot; to the
     procedure/predicate/function named &quot;nm&quot; with &quot;realInCnt&quot; and
     &quot;realInoutCnt&quot; IN and INOUT arguments.

     If &quot;nm&quot; is a call to &quot;APPLY&quot;, then it is simply required to have at least
     one IN parameter. If it is a call to &quot;CLOSE&quot;, it is required to have
     &quot;inoutCnt&quot; INOUT parameters (namely, 0), and at least one IN parameter.
     Otherwise, it is required to have &quot;inCnt&quot; IN parameters, and &quot;inoutCnt&quot;
     INOUT parameters. If any of these conditions is violoated, &quot;Error&quot; is
     raised with an appropriate error message and associated AST &quot;c&quot;. *)
    BEGIN
      (* check APPLY case *)
      IF BuiltInSlots.IsApplyProc(nm) THEN
        IF realInCnt &lt; 1 THEN
          Raise(&quot;APPLY requires at least one IN parameter&quot;, c)
        END
      (* check INOUT parameters *)
      ELSIF realInoutCnt # inoutCnt THEN
	Raise(&quot;Wrong number of INOUT parameters&quot;, c)
      (* check CLOSE case *)
      ELSIF BuiltInSlots.IsCloseProc(nm) THEN
        IF realInCnt &lt; 1 THEN
          Raise(&quot;CLOSE requires at least IN parameter&quot;, c)
        END
      (* check IN parameters *)
      ELSIF realInCnt # inCnt THEN
        Raise(&quot;Wrong number of IN parameters&quot;, c)
      END
    END CheckInCnts;

  PROCEDURE CheckArgCnts(c: JunoAST.T; nm: JunoAST.QId;
    realOutCnt, realInoutCnt, realInCnt, outCnt, inoutCnt, inCnt: CARDINAL)
    RAISES {Error} =
  (* Like &quot;CheckInCnts&quot; above, but also checks that the number of OUT
     parameters also agree. That is, so long as &quot;nm&quot; is not &quot;APPLY&quot;,
     &quot;realOutCnt&quot; must agree with &quot;outCnt&quot;. *)
    BEGIN
      CheckInCnts(c, nm, realInoutCnt, realInCnt, inoutCnt, inCnt);
      IF realOutCnt # outCnt AND NOT BuiltInSlots.IsApplyProc(nm) THEN
        Raise(&quot;Wrong number of OUT parameters&quot;, c)
      END
    END CheckArgCnts;

  PROCEDURE Expr0(ast: JunoAST.Expr) RAISES {Error} =
    BEGIN
      TYPECASE Utils.Ungroup(ast) OF &lt;* NOWARN *&gt;
      | JunoAST.Text (e) =&gt; e.index := JunoRT.GetValueIndex(e.val)
      | JunoAST.LitValue =&gt; (* SKIP JunoAST.Number and JunoAST.Nil *)
      | JunoAST.QId (e) =&gt; QId0(e, lvalue := FALSE)
      | JunoAST.BIUFunc (e) =&gt; Expr0(e.e);
      | JunoAST.BIBFunc (e) =&gt; Expr0(e.e1); Expr0(e.e2)
      | JunoAST.List (e) =&gt; ExprList0(e.elts);
      | JunoAST.Call (c) =&gt;
          VAR ent := QIdInScope(c.name); BEGIN
            TYPECASE ent OF
              NULL =&gt; Raise(&quot;Undefined function&quot;, c)
            | JunoScope.Func (f) =&gt;
                c.normal_form := f.normal_form;
                CheckInCnts(c, c.name, c.inouts.size, c.ins.size, 0, f.in_cnt)
            | JunoScope.Proc (p) =&gt;
                IF p.out_cnt # 1 AND NOT BuiltInSlots.IsApplySlot(p.index) THEN
                  Raise(&quot;Not a functional procedure&quot;, c)
                END;
                CheckInCnts(c, c.name, c.inouts.size, c.ins.size,
                  p.inout_cnt, p.in_cnt)
            ELSE
                Raise(&quot;Not a function&quot;, c)
	    END
          END;
          LValueList(c.inouts);
          ExprList0(c.ins)
      END
    END Expr0;

  PROCEDURE LValueList(el: JunoAST.ExprList) RAISES {Error} =
    VAR curr := el.head; BEGIN
      WHILE curr # NIL DO
        QId0(curr.expr, lvalue := TRUE);
        curr := curr.next
      END
    END LValueList;

  PROCEDURE ExprList0(el: JunoAST.ExprList) RAISES {Error} =
    VAR curr := el.head; BEGIN
      WHILE curr # NIL DO
        Expr0(curr.expr);
        curr := curr.next
      END
    END ExprList0;

  PROCEDURE Cmd0(ast: JunoAST.T) RAISES {Error} =
    BEGIN
      TYPECASE Utils.Ungroup(ast) OF &lt;* NOWARN *&gt;
	JunoAST.Skip, JunoAST.Abort, JunoAST.Halt =&gt; RETURN
      | JunoAST.Assign (c) =&gt;
          IF c.vars.size # c.exprs.size THEN
            Raise(&quot;The number of variables on the left\n&quot;
              &amp; &quot;is different from the\nnumber of terms on the right&quot;, c)
          END;
          LValueList(c.vars);
          ExprList0(c.exprs)
      | JunoAST.If (c) =&gt; Cmd0(c.body)
      | JunoAST.Do (c) =&gt; Cmd0(c.body)
      | JunoAST.Save (c) =&gt;
          c.save := NEW(JunoAST.QId, bp := c.nm,
            id0 := c.nm.id1, id1 := saveName);
          c.restore := NEW(JunoAST.QId, bp := c.nm,
            id0 := c.nm.id1, id1 := restoreName);
          EVAL QIdInScope(c.save);
          EVAL QIdInScope(c.restore);
          Cmd0(c.body)
      | JunoAST.Proj (c) =&gt;
	  StackTbl.Mark(t);
          NearVarList(c.vars);
	  Cmd0(c.body);
	  StackTbl.PopToMark(t)
      | JunoAST.Seq (c) =&gt;
          (* The following is equivalent to &quot;Cmd0(c.c1); Cmd0(c.c2)&quot;
             except that it uses fewer stack frames when &quot;c&quot; is a long
             right-associative list of semi-colon-separated commands. *)
          Cmd0(c.c1);
          LOOP
            TYPECASE Utils.Ungroup(c.c2) OF JunoAST.Seq (newC) =&gt;
              Cmd0(newC.c1);
              c := newC
            ELSE EXIT
            END
          END;
          Cmd0(c.c2)
      | JunoAST.Guard (c) =&gt; Pred0(c.grd); Cmd0(c.body)
      | JunoAST.Else (c) =&gt; Cmd0(c.c1); Cmd0(c.c2)
      | JunoAST.ProcCall (c) =&gt;
          &lt;* ASSERT NOT pure *&gt;
          VAR ent := QIdInScope(c.name); proc: JunoScope.Proc; BEGIN
            TYPECASE ent OF
              NULL =&gt; Raise(&quot;Undefined procedure&quot;, c)
            | JunoScope.Proc (p) =&gt; proc := p
            ELSE Raise(&quot;Not a procedure&quot;, c)
	    END;
            CheckArgCnts(c, c.name, c.outs.size, c.inouts.size, c.ins.size,
              proc.out_cnt, proc.inout_cnt, proc.in_cnt)
          END;
          LValueList(c.outs);
          LValueList(c.inouts);
          ExprList0(c.ins)
      | JunoAST.Query (c) =&gt; Pred0(c.f); QueryVars(c.vars)
      END;
    END Cmd0;

  PROCEDURE NearVarList(nvl: JunoAST.NearVarList) RAISES {Error} =
  (* Annotate the variables in the list &quot;head&quot; and their hint expressions
     (if any). This procedure works in two passes. First, it annotates all
     of the variables; then it annotates the hints. This is necessary
     because a hint may refer to a variable introduced later in the list.
     Raise &quot;Error&quot; if the same variable appears more than once in the list. *)
    VAR head := nvl.head; BEGIN
      (* Mark the variables *)
      EVAL varTbl.init(sizeHint := 20);
      VAR l: JunoAST.NearVarLink := head; BEGIN
        WHILE l # NIL DO
          IF varTbl.put(l.id, 0) THEN
            Raise(&quot;The variable \&quot;&quot; &amp; Atom.ToText(l.id)
              &amp; &quot;\&quot; appears more than once&quot;, nvl)
          END;
          l.index := t.next_index;
          StackTbl.Push(t, l.id);
          l := l.next
        END
      END;
      (* annotate their hints *)
      VAR l: JunoAST.NearVarLink := head; BEGIN
        WHILE l # NIL DO
          IF l.hint # JunoAST.NilExpr THEN Expr0(l.hint) END;
          l := l.next
        END
      END
    END NearVarList;

  PROCEDURE QueryVars(nv: JunoAST.NearVarList) RAISES {Error} =
  (* Annotate the indices of the query variables in &quot;nv&quot; from the stack
     table &quot;t&quot;. Any hints in this list are *not* annotated. Raise &quot;Error&quot; if
     any of the variables is not bound to an index in &quot;t&quot;. *)
    VAR curr := nv.head; BEGIN
      WHILE curr # NIL DO
        VAR i := StackTbl.Lookup(t, curr.id); BEGIN
          IF i = 0 THEN Raise(&quot;Query variable is not a local&quot;, nv) END;
          curr.index := i
        END;
        curr := curr.next
      END
    END QueryVars;

  (* AnnotateAtoms *)
  BEGIN
    CASE kind OF &lt;*NOWARN*&gt;
      ASTKind.Pred =&gt; Pred0(ast)
    | ASTKind.Expr =&gt; Expr0(ast)
    | ASTKind.Cmd  =&gt; Cmd0(ast)
    END
  END AnnotateAtoms;
</PRE> =============================== Cmd ===================================== 

<P><PRE>PROCEDURE <A NAME="Cmd"><procedure>Cmd</procedure></A>(
    cmd: JunoAST.Cmd;
    scp: JunoScope.T;
    stack_tbl: StackTbl.T;
    annotate := TRUE;
    pure := FALSE):
  Result RAISES {Error} =

  PROCEDURE C1(cmd: JunoAST.Cmd): JunoAST.Cmd RAISES {Error} =
  (* Returns a command equivalent to &quot;cmd&quot; in which all commands to the
     right of guard arrows are total, and in which all &quot;Near&quot; and &quot;Equals&quot;
     constraints on projected variables have been extracted (hence, all
     projected variables are unhinted with reset &quot;frozen&quot; bits).

     Here are the rewrite rules embodied by this procedure:

|      C1(DO A OD) == DO C1(A) OD                            (rule C1.06)
|      C1(IF A FI) == IF C1(A) FI                            (rule C1.07)
|      C1(SAVE M IN A END) == SAVE M IN C1(A) END            (rule C1.08)
|      C1(A ; B) == C1(A) ; C1(B)                            (rule C1.09)
|      C1(A | B) == C1(A) | C1(B)                            (rule C1.10)
|      C1(VAR x IN A END) == VAR x IN C1(A) END              (rule C1.11)
|      C1(P -&gt; A) == C1Grd(P -&gt; A)                           (see C1Grd below)
|      C1(A) == A (SKIP, ABORT, HALT, Assignment, ProcCall, Query)

     In rule C1.11 (projection), any hints associated with the projected
     variables &quot;x&quot; are stripped out and incorporated as a new guard on the
     command &quot;A&quot;. For example:

|      C1(VAR x ~ f(y) IN A END) == VAR x IN C1(x ~ f(y) -&gt; A) END

     Queries are only allowed to appear in &quot;cmd&quot; under certain conditions. It
     is assumed that a query of the form &quot;P?(vlist)&quot; will appear in &quot;cmd&quot;
     if and only if all of the variables &quot;vlist&quot; are all locally projected
     variables in scope. Furthermore, for each projection command in &quot;cmd&quot;,
     the guard of the command, when computed according to the rewrite rules
     below, may not contain an expression of the form &quot;Grd(&lt;query&gt;)&quot;. The
     guard rewrite rules are:

|      Grd(A ; B)  == Grd(A)               (Grd(B) must be True)
|      Grd(A | B)  == Grd(A) OR Grd(B)
|      Grd(x :: S) == (E x: Grd(S))
|      Grd(P -&gt; S) == P =&gt; Grd(S)

     All other commands are total, i.e., Grd(S) == True. *)
    BEGIN
      cmd := Utils.Ungroup(cmd);
      TYPECASE cmd OF &lt;* NOWARN *&gt;
	JunoAST.Skip, JunoAST.Abort, JunoAST.Halt, JunoAST.Assign,
        JunoAST.ProcCall, JunoAST.Query =&gt;
	  RETURN cmd
      | JunoAST.Do (c) =&gt;				       (* rule C1.06 *)
	  RETURN NEW(JunoAST.Do, bp := c, body := C1(c.body))
      | JunoAST.If (c) =&gt;				       (* rule C1.07 *)
	  RETURN NEW(JunoAST.If, bp := c, body := C1(c.body))
      | JunoAST.Save (c) =&gt;				       (* rule C1.08 *)
	  RETURN NEW(JunoAST.Save, bp := c, nm := c.nm, body := C1(c.body),
            save := c.save, restore := c.restore)
      | JunoAST.Seq (c) =&gt;				       (* rule C1.09 *)
	  RETURN C1Seq(c)
      | JunoAST.Else (c) =&gt;				       (* rule C1.10 *)
	  RETURN NEW(JunoAST.Else, bp := c, c1 := C1(c.c1), c2 := C1(c.c2))
      | JunoAST.Proj (c) =&gt;				       (* rule C1.11 *)
          VAR
            hints := Utils.ExtractHints(c.vars);
            body := c.body; uv := c.vars;
          BEGIN
            IF hints # JunoAST.TrueVal THEN
              body := NEW(JunoAST.Guard, bp := c, grd := hints, body := body);
              uv := Utils.StripHints(uv)
            END;
	    RETURN NEW(JunoAST.Proj, bp := c, vars := uv, body := C1(body))
          END
      | JunoAST.Guard (g) =&gt; RETURN C1Grd(g)
      END
    END C1;

  PROCEDURE C1Seq(seq: JunoAST.Seq): JunoAST.Seq RAISES { Error } =
  (* Equivalent to:
|
|      RETURN NEW(JunoAST.Seq, bp := seq,
|        c1 := C1(seq.c1), c2 := C1(seq.c2))
|
     except that it uses fewer stack frames when &quot;seq&quot; is a long
     right-associative list of semi-colon-separated commands. *)
    VAR
      res := NEW(JunoAST.Seq, bp := seq, c1 := C1(seq.c1));
      curr := res;
    BEGIN
      LOOP
        TYPECASE Utils.Ungroup(seq.c2) OF JunoAST.Seq (newSeq) =&gt;
          curr.c2 := NEW(JunoAST.Seq, bp := newSeq, c1 := C1(newSeq.c1));
          seq := newSeq;
          curr := curr.c2
        ELSE EXIT
        END
      END;
      curr.c2 := C1(seq.c2);
      RETURN res
    END C1Seq;

  PROCEDURE C1Grd(g: JunoAST.Guard): JunoAST.Cmd RAISES {Error} =
  (* This is the procedure &quot;C1&quot; above specialized to compiling guarded
     commands only. Here are the compilation rules:

|      C1(P -&gt; VAR x IN A END) == VAR x IN C1(P -&gt; A) END      (rule C1.12)
|      C1(P -&gt; { A | B }) == C1(P -&gt; A) | C1(P -&gt; B)           (rule C1.13)
|      C1(P -&gt; { A ; B }) == C1(P -&gt; A) | C1(B)                (rule C1.14)
|      C1(P -&gt; { Q -&gt; A }) == C1((P AND Q) -&gt; A)               (rule C1.15)
|      C1(P -&gt; A) == P -&gt; C1(A) (all other cases)              (rule C1.11)

    In the first rule, any hints associated with the projected variables &quot;x&quot;
    are stripped out and incorporated into &quot;P&quot;, and all variables in the
    resulting projected list of variables are made unhinted with reset
    &quot;frozen&quot; bits.

    Since we know that &quot;C1(P -&gt; A) == C1Grd(P -&gt; A)&quot;, we invoke &quot;C1Grd&quot;
    directly for those right-hand sides in the rules above that contain
    statements of the form &quot;C1(P -&gt; A)&quot;. This saves a stack frame, procedure
    call, and the work of doing the TYPECASE in &quot;C1&quot;.
  *)
    VAR gBody := Utils.Ungroup(g.body); BEGIN
      TYPECASE gBody OF
        JunoAST.Proj (c) =&gt;                                (* rule C1.12 *)
          VAR
            hints := Utils.ExtractHints(c.vars);
            grd := g.grd; uv := c.vars;
          BEGIN
            IF hints # JunoAST.TrueVal THEN
              grd := NEW(JunoAST.And, bp := g, f1 := hints, f2 := grd);
              uv := Utils.StripHints(uv)
            END;
            RETURN NEW(JunoAST.Proj, bp := g, vars := uv,
              body := C1Grd(NEW(JunoAST.Guard, bp := g,
                grd := grd, body := c.body)))
          END
      | JunoAST.Else (c) =&gt;                                (* rule C1.13 *)
          RETURN NEW(JunoAST.Else, bp := c,
            c1 := C1Grd(NEW(JunoAST.Guard,
              bp := g, grd := g.grd, body := c.c1)),
            c2 := C1Grd(NEW(JunoAST.Guard,
              bp := g, grd := g.grd, body := c.c2)))
      | JunoAST.Seq (c) =&gt;                                 (* rule C1.14 *)
          RETURN NEW(JunoAST.Seq, bp := c,
            c1 := C1Grd(NEW(JunoAST.Guard,
              bp := g, grd := g.grd, body := c.c1)),
            c2 := C1(c.c2))
      | JunoAST.Guard (c) =&gt;                               (* rule C1.15 *)
          RETURN C1Grd(NEW(JunoAST.Guard, bp := c,
            grd := NEW(JunoAST.And, bp := g, f1 := g.grd, f2 := c.grd),
            body := c.body))
      | JunoAST.Query =&gt; &lt;* ASSERT FALSE *&gt;
      ELSE                                                 (* rule C1.11 *)
        RETURN NEW(JunoAST.Guard, bp := g,
          grd := g.grd, body := C1(gBody))
      END
    END C1Grd;

  PROCEDURE C2(cmd: JunoAST.Cmd): JunoAST.Cmd RAISES {Error} =
  (* Returns a command equivalent to &quot;cmd&quot; in which:

|     - guard arrows are replaced by queries
|     - constraints are compiled into normal form
|     - projections and E quantifications are eliminated
|     - SAVE commands are eliminated

     This procedure requires that all projected variables are unhinted with
     reset &quot;frozen&quot; bits, but ``de-sugars'' hints on existentially quantified
     variables.

     Here are the compilation rules implemented by this procedure:

|      C2(DO A OD) == DO C2(A) OD                               (rule C2.05)
|      C2(IF A FI) == IF C2(A) FI                               (rule C2.06)
|      C2(SAVE M IN A END) == M.Save(); C2(A); M.Restore()      (rule C2.07)
|      C2(A ; B) == C2(A) ; C2(B)                               (rule C2.08)
|      C2(A | B) == C2(A) | C2(B)                               (rule C2.09)
|      C2(P -&gt; A) == C2q(P) ; C2(A)                             (rule C2.10)
|      C2(VAR x IN A END) == C2p(A, x)                          (rule C2.11)
|      C2(P?(v)) == C2pp(P, {v})
|      C2(A) == A (SKIP, ABORT, HALT, Assignment, Procedure Call)
  *)
    BEGIN
      cmd := Utils.Ungroup(cmd);
      TYPECASE cmd OF &lt;* NOWARN *&gt;
	JunoAST.Skip, JunoAST.Abort, JunoAST.Halt,
        JunoAST.Assign, JunoAST.ProcCall =&gt;
	  RETURN cmd
      | JunoAST.Do (c) =&gt;				       (* rule C2.05 *)
	  RETURN NEW(JunoAST.Do, bp := c, body := C2(c.body))
      | JunoAST.If (c) =&gt;				       (* rule C2.06 *)
	  RETURN NEW(JunoAST.If, bp := c, body := C2(c.body))
      | JunoAST.Save (c) =&gt;				       (* rule C2.07 *)
          VAR
            save := NEW(JunoAST.ProcCall, bp := c, name := c.save,
              outs := JunoAST.EmptyQIdList, inouts := JunoAST.EmptyQIdList,
              ins := JunoAST.EmptyExprList);
            restore := NEW(JunoAST.ProcCall, bp := c, name := c.restore,
              outs := JunoAST.EmptyQIdList, inouts := JunoAST.EmptyQIdList,
              ins := JunoAST.EmptyExprList);
          BEGIN
            RETURN NEW(JunoAST.Seq, c1 := save,
              c2 := NEW(JunoAST.Seq, c1 := C2(c.body), c2 := restore))
          END
      | JunoAST.Seq (c) =&gt;				       (* rule C2.08 *)
          RETURN C2Seq(c)
      | JunoAST.Else (c) =&gt;				       (* rule C2.09 *)
	  RETURN NEW(JunoAST.Else, bp := c, c1 := C2(c.c1), c2 := C2(c.c2))
      | JunoAST.Guard (c) =&gt;				       (* rule C2.10 *)
	  RETURN NEW(JunoAST.Seq, bp := c, c1 := C2q(c.grd), c2 := C2(c.body))
      | JunoAST.Proj (c) =&gt;				       (* rule C2.11 *)
          (* NOTE: We can drop the projection here since all
	     variables have been annotated and their hints extracted. *)
          RETURN C2p(c.body, c.vars)
      | JunoAST.Query (c) =&gt;
          RETURN C2pp(c.f, c.vars)
      END
    END C2;

  PROCEDURE C2Seq(seq: JunoAST.Seq): JunoAST.Seq RAISES { Error } =
  (* Equivalent to:
|
|      RETURN NEW(JunoAST.Seq, bp := seq,
|        c1 := C2(seq.c1), c2 := C2(seq.c2))
|
     except that it uses fewer stack frames when &quot;seq&quot; is a long
     right-associative list of semi-colon-separated commands. *)
    VAR
      res := NEW(JunoAST.Seq, bp := seq, c1 := C2(seq.c1));
      curr := res;
    BEGIN
      LOOP
        TYPECASE Utils.Ungroup(seq.c2) OF
          JunoAST.Seq (newSeq) =&gt;
            curr.c2 := NEW(JunoAST.Seq, bp := newSeq, c1 := C2(newSeq.c1));
            seq := newSeq;
            curr := curr.c2
        ELSE EXIT
        END
      END;
      curr.c2 := C2(seq.c2);
      RETURN res
    END C2Seq;

  PROCEDURE C2q(pred: JunoAST.Formula): JunoAST.Cmd RAISES {Error} =
  (* Returns a command equivalent to the command &quot;pred?()&quot;. Furthermore, the
     resulting command does not contain any predicates of the form &quot;NOT p&quot;,
     &quot;e1 # e2&quot;, or &quot;(E x ~= e :: p)&quot;. Here are the compilation rules
     implemented by this procedure:

|      C2q(TRUE) == SKIP                                         (rule C2.12)
|      C2q(FALSE) == FAIL                                        (rule C2.13)
|      C2q(NOT P) == FLIP(C2q(P))                                (rule C2.14)
|      C2q(P OR Q) == C2q(P) | C2q(Q)                            (rule C2.15)
|      C2q(P AND Q) == C2q(P) ; C2q(Q)                           (rule C2.16)
|      C2q(e1 # e2) == FLIP((e1 = e2)?())                        (rule C2.17)
|      C2q((E x :: P)) == C2pp((E x :: P), {})                   (rule C2.20)
|      C2q(P) == (P)?() (all other cases)                        (rule C2.21)
*)
    BEGIN
      TYPECASE Utils.Ungroup(pred) OF
	JunoAST.True =&gt;					       (* rule C2.12 *)
	  RETURN JunoAST.SkipVal
      | JunoAST.False =&gt;				       (* rule C2.13 *)
	  RETURN JunoAST.FailVal
      | JunoAST.Not (p) =&gt;				       (* rule C2.14 *)
	  RETURN NEW(JunoAST.Flip, bp := p, body := C2q(p.f))
      | JunoAST.Or (p) =&gt;				       (* rule C2.15 *)
	  RETURN NEW(JunoAST.Else, bp := p, c1 := C2q(p.f1), c2 := C2q(p.f2))
      | JunoAST.And (p) =&gt;				       (* rule C2.16 *)
	  RETURN NEW(JunoAST.Seq, bp := p, c1 := C2q(p.f1), c2 := C2q(p.f2))
      | JunoAST.Differs (p) =&gt;				       (* rule C2.17 *)
	  RETURN NEW(JunoAST.Flip, body := NEW(JunoAST.Query,
	    f := NEW(JunoAST.Equals, bp := p, e1 := p.e1, e2 := p.e2),
	    vars := JunoAST.EmptyNVList))
      | JunoAST.Exists (p) =&gt;				       (* rule C2.20 *)
	  RETURN C2pp(p, vars := JunoAST.EmptyNVList)
      ELSE						       (* rule C2.21 *)
	  RETURN NEW(JunoAST.Query, f := pred, vars := JunoAST.EmptyNVList)
      END
    END C2q;

  PROCEDURE C2p(cmd: JunoAST.Cmd; vars: JunoAST.NearVarList): JunoAST.Cmd
      RAISES {Error} =
  (* Returns a command that first solves the projected variables &quot;vars&quot; for
     the constraint &quot;Grd(cmd)&quot;, and then executes the ``body'' of &quot;cmd&quot;.
     Requires that hints have been extracted from any projected variables in
     &quot;cmd&quot;, that all variables in &quot;vars&quot; are unhinted with reset &quot;frozen&quot;
     bits, and that the &quot;evar&quot; fields of all variables in &quot;vars&quot; are false.

     Here are the compilation rules implemented by this procedure:

|      C2p(VAR v' IN A END, v) == C2p(A, v \union v')            (rule C2.23)
|      C2p(A | B, v) == C2p(A, v) | C2p(B, v)                    (rule C2.24)
|      C2p(A ; B, v) == C2p(A, v) ; C2(B)                        (rule C2.25)
|      C2p(P -&gt; A, v) == C2pp(P, v) ; C2(A)                      (rule C2.26)
|      C2p(A, v) == C2(A) (all other cases)                      (rule C2.22)

     In rule C2.24, a copy of the variable list &quot;v&quot; is made so any
     side-effects on one list do not effect the other.
*)
    BEGIN
      (* Check the pre-condition *)
      VAR l := vars.head; BEGIN
        WHILE l # NIL DO
          &lt;* ASSERT l.frozen = FALSE AND l.hint = JunoAST.NilExpr *&gt;
          &lt;* ASSERT l.evar = FALSE *&gt;
          l := l.next
        END
      END;
      cmd := Utils.Ungroup(cmd);
      TYPECASE cmd OF
	JunoAST.Proj (c) =&gt;				       (* rule C2.23 *)
          (* NOTE: We can drop the projection here since all
	     variables have been annotated and their hints extracted. *)
          RETURN C2p(c.body, Utils.NearVarListUnion(vars, c.vars))
      | JunoAST.Else (c) =&gt;				       (* rule C2.24 *)
          VAR varsCopy := Utils.NearVarListCopy(vars); BEGIN
	    RETURN NEW(JunoAST.Else, bp := c,
              c1 := C2p(c.c1, vars), c2 := C2p(c.c2, varsCopy))
          END
      | JunoAST.Seq (c) =&gt;				       (* rule C2.25 *)
	  RETURN NEW(JunoAST.Seq, bp := c,
            c1 := C2p(c.c1, vars), c2 := C2(c.c2))
      | JunoAST.Guard (c) =&gt;				       (* rule C2.26 *)
	  RETURN NEW(JunoAST.Seq, bp := c,
	    c1 := C2pp(c.grd, vars), c2 := C2(c.body))
      ELSE						       (* rule C2.22 *)
	  RETURN C2(cmd)
      END
    END C2p;

  PROCEDURE C2pp(f: JunoAST.Formula; vars: JunoAST.NearVarList): JunoAST.Cmd
      RAISES {Error} =
  (* Returns a command that solves the projected variables &quot;vars&quot; for the
     constraint &quot;f&quot;. Requires that all variables in &quot;vars&quot; are unhinted, and
     that the &quot;evar&quot; fields of all variables in &quot;vars&quot; are false. The
     &quot;frozen&quot; bits of the variables should be set on entry iff the
     corresponding variable has been initialized; the values of these bits are
     undefined on return. *)
    BEGIN
      RETURN JunoCompileNF.ToCmd(JunoCompileNF.Normalize(f, stack_tbl),
        scp, stack_tbl, xtra_vars := vars);
    END C2pp;

  (* Cmd *)
  BEGIN
    IF annotate THEN
      AnnotateAtoms(cmd, stack_tbl, scp, ASTKind.Cmd, pure := pure)
    END;
    IF debug &gt; 1 THEN
      Wr.PutText(stderr, &quot;\n  Original Command:\n&quot;);
      DebugUnparse(cmd)
    END;
    VAR res := NEW(Result, cmd := C2(C1(cmd))); BEGIN
      IF debug &gt; 2 THEN
        Wr.PutText(stderr, &quot;\n  Compiled Command:\n&quot;);
        DebugUnparse(res.cmd)
      END;
      RETURN res
    END
  END Cmd;
</PRE> ============================== Normal Form ============================== 

<P><PRE>PROCEDURE <A NAME="NormalForm"><procedure>NormalForm</procedure></A>(
    nf: JunoAST.NormalForm;
    scp: JunoScope.T;
    stack_tbl: StackTbl.T;
    xtra_vars: JunoAST.NearVarList := NIL):
  Result RAISES {Error} =
</PRE><BLOCKQUOTE><EM> Compiles the normal-form query <CODE>nf</CODE> in isolation. See the description for
   the procedure <CODE>JunoCompileNF.ToCmd</CODE>. </EM></BLOCKQUOTE><PRE>
  VAR res := NEW(Result, cmd :=
    JunoCompileNF.ToCmd(nf, scp, stack_tbl, xtra_vars));
  BEGIN
    IF debug &gt; 2 THEN
      Wr.PutText(stderr, &quot;\n  Compiled Command:\n&quot;);
      DebugUnparse(res.cmd)
    END;
    RETURN res
  END NormalForm;

PROCEDURE <A NAME="DebugUnparse"><procedure>DebugUnparse</procedure></A>(ast: JunoAST.T) =
  BEGIN
    JunoUnparse.Debug(ast);
    Wr.Flush(stderr)
  END DebugUnparse;

PROCEDURE <A NAME="SaveSlots"><procedure>SaveSlots</procedure></A>(wr: Wr.T) =
  BEGIN
    Wr.PutText(wr, Fmt.Int(dummy_slot) &amp; &quot;\n&quot;);
    BuiltInSlots.Save(wr);
  END SaveSlots;

PROCEDURE <A NAME="RestoreSlots"><procedure>RestoreSlots</procedure></A>(rd: Rd.T) =
  &lt;* FATAL FloatMode.Trap, Lex.Error, Rd.Failure *&gt;
  BEGIN
    dummy_slot := Lex.Int(rd);
    BuiltInSlots.Restore(rd);
  END RestoreSlots;

BEGIN
END JunoCompile.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
