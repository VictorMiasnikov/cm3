<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: metasyn/derived/MetaSynBdl.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>metasyn/derived/MetaSynBdl.m3</H2></A><HR>
<inModule>
<PRE>MODULE <module><implements><A HREF="MetaSynBdl.i3.html">MetaSynBdl</A></implements></module>;
</PRE><BLOCKQUOTE><EM> Generated by m3bundle; see its manpage. </EM></BLOCKQUOTE><PRE>

IMPORT <A HREF="../../libm3/src/bundleintf/Bundle.i3.html">Bundle</A>, <A HREF="../../libm3/src/bundleintf/BundleRep.i3.html">BundleRep</A>, <A HREF="../../m3core/src/text/Text.i3.html">Text</A>;

TYPE T = Bundle.T OBJECT OVERRIDES
           get      := LookUp;
           getNames := GetNames;
         END;

TYPE Texts = REF ARRAY OF TEXT;

VAR
  bundle: T     := NIL;
  names : Texts := NIL;

PROCEDURE <A NAME="Get"><procedure>Get</procedure></A>(): Bundle.T =
  BEGIN
    IF (bundle = NIL) THEN bundle := NEW (T) END;
    RETURN bundle;
  END Get;

PROCEDURE <A NAME="GetNames"><procedure>GetNames</procedure></A> (&lt;*UNUSED*&gt; self: T): Texts =
  BEGIN
    IF names = NIL THEN
      names := NEW (Texts, NUMBER (Names));
      names^ := Names;
    END;
    RETURN names;
  END GetNames;

PROCEDURE <A NAME="LookUp"><procedure>LookUp</procedure></A> (&lt;*UNUSED*&gt; self: T;  element: TEXT): TEXT =
  BEGIN
    FOR i := 0 TO LAST (Names)-1 DO
      IF Text.Equal (Names[i], element) THEN
        RETURN Elements[i];
      END;
    END;
    RETURN NIL;
  END LookUp;

CONST Names = ARRAY [0..2] OF TEXT {
  &quot;MetaGram&quot;,
  &quot;ExtendGram&quot;,
  NIL
};

CONST Elements = ARRAY [0..2] OF TEXT {
  E0,
  E1,
  NIL
};

CONST E0 =
   &quot;grammar ::=\n     clauseSeq\nclauseSeq ::=\n     [ \tgramExpIde _1\n\t\&quot;&quot;
 &amp; &quot;::=\&quot; \n\tclauseExtends_2 \n\tgramExp_3\n\tclauseRest_4 \n\t] :: Clause&quot;
 &amp; &quot;List\nclauseRest ::=\n     { \&quot;EOF\&quot; clauseSeq  }\nclauseExtends ::=\n &quot;
 &amp; &quot;    { [ \&quot;.\&quot; \&quot;.\&quot; \&quot;.\&quot; \n        { [ \&quot;*\&quot; { [ \&quot;_\&quot; int_3 ] :: Clau&quot;
 &amp; &quot;seExtendsIterPos \n\t          []            :: ClauseExtendIterNoPos \n&quot;
 &amp; &quot;                }_2 ]  :: ClauseExtendsIter \n          []           ::&quot;
 &amp; &quot; ClauseExtendsChoice\n        }_1 \n       ]   :: ClauseExtendsYes\n   &quot;
 &amp; &quot;    []  :: ClauseExtendsNo\n     }_1\n\ngramExpIde ::=\n     ide\n\ngra&quot;
 &amp; &quot;mExp ::=\n     [ gramExpBase_1 \n\t{ [ \&quot;_\&quot; int_3 ]::Storage [ \&quot;::\&quot; &quot;
 &amp; &quot;sum_3 ]::caction []::select1 }_2 \n     ]::select2\n\n\ngramExpBase ::=&quot;
 &amp; &quot;\n     { ide_1    :: GramIde\n       string_1 :: GramString\n       \&quot;i&quot;
 &amp; &quot;de\&quot;    :: GramKeyIde\n       \&quot;int\&quot;    :: GramKeyInt\n       \&quot;EOF\&quot; &quot;
 &amp; &quot;   :: GramKeyEof\n       \&quot;real\&quot;   :: GramKeyReal\n       \&quot;char\&quot;   :&quot;
 &amp; &quot;: GramKeyChar\n       \&quot;string\&quot; :: GramKeyString \n       gramExpSeque&quot;
 &amp; &quot;nce \n       gramExpChoice   \n       gramExpParens \n     }\n\ngramExp&quot;
 &amp; &quot;Sequence ::=\n     [ \&quot;[\&quot; gramExpList \&quot;]\&quot; ]   :: GramExpSequence\n  &quot;
 &amp; &quot;\ngramExpChoice ::=\n     [ \&quot;{\&quot; gramExpList_1 \&quot;}\&quot; ] :: GramExpChoic&quot;
 &amp; &quot;e\n  \ngramExpParens ::=\n     [ \&quot;(\&quot; gramExp_1\n     { [ \&quot;*\&quot; { [ \&quot;&quot;
 &amp; &quot;_\&quot; int_4 gramExp_3  ] :: GramExpIterPos\n               gramExp_3     &quot;
 &amp; &quot;           :: GramExpIterNoPos  \n             }_5 ]  :: GramExpIter\n &quot;
 &amp; &quot;      []           :: GramExpBase   }_6\n     \&quot;)\&quot; ]  :: GramExpParens&quot;
 &amp; &quot;\n  \ngramExpList ::=\n     { [ gramExp_1 gramExpList_2 ]::GramList [] &quot;
 &amp; &quot;}\n  \n  \n\n\n&quot;;

CONST E1 =
   &quot;(* Grammar file for extensible grammars, using MPTreeSubst as their\n  &quot;
 &amp; &quot; substitution\troutine *)\n\ngrammar ::=\n     clauseSeq\nclauseSeq ::=&quot;
 &amp; &quot;\n     [ \tgramExpIde _1\n        paramList_5\n\t\&quot;::=\&quot; \n\tclauseExte&quot;
 &amp; &quot;nds_2 \n\tgramExp_3\n\tclauseRest_4 \n\t] :: ClauseList\nclauseRest ::=&quot;
 &amp; &quot;\n     { clauseSeq [] }\nclauseExtends ::=\n     { [ \&quot;.\&quot; \&quot;.\&quot; \&quot;.\&quot; &quot;
 &amp; &quot;\n        { [ \&quot;*\&quot; { [ \&quot;_\&quot; int_3 ] :: ClauseExtendsIterPos \n\t     &quot;
 &amp; &quot;     []            :: ClauseExtendsIterNoPos \n                }_2 ]  :&quot;
 &amp; &quot;: ClauseExtendsIter \n          []           :: ClauseExtendsChoice\n  &quot;
 &amp; &quot;      }_1 \n       ]   :: ClauseExtendsYes\n       []  :: ClauseExtends&quot;
 &amp; &quot;No\n     }\n\n\n\nparamList ::= { [ \&quot;&lt;\&quot; paramList2_1 \&quot;&gt;\&quot; ]::select1&quot;
 &amp; &quot; [] }\nparamList2 ::= { [ \&quot;_\&quot; int_1 { [ \&quot;,\&quot; paramList2_2 ]::select2&quot;
 &amp; &quot; [] }_2 ]::cons [] }\n\n\n(*3456789012345678901234567890123456789012345&quot;
 &amp; &quot;678901234567890*)\n(*       1         2         3         4         5  &quot;
 &amp; &quot;        *)\n\ngramExp ::=\n     [ gramExpBase_1 \n\t{ [ \&quot;_\&quot; int_3 ]::&quot;
 &amp; &quot;Storage \n          [ ExtendAction&lt;_1&gt;_2 ] :: select2\n          []::se&quot;
 &amp; &quot;lect1 }_2 \n     ]::select2\n\n\ngramExpBase ::=\n     { [ ide_1 paramL&quot;
 &amp; &quot;ist_2 ] :: GramIde\n       string_1              :: GramString\n       &quot;
 &amp; &quot;\&quot;ide\&quot;                 :: GramKeyIde\n       \&quot;int\&quot;                 :&quot;
 &amp; &quot;: GramKeyInt\n       \&quot;EOF\&quot;                 :: GramKeyEof\n       \&quot;re&quot;
 &amp; &quot;al\&quot;                :: GramKeyReal\n       \&quot;char\&quot;                :: G&quot;
 &amp; &quot;ramKeyChar\n       \&quot;string\&quot;              :: GramKeyString \n       gr&quot;
 &amp; &quot;amExpSequence \n       gramExpChoice   \n       gramExpParens \n     }\n&quot;
 &amp; &quot;\ngramExpIde ::=\n     ide_1 :: Ide\n\n\ngramExpSequence ::=\n     [ \&quot;&quot;
 &amp; &quot;[\&quot; gramExpList_1 \&quot;]\&quot; ]   :: GramExpSequence\n  \ngramExpChoice ::=\n&quot;
 &amp; &quot;     [ \&quot;{\&quot; gramExpList_1 \&quot;}\&quot; ] :: GramExpChoice\n  \ngramExpParens &quot;
 &amp; &quot;::=\n     [ \&quot;(\&quot; gramExp_1\n     { [ \&quot;*\&quot; { [ \&quot;_\&quot; int_4 gramExp_3  &quot;
 &amp; &quot;] :: GramExpIterPos\n               gramExp_3                :: GramExp&quot;
 &amp; &quot;IterNoPos  \n             }_5 ]  :: GramExpIter\n       []           ::&quot;
 &amp; &quot; GramExpBase   }_6\n     \&quot;)\&quot; ]  :: GramExpParens\n  \ngramExpList ::=&quot;
 &amp; &quot;\n     { [ gramExp_1 gramExpList_2 ]::GramList [] }\n\n\n\n\n\n\n\n&quot;;

BEGIN
END MetaSynBdl.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
