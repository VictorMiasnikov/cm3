<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: cm3ide/src/nodes/Roots.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>cm3ide/src/nodes/Roots.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright 1996 Critical Mass, Inc. All rights reserved.    

<P><PRE>MODULE <module><implements><A HREF="Roots.i3.html">Roots</A></implements></module>;

IMPORT <A HREF="../../../m3core/src/time/Common/FmtTime.i3.html">FmtTime</A>, <A HREF="../../../libm3/src/os/Common/FS.i3.html">FS</A>, <A HREF="../../../libm3/derived/IntList.i3.html">IntList</A>, <A HREF="../../../libm3/derived/IntRefTbl.i3.html">IntRefTbl</A>, <A HREF="../../../libm3/src/os/Common/OSError.i3.html">OSError</A>, <A HREF="../../../libm3/src/os/Common/Pathname.i3.html">Pathname</A>, <A HREF="../../../m3core/src/text/Text.i3.html">Text</A>, <A HREF="../../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../../libm3/src/rw/Wr.i3.html">Wr</A>;
IMPORT <A HREF="../misc/BrowserDB.i3.html">BrowserDB</A>, <A HREF="BuildCache.i3.html">BuildCache</A>, (**ClassDir,**) <A HREF="../misc/ConfigItem.i3.html">ConfigItem</A>, <A HREF="../misc/Default.i3.html">Default</A>, <A HREF="Dir.i3.html">Dir</A>, <A HREF="#x1">ErrLog</A>, <A HREF="FileDir.i3.html">FileDir</A>;
IMPORT <A HREF="FileNode.i3.html">FileNode</A>, <A HREF="Fixed.i3.html">Fixed</A>, <A HREF="#x2">HTML</A>, <A HREF="#x3">ID</A>, <A HREF="../utils/LexMisc.i3.html">LexMisc</A>, <A HREF="Node.i3.html">Node</A>, <A HREF="#x4">OS</A>, <A HREF="Pkg.i3.html">Pkg</A>, <A HREF="PkgRoot.i3.html">PkgRoot</A>, <A HREF="../utils/RegExpr.i3.html">RegExpr</A>, <A HREF="#x5">Type</A>;
IMPORT <A HREF="../misc/WebServer.i3.html">WebServer</A>, <A HREF="#x6">Wx</A>;

TYPE NC = Node.Class;

VAR
  viewID   := ID.Add (&quot;view&quot;);
  rescanID := ID.Add (&quot;rescan&quot;);

PROCEDURE <A NAME="Init"><procedure>Init</procedure></A> () =
  BEGIN
    PkgRootRoot := NEW (RootRoot, name := ID.Add (&quot;root&quot;));
    WebServer.RegisterRoot (&quot;root&quot;, PkgRootRoot);

    AnyPkgRoot := NEW (PkgRoots, name := ID.Add (&quot;package&quot;));
    (** AddClassEntries (AnyPkgRoot); **)
    WebServer.RegisterRoot (&quot;package&quot;, AnyPkgRoot);
    WebServer.RegisterRoot (&quot;pkg&quot;, AnyPkgRoot);

    ResourceRoot := NEW (FixedRoot, name := ID.Add (&quot;rsrc&quot;));
    WebServer.RegisterRoot (&quot;rsrc&quot;, ResourceRoot);

    TypeRoot := NEW (TNameRoot, name := ID.Add (&quot;type&quot;));
    WebServer.RegisterRoot (&quot;type&quot;, TypeRoot);

    TypeUIDRoot := NEW (TUIDRoot, name := ID.Add (&quot;type-uid&quot;));
    WebServer.RegisterRoot (&quot;type-uid&quot;, TypeUIDRoot);
    WebServer.RegisterRoot (&quot;type uid&quot;, TypeUIDRoot);
    WebServer.RegisterRoot (&quot;uid&quot;, TypeUIDRoot);

    InterfaceRoot := NEW (SourceRoot, name := ID.Add (&quot;interface&quot;),
                        kind := NC.Interface);
    WebServer.RegisterRoot (&quot;interface&quot;, InterfaceRoot);
    WebServer.RegisterRoot (&quot;intf&quot;, InterfaceRoot);

    ModuleRoot :=  NEW (SourceRoot, name := ID.Add (&quot;module&quot;),
                        kind := NC.Module);
    WebServer.RegisterRoot (&quot;module&quot;, ModuleRoot);
    WebServer.RegisterRoot (&quot;implementation&quot;, ModuleRoot);
    WebServer.RegisterRoot (&quot;impl&quot;, ModuleRoot);

    GenIntfRoot :=  NEW (SourceRoot, name := ID.Add (&quot;generic-interface&quot;),
                        kind := NC.GenericInterface);
    WebServer.RegisterRoot (&quot;generic-interface&quot;, GenIntfRoot);
    WebServer.RegisterRoot (&quot;generic interface&quot;, GenIntfRoot);
    WebServer.RegisterRoot (&quot;generic-intf&quot;, GenIntfRoot);
    WebServer.RegisterRoot (&quot;generic intf&quot;, GenIntfRoot);
    WebServer.RegisterRoot (&quot;gen-interface&quot;, GenIntfRoot);
    WebServer.RegisterRoot (&quot;gen interface&quot;, GenIntfRoot);
    WebServer.RegisterRoot (&quot;gen-intf&quot;, GenIntfRoot);
    WebServer.RegisterRoot (&quot;gen intf&quot;, GenIntfRoot);

    GenImplRoot := NEW (SourceRoot, name := ID.Add (&quot;generic-module&quot;),
                        kind := NC.GenericModule);
    WebServer.RegisterRoot (&quot;generic-module&quot;, GenImplRoot);
    WebServer.RegisterRoot (&quot;generic module&quot;, GenImplRoot);
    WebServer.RegisterRoot (&quot;generic-implementation&quot;, GenImplRoot);
    WebServer.RegisterRoot (&quot;generic implementation&quot;, GenImplRoot);
    WebServer.RegisterRoot (&quot;generic-impl&quot;, GenImplRoot);
    WebServer.RegisterRoot (&quot;generic impl&quot;, GenImplRoot);
    WebServer.RegisterRoot (&quot;gen-module&quot;, GenImplRoot);
    WebServer.RegisterRoot (&quot;gen module&quot;, GenImplRoot);
    WebServer.RegisterRoot (&quot;gen-implementation&quot;, GenImplRoot);
    WebServer.RegisterRoot (&quot;gen implementation&quot;, GenImplRoot);
    WebServer.RegisterRoot (&quot;gen-impl&quot;, GenImplRoot);
    WebServer.RegisterRoot (&quot;gen impl&quot;, GenImplRoot);

    CsourceRoot := NEW (SourceRoot, name := ID.Add (&quot;c-source&quot;),
                        kind := NC.CSource);
    WebServer.RegisterRoot (&quot;c-source&quot;, CsourceRoot);
    WebServer.RegisterRoot (&quot;c source&quot;, CsourceRoot);

    HsourceRoot := NEW (SourceRoot, name := ID.Add (&quot;h-source&quot;),
                        kind := NC.HSource);
    WebServer.RegisterRoot (&quot;h-source&quot;, HsourceRoot);
    WebServer.RegisterRoot (&quot;h source&quot;, HsourceRoot);

    AnyUnitRoot := NEW (UnitRoot, name := ID.Add (&quot;unit&quot;));
    WebServer.RegisterRoot (&quot;unit&quot;, AnyUnitRoot);
    WebServer.RegisterRoot (&quot;source&quot;, AnyUnitRoot);

    ImporterRoot := NEW (ImportRoot, name := ID.Add (&quot;importer&quot;));
    WebServer.RegisterRoot (&quot;importer&quot;, ImporterRoot);

    ExporterRoot := NEW (ExportRoot, name := ID.Add (&quot;exporter&quot;));
    WebServer.RegisterRoot (&quot;exporter&quot;, ExporterRoot);

    LibraryRoot := NEW (DerivedRoot, name := ID.Add (&quot;library&quot;), pgm := FALSE);
    WebServer.RegisterRoot (&quot;library&quot;, LibraryRoot);
    WebServer.RegisterRoot (&quot;lib&quot;, LibraryRoot);

    ProgramRoot := NEW (DerivedRoot, name := ID.Add (&quot;program&quot;), pgm := TRUE);
    WebServer.RegisterRoot (&quot;program&quot;, ProgramRoot);
    WebServer.RegisterRoot (&quot;pgm&quot;, ProgramRoot);

    BuildCacheRoot := NEW (CacheRoot, name := ID.Add (&quot;build-cache&quot;));
    WebServer.RegisterRoot (&quot;build-cache&quot;, BuildCacheRoot);

    TutorialRoot := NEW (DocumentRoot, name := ID.Add (&quot;tutorial&quot;),
                         base := &quot;tutorial&quot;, title := &quot;Modula-3 Tutorial&quot;);
    WebServer.RegisterRoot (&quot;tutorial&quot;, TutorialRoot);

    HelpRoot := NEW (DocumentRoot,  name := ID.Add (&quot;help&quot;),
                     base := &quot;help&quot;,  title := &quot;CM3-IDE Help&quot;);
    WebServer.RegisterRoot (&quot;help&quot;, HelpRoot);

    RefManualRoot := NEW (DocumentRoot, name := ID.Add (&quot;reference&quot;),
                          base := &quot;reference&quot;,
                          title := &quot;Critical Mass Modula-3 Reference Manual&quot;);
    WebServer.RegisterRoot (&quot;ref&quot;, RefManualRoot);
    WebServer.RegisterRoot (&quot;reference&quot;, RefManualRoot);

    SRCReportRoot := NEW (DocumentRoot, name := ID.Add (&quot;SRC_report&quot;),
                          base := &quot;src_reports&quot;, title := &quot;SRC Research Reports&quot;);
    WebServer.RegisterRoot (&quot;SRC_report&quot;, SRCReportRoot);
    WebServer.RegisterRoot (&quot;src_report&quot;, SRCReportRoot);

    ExampleRoot := NEW (ExamplesRoot, name := ID.Add (&quot;example&quot;));
    WebServer.RegisterRoot (&quot;example&quot;, ExampleRoot);

    ConsoleLogRoot := NEW (LogRoot, name := ID.Add (&quot;log&quot;));
    WebServer.RegisterRoot (&quot;log&quot;, ConsoleLogRoot);

    UserHomeDir := NEW (UserRoot, name := ID.Add (&quot;user&quot;));
    WebServer.RegisterRoot (&quot;user&quot;, UserHomeDir);
  END Init;

PROCEDURE <A NAME="RootClass"><procedure>RootClass</procedure></A> (&lt;*UNUSED*&gt; self: Node.T): Node.Class =
  BEGIN
    RETURN Node.Class.Root;
  END RootClass;

PROCEDURE <A NAME="GenScanWarning"><procedure>GenScanWarning</procedure></A> (wx: Wx.T)
  RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    IF BrowserDB.n_updates &lt; 1 THEN
      wx.put (&quot;&lt;P&gt;\n&lt;STRONG&gt;Initial package scan is still underway...&lt;/STRONG&gt;\n&quot;);
      wx.put (&quot;&lt;META HTTP-EQUIV=\&quot;Refresh\&quot; CONTENT=2&gt;\n&quot;);
    ELSE
      wx.put (&quot;&lt;P&gt;\nLast scanned: &quot;,
              FmtTime.Short (OS.FileToM3Time (BrowserDB.last_update)),
              &quot;\n&quot;);
    END;
  END GenScanWarning;

PROCEDURE <A NAME="TableIterate"><procedure>TableIterate</procedure></A> (tbl: IntRefTbl.T;  VAR s: Node.IteratorState) =
  VAR nm := RegExpr.SimpleString (s.pattern);  ref: REFANY;
  BEGIN
    s.d := NIL;
    s.e := NIL;
    s.f := NIL;

    (* try a direct hit instead of a full scan! *)
    IF (nm # NIL) AND (tbl # NIL) AND tbl.get (ID.Add (nm), ref)
      THEN s.d := ref;
      ELSE s.e := tbl.iterate ();
    END;
  END TableIterate;

TYPE FilterProc = PROCEDURE (root, node: Node.T): BOOLEAN;

PROCEDURE <A NAME="TableNext"><procedure>TableNext</procedure></A> (root: Node.T;  VAR s: Node.IteratorState;
                     filter: FilterProc): BOOLEAN =
  VAR
    nd   : Node.List;
    n    : Node.T;
    iter : IntRefTbl.Iterator;
    nm   : INTEGER;
    ref  : REFANY;
  BEGIN
    IF (s.d # NIL) THEN
      (* try the direct hits first *)
      nd := s.d;  s.d := nd.tail;
      WHILE (nd # NIL) DO
        n := nd.head;  nd := nd.tail;  s.d := nd;
        IF (filter = NIL) OR filter (root, n) THEN
          s.match := n;
          RETURN TRUE;
        END;
      END;
    END;

    WHILE (s.e # NIL) DO
      nd := s.f;
      WHILE (nd # NIL) DO
        n := nd.head;  nd := nd.tail;  s.f := nd;
        IF ((filter = NIL) OR filter (root, n)) AND n.match (s.pattern) THEN
          s.match := n;
          RETURN TRUE;
        END;
      END;

      iter := s.e;
      IF NOT iter.next (nm, ref) THEN EXIT; END;
      s.f := ref;
    END;

    (* failed... *)
    s.d := NIL;
    s.e := NIL;
    s.f := NIL;
    RETURN FALSE;
  END TableNext;

PROCEDURE <A NAME="NameTableNext"><procedure>NameTableNext</procedure></A> (VAR s: Node.IteratorState): BOOLEAN =
  VAR
    nd   : Node.List;
    iter : IntRefTbl.Iterator;
    nms  : IntList.T;
    nm   : INTEGER;
    ref  : REFANY;
  BEGIN
    WHILE (s.f # NIL) OR (s.e # NIL) OR (s.d # NIL) DO
      IF (s.f # NIL) THEN
        (* return the next unit *)
        nd := s.f;  s.f := nd.tail;
        s.match := nd.head;
        RETURN TRUE;
      END;

      IF (s.d # NIL) THEN
        (* try the current name list *)
        nms := s.d;
        WHILE (nms # NIL) AND (s.f = NIL) DO
          nm := nms.head;  nms := nms.tail;  s.d := nms;
          IF BrowserDB.db.units.get (nm, ref) THEN
            s.f := ref;
          END;
        END;
      END;

      WHILE (s.e # NIL) AND (s.d = NIL) AND (s.f = NIL) DO
        iter := s.e;
        IF NOT iter.next (nm, ref) THEN s.e := NIL; EXIT; END;
        IF RegExpr.Match (s.pattern, ID.ToText (nm)) THEN
          s.d := ref;
        END;
      END;

    END; (*WHILE*)
    RETURN FALSE;
  END NameTableNext;

PROCEDURE <A NAME="TableEnumerate"><procedure>TableEnumerate</procedure></A> (root: Node.T;  tbl: IntRefTbl.T;
                          filter: FilterProc): Node.Set =
  VAR
    results : Node.Set;
    iter    := tbl.iterate ();
    nm      : INTEGER;
    ref     : REFANY;
    nd      : Node.List;
  BEGIN
    WHILE iter.next (nm, ref) DO
      nd := ref;
      WHILE (nd # NIL) DO
        IF (filter = NIL) OR filter (root, nd.head) THEN
          Node.Append (results, nd.head);
        END;
        nd := nd.tail;
      END;
    END;
    RETURN results;
  END TableEnumerate;

PROCEDURE <A NAME="GenTable"><procedure>GenTable</procedure></A> (root: Node.T;  tbl: IntRefTbl.T;
                    filter: FilterProc;  wx: Wx.T)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR results := TableEnumerate (root, tbl, filter);
  BEGIN
    HTML.GenChoices (results, wx);
  END GenTable;
</PRE>------------------------------------------------ package root nodes ---

<P><PRE>TYPE
  RootRoot = Node.Named_T OBJECT
  OVERRIDES
    class      := RootClass;
    iterate    := RootRootIterate;
    next       := RootRootNext;
    gen_page   := RootRootPage;
  END;

PROCEDURE <A NAME="RootRootIterate"><procedure>RootRootIterate</procedure></A> (&lt;*UNUSED*&gt; self: RootRoot;  VAR s: Node.IteratorState) =
  BEGIN
    s.d := PkgRoot.First ();
  END RootRootIterate;

PROCEDURE <A NAME="RootRootNext"><procedure>RootRootNext</procedure></A> (&lt;*UNUSED*&gt; self: RootRoot;
                        VAR s: Node.IteratorState): BOOLEAN =
  VAR nd: PkgRoot.T;
  BEGIN
    nd := s.d;
    WHILE (nd # NIL) DO
      s.d := nd.sibling;
      IF nd.match (s.pattern) THEN
        s.match := nd;
        RETURN TRUE;
      END;
      nd := nd.sibling;
    END;
    RETURN FALSE;
  END RootRootNext;

PROCEDURE <A NAME="RootRootPage"><procedure>RootRootPage</procedure></A> (self: RootRoot;  wx: Wx.T;
                       action: ID.T;  data: Node.FormData)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR nd: PkgRoot.T;  results: Node.Set;
  BEGIN
    HTML.BeginXX (self, wx, &quot;Package roots&quot;);
    GenScanWarning (wx);

    wx.put (&quot;&lt;P&gt;\n&lt;TABLE&gt;&lt;TR&gt;\n&quot;);
    GenButton (&quot;./[rescan]&quot;, &quot;Rescan&quot;, wx);
    GenButton (&quot;/form/new-pkg/&quot;, &quot;Create package&quot;, wx);
    wx.put (&quot;&lt;/TR&gt;&lt;/TABLE&gt;\n&quot;);

    IF (action = rescanID) THEN
      BrowserDB.Refresh (wx);
      action := viewID;
    ELSE
      nd := PkgRoot.First ();
      WHILE (nd # NIL) DO
        Node.Append (results, nd);
        nd := nd.sibling;
      END;
      HTML.GenChoices (results, wx);
    END;

    HTML.ViewOnly (action, data, wx);
    HTML.End (wx);
  END RootRootPage;
</PRE>------------------------------------------------ package root nodes ---

<P><PRE>TYPE
  PkgRoots = Node.Named_T OBJECT
</PRE><BLOCKQUOTE><EM>**
    build_class  : ClassDir.T;
    browse_class : ClassDir.T;
*</EM></BLOCKQUOTE><PRE>
  OVERRIDES
    class      := RootClass;
    iterate    := PkgRootIterate;
    next       := PkgRootNext;
    gen_page   := PkgRootPage;
  END;
</PRE>**
PROCEDURE AddClassEntries (t: PkgRoots) =
  BEGIN
    t.build_class := NEW (ClassDir.T,
                          name := Node.ClassID[Node.Class.BuildPackage],
                          kind := Node.Class.BuildPackage,
                          parent := t);
    t.browse_class := NEW (ClassDir.T,
                           name := Node.ClassID[Node.Class.BrowsePackage],
                           kind := Node.Class.BrowsePackage,
                           parent := t);
  END AddClassEntries;
**

<P><PRE>PROCEDURE <A NAME="PkgRootIterate"><procedure>PkgRootIterate</procedure></A> (&lt;*UNUSED*&gt; self: PkgRoots;  VAR s: Node.IteratorState) =
  BEGIN
    TableIterate (BrowserDB.db.packages, s);
    s.a := 0; (* phase *)
    s.f := NIL;
  END PkgRootIterate;

PROCEDURE <A NAME="PkgRootNext"><procedure>PkgRootNext</procedure></A> (self: PkgRoots;  VAR s: Node.IteratorState): BOOLEAN =
  VAR root: Node.Named_T;
  BEGIN
    IF (s.a = 0) THEN
      IF TableNext (self, s, NIL) THEN RETURN TRUE; END;
      s.f := PkgRoot.First ();
      INC (s.a);
    END;
    IF (s.a = 1) THEN
      WHILE (s.f # NIL) DO
        root := s.f;  s.f := root.sibling;
        IF root.match (s.pattern) THEN
          s.match := root;
          RETURN TRUE;
        END;
      END;
      INC (s.a);
    END;
    RETURN FALSE;
  END PkgRootNext;

PROCEDURE <A NAME="PkgRootPage"><procedure>PkgRootPage</procedure></A> (self: PkgRoots;  wx: Wx.T;
                       action: ID.T;  data: Node.FormData)
  RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    HTML.BeginXX (self, wx, &quot;Packages&quot;);
    GenScanWarning (wx);

    wx.put (&quot;&lt;P&gt;\n&lt;TABLE&gt;&lt;TR&gt;\n&quot;);
    GenButton (&quot;./[rescan]&quot;, &quot;Rescan&quot;, wx);
    GenButton (&quot;/form/new-pkg/&quot;, &quot;Create package&quot;, wx);
    wx.put (&quot;&lt;/TR&gt;&lt;/TABLE&gt;\n&quot;);

    IF (action = rescanID) THEN
      BrowserDB.Refresh (wx);
      action := viewID;
    ELSE
      GenTable (self, BrowserDB.db.packages, NIL, wx);
    END;

    HTML.ViewOnly (action, data, wx);
    HTML.End (wx);
  END PkgRootPage;

PROCEDURE <A NAME="GenButton"><procedure>GenButton</procedure></A> (url, label: TEXT;  wx: Wx.T)
  RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    wx.put (&quot;&lt;TD&gt;&lt;FORM method=get action=\&quot;&quot;, url, &quot;\&quot;&gt;&quot;);
    wx.put (&quot;&lt;INPUT TYPE=submit VALUE=\&quot;&quot;, label, &quot;\&quot;&gt;&lt;/FORM&gt;&lt;/TD&gt;\n&quot;);
  END GenButton;
</PRE>-------------------------------------------------- fixed root nodes ---

<P><PRE>TYPE
  FixedRoot = Node.Named_T OBJECT
  OVERRIDES
    class      := RootClass;
    iterate    := FixedRootIterate;
    next       := FixedRootNext;
    gen_page   := FixedRootPage;
  END;

PROCEDURE <A NAME="FixedRootIterate"><procedure>FixedRootIterate</procedure></A> (&lt;*UNUSED*&gt; self: FixedRoot;
                            VAR s: Node.IteratorState) =
  BEGIN
    s.d := RegExpr.SimpleString (s.pattern);
  END FixedRootIterate;

PROCEDURE <A NAME="FixedRootNext"><procedure>FixedRootNext</procedure></A> (&lt;*UNUSED*&gt; self: FixedRoot;
                         VAR s: Node.IteratorState): BOOLEAN =
  BEGIN
    IF (s.d # NIL) THEN
      s.match := Fixed.Find (s.d);
      s.d := NIL;
      IF (s.match # NIL) THEN RETURN TRUE; END;
    END;
    RETURN FALSE;
  END FixedRootNext;

PROCEDURE <A NAME="FixedRootPage"><procedure>FixedRootPage</procedure></A> (self: FixedRoot;  wx: Wx.T;
                         action: ID.T;  data: Node.FormData)
  RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    HTML.BeginXX (self, wx, &quot;Fixed resources&quot;);
    HTML.ViewOnly (action, data, wx);
    HTML.End (wx);
  END FixedRootPage;
</PRE>-------------------------------------------------- user root nodes ---

<P><PRE>TYPE
  UserRoot = Node.Named_T OBJECT
    home  : TEXT;
    root  : FileDir.T := NIL;
  OVERRIDES
    class      := RootClass;
    iterate    := UserRootIterate;
    next       := UserRootNext;
    gen_page   := UserRootPage;
  END;

PROCEDURE <A NAME="UserRootIterate"><procedure>UserRootIterate</procedure></A> (self: UserRoot;
                           VAR s: Node.IteratorState) =
  VAR user_home := ConfigItem.X [ConfigItem.T.Homepage].text;
  BEGIN
    IF (user_home # NIL) AND Text.Length (user_home) &gt; 0 THEN
      IF (self.home = NIL) OR NOT OS.FileNameEq (user_home, self.home) THEN
        (* we have a new root *)
        self.home := user_home;
        self.root := NEW (FileDir.T, name := ID.Add (&quot;user&quot;),
                           path := Pathname.Prefix (user_home));
      END;
    ELSE
      self.root := NIL;
    END;
    IF (self.root # NIL) THEN self.root.iterate (s); END;
  END UserRootIterate;

PROCEDURE <A NAME="UserRootNext"><procedure>UserRootNext</procedure></A> (self: UserRoot;
                        VAR s: Node.IteratorState): BOOLEAN =
  BEGIN
    IF (self.root # NIL)
      THEN RETURN self.root.next (s);
      ELSE RETURN FALSE;
    END;
  END UserRootNext;

PROCEDURE <A NAME="UserRootPage"><procedure>UserRootPage</procedure></A> (self: UserRoot;  wx: Wx.T;
                         action: ID.T;  data: Node.FormData)
  RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    IF (self.root # NIL) THEN
      self.root.gen_page (wx, action, data);
    ELSE
      HTML.BeginXX (self, wx, &quot;User pages&quot;);
      HTML.ViewOnly (action, data, wx);
      HTML.End (wx);
    END;
  END UserRootPage;
</PRE>---------------------------------------------- type name root nodes ---

<P><PRE>TYPE
  TNameRoot = Node.Named_T OBJECT
  OVERRIDES
    class      := RootClass;
    iterate    := TNameRootIterate;
    next       := TNameRootNext;
    gen_page   := TNameRootPage;
  END;

PROCEDURE <A NAME="TNameRootIterate"><procedure>TNameRootIterate</procedure></A> (&lt;*UNUSED*&gt; self: TNameRoot;
                            VAR s: Node.IteratorState) =
  BEGIN
    TableIterate (BrowserDB.db.type_names, s);
  END TNameRootIterate;

PROCEDURE <A NAME="TNameRootNext"><procedure>TNameRootNext</procedure></A> (self: TNameRoot;  VAR s: Node.IteratorState): BOOLEAN =
  BEGIN
    RETURN TableNext (self, s, NIL);
  END TNameRootNext;

PROCEDURE <A NAME="TNameRootPage"><procedure>TNameRootPage</procedure></A> (self: TNameRoot;  wx: Wx.T;
                         action: ID.T;  data: Node.FormData)
  RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    HTML.BeginXX (self, wx, &quot;Types&quot;);
    GenScanWarning (wx);
    GenTable (self, BrowserDB.db.type_names, NIL, wx);
    HTML.ViewOnly (action, data, wx);
    HTML.End (wx);
  END TNameRootPage;
</PRE>----------------------------------------------- type UID root nodes ---

<P><PRE>TYPE
  TUIDRoot = Node.Named_T OBJECT
  OVERRIDES
    class      := RootClass;
    iterate    := TUIDRootIterate;
    next       := TUIDRootNext;
    gen_page   := TUIDRootPage;
  END;

PROCEDURE <A NAME="TUIDRootIterate"><procedure>TUIDRootIterate</procedure></A> (&lt;*UNUSED*&gt; self: TUIDRoot;  VAR s: Node.IteratorState) =
  VAR txt := RegExpr.SimpleString (s.pattern);
  BEGIN
    IF (txt # NIL) THEN
      IF NOT BrowserDB.db.types.get (LexMisc.ScanUID (txt), s.d) THEN
        s.d := NIL;
      END;
      s.e := NIL;
    ELSE
      s.d := NIL;
      s.e := BrowserDB.db.types.iterate ();
    END;
  END TUIDRootIterate;

PROCEDURE <A NAME="TUIDRootNext"><procedure>TUIDRootNext</procedure></A> (&lt;*UNUSED*&gt; self: TUIDRoot;
                        VAR s: Node.IteratorState): BOOLEAN =
  VAR
    iter : IntRefTbl.Iterator;
    uid  : INTEGER;
    ref  : REFANY;
    info : Type.Info;
  BEGIN
    IF (s.d # NIL) THEN
      info := s.d;  s.d := NIL;
      IF (info.names # NIL)
        THEN s.match := info.names;
        ELSE s.match := NEW (Type.T, uid := info.uid);
      END;
      RETURN TRUE;
    END;

    IF (s.e # NIL) THEN
      iter := s.e;
      WHILE iter.next (uid, ref) DO
        IF RegExpr.Match (s.pattern, LexMisc.FmtUID (uid)) THEN
          info := ref;
          IF (info.names # NIL) THEN
            s.match := info.names;
            RETURN TRUE;
          END;
        END;
      END;
      s.e := NIL;
    END;

    RETURN FALSE;
  END TUIDRootNext;

PROCEDURE <A NAME="TUIDRootPage"><procedure>TUIDRootPage</procedure></A> (self: TUIDRoot;  wx: Wx.T;
                        action: ID.T;  data: Node.FormData)
  RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    HTML.BeginXX (self, wx, &quot;Types&quot;);
    GenScanWarning (wx);
    GenTable (self, BrowserDB.db.type_names, NIL, wx);
    HTML.ViewOnly (action, data, wx);
    HTML.End (wx);
  END TUIDRootPage;
</PRE>------------------------------------------------- source root nodes ---

<P><PRE>TYPE
  SourceRoot = Node.Named_T OBJECT
    kind : Node.Class;
  OVERRIDES
    class      := RootClass;
    iterate    := SourceRootIterate;
    next       := SourceRootNext;
    gen_page   := SourceRootPage;
  END;

PROCEDURE <A NAME="SourceRootIterate"><procedure>SourceRootIterate</procedure></A> (&lt;*UNUSED*&gt; self: SourceRoot;
                             VAR s: Node.IteratorState) =
  BEGIN
    TableIterate (BrowserDB.db.units, s);
  END SourceRootIterate;

PROCEDURE <A NAME="SourceRootNext"><procedure>SourceRootNext</procedure></A> (self: SourceRoot;  VAR s: Node.IteratorState): BOOLEAN =
  BEGIN
    RETURN TableNext (self, s, SourceFilter);
  END SourceRootNext;

PROCEDURE <A NAME="SourceFilter"><procedure>SourceFilter</procedure></A> (root, node: Node.T): BOOLEAN =
  VAR self: SourceRoot := root;
  BEGIN
    RETURN (self.kind = node.class ());
  END SourceFilter;

PROCEDURE <A NAME="SourceRootPage"><procedure>SourceRootPage</procedure></A> (self: SourceRoot;  wx: Wx.T;
                          action: ID.T;  data: Node.FormData)
  RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    HTML.BeginXX (self, wx, Node.ClassPlural [self.kind]);
    GenScanWarning (wx);
    GenTable (self, BrowserDB.db.units, SourceFilter, wx);
    HTML.ViewOnly (action, data, wx);
    HTML.End (wx);
  END SourceRootPage;
</PRE>--------------------------------------------------- unit root nodes ---

<P><PRE>TYPE
  UnitRoot = Node.Named_T OBJECT
    pgm : BOOLEAN;
  OVERRIDES
    class      := RootClass;
    iterate    := UnitRootIterate;
    next       := UnitRootNext;
    gen_page   := UnitRootPage;
  END;

PROCEDURE <A NAME="UnitRootIterate"><procedure>UnitRootIterate</procedure></A> (&lt;*UNUSED*&gt; self: UnitRoot;
                           VAR s: Node.IteratorState) =
  BEGIN
    TableIterate (BrowserDB.db.units, s);
  END UnitRootIterate;

PROCEDURE <A NAME="UnitRootNext"><procedure>UnitRootNext</procedure></A> (self: UnitRoot;  VAR s: Node.IteratorState): BOOLEAN =
  BEGIN
    RETURN TableNext (self, s, NIL);
  END UnitRootNext;

PROCEDURE <A NAME="UnitRootPage"><procedure>UnitRootPage</procedure></A> (self: UnitRoot;  wx: Wx.T;
                        action: ID.T;  data: Node.FormData)
  RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    HTML.BeginXX (self, wx, &quot;Source units&quot;);
    GenScanWarning (wx);
    GenTable (self, BrowserDB.db.units, NIL, wx);
    HTML.ViewOnly (action, data, wx);
    HTML.End (wx);
  END UnitRootPage;
</PRE>------------------------------------------------- import root nodes ---

<P><PRE>TYPE
  ImportRoot = Node.Named_T OBJECT
  OVERRIDES
    class      := RootClass;
    iterate    := ImportRootIterate;
    next       := ImportRootNext;
    gen_page   := ImportRootPage;
  END;

PROCEDURE <A NAME="ImportRootIterate"><procedure>ImportRootIterate</procedure></A> (&lt;*UNUSED*&gt; self: ImportRoot;
                             VAR s: Node.IteratorState) =
  BEGIN
    TableIterate (BrowserDB.db.importers, s);
  END ImportRootIterate;

PROCEDURE <A NAME="ImportRootNext"><procedure>ImportRootNext</procedure></A> (&lt;*UNUSED*&gt; self: ImportRoot;
                          VAR s: Node.IteratorState): BOOLEAN =
  BEGIN
    RETURN NameTableNext (s);
  END ImportRootNext;

PROCEDURE <A NAME="ImportRootPage"><procedure>ImportRootPage</procedure></A> (self: ImportRoot;  wx: Wx.T;
                          action: ID.T;  data: Node.FormData)
  RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    HTML.BeginXX (self, wx, &quot;Interface importers&quot;);
    GenScanWarning (wx);
    GenTable (self, BrowserDB.db.units, ImportFilter, wx);
    HTML.ViewOnly (action, data, wx);
    HTML.End (wx);
  END ImportRootPage;

PROCEDURE <A NAME="ImportFilter"><procedure>ImportFilter</procedure></A> (&lt;*UNUSED*&gt; root: Node.T;  node: Node.T): BOOLEAN =
  VAR c := node.class ();
  BEGIN
    (* assume any M3 source is an importer *)
    RETURN (Node.Class.Interface &lt;= c)
       AND (c &lt;= Node.Class.GenericModule);
  END ImportFilter;
</PRE>------------------------------------------------- export root nodes ---

<P><PRE>TYPE
  ExportRoot = Node.Named_T OBJECT
  OVERRIDES
    class      := RootClass;
    iterate    := ExportRootIterate;
    next       := ExportRootNext;
    gen_page   := ExportRootPage;
  END;

PROCEDURE <A NAME="ExportRootIterate"><procedure>ExportRootIterate</procedure></A> (&lt;*UNUSED*&gt; self: ExportRoot;
                             VAR s: Node.IteratorState) =
  BEGIN
    TableIterate (BrowserDB.db.exporters, s);
  END ExportRootIterate;

PROCEDURE <A NAME="ExportRootNext"><procedure>ExportRootNext</procedure></A> (&lt;*UNUSED*&gt; self: ExportRoot;
                          VAR s: Node.IteratorState): BOOLEAN =
  BEGIN
    RETURN NameTableNext (s);
  END ExportRootNext;

PROCEDURE <A NAME="ExportRootPage"><procedure>ExportRootPage</procedure></A> (self: ExportRoot;  wx: Wx.T;
                          action: ID.T;  data: Node.FormData)
  RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    HTML.BeginXX (self, wx, &quot;Interface exporters&quot;);
    GenScanWarning (wx);
    GenTable (self, BrowserDB.db.units, ExportFilter, wx);
    HTML.ViewOnly (action, data, wx);
    HTML.End (wx);
  END ExportRootPage;

PROCEDURE <A NAME="ExportFilter"><procedure>ExportFilter</procedure></A> (&lt;*UNUSED*&gt; root: Node.T;  node: Node.T): BOOLEAN =
  BEGIN
    RETURN node.class () = Node.Class.Module;
  END ExportFilter;
</PRE>------------------------------------------------ derived root nodes ---

<P><PRE>TYPE
  DerivedRoot = Node.Named_T OBJECT
    pgm : BOOLEAN;
  OVERRIDES
    class      := RootClass;
    iterate    := DerivedRootIterate;
    next       := DerivedRootNext;
    gen_page   := DerivedRootPage;
  END;

PROCEDURE <A NAME="DerivedRootIterate"><procedure>DerivedRootIterate</procedure></A> (self: DerivedRoot;  VAR s: Node.IteratorState) =
  BEGIN
    IF self.pgm
      THEN TableIterate (BrowserDB.db.pgms, s);
      ELSE TableIterate (BrowserDB.db.libs, s);
    END;
  END DerivedRootIterate;

PROCEDURE <A NAME="DerivedRootNext"><procedure>DerivedRootNext</procedure></A> (self: DerivedRoot;  VAR s: Node.IteratorState): BOOLEAN =
  BEGIN
    RETURN TableNext (self, s, NIL);
  END DerivedRootNext;

PROCEDURE <A NAME="DerivedRootPage"><procedure>DerivedRootPage</procedure></A> (self: DerivedRoot;  wx: Wx.T;
                           action: ID.T;  data: Node.FormData)
  RAISES {Wr.Failure, Thread.Alerted} =
  CONST Map = ARRAY BOOLEAN OF NC { NC.Library, NC.Program };
  BEGIN
    HTML.BeginXX (self, wx, Node.ClassPlural [Map [self.pgm]]);
    GenScanWarning (wx);
    IF self.pgm
      THEN GenTable (self, BrowserDB.db.pgms, NIL, wx);
      ELSE GenTable (self, BrowserDB.db.libs, NIL, wx);
    END;
    HTML.ViewOnly (action, data, wx);
    HTML.End (wx);
  END DerivedRootPage;
</PRE>-------------------------------------------- build cache root nodes ---

<P><PRE>TYPE
  CacheRoot = Node.Named_T OBJECT
  OVERRIDES
    class      := RootClass;
    iterate    := CacheRootIterate;
    next       := CacheRootNext;
    gen_page   := CacheRootPage;
  END;

PROCEDURE <A NAME="CacheRootIterate"><procedure>CacheRootIterate</procedure></A> (&lt;*UNUSED*&gt; self: CacheRoot;
                            VAR s: Node.IteratorState) =
  VAR c := BuildCache.cache;
  BEGIN
    IF (c # NIL)
      THEN s.a := 1; TableIterate (c, s);
      ELSE s.a := 0;
    END;
  END CacheRootIterate;

PROCEDURE <A NAME="CacheRootNext"><procedure>CacheRootNext</procedure></A> (self: CacheRoot;  VAR s: Node.IteratorState): BOOLEAN =
  BEGIN
    IF (s.a # 0) THEN RETURN TableNext (self, s, NIL); END;
    RETURN FALSE;
  END CacheRootNext;

PROCEDURE <A NAME="CacheRootPage"><procedure>CacheRootPage</procedure></A> (self: CacheRoot;  wx: Wx.T;
                         action: ID.T;  data: Node.FormData)
  RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    HTML.BeginXX (self, wx, &quot;Build cache&quot;);
    GenScanWarning (wx);
    IF (BuildCache.cache # NIL) THEN
      GenTable (self, BuildCache.cache, NIL, wx);
    END;
    HTML.ViewOnly (action, data, wx);
    HTML.End (wx);
  END CacheRootPage;
</PRE>------------------------------------------ documentation root nodes ---

<P><PRE>TYPE
  DocumentRoot = Dir.T OBJECT
    base  : TEXT;
    title : TEXT;
    tbl   : IntRefTbl.T := NIL;
  OVERRIDES
    class      := RootClass;
    iterate    := DocumentRootIterate;
    next       := DocumentRootNext;
    gen_page   := DocumentRootPage;
  END;

PROCEDURE <A NAME="DocumentRootIterate"><procedure>DocumentRootIterate</procedure></A> (self: DocumentRoot;
                            VAR s: Node.IteratorState) =
  BEGIN
    IF self.tbl = NIL THEN ScanDocDir (self); END;
    TableIterate (self.tbl, s);
  END DocumentRootIterate;

PROCEDURE <A NAME="DocumentRootNext"><procedure>DocumentRootNext</procedure></A> (self: DocumentRoot;
                            VAR s: Node.IteratorState): BOOLEAN =
  BEGIN
    RETURN TableNext (self, s, NIL);
  END DocumentRootNext;

PROCEDURE <A NAME="DocumentRootPage"><procedure>DocumentRootPage</procedure></A> (self: DocumentRoot;  wx: Wx.T;
                         action: ID.T;  data: Node.FormData)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR ref: REFANY;
  BEGIN
    IF self.tbl = NIL THEN ScanDocDir (self); END;
    IF self.tbl.get (ID.Add (&quot;index.html&quot;), ref) THEN
      NARROW (ref, Node.List).head.gen_page (wx, action, data);
    ELSE
      HTML.BeginXX (self, wx, self.title);
      GenTable (self, self.tbl, NIL, wx);
      HTML.ViewOnly (action, data, wx);
      HTML.End (wx);
    END;
  END DocumentRootPage;

PROCEDURE <A NAME="ScanDocDir"><procedure>ScanDocDir</procedure></A> (self: DocumentRoot) =
  VAR
    root := OS.MakePath (Default.doc_root, self.base);
    d: Dir.T;
    n: Node.Named_T;
  BEGIN
    self.scanned  := OS.Now ();
    self.contents := NIL;
    self.tbl      := NEW (IntRefTbl.Default).init ();

    IF OS.IsDirectory (root) THEN
      d := ScanDir (self.base, root);
      self.contents := d.contents;
    END;

    (* steal the directory's contents away &amp; build the table *)
    n := self.contents;
    WHILE (n # NIL) DO
      n.parent := self;
      EVAL self.tbl.put (n.name, NEW (Node.List, head := n, tail := NIL));
      n := n.sibling;
    END;
  END ScanDocDir;

PROCEDURE <A NAME="ScanDir"><procedure>ScanDir</procedure></A> (dir_name, dir_path: TEXT): Dir.T =
  VAR iter: FS.Iterator;  nm, path: TEXT;   self: Dir.T;  n: Node.Named_T;
  BEGIN
    self := NEW (Dir.T, name := ID.Add (dir_name), contents := NIL);
    TRY
      iter := FS.Iterate (dir_path);
      TRY
        WHILE iter.next (nm) DO
          path := OS.MakePath (dir_path, nm);
          IF OS.IsDirectory (path)
            THEN n := ScanDir (nm, path);
            ELSE n := NEW (FileNode.T, name := ID.Add (nm), path := path);
          END;
          n.parent := self;
          n.sibling := self.contents;
          self.contents := n;
        END;
      FINALLY
        iter.close ();
      END;
    EXCEPT OSError.E (ec) =&gt;
      ErrLog.Msg (&quot;trouble scanning document directory: &quot;,
                   dir_path, OS.Err (ec));
    END;
    RETURN self;
  END ScanDir;
</PRE>----------------------------------------------- example root nodes ---

<P><PRE>TYPE
  ExamplesRoot = Node.Named_T OBJECT
    root     : TEXT    := NIL;
    contents : Example := NIL;
  OVERRIDES
    class      := RootClass;
    iterate    := ExamplesRootIterate;
    next       := ExamplesRootNext;
    gen_page   := ExamplesRootPage;
  END;

  Example = REF RECORD
    name : TEXT    := NIL;
    node : Node.T  := NIL;
    next : Example := NIL;
  END;

PROCEDURE <A NAME="ExamplesRootIterate"><procedure>ExamplesRootIterate</procedure></A> (self: ExamplesRoot;
                            VAR s: Node.IteratorState) =
  BEGIN
    IF self.root = NIL THEN ScanExamples (self); END;
    s.d := self.contents;
  END ExamplesRootIterate;

PROCEDURE <A NAME="ExamplesRootNext"><procedure>ExamplesRootNext</procedure></A> (self: ExamplesRoot;
                            VAR s: Node.IteratorState): BOOLEAN =
  VAR ex: Example;
  BEGIN
    WHILE s.d # NIL DO
      ex := s.d;  s.d := ex.next;
      IF RegExpr.Match (s.pattern, ex.name) THEN
        IF (ex.node # NIL)
          THEN s.match := ex.node;
          ELSE s.match := FindExamplePkg (self.root, ex);
        END;
        RETURN TRUE;
      END;
    END;
    RETURN FALSE;
  END ExamplesRootNext;

PROCEDURE <A NAME="ExamplesRootPage"><procedure>ExamplesRootPage</procedure></A> (self: ExamplesRoot;  wx: Wx.T;
                         action: ID.T;  data: Node.FormData)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR ex: Example;
  BEGIN
    IF self.root = NIL THEN ScanExamples (self); END;
    ex := self.contents;
    WHILE (ex # NIL)
      AND (NOT OS.FileNameEq (ex.name, &quot;index.html&quot;))
      AND (NOT OS.FileNameEq (ex.name, &quot;index.htm&quot;)) DO
      ex := ex.next;
    END;
    IF (ex # NIL) THEN
      ex.node.gen_page (wx, action, data);
    ELSE
      HTML.BeginXX (self, wx, &quot;CM3-IDE examples&quot;);
      wx.put (&quot;&lt;STRONG&gt;The CM3-IDE examples are missing.&lt;/STRONG&gt;\n&quot;);
      HTML.ViewOnly (action, data, wx);
      HTML.End (wx);
    END;
  END ExamplesRootPage;

PROCEDURE <A NAME="ScanExamples"><procedure>ScanExamples</procedure></A> (self: ExamplesRoot) =
  VAR ex: Example;  iter: FS.Iterator;  nm, path: TEXT;
  BEGIN
    self.root := Default.example_root;
    TRY
      iter := FS.Iterate (self.root);
      TRY
        WHILE iter.next (nm) DO
          path := OS.MakePath (self.root, nm);
          ex := NEW (Example, next := self.contents, name := nm);
          self.contents := ex;
          IF NOT OS.IsDirectory (path) THEN
            (* convert non-directories into simple file nodes *)
            ex.node := NEW (FileNode.T, name := ID.Add (nm), path := path,
                            parent := self);
          END;
        END;
      FINALLY
        iter.close ();
      END;
    EXCEPT OSError.E (ec) =&gt;
      ErrLog.Msg (&quot;trouble scanning example directory: &quot;,
                   self.root, OS.Err (ec));
    END;
  END ScanExamples;

PROCEDURE <A NAME="FindExamplePkg"><procedure>FindExamplePkg</procedure></A> (root: TEXT;  ex: Example): Node.T =
  VAR pkg_root: PkgRoot.T;  n: Node.Named_T;
  BEGIN
    IF (Default.user_home = NIL) THEN
      (* There's no HOME root.  We can't auto-clone examples. *)
      ex.node := ScanDir (ex.name, OS.MakePath (root, ex.name));
      RETURN ex.node;
    END;

    (* find the package root that corresponds to the user's &quot;home&quot; *)
    pkg_root := PkgRoot.First ();
    LOOP
      IF (pkg_root = NIL) THEN
        (* didn't find it!  We can't auto-clone examples. *)
        ex.node := ScanDir (ex.name, OS.MakePath (root, ex.name));
        RETURN ex.node;
      END;
      IF OS.FileNameEq (pkg_root.path, Default.user_home) THEN
        EXIT;
      END;
      pkg_root := pkg_root.sibling;
    END;

    (* find the named package in that root *)
    n := pkg_root.contents;
    WHILE (n # NIL) DO
      TYPECASE n OF
      | Pkg.T (pkg) =&gt;
          IF OS.FileNameEq (ID.ToText (pkg.name), ex.name) THEN
            RETURN pkg;
          END;
      ELSE (* skip *)
      END;
      n := n.sibling;
    END;

    (* no matching package found =&gt; clone the example directory
       and return it as a newly created package.  *)
    OS.CopyDirectory (OS.MakePath (root, ex.name),
                      OS.MakePath (pkg_root.path, ex.name));
    TRY
      RETURN Pkg.Rescan (NEW (Pkg.T, name := ID.Add (ex.name), parent := pkg_root));
    EXCEPT Thread.Alerted =&gt;
      RETURN ExampleRoot;
    END;
  END FindExamplePkg;
</PRE>------------------------------------------------- console log node ---

<P><PRE>TYPE
  LogRoot = Node.Named_T OBJECT
  OVERRIDES
    class      := RootClass;
    iterate    := LogRootIterate;
    next       := LogRootNext;
    gen_page   := LogRootPage;
  END;

PROCEDURE <A NAME="LogRootIterate"><procedure>LogRootIterate</procedure></A> (&lt;*UNUSED*&gt; self: LogRoot;
                          &lt;*UNUSED*&gt; VAR s: Node.IteratorState) =
  BEGIN
  END LogRootIterate;

PROCEDURE <A NAME="LogRootNext"><procedure>LogRootNext</procedure></A> (&lt;*UNUSED*&gt; self: LogRoot;
                       &lt;*UNUSED*&gt; VAR s: Node.IteratorState): BOOLEAN =
  BEGIN
    RETURN FALSE;
  END LogRootNext;

PROCEDURE <A NAME="LogRootPage"><procedure>LogRootPage</procedure></A> (self: LogRoot;  wx: Wx.T;
                         action: ID.T;  data: Node.FormData)
  RAISES {Wr.Failure, Thread.Alerted} =
  CONST Title = &quot;CM3-IDE console log: &quot;;
  VAR now := &quot;&lt;TT&gt;&quot; &amp; FmtTime.Short (OS.FileToM3Time (OS.Now ())) &amp; &quot;&lt;/TT&gt;&quot;;
  BEGIN
    HTML.BeginXX (self, wx, Title, now);
    wx.put (&quot;&lt;A NAME=\&quot;HEAD\&quot;&gt;&lt;HR&gt;&lt;/A&gt;\n&lt;PRE&gt;\n&quot;);
    LOCK ErrLog.log_mu DO
      FOR i := ErrLog.log_head - ErrLog.log_len TO ErrLog.log_head - 1 DO
        IF (i &lt; 0)
          THEN wx.put (ErrLog.log[i + NUMBER (ErrLog.log)], &quot;\n&quot;);
          ELSE wx.put (ErrLog.log[i], &quot;\n&quot;);
        END;
      END;
    END;
    wx.put (&quot;&lt;/PRE&gt;\n&lt;A NAME=\&quot;TAIL\&quot;&gt;&lt;HR&gt;&lt;/A&gt;\n&quot;);
    wx.put (&quot;&lt;H2&gt;&quot;, Title, now, &quot;&lt;/H2&gt;\n&quot;);
    HTML.ViewOnly (action, data, wx);
    HTML.End (wx);
  END LogRootPage;

BEGIN
END Roots.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface ErrLog is in:
</A><UL>
<LI><A HREF="../utils/ErrLog.i3.html#0TOP0">cm3ide/src/utils/ErrLog.i3</A>
<LI><A HREF="../../../m3markup/src/ErrLog.i3.html#0TOP0">m3markup/src/ErrLog.i3</A>
</UL>
<P>
<HR>
<A NAME="x2">interface HTML is in:
</A><UL>
<LI><A HREF="../misc/HTML.i3.html#0TOP0">cm3ide/src/misc/HTML.i3</A>
<LI><A HREF="../../../webvbt/src/HTML.i3.html#0TOP0">webvbt/src/HTML.i3</A>
</UL>
<P>
<HR>
<A NAME="x3">interface ID is in:
</A><UL>
<LI><A HREF="../utils/ID.i3.html#0TOP0">cm3ide/src/utils/ID.i3</A>
<LI><A HREF="../../../m3markup/src/ID.i3.html#0TOP0">m3markup/src/ID.i3</A>
</UL>
<P>
<HR>
<A NAME="x4">interface OS is in:
</A><UL>
<LI><A HREF="../utils/OS.i3.html#0TOP0">cm3ide/src/utils/OS.i3</A>
<LI><A HREF="../../../fix_nl/src/OS.i3.html#0TOP0">fix_nl/src/OS.i3</A>
<LI><A HREF="../../../m3browser/src/OS.i3.html#0TOP0">m3browser/src/OS.i3</A>
</UL>
<P>
<HR>
<A NAME="x5">interface Type is in:
</A><UL>
<LI><A HREF="Type.i3.html#0TOP0">cm3ide/src/nodes/Type.i3</A>
<LI><A HREF="../../../m3front/src/types/Type.i3.html#0TOP0">m3front/src/types/Type.i3</A>
<LI><A HREF="../../../sharedobjgen/src/Type.i3.html#0TOP0">sharedobjgen/src/Type.i3</A>
<LI><A HREF="../../../stablegen/src/Type.i3.html#0TOP0">stablegen/src/Type.i3</A>
<LI><A HREF="../../../stubgen/src/Type.i3.html#0TOP0">stubgen/src/Type.i3</A>
</UL>
<P>
<HR>
<A NAME="x6">interface Wx is in:
</A><UL>
<LI><A HREF="../utils/Wx.i3.html#0TOP0">cm3ide/src/utils/Wx.i3</A>
<LI><A HREF="../../../libbuf/src/Wx.i3.html#0TOP0">libbuf/src/Wx.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
