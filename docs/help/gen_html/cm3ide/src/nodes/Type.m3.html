<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: cm3ide/src/nodes/Type.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>cm3ide/src/nodes/Type.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright 1996 Critical Mass, Inc. All rights reserved.    

<P><PRE>MODULE <module><implements><A HREF="#x1">Type</A></implements></module>;

IMPORT <A HREF="../../../libm3/derived/AtomList.i3.html">AtomList</A>, <A HREF="../../../libm3/derived/IntArraySort.i3.html">IntArraySort</A>, <A HREF="../../../libm3/derived/IntRefTbl.i3.html">IntRefTbl</A>, <A HREF="../../../libm3/src/fmtlex/Fmt.i3.html">Fmt</A>;
IMPORT <A HREF="../../../libm3/src/rw/Rd.i3.html">Rd</A>, <A HREF="../../../libm3/derived/RefSeq.i3.html">RefSeq</A>, <A HREF="../../../m3core/src/text/Text.i3.html">Text</A>, <A HREF="../../../libm3/src/rw/TextRd.i3.html">TextRd</A>, <A HREF="../../../libm3/derived/TextRefTbl.i3.html">TextRefTbl</A>, <A HREF="../../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../../libm3/src/rw/Wr.i3.html">Wr</A>;

IMPORT <A HREF="../misc/BrowserDB.i3.html">BrowserDB</A>, <A HREF="../misc/ConfigItem.i3.html">ConfigItem</A>, <A HREF="../misc/Default.i3.html">Default</A>, <A HREF="#x2">ErrLog</A>, <A HREF="#x3">ID</A>, <A HREF="Node.i3.html">Node</A>, <A HREF="#x4">HTML</A>, <A HREF="#x5">OS</A>, <A HREF="#x6">Wx</A>, <A HREF="#x7">XFormat</A>;
FROM <A HREF="../utils/LexMisc.i3.html">LexMisc</A> IMPORT ReadUID, FmtUID, ReadInt, ReadBrand, ReadName;

REVEAL
  <A NAME="T">T</A> = Tx BRANDED &quot;Type.T&quot; OBJECT
  OVERRIDES
    class     := Class;
    arcname   := NodeID;
    filename  := NodeName;
    printname := NodeName;
    iterate   := Iterate;
    next      := Next;
    gen_page  := GenPage;
  END;

VAR
  viewID     := ID.Add (&quot;view&quot;);
  expandedID := ID.Add (&quot;expanded&quot;);
  graphID    := ID.Add (&quot;graph&quot;);
  flatID     := ID.Add (&quot;flat&quot;);

TYPE
  ScanLine = ARRAY [0..511] OF CHAR;

CONST
  BuiltinUnit = &quot;M3_BUILTIN.i3&quot;;

PROCEDURE <A NAME="Class"><procedure>Class</procedure></A> (&lt;*UNUSED*&gt; t: T): Node.Class =
  BEGIN
    RETURN Node.Class.Type;
  END Class;

PROCEDURE <A NAME="NodeName"><procedure>NodeName</procedure></A> (t: T): TEXT =
  BEGIN
    RETURN ID.ToText (NodeID (t));
  END NodeName;

PROCEDURE <A NAME="NodeID"><procedure>NodeID</procedure></A> (t: T): ID.T =
  VAR info: Info;  ref: REFANY;
  BEGIN
    IF (t.name # ID.NoID) THEN
      RETURN t.name;
    END;
    IF BrowserDB.db.types.get (t.uid, ref) THEN
      info := ref;
      IF (info.names # NIL) THEN
        RETURN info.names.name;
      END;
    END;
    RETURN ID.Add (FmtUID (t.uid));
  END NodeID;

PROCEDURE <A NAME="Iterate"><procedure>Iterate</procedure></A> (t: T;  VAR s: Node.IteratorState) =
  (* type nodes are fixed-points =&gt; they only return self. *)
  BEGIN
    s.d := t;
  END Iterate;

PROCEDURE <A NAME="Next"><procedure>Next</procedure></A> (&lt;*UNUSED*&gt; t: T;  VAR s: Node.IteratorState): BOOLEAN =
  BEGIN
    s.match := s.d;  s.d := NIL;
    RETURN (s.match # NIL);
  END Next;

PROCEDURE <A NAME="GenPage"><procedure>GenPage</procedure></A> (t: T;  wx: Wx.T;  action: ID.T;  data: Node.FormData)
  RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    IF    (action = viewID)     THEN GenView (t, wx);
    ELSIF (action = flatID)     THEN GenFlatView (t, wx);
    ELSIF (action = expandedID) THEN GenExpandedView (t, wx);
    ELSIF (action = graphID)    THEN GenGraphView (t, wx);
    ELSE GenView (t, wx);  HTML.NoAction (action, wx);
    END;
    HTML.NoData (data, wx);
    HTML.End (wx);
  END GenPage;

PROCEDURE <A NAME="GenView"><procedure>GenView</procedure></A> (t: T;  wx: Wx.T)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR info: Info;
  BEGIN
    info := GenTitle (t, 0, NIL, wx);
    GenType (info, wx, FALSE);
  END GenView;

PROCEDURE <A NAME="GenExpandedView"><procedure>GenExpandedView</procedure></A> (t: T;  wx: Wx.T)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR info: Info;
  BEGIN
    info := GenTitle (t, 1, NIL, wx);
    GenType (info, wx, TRUE);
  END GenExpandedView;

PROCEDURE <A NAME="GenFlatView"><procedure>GenFlatView</procedure></A> (t: T;  wx: Wx.T)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR info: Info;
  BEGIN
    info := GenTitle (t, 2, NIL, wx);
    GenFlatType (info, wx);
  END GenFlatView;

PROCEDURE <A NAME="GenGraphView"><procedure>GenGraphView</procedure></A> (t: T;  wx: Wx.T)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR info: Info;
  BEGIN
    info := GenTitle (t, 3, NIL, wx);
    GenTypeGraph (info, wx);
  END GenGraphView;

PROCEDURE <A NAME="GenTitle"><procedure>GenTitle</procedure></A> (t: T;  mode: INTEGER;  pref: TEXT;  wx: Wx.T): Info
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR
    uid      := FmtUID (t.uid);
    info     : Info  := NIL;
    tn       : T := NIL;
    name     : TEXT;
    home     : TEXT;
    alias    : TEXT;
    u        : Info;
    obj_info : ObjectInfo;
  BEGIN
    GetTypeName (t.uid, name, home, pref);
    EVAL Get (t.uid, info);

    wx.put (&quot;Content-type: text/html\n&quot;);
    wx.put (&quot;Location: &quot;, Default.server_href, FmtHREF (info, t.uid), &quot;/\n&quot;);
    IF ConfigItem.X[ConfigItem.T.Use_multiple_windows].bool THEN
      wx.put (&quot;Window-target: &quot;, Node.ClassWindow[Node.Class.Type], &quot;\n&quot;);
    END;
    wx.put (&quot;\n&lt;HTML&gt;\n&lt;HEAD&gt;\n&quot;);
    HTML.GenBase (t, wx);

    IF (home # NIL) AND NOT Text.Equal (home, BuiltinUnit) THEN
      wx.put (&quot;&lt;TITLE&gt;Type &quot;, name, &quot; in &quot;, home);
      wx.put (&quot;&lt;/TITLE&gt;\n&lt;/HEAD&gt;\n&lt;BODY BGCOLOR=\&quot;#ffffff\&quot;&gt;\n&lt;H3&gt;&quot;);
      HTML.PutImg (Node.ClassIcon[Node.Class.Type], wx);
      wx.put (&quot; Type &quot;, name);
      wx.put (&quot; in &lt;A HREF=\&quot;/unit/&quot;, home, &quot;\&quot;&gt;&quot;);
      wx.put (home, &quot;&lt;/A&gt;:&lt;/H3&gt;\n&quot;);
    ELSE
      wx.put (&quot;&lt;TITLE&gt;Type &quot;, name);
      wx.put (&quot;&lt;/TITLE&gt;\n&lt;/HEAD&gt;\n&lt;BODY BGCOLOR=\&quot;#ffffff\&quot;&gt;\n&lt;H3&gt;&quot;);
      HTML.PutImg (Node.ClassIcon[Node.Class.Type], wx);
      wx.put (&quot; Type &quot;, name, &quot;:&lt;/H3&gt;\n&quot;);
    END;
    HTML.GenPathFinder (t, wx);
    wx.put (&quot;&lt;P&gt;\n&quot;);

    wx.put (&quot;&lt;BR&gt;(internal uid = &amp;lt;&quot;, uid, &quot;&amp;gt;&quot;);
    IF TranslateOpaque (t.uid, u) THEN
      wx.put (&quot;, revealed = &amp;lt;&quot;, FmtUID (u.uid), &quot;&amp;gt;&quot;);
    END;
    IF FindOpaque (t.uid, u) THEN
      wx.put (&quot;, opaque = &amp;lt;&quot;, FmtUID (u.uid), &quot;&amp;gt;&quot;);
    END;
    wx.put (&quot;)\n&quot;);

    wx.put (&quot;&lt;BR&gt;&quot;);
    IF (mode # 0) THEN
      wx.put (&quot; &lt;A HREF=\&quot;[view]\&quot;&gt;[condensed view]&lt;/A&gt;\n&quot;);
    END;
    IF (mode # 1) THEN
      wx.put (&quot; &lt;A HREF=\&quot;[expanded]\&quot;&gt;[expanded view]&lt;/A&gt;\n&quot;);
    END;
    IF (mode # 2) AND (info # NIL) AND IsObject (info) THEN
      wx.put (&quot; &lt;A HREF=\&quot;[flat]\&quot;&gt;[flat view]&lt;/A&gt;\n&quot;);
    END;
    IF GetObjInfo (t.uid, obj_info) THEN
      wx.put (&quot; &lt;A HREF=\&quot;[graph]\&quot;&gt;[subtype graph]&lt;/A&gt;\n&quot;);
    END;

    IF (info # NIL) THEN tn := info.names; END;
    IF (tn # NIL) AND (tn.alias # NIL) THEN
      wx.put (&quot;&lt;P&gt;&lt;STRONG&gt;Aliases:&lt;/STRONG&gt;\n&lt;MENU&gt;\n&quot;);
      WHILE (tn # NIL) DO
        alias := ID.ToText (tn.home);
        IF (home = NIL) OR NOT Text.Equal (home, alias) THEN
          IF Text.Equal (alias, BuiltinUnit) THEN
            wx.put (&quot;&lt;LI&gt;&quot;, ID.ToText (tn.name), &quot;\n&quot;);
          ELSE
            wx.put (&quot;&lt;LI&gt;&quot;, ID.ToText (tn.name), &quot; in &quot;);
            wx.put (&quot;&lt;A HREF=\&quot;/unit/&quot;, alias);
            wx.put (&quot;/\&quot;&gt;&quot;, alias,&quot;&lt;/A&gt;\n&quot;);
          END;
        END;
        tn := tn.alias;
      END;
      wx.put (&quot;&lt;/MENU&gt;\n&quot;);
    END;

    wx.flush (); (* force the title to appear *)
    RETURN info;
  END GenTitle;
</PRE>------------------------------------------------- subtype graph ---

<P><PRE>PROCEDURE <A NAME="GenTypeGraph"><procedure>GenTypeGraph</procedure></A> (info: Info;  wx: Wx.T)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR
    indent   : INTEGER;
    cnt      : ARRAY [0..4] OF INTEGER ;
    maxDepth : INTEGER := 0;
    total    : INTEGER := 0;
  BEGIN
    IF (info = NIL) THEN RETURN END;

    (* find out how deep to print the tree *)
    FOR i := FIRST (cnt) TO LAST (cnt) DO cnt[i] := 0 END;
    CountSubtypes (info, 0, cnt);
    WHILE (maxDepth &lt;= LAST (cnt)) AND (total + cnt[maxDepth] &lt; 100) DO
      INC (total, cnt[maxDepth]);
      INC (maxDepth);
    END;
    maxDepth := MAX (1, maxDepth - 1);

    wx.put (&quot;&lt;PRE&gt;\n&quot;);
    indent := GenSuperTypes (info, 0, wx);
    GenSubtypes (info, 0, maxDepth, indent, wx);
    wx.put (&quot;&lt;/PRE&gt;\n&quot;);
  END GenTypeGraph;

PROCEDURE <A NAME="CountSubtypes"><procedure>CountSubtypes</procedure></A> (info: Info;  depth: INTEGER;  VAR cnt: ARRAY OF INTEGER) =
  VAR u, v: Info;
  BEGIN
    IF (depth &lt;= LAST (cnt)) AND (info.uid # 0) THEN
      u := Subtypes (info);
      WHILE (u # NIL) DO
        INC (cnt[depth]);
        v := u;
        EVAL FindOpaque (u.uid, v);
        CountSubtypes (v, depth+1, cnt);
        u := NextPeer (u);
      END;
    END;
  END CountSubtypes;

PROCEDURE <A NAME="GenSuperTypes"><procedure>GenSuperTypes</procedure></A> (info: Info;  depth: INTEGER;  wx: Wx.T): INTEGER
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR in: INTEGER;
  BEGIN
    IF (info = NIL) THEN
      RETURN 0;
    ELSIF (depth &gt;= 99) THEN
      wx.put (&quot;....\n&quot;);
      RETURN 3;
    ELSE
      in := GenSuperTypes (SuperType (info), depth+1, wx);
      IF (depth # 0) THEN in := 0 END; (* hack *)
      GenGraphEntry (info, in, 0, wx, (depth = 0));
      RETURN in + 3;
    END;
  END GenSuperTypes;

PROCEDURE <A NAME="GenGraphEntry"><procedure>GenGraphEntry</procedure></A> (info: Info;  indent, depth: INTEGER;
                         wx: Wx.T;  key: BOOLEAN)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR name, home: TEXT;
  BEGIN
    GetTypeName (info.uid, name, home, NIL);
    Indent (wx, indent);
    FOR i := 1 TO depth DO wx.put (&quot;|  &quot;); END;
    wx.put (&quot;&lt;A HREF=\&quot;/&quot;, FmtHREF (info, info.uid), &quot;/\&quot;&gt;&quot;);
    wx.put (name, &quot;&lt;/A&gt;&quot;);
    IF (home # NIL) AND NOT Text.Equal (home, BuiltinUnit) THEN
      wx.put (&quot; in &lt;A HREF=\&quot;/unit/&quot;, home,&quot;\&quot;&gt;&quot;);
      wx.put (home, &quot;&lt;/A&gt;&quot;);
    END;
    IF (key) THEN
      wx.put (&quot; &lt;STRONG&gt;&amp;lt;==&lt;/STRONG&gt;&quot;);
    END;
    wx.put (&quot;\n&quot;);
  END GenGraphEntry;

PROCEDURE <A NAME="GenSubtypes"><procedure>GenSubtypes</procedure></A> (info: Info;  depth, maxDepth, indent: INTEGER;  wx: Wx.T)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR z: RefSeq.T;  u, v: Info;
  BEGIN
    IF (info = NIL) THEN RETURN; END;

    IF (depth &gt;= maxDepth) THEN
      Indent (wx, indent);
      FOR i := 1 TO depth DO wx.put (&quot;|  &quot;); END;
      wx.put (&quot;....\n&quot;);
      RETURN;
    END;

    u := Subtypes (info);
    IF (u = NIL) THEN RETURN; END;

    z := NEW (RefSeq.T).init ();
    WHILE (u # NIL) DO
      IF FindOpaque (u.uid, v)
        THEN z.addhi (v);
        ELSE z.addhi (u);
      END;
      u := NextPeer (u);
    END;
    GenSubtypeNames (z, depth, maxDepth, indent, wx);
  END GenSubtypes;

PROCEDURE <A NAME="Indent"><procedure>Indent</procedure></A> (wx: Wx.T;  indent: INTEGER)
  RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    WHILE (indent &gt; 8) DO  wx.put (&quot;        &quot;); DEC (indent, 8);  END;
    WHILE (indent &gt; 0) DO  wx.putChar (' ');    DEC (indent);     END;
  END Indent;

PROCEDURE <A NAME="GenSubtypeNames"><procedure>GenSubtypeNames</procedure></A> (z: RefSeq.T;  depth, maxDepth, indent: INTEGER;
                           wx: Wx.T)
  RAISES {Wr.Failure, Thread.Alerted} =
  TYPE XX = REF ARRAY OF RECORD info: Info;  name, home: TEXT; END;
  VAR
    n   := z.size ();
    map := NEW (REF ARRAY OF INTEGER, n);
    xx  := NEW (XX, n);

  PROCEDURE CmpTypeName (a, b: INTEGER): [-1..+1] =
    VAR ca, cb: CHAR;
    BEGIN
      WITH xa = xx[a],  xb = xx[b] DO
        ca := Text.GetChar (xa.name, 0);
        cb := Text.GetChar (xb.name, 0);
        IF    (ca # '&amp;') AND (cb = '&amp;') THEN RETURN -1;
        ELSIF (ca = '&amp;') AND (cb # '&amp;') THEN RETURN +1;
        ELSE RETURN Text.Compare (xa.name, xb.name);
        END;
      END;
    END CmpTypeName;

  BEGIN
    (* build the list of names &amp; homes *)
    FOR i := 0 TO n-1 DO
      map[i] := i;
      WITH zz = xx[i] DO
        zz.info := z.get (i);
        GetTypeName (zz.info.uid, zz.name, zz.home, NIL);
      END;
    END;

    IntArraySort.Sort (map^, CmpTypeName);

    FOR i := 0 TO n-1 DO
      WITH zz = xx[map[i]] DO
        GenGraphEntry (zz.info, indent, depth, wx, FALSE);
        GenSubtypes (zz.info, depth+1, maxDepth, indent, wx);
      END;
    END;
  END GenSubtypeNames;
</PRE>----------------------------------------------- top-level views ---

<P><PRE>PROCEDURE <A NAME="GenType"><procedure>GenType</procedure></A> (info: Info;  wx: Wx.T;  expanded: BOOLEAN)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR already_expanded: IntRefTbl.T := NIL;
  BEGIN
    IF (info = NIL) THEN RETURN; END;

    IF expanded THEN
      already_expanded := NEW (IntRefTbl.Default).init ();
      EVAL already_expanded.put (info.uid, NIL);
    END;

    wx.put (&quot;&lt;P&gt;&lt;STRONG&gt;Structure:&lt;/STRONG&gt;\n&quot;);
    wx.flush ();
    wx.put (&quot;&lt;PRE&gt;\n&quot;);
    FormatType (info, already_expanded, wx);
    wx.put (&quot;&lt;/PRE&gt;\n&quot;);
    wx.flush ();
  END GenType;

PROCEDURE <A NAME="FormatType"><procedure>FormatType</procedure></A> (info: Info;  expanded: IntRefTbl.T;  wx: Wx.T)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR fmt := XFormat.New (wx);
  BEGIN
    fmt.putText (&quot;  &quot;);
    fmt.begin (0);
    GenTypeExpr (info, expanded, fmt, topLevel := TRUE);
    fmt.end ();
    fmt.flush ();
    fmt.close ();
  END FormatType;

PROCEDURE <A NAME="GenFlatType"><procedure>GenFlatType</procedure></A> (info: Info;  wx: Wx.T)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR xxx: ObjInfo;
  BEGIN
    IF (info = NIL) THEN RETURN END;

    xxx.names := NEW (TextRefTbl.Default).init ();
    ExtractObject (info, xxx);

    wx.put (&quot;&lt;P&gt;&lt;STRONG&gt;Structure:&lt;/STRONG&gt;\n&quot;);
    wx.flush ();
    wx.put (&quot;&lt;PRE&gt;\n&quot;);
    IF (xxx.fields.head # NIL) OR (xxx.methods.head # NIL)
      THEN FormatObject (xxx, wx);
      ELSE FormatType (info, NIL, wx);
    END;
    wx.put (&quot;&lt;/PRE&gt;\n&quot;);
    wx.flush ();
  END GenFlatType;
</PRE>------------------------------------------------- object types  ---

<P><PRE>TYPE
  ObjEntry = REF RECORD
    next   : ObjEntry := NIL;
    name   : TEXT     := NIL;
    uid    : INTEGER  := 0;
    dfault : TEXT     := NIL;
    hidden : BOOLEAN  := FALSE;
    source : INTEGER  := 0;
  END;

  ObjEntryQueue = RECORD
    head, tail: ObjEntry := NIL;
  END;

  ObjInfo = RECORD
    traced  : BOOLEAN := FALSE;
    fields  : ObjEntryQueue;
    methods : ObjEntryQueue;
    names   : TextRefTbl.T := NIL;
  END;

PROCEDURE <A NAME="ExtractObject"><procedure>ExtractObject</procedure></A> (info: Info;  VAR xxx: ObjInfo)
  RAISES {Thread.Alerted} =
  VAR rhs: Info;  field_source, method_source: INTEGER;  rd: Rd.T;
  BEGIN
    IF (info = NIL) THEN RETURN END;
    field_source  := info.uid;
    method_source := info.uid;
    IF TranslateOpaque (info.uid, rhs) THEN info := rhs; END;
    ExtractObject (SuperType (info), xxx);
    rd := OpenDesc (info);
    TRY
      TRY
        ExtractThisObject (rd, xxx, field_source, method_source);
      FINALLY
        CloseDesc (rd);
      END;
    EXCEPT Rd.Failure(ec) =&gt;
      Choke (&quot;Trouble reading&quot;, info.info_file, ec);
    END;
  END ExtractObject;

PROCEDURE <A NAME="ExtractThisObject"><procedure>ExtractThisObject</procedure></A> (rd: Rd.T;  VAR xxx: ObjInfo;
                             field_source, method_source: INTEGER)
  RAISES {Thread.Alerted, Rd.Failure} =
  VAR
    line          : ScanLine;
    eol           : INTEGER;
    cur           : INTEGER;
    ch            : CHAR;
    n_fields      : INTEGER;
    n_methods     : INTEGER;
    n_overrides   : INTEGER;
    n_pending     : INTEGER;
    id, idX       : TEXT;
    entry         : ObjEntry;
    ref           : REFANY;
  BEGIN
    IF (rd = NIL) THEN RETURN END;

    eol := Rd.GetSubLine (rd, line);
    ch := line[0];  cur := 1;
    IF (ch # 'U') AND (ch # 'V') THEN RETURN END;
    IF (ch = 'V') THEN xxx.traced := TRUE END;

    EVAL ReadUID (line, cur); (* self *)
    EVAL ReadUID (line, cur); (* super type *)
    n_fields    := ReadInt (line, cur); (* # fields *)
    n_methods   := ReadInt (line, cur); (* # methods *)
    n_overrides := ReadInt (line, cur); (* # overrides *)
    n_pending   := n_fields + n_methods + n_overrides;

    WHILE (n_pending &gt; 0) AND NOT Rd.EOF (rd) DO
      eol := Rd.GetSubLine (rd, line);
      ch  := line[0];  cur := 1;
      CASE ch OF

      | 'L' =&gt; (* field *)
           DEC (n_fields);
           DEC (n_pending);
           entry := NEW (ObjEntry);
           entry.name := ReadName (line, cur);
           EVAL ReadInt (line, cur); (* bit offset *)
           EVAL ReadInt (line, cur); (* bit size *)
           entry.uid := ReadUID (line, cur); (* type *)
           entry.source := field_source;  field_source := 0;
           AddObjEntry (xxx, xxx.fields, entry);

      | 'W' =&gt; (* method *)
           DEC (n_methods);
           DEC (n_pending);
           entry := NEW (ObjEntry);
           entry.name := ReadName (line, cur);
           entry.uid := ReadUID (line, cur); (* type *)
           entry.dfault := ReadBrand (line, cur);
           entry.source := method_source;  method_source := 0;
           AddObjEntry (xxx, xxx.methods, entry);

      | 'X' =&gt; (* overrides *)
           DEC (n_overrides);
           DEC (n_pending);
           id  := ReadName (line, cur);
           idX := ReadName (line, cur);
           IF xxx.names.get (id, ref) THEN
             entry := ref;
             entry.dfault := idX;
           END;

      ELSE (* skip *)
      END; (* CASE *)
    END; (* WHILE *)
  END ExtractThisObject;

PROCEDURE <A NAME="AddObjEntry"><procedure>AddObjEntry</procedure></A> (VAR xxx: ObjInfo;  VAR q: ObjEntryQueue;  e: ObjEntry)=
  VAR ref: REFANY;  old: ObjEntry;
  BEGIN
    IF (q.head = NIL)
      THEN q.head := e;
      ELSE q.tail.next := e;
    END;
    q.tail := e;
    IF xxx.names.get (e.name, ref) THEN
      old := ref;
      old.hidden := TRUE;
    END;
    EVAL xxx.names.put (e.name, e);
  END AddObjEntry;

PROCEDURE <A NAME="FormatObject"><procedure>FormatObject</procedure></A> (READONLY xxx: ObjInfo;  wx: Wx.T)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR fmt := XFormat.New (wx);  x: ObjEntry;
  BEGIN
    fmt.putText (&quot;  &quot;);
    fmt.begin (2);
    IF (NOT xxx.traced) THEN fmt.putText (&quot;UNTRACED &quot;); END;
    fmt.putText (&quot;OBJECT&quot;);
    fmt.newLine ();
    IF (xxx.fields.head # NIL) THEN
      fmt.newLine ();
      fmt.align (4, tryOneLine := FALSE);
      x := xxx.fields.head;
      WHILE (x # NIL) DO
        FormatObjEntry (x, fmt, FALSE);
        x := x.next;
      END;
      fmt.end ();
    END;
    IF (xxx.methods.head # NIL) THEN
      fmt.newLine (-2);
      fmt.putText (&quot;METHODS&quot;);
      fmt.newLine ();
      fmt.align (4, tryOneLine := FALSE);
      x := xxx.methods.head;
      WHILE (x # NIL) DO
        FormatObjEntry (x, fmt, TRUE);
        x := x.next;
      END;
      fmt.end ();
    END;
    fmt.newLine (-2);
    fmt.putText (&quot;END&quot;);
    fmt.end ();
    fmt.flush ();
    fmt.close ();
  END FormatObject;

PROCEDURE <A NAME="FormatObjEntry"><procedure>FormatObjEntry</procedure></A> (x: ObjEntry;  fmt: XFormat.T;  method: BOOLEAN)
  RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    fmt.group ();

      fmt.group ();
        fmt.putText (x.name);
        fmt.putChar (' ');
      fmt.end ();

      fmt.group ();
        IF (method) THEN
          GenTypeName (x.uid, NIL, fmt, sig_only := TRUE);
        ELSE
          fmt.putText (&quot;: &quot;);
          GenTypeName (x.uid, NIL, fmt);
        END;
        IF (x.dfault = NIL) THEN fmt.putText (&quot;;&quot;); END;
      fmt.end ();

      fmt.group ();
        IF (x.dfault # NIL) THEN
          fmt.putText (&quot; := &quot;);
          GenProcRef (fmt, x.dfault);
          fmt.putText (&quot;;&quot;);
        END;
      fmt.end ();

      fmt.group ();
        IF (x.source # 0) THEN
          fmt.putText (&quot; (* &quot;);
          GenTypeName (x.source, NIL, fmt);
          fmt.putText (&quot; *)&quot;);
        END;
        IF (x.hidden) THEN
          fmt.putText (&quot; (*HIDDEN*)&quot;);
        END;
      fmt.end ();

    fmt.end ();
  END FormatObjEntry;
</PRE>------------------------------------------ expression formatter ---

<P><PRE>PROCEDURE <A NAME="GenTypeExpr"><procedure>GenTypeExpr</procedure></A> (info     : Info;
                       expanded : IntRefTbl.T;
                       fmt      : XFormat.T;
                       topLevel : BOOLEAN := FALSE;
                       sig_only : BOOLEAN := FALSE;
                       opaque_id: INTEGER := 0)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR rd := OpenDesc (info);   buf: ScanLine;
  BEGIN
    IF (rd = NIL) THEN RETURN END;
    TRY
      TRY
        EmitTypeExpr (rd, buf, 1, ' ', expanded, fmt,
                      topLevel, sig_only, opaque_id);
      FINALLY
        CloseDesc (rd);
      END;
    EXCEPT Rd.Failure(ec) =&gt;
      Choke2 (&quot;Trouble reading&quot;, info.info_file, ec, fmt);
    END;
  END GenTypeExpr;

PROCEDURE <A NAME="EmitTypeExpr"><procedure>EmitTypeExpr</procedure></A> (rd       : Rd.T;
                    VAR line     : ScanLine;
                        count    : INTEGER;
                        kind     : CHAR;
                        expanded : IntRefTbl.T;
                        fmt      : XFormat.T;
                        topLevel : BOOLEAN := FALSE;
                        sig_only : BOOLEAN := FALSE;
                        opaque_id: INTEGER := 0)
  RAISES {Rd.Failure, Wr.Failure, Thread.Alerted} =
  VAR
    eol, cur   : INTEGER;
    ch         : CHAR;
    a, b, c, d : INTEGER;
    e, f       : INTEGER;
    id, idX    : TEXT;
    rhs        : Info;
  BEGIN
    WHILE (count &gt; 0) AND NOT Rd.EOF (rd) DO
      eol := Rd.GetSubLine (rd, line);
      ch := line[0];  cur := 1;
      IF (ch = kind) OR (kind = ' ') THEN
        DEC (count);
        CASE ch OF
        | '?' =&gt; (* builtin type *)
             EVAL ReadUID (line, cur);
             id := ReadName (line, cur);
             fmt.putText (id);
        | 'F' =&gt; (* array *)
             EVAL ReadUID (line, cur);
             a := ReadUID (line, cur);
             b := ReadUID (line, cur);
             fmt.begin (2);
               fmt.putText (&quot;ARRAY &quot;);
               fmt.break (0);
               GenTypeName (a, expanded, fmt);
               fmt.putChar (' ');
               fmt.break (0);
               fmt.putText (&quot;OF &quot;);
               fmt.break (0);
               GenTypeName (b, expanded, fmt);
             fmt.end ();
        | 'G' =&gt; (* open array *)
             EVAL ReadUID (line, cur);
             a := ReadUID (line, cur);
             fmt.begin (2);
               fmt.putText (&quot;ARRAY OF &quot;);
               fmt.break ();
               GenTypeName (a, expanded, fmt);
             fmt.end ();
        | 'H' =&gt; (* enum *)
             EVAL ReadUID (line, cur);
             a := ReadInt (line, cur); (* # enum elements *)
             fmt.begin (2);
               fmt.putText (&quot;{&quot;);
               EmitTypeExpr (rd, line, a, 'I', expanded, fmt);
               fmt.putText (&quot;}&quot;);
             fmt.end ();
        | 'I' =&gt; (* enum elt *)
             id := ReadName (line, cur);
             fmt.break ();
             fmt.putText (id);
             IF (count &gt; 0) THEN fmt.putText (&quot;, &quot;); END;
        | 'J' =&gt; (* bits for *)
             EVAL ReadUID (line, cur);
             a := ReadInt (line, cur);
             b := ReadUID (line, cur);
             fmt.begin (2);
               fmt.putText (&quot;BITS &quot;);
               fmt.putText (Fmt.Int (a));
               fmt.putText (&quot; FOR &quot;);
               fmt.break ();
               GenTypeName (b, expanded, fmt);
             fmt.end ();
        | 'K' =&gt; (* record *)
             EVAL ReadUID (line, cur);  (* self *)
             EVAL ReadInt (line, cur);  (* total size *)
             a := ReadInt (line, cur);  (* # fields *)
             fmt.begin (2);
               fmt.putText (&quot;RECORD &quot;);
               IF (topLevel) THEN fmt.newLine () END;
               fmt.unitedBreak ();
               fmt.align (3, tryOneLine := NOT topLevel);
               EmitTypeExpr (rd, line, a, 'L', expanded, fmt);
               fmt.end ();
               fmt.unitedBreak (-2);
               fmt.putText (&quot;END &quot;);
             fmt.end (); (* RECORD *)
        | 'L' =&gt; (* field *)
             id := ReadName (line, cur);
             EVAL ReadInt (line, cur);
             EVAL ReadInt (line, cur);
             a := ReadUID (line, cur);
             fmt.group ();
               fmt.group ();
                 fmt.putText (id);
                 fmt.putChar (' ');
               fmt.end ();
               fmt.group ();
                 fmt.putText (&quot;: &quot;);
               fmt.end ();
               fmt.group ();
                 GenTypeName (a, expanded, fmt);
                 fmt.putText (&quot;; &quot;);
               fmt.end ();
             fmt.end ();
        | 'M' =&gt; (* set *)
             EVAL ReadUID (line, cur);
             a := ReadUID (line, cur);
             fmt.begin (2);
               fmt.putText (&quot;SET OF &quot;);
               fmt.break ();
               GenTypeName (a, expanded, fmt);
             fmt.end ();
        | 'N' =&gt; (* subrange *)
             EVAL ReadUID (line, cur);
             a   := ReadUID (line, cur);
             id  := ReadName (line, cur);
             idX := ReadName (line, cur);
             fmt.begin (2);
               fmt.putText (&quot;[ &quot;);
               fmt.putText (id);
               fmt.break ();
               fmt.putText (&quot; .. &quot;);
               fmt.putText (idX);
               fmt.putText (&quot; ]&quot;);
               IF (a # INTEGER_UID) THEN
                 fmt.putChar (' ');
                 fmt.break ();
                 fmt.putText (&quot;(OF &quot;);
                 GenTypeName (a, expanded, fmt);
                 fmt.putText (&quot;)&quot;);
               END;
             fmt.end ();
        | 'O', 'P' =&gt; (* untraced ref *)
             EVAL ReadUID (line, cur);
             a := ReadUID (line, cur);
             id := ReadBrand (line, cur);
             fmt.begin (2);
               IF (ch = 'O') THEN
                 fmt.putText (&quot;UNTRACED &quot;);
               END;
               IF (id # NIL) THEN
                 fmt.break ();
                 fmt.putText (&quot;BRANDED \&quot;&quot;);
                 fmt.putText (id, raw := TRUE);
                 fmt.putText (&quot;\&quot; &quot;);
               END;
               fmt.break ();
               fmt.putText (&quot;REF &quot;);
               fmt.break ();
               GenTypeName (a, expanded, fmt);
             fmt.end ();
        | 'Q' =&gt; (* indirect *)
             EVAL ReadUID (line, cur);
             a := ReadUID (line, cur);
             fmt.begin (2);
               fmt.putText (&quot;VAR &quot;);
               fmt.break ();
               GenTypeName (a, expanded, fmt);
             fmt.end ();
        | 'R' =&gt; (* procedure *)
             EVAL ReadUID (line, cur);
             a := ReadInt (line, cur);  (* # formals *)
             b := ReadUID (line, cur);  (* return type *)
             c := ReadInt (line, cur);  (* # raises *)
             d := Rd.Index (rd);
             fmt.begin (2);
               IF (NOT sig_only) THEN
                 fmt.putText (&quot;PROCEDURE &quot;);
               END;
               fmt.putText (&quot;(&quot;);
               IF (a &gt; 0) THEN
                 fmt.align (3, tryOneLine := TRUE);
                 Rd.Seek (rd, d);
                 EmitTypeExpr (rd, line, a, 'S', expanded, fmt);
                 fmt.end ();
               END;
               fmt.putText (&quot;)&quot;);
               IF (b # 0) THEN
                 fmt.break ();
                 fmt.putText (&quot;: &quot;);
                 GenTypeName (b, expanded, fmt);
               END;
               IF (c &gt; 0) THEN
                 fmt.break ();
                 fmt.begin (2);
                 fmt.putText (&quot; RAISES {&quot;);
                 Rd.Seek (rd, d);
                 EmitTypeExpr (rd, line, a, 'T', expanded, fmt);
                 fmt.putText (&quot;}&quot;);
                 fmt.end ();
               END;
             fmt.end ();
          | 'S' =&gt; (* formal *)
             id := ReadName (line, cur);
             a := ReadUID (line, cur);
             fmt.group ();
               fmt.group ();
                 fmt.putText (id);
                 fmt.putChar (' ');
               fmt.end ();
               fmt.group ();
                 fmt.putText (&quot;: &quot;);
               fmt.end ();
               fmt.group ();
                 GenTypeName (a, expanded, fmt);
                 IF (count &gt; 0) THEN fmt.putText (&quot;; &quot;); END;
               fmt.end ();
             fmt.end ();
        | 'T' =&gt; (* raises *)
             id := ReadName (line, cur);
             fmt.break ();
             fmt.putText (id);
             IF (count &gt; 0) THEN fmt.putText (&quot;, &quot;); END;
        | 'U', 'V' =&gt; (* untraced obj, obj *)
             a := ReadUID (line, cur); (* self *)
             b := ReadUID (line, cur); (* super type *)
             c := ReadInt (line, cur); (* # fields *)
             d := ReadInt (line, cur); (* # methods *)
             e := ReadInt (line, cur); (* # overrides *)
             EVAL ReadInt (line, cur); (* total field size *)
             id := ReadBrand (line, cur);
             f := Rd.Index (rd);

             fmt.begin (2);
               IF (b # 0) THEN (* super type *)
                 IF (expanded = NIL) THEN
                   GenTypeName (b, expanded, fmt);
                   fmt.putChar (' ');
                 ELSE
                   GenTypeName (b, expanded, fmt, topLevel);
                   fmt.newLine ();
                   fmt.newLine (-2);
                 END;
               ELSE
                 IF (ch = 'U') THEN fmt.putText (&quot;UNTRACED &quot;); END;
               END;
               IF (id # NIL) THEN
                 fmt.break ();
                 fmt.putText (&quot;BRANDED \&quot;&quot;);
                 fmt.putText (id, raw := TRUE);
                 fmt.putText (&quot;\&quot; &quot;);
               END;
               fmt.putText (&quot;OBJECT &quot;);
               IF (expanded # NIL) THEN
                 IF NOT GenObjectName (a, fmt) THEN
                   EVAL GenObjectName (opaque_id, fmt);
                 END;
               END;
               IF (c &gt; 0) THEN
                 fmt.unitedBreak ();
                 fmt.align (3, tryOneLine := NOT topLevel);
                 Rd.Seek (rd, f);
                 EmitTypeExpr (rd, line, c, 'L', expanded, fmt);
                 fmt.end ();
               END;
               IF (d &gt; 0) THEN
                 fmt.unitedBreak (-2);
                 fmt.putText (&quot;METHODS &quot;);
                 fmt.unitedBreak (0);
                 Rd.Seek (rd, f);
                 EmitTypeExpr (rd, line, d, 'W', expanded, fmt);
               END;
               IF (e &gt; 0) THEN
                 fmt.unitedBreak (-2);
                 fmt.putText (&quot;OVERRIDES &quot;);
                 fmt.unitedBreak (0);
                 fmt.align (3, tryOneLine := NOT topLevel);
                 Rd.Seek (rd, f);
                 EmitTypeExpr (rd, line, e, 'X', expanded, fmt);
                 fmt.end ();
               END;
               IF (topLevel) THEN fmt.newLine (-2); END;
               fmt.unitedBreak (-2);
               fmt.putText (&quot;END &quot;);
             fmt.end (); (* OBJECT *)
        | 'W' =&gt; (* method *)
             id := ReadName (line, cur);
             a := ReadUID (line, cur);
             idX := ReadBrand (line, cur);
             fmt.unitedBreak ();
             fmt.putText (id);
             fmt.putChar (' ');
             fmt.begin ();
               GenTypeName (a, expanded, fmt, sig_only := TRUE);
               IF (idX # NIL) THEN
                 fmt.putText (&quot; := &quot;);
                 GenProcRef (fmt, idX);
               END;
               fmt.putText (&quot;; &quot;);
             fmt.end ();
        | 'X' =&gt; (* overrides *)
             id  := ReadName (line, cur);
             idX := ReadName (line, cur);
             fmt.group ();
               fmt.group ();
                 fmt.putText (id);
                 fmt.putChar (' ');
               fmt.end ();
               fmt.group ();
                 fmt.putText (&quot;:= &quot;);
               fmt.end ();
               fmt.group ();
                 GenProcRef (fmt, idX);
                 fmt.putText (&quot;; &quot;);
               fmt.end ();
             fmt.end ();
        | 'Y' =&gt; (* opaque *)
             a := ReadUID (line, cur); (* self *)
             b := ReadUID (line, cur); (* super *)
             IF TranslateOpaque (a, rhs) THEN
               GenTypeExpr (rhs, expanded, fmt, topLevel, opaque_id := a);
             ELSE
               fmt.begin (2);
                 fmt.putText (&quot;&lt;: &quot;);
                 GenTypeName (a, expanded, fmt, topLevel);
               fmt.end ();
             END;
        | '@', 'A', 'B', 'C', 'D', 'Z' =&gt;
             INC (count); (* ignore this line *)
        ELSE
          fmt.putMarkup (&quot;(! bad char =\&quot;&quot;);
          fmt.putMarkup (Text.FromChar (ch));
          fmt.putMarkup (&quot;\&quot; !)&quot;);
        END; (* CASE *)
      END; (* IF ch = kind *)
    END; (* WHILE *)
  END EmitTypeExpr;

PROCEDURE <A NAME="GenTypeName"><procedure>GenTypeName</procedure></A> (uid      : INTEGER;
                       ex       : IntRefTbl.T;
                       fmt      : XFormat.T;
                       topLevel : BOOLEAN := FALSE;
                       sig_only : BOOLEAN := FALSE)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR ref: REFANY;  old: BOOLEAN;  info: Info;
  BEGIN
    IF NOT Get (uid, info) THEN
      fmt.putMarkup (&quot;&amp;lt;&quot;, 1);
      fmt.putText   (&quot;anon: &quot; &amp; FmtUID (uid));
      fmt.putMarkup (&quot;&amp;gt;&quot;, 1);
      RETURN;
    END;
    IF (ex # NIL)
      AND (info.info_file # NIL)
      AND (topLevel = IsRef (info))
      AND NOT ex.get (uid, ref) THEN
      old := ex.put (uid, NIL);
      fmt.group ();
      GenTypeExpr (info, ex, fmt, topLevel, sig_only);
      fmt.end ();
      IF NOT old THEN EVAL ex.delete (uid, ref); END;
      RETURN;
    END;
    fmt.group ();
    fmt.putMarkup (&quot;&lt;A HREF=\&quot;/&quot;);
    fmt.putMarkup (FmtHREF (info, uid));
    fmt.putMarkup (&quot;/\&quot;&gt;&quot;);
    IF (info.names # NIL) AND NOT sig_only THEN
      fmt.putText (ID.ToText (info.names.name));
    ELSE
      fmt.putMarkup (&quot;&amp;lt;&quot;, 1);
      fmt.putText   (&quot;anon: &quot; &amp; FmtUID (uid));
      fmt.putMarkup (&quot;&amp;gt;&quot;, 1);
    END;
    fmt.putMarkup (&quot;&lt;/A&gt;&quot;);
    fmt.end ();
  END GenTypeName;

PROCEDURE <A NAME="GenObjectName"><procedure>GenObjectName</procedure></A> (uid: INTEGER;  fmt: XFormat.T): BOOLEAN
  RAISES {Wr.Failure} =
  VAR info: Info;
  BEGIN
    IF (uid = 0) THEN RETURN FALSE END;
    IF NOT Get (uid, info) THEN RETURN FALSE END;
    IF (info.names = NIL) THEN RETURN FALSE END;
    fmt.group ();
    fmt.putText (&quot;(* &quot;);
    fmt.putMarkup (&quot;&lt;A HREF=\&quot;/&quot;);
    fmt.putMarkup (FmtHREF (info, uid));
    fmt.putMarkup (&quot;/\&quot;&gt;&quot;);
    fmt.putText (ID.ToText (info.names.name));
    fmt.putMarkup (&quot;&lt;/A&gt;&quot;);
    fmt.putText (&quot; *)&quot;);
    fmt.end ();
    RETURN TRUE;
  END GenObjectName;

PROCEDURE <A NAME="GenProcRef"><procedure>GenProcRef</procedure></A> (fmt: XFormat.T;  t: TEXT)
  RAISES {Wr.Failure} =
  VAR dotIndex := Text.FindChar(t, '.');  unit, proc: TEXT;
  BEGIN
    fmt.group();
    IF dotIndex = -1 THEN
      fmt.putMarkup(t)
    ELSE
      unit := Text.Sub (t, 0, dotIndex);
      proc := Text.Sub (t, dotIndex + 1);
      fmt.putMarkup(Fmt.F (&quot;&lt;A HREF=\&quot;/exporter/%s.i3/%s#%s\&quot;&gt;%s&lt;/A&gt;&quot;,
                           unit, proc, proc, t));
    END;
    fmt.end();
  END GenProcRef;
</PRE>--------------------------------------------------------- names ---

<P><PRE>PROCEDURE <A NAME="GetTypeName"><procedure>GetTypeName</procedure></A> (uid: INTEGER;  VAR(*OUT*)name, home: TEXT;  pref: TEXT)=
  VAR t, u: Info := NIL;
  BEGIN
    IF Get (uid, t) THEN
      IF SetTypeName (t, name, home, pref) THEN RETURN END;
    END;
    IF FindOpaque (uid, u) THEN
      t := u;
      IF SetTypeName (t, name, home, pref) THEN RETURN END;
    END;
    name := Fmt.F (&quot;&amp;lt;anon: %s&amp;gt;&quot;, FmtUID (uid));
    home := NIL;
    IF (t # NIL) THEN home := ID.ToText (t.home); END;
  END GetTypeName;

PROCEDURE <A NAME="SetTypeName"><procedure>SetTypeName</procedure></A> (t: Info;  VAR(*OUT*)name, home: TEXT;
                       pref: TEXT): BOOLEAN =
  VAR id: ID.T;  tn: T;
  BEGIN
    IF (t.names = NIL) THEN RETURN FALSE; END;

    IF (pref # NIL) THEN
      (* search for a match *)
      id := ID.Add (pref);
      tn := t.names;
      WHILE (tn # NIL) DO
        IF (tn.name = id) THEN
          name := pref;
          home := ID.ToText (tn.home);
          RETURN TRUE;
        END;
        tn := tn.alias;
      END;
    END;

    name := ID.ToText (t.names.name);
    home := ID.ToText (t.names.home);
    RETURN TRUE;
  END SetTypeName;

PROCEDURE <A NAME="FmtHREF"><procedure>FmtHREF</procedure></A> (info: Info;  uid: INTEGER): TEXT =
  VAR nd: Node.List;  ref: REFANY;
  BEGIN
    IF (info # NIL) AND (info.names # NIL) THEN
      IF BrowserDB.db.type_names.get (info.names.name, ref) AND (ref # NIL) THEN
        nd := NARROW (ref, Node.List);
        IF (nd.tail = NIL) THEN
          (* the type's name is unique, skip the UID nonsense. *)
          RETURN &quot;type/&quot; &amp; ID.ToText (info.names.name);
        END;
      END;
    END;
    RETURN &quot;type-uid/&quot; &amp; FmtUID (uid);
  END FmtHREF;
</PRE>------------------------------------------ opaque &amp; revelations ---

<P><PRE>PROCEDURE <A NAME="Get"><procedure>Get</procedure></A> (uid: INTEGER;  VAR info: Info): BOOLEAN =
  VAR ref: REFANY;
  BEGIN
    IF BrowserDB.db.types.get (uid, ref) THEN
      info := ref;
      RETURN TRUE;
    END;
    RETURN FALSE;
  END Get;

PROCEDURE <A NAME="GetObjInfo"><procedure>GetObjInfo</procedure></A> (uid: INTEGER;  VAR info: ObjectInfo): BOOLEAN =
  VAR ref: REFANY;
  BEGIN
    IF BrowserDB.db.objects.get (uid, ref) THEN
      info := ref;
      RETURN TRUE;
    END;
    RETURN FALSE;
  END GetObjInfo;

PROCEDURE <A NAME="FindOpaque"><procedure>FindOpaque</procedure></A> (rhs_uid: INTEGER;  VAR lhs: Info): BOOLEAN =
  VAR obj_info: ObjectInfo;
  BEGIN
    RETURN GetObjInfo (rhs_uid, obj_info)
       AND (obj_info.opaque # 0)
       AND (obj_info.opaque # rhs_uid)
       AND Get (obj_info.opaque, lhs);
  END FindOpaque;

PROCEDURE <A NAME="TranslateOpaque"><procedure>TranslateOpaque</procedure></A> (lhs_uid: INTEGER;  VAR rhs: Info): BOOLEAN =
  VAR obj_info: ObjectInfo;
  BEGIN
    RETURN GetObjInfo (lhs_uid, obj_info)
       AND (obj_info.concrete # lhs_uid)
       AND Get (obj_info.concrete, rhs);
  END TranslateOpaque;
</PRE>------------------------------------------------------ subtypes ---

<P><PRE>PROCEDURE <A NAME="IsRef"><procedure>IsRef</procedure></A> (t: Info): BOOLEAN =
  BEGIN
    RETURN (t.kind = 'P') OR (t.kind = 'V')
        OR (t.kind = 'O') OR (t.kind = 'U')
        OR (t.kind = 'Y');
  END IsRef;

PROCEDURE <A NAME="IsObject"><procedure>IsObject</procedure></A> (t: Info): BOOLEAN =
  VAR u: Info;
  BEGIN
    RETURN (t.kind = 'V')
        OR (t.kind = 'U')
        OR ((t.kind = 'Y') AND TranslateOpaque (t.uid, u));
  END IsObject;

PROCEDURE <A NAME="SuperType"><procedure>SuperType</procedure></A> (t: Info): Info =
  VAR u: Info;  obj_info: ObjectInfo;
  BEGIN
    IF (t # NIL)
      AND GetObjInfo (t.uid, obj_info)
      AND (obj_info.supertype # 0)
      AND Get (obj_info.supertype, u) THEN
      RETURN u;
    END;
    RETURN NIL;
  END SuperType;

PROCEDURE <A NAME="Subtypes"><procedure>Subtypes</procedure></A> (t: Info): Info =
  VAR u: Info;  obj_info: ObjectInfo;
  BEGIN
    IF (t # NIL)
      AND GetObjInfo (t.uid, obj_info)
      AND (obj_info.subtypes # 0)
      AND Get (obj_info.subtypes, u) THEN
      RETURN u;
    END;
    RETURN NIL;
  END Subtypes;

PROCEDURE <A NAME="NextPeer"><procedure>NextPeer</procedure></A> (t: Info): Info =
  VAR u: Info;  obj_info: ObjectInfo;
  BEGIN
    IF (t # NIL)
      AND GetObjInfo (t.uid, obj_info)
      AND (obj_info.next_peer # 0)
      AND Get (obj_info.next_peer, u) THEN
      RETURN u;
    END;
    RETURN NIL;
  END NextPeer;
</PRE>--------------------------------------------------------- files ---

<P><PRE>PROCEDURE <A NAME="OpenDesc"><procedure>OpenDesc</procedure></A> (info: Info): Rd.T
  RAISES {Thread.Alerted} =
  VAR rd: Rd.T;
  BEGIN
    IF (info.info_file = NIL) THEN RETURN NIL; END;

    IF Text.Equal (info.info_file, BuiltinName)
      THEN rd := TextRd.New (BuiltinInfo);
      ELSE rd := OS.OpenRd (info.info_file);
    END;
    IF (rd = NIL) THEN RETURN NIL; END;

    TRY
      Rd.Seek (rd, info.info_offset);
    EXCEPT Rd.Failure (ec) =&gt;
      Choke (&quot;Unable to seek in&quot;, info.info_file, ec);
      OS.CloseRd (rd);
      RETURN NIL;
    END;

    RETURN rd;
  END OpenDesc;

PROCEDURE <A NAME="CloseDesc"><procedure>CloseDesc</procedure></A> (rd: Rd.T) =
  BEGIN
    OS.CloseRd (rd);
  END CloseDesc;

PROCEDURE <A NAME="Choke"><procedure>Choke</procedure></A> (tag: TEXT;  file: TEXT;  ec: AtomList.T) =
  BEGIN
    ErrLog.Msg (tag &amp; &quot; \&quot;&quot;, file, &quot;\&quot;&quot;, OS.Err (ec));
  END Choke;

PROCEDURE <A NAME="Choke2"><procedure>Choke2</procedure></A> (tag: TEXT;  file: TEXT;  ec: AtomList.T;  fmt: XFormat.T)
  RAISES {Wr.Failure} =
  BEGIN
    Choke (tag, file, ec);
    fmt.putMarkup (Fmt.F (&quot;\n&lt;PRE&gt;\n!!%s \&quot;%s\&quot;%s !!\n&lt;/PRE&gt;\n&quot;,
                          tag, file, OS.Err (ec)));
  END Choke2;
</PRE>------------------------------------------------ initialization ---

<P><PRE>PROCEDURE <A NAME="Init"><procedure>Init</procedure></A> () =
  BEGIN
  END Init;

BEGIN
END Type.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface Type is in:
</A><UL>
<LI><A HREF="Type.i3.html#0TOP0">cm3ide/src/nodes/Type.i3</A>
<LI><A HREF="../../../m3front/src/types/Type.i3.html#0TOP0">m3front/src/types/Type.i3</A>
<LI><A HREF="../../../sharedobjgen/src/Type.i3.html#0TOP0">sharedobjgen/src/Type.i3</A>
<LI><A HREF="../../../stablegen/src/Type.i3.html#0TOP0">stablegen/src/Type.i3</A>
<LI><A HREF="../../../stubgen/src/Type.i3.html#0TOP0">stubgen/src/Type.i3</A>
</UL>
<P>
<HR>
<A NAME="x2">interface ErrLog is in:
</A><UL>
<LI><A HREF="../utils/ErrLog.i3.html#0TOP0">cm3ide/src/utils/ErrLog.i3</A>
<LI><A HREF="../../../m3markup/src/ErrLog.i3.html#0TOP0">m3markup/src/ErrLog.i3</A>
</UL>
<P>
<HR>
<A NAME="x3">interface ID is in:
</A><UL>
<LI><A HREF="../utils/ID.i3.html#0TOP0">cm3ide/src/utils/ID.i3</A>
<LI><A HREF="../../../m3markup/src/ID.i3.html#0TOP0">m3markup/src/ID.i3</A>
</UL>
<P>
<HR>
<A NAME="x4">interface HTML is in:
</A><UL>
<LI><A HREF="../misc/HTML.i3.html#0TOP0">cm3ide/src/misc/HTML.i3</A>
<LI><A HREF="../../../webvbt/src/HTML.i3.html#0TOP0">webvbt/src/HTML.i3</A>
</UL>
<P>
<HR>
<A NAME="x5">interface OS is in:
</A><UL>
<LI><A HREF="../utils/OS.i3.html#0TOP0">cm3ide/src/utils/OS.i3</A>
<LI><A HREF="../../../fix_nl/src/OS.i3.html#0TOP0">fix_nl/src/OS.i3</A>
<LI><A HREF="../../../m3browser/src/OS.i3.html#0TOP0">m3browser/src/OS.i3</A>
</UL>
<P>
<HR>
<A NAME="x6">interface Wx is in:
</A><UL>
<LI><A HREF="../utils/Wx.i3.html#0TOP0">cm3ide/src/utils/Wx.i3</A>
<LI><A HREF="../../../libbuf/src/Wx.i3.html#0TOP0">libbuf/src/Wx.i3</A>
</UL>
<P>
<HR>
<A NAME="x7">interface XFormat is in:
</A><UL>
<LI><A HREF="../markup/XFormat.i3.html#0TOP0">cm3ide/src/markup/XFormat.i3</A>
<LI><A HREF="../../../m3markup/src/XFormat.i3.html#0TOP0">m3markup/src/XFormat.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
