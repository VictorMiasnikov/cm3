<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: netobj/src/netobjrt/StubLib.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>netobj/src/netobjrt/StubLib.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright 1992 Digital Equipment Corporation.               
 Distributed only by permission.                             
 StubLib.m3 
 Last modified on Tue Jan 31 08:47:30 PST 1995 by kalsow 
      modified on Wed Aug 31 16:52:41 PDT 1994 by wobber 
      modified on Wed Feb 10 17:10:17 PST 1993 by owicki 

<P><PRE>UNSAFE MODULE <module>StubLib</module> EXPORTS <A HREF="StubLib.i3.html"><implements>StubLib</A></implements>, <A HREF="NetObjF.i3.html"><implements>NetObjF</A></implements>;
   (* unsafe because of marshalling code *)

IMPORT <A HREF="NetObj.i3.html">NetObj</A>, <A HREF="NetObjRep.i3.html">NetObjRep</A>, <A HREF="NetObjRT.i3.html">NetObjRT</A>, <A HREF="../../../libm3/src/pickle/ver1/Pickle.i3.html">Pickle</A>, <A HREF="../../../libm3/src/pickle/ver2/Pickle2.i3.html">Pickle2</A>, <A HREF="#x1">Protocol</A>, <A HREF="Transport.i3.html">Transport</A>,
       <A HREF="TransportUtils.i3.html">TransportUtils</A>, <A HREF="Voucher.i3.html">Voucher</A>, <A HREF="WireRep.i3.html">WireRep</A>;
IMPORT <A HREF="../../../libm3/src/atom/Atom.i3.html">Atom</A>, <A HREF="../../../libm3/derived/AtomList.i3.html">AtomList</A>, <A HREF="../../../libm3/src/rw/Rd.i3.html">Rd</A>, <A HREF="../../../m3core/src/runtime/common/RTType.i3.html">RTType</A>, <A HREF="../../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="../../../m3core/src/text/Text.i3.html">Text</A>, <A HREF="../../../m3core/src/text/TextClass.i3.html">TextClass</A>, <A HREF="../../../m3core/src/text/Text8.i3.html">Text8</A>, <A HREF="../../../m3core/src/text/Text16.i3.html">Text16</A>,
       <A HREF="../../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../../libm3/src/rw/RdClass.i3.html">RdClass</A>, <A HREF="../../../libm3/src/rw/WrClass.i3.html">WrClass</A>, <A HREF="../../../libm3/src/rw/UnsafeRd.i3.html">UnsafeRd</A>, <A HREF="../../../libm3/src/rw/UnsafeWr.i3.html">UnsafeWr</A>, <A HREF="../../../m3core/src/float/IEEE-default/FloatMode.i3.html">FloatMode</A>, <A HREF="../../../libm3/src/uid/Common/Swap.i3.html">Swap</A>;

FROM <A HREF="#x1">Protocol</A> IMPORT MsgHeader, CallHeader, Op;

REVEAL RdClass.Private &lt;: MUTEX;
REVEAL WrClass.Private &lt;: MUTEX;
</PRE> most if not all of the following could be inline in stub code 

<P> Since clients of <CODE>Conn</CODE> must avoid accessing them concurrently,
   we operate on the embedded streams without locking them.


<P><PRE>TYPE ObjectStack = RECORD
    pos: CARDINAL := 0;
    objs: REF ARRAY OF NetObj.T := NIL;
  END;

CONST DefaultObjStackSize = 8;

REVEAL
  <A NAME="Conn">Conn</A> = Transport.Conn BRANDED OBJECT
    protocol: StubProtocol := 0;
    objStack: ObjectStack := ObjectStack {};
    inObj: BOOLEAN := FALSE;
  END;
</PRE> The field <CODE>t.objStack</CODE> is used to record the set of network objects
   marshalled during any single method invocation (at either client or
   server).  This record is required for cleanup at the termination of
   the call.   The <CODE>t.objStack</CODE> field is managed by the network object
   runtime and should not be modified by any transport implementation. 

<P><PRE>REVEAL
  Transport.<A NAME="T">T</A> = TransportUtils.Public BRANDED OBJECT
  OVERRIDES
    serviceCall := ServiceCall;
  END;
</PRE> Pickle.Reader and Pickle.Writer subtypes and free list headers 

<P><PRE>TYPE SpecWr = Pickle.Writer OBJECT
  c: Conn;
  next: SpecWr;
  END;

TYPE SpecWr2 = Pickle2.Writer OBJECT
  c: Conn;
  next: SpecWr2;
  END;

TYPE SpecRd = Pickle.Reader OBJECT
  c: Conn;
  rep: DataRep;
  next: SpecRd;
  END;

TYPE SpecRd2 = Pickle2.Reader OBJECT
  c: Conn;
  rep: DataRep;
  next: SpecRd2;
  END;

TYPE
  CharPtr  = UNTRACED REF ARRAY [0..65535] OF CHAR;
  WCharPtr = UNTRACED REF ARRAY [0..65535] OF WIDECHAR;

VAR mu: MUTEX;
    freeWr: SpecWr;
    freeRd: SpecRd;
    freeWr2: SpecWr2;
    freeRd2: SpecRd2;

PROCEDURE <A NAME="ServiceCall"><procedure>ServiceCall</procedure></A>(&lt;*UNUSED*&gt; tt: Transport.T; c: Conn) : BOOLEAN
    RAISES {Thread.Alerted} =
  BEGIN
      TRY
        VAR
          dispatcher: Dispatcher;
          obj: NetObj.T;
          rd := c.rd;
          h := LOOPHOLE(ADR(rd.buff[rd.st+rd.cur-rd.lo]),
                                     UNTRACED REF CallHeader);
        BEGIN
          IF rd.hi - rd.cur &lt; BYTESIZE(CallHeader) OR
                     h.hdr.private # ORD(Op.MethodCall) THEN
               RaiseUnmarshalFailure();
          END;
          INC(rd.cur, BYTESIZE(CallHeader));
          IF h.hdr.intFmt # NativeRep.intFmt THEN
            IF NOT NativeEndian(h.hdr) THEN
              h.prot := Swap.Swap4(h.prot);
            END;
          END;
          c.protocol := h.prot;
          obj := NetObjRT.FindTarget(h.obj, h.prot, dispatcher);
          TRY
            c.objStack.pos := 0;
            dispatcher(c, obj, h.hdr, h.prot);
            IF (c.objStack.pos # 0) THEN
              c.wr.nextMsg();
              IF NOT rd.nextMsg() OR rd.hi - rd.cur &lt; BYTESIZE(MsgHeader) THEN
                RETURN FALSE;
              END;
              VAR hh := LOOPHOLE(ADR(rd.buff[rd.st+rd.cur-rd.lo]),
                                              UNTRACED REF MsgHeader)^;
              BEGIN
                INC(rd.cur, BYTESIZE(MsgHeader));
                IF hh.hdr.private # ORD(Op.ResultAck) THEN RETURN FALSE; END;
              END;
            ELSE
              c.wr.nextMsg();
            END;
          FINALLY
            IF (c.objStack.pos # 0) THEN
              NetObjRT.Unpin(SUBARRAY(c.objStack.objs^, 0, c.objStack.pos));
              FOR i := 0 TO c.objStack.pos-1 DO
                c.objStack.objs[i] := NIL;
              END;
            END;
          END;
        END;
      EXCEPT
      | Rd.Failure, Wr.Failure =&gt; RETURN FALSE;
      | NetObj.Error(ec) =&gt;
          TRY
            (* this test checks whether we have started marshalling results *)
            IF c.wr.cur = 0 THEN
              VAR wr := c.wr;
                  h := LOOPHOLE(ADR(wr.buff[wr.st+wr.cur-wr.lo]),
                                             UNTRACED REF MsgHeader);
              BEGIN
                h.hdr := NativeRep;
                h.hdr.private := ORD(Op.CallFailed);
                INC(wr.cur, BYTESIZE(MsgHeader));
              END;
              OutRef(c, ec);
            END;
            c.wr.nextMsg();
          EXCEPT
          | Wr.Failure =&gt; RETURN FALSE;
          END;
      END;
    RETURN TRUE;
  END ServiceCall;
</PRE> exports to StubLib 

<P><PRE>PROCEDURE <A NAME="StartCall"><procedure>StartCall</procedure></A>(obj: NetObj.T; stubProt: StubProtocol) : Conn
    RAISES {NetObj.Error, Thread.Alerted} =
  VAR c := NARROW(obj.r, Transport.Location).new();
  BEGIN
    c.objStack.pos := 0;
    c.inObj := FALSE;
    c.protocol := stubProt;
    VAR wr := c.wr;
        h := LOOPHOLE(ADR(wr.buff[wr.st+wr.cur-wr.lo]),
                                 UNTRACED REF CallHeader);
    BEGIN
      &lt;* ASSERT (wr.hi - wr.cur &gt;= BYTESIZE(CallHeader)) *&gt;
      INC(wr.cur, BYTESIZE(CallHeader));
      h.hdr := NativeRep;
      h.hdr.private := ORD(Op.MethodCall);
      h.prot := stubProt;
      h.obj := obj.w;
    END;
    RETURN c;
  END StartCall;

PROCEDURE <A NAME="AwaitResult"><procedure>AwaitResult</procedure></A>(c: Conn) : DataRep
    RAISES {NetObj.Error, Rd.Failure, Wr.Failure, Thread.Alerted} =
  VAR h: MsgHeader;
      rd := c.rd;
  BEGIN
    c.wr.nextMsg();
    TRY
      IF NOT rd.nextMsg() OR rd.hi - rd.cur &lt; BYTESIZE(MsgHeader) THEN
        RaiseUnmarshalFailure();
      END;
      h := LOOPHOLE(ADR(rd.buff[rd.st+rd.cur-rd.lo]), UNTRACED REF MsgHeader)^;
      INC(rd.cur, BYTESIZE(MsgHeader));
    EXCEPT
    | Thread.Alerted =&gt; RAISE NetObj.Error(AtomList.List1(NetObj.Alerted));
    END;
    CASE h.hdr.private OF
    | ORD(Op.Return) =&gt;
    | ORD(Op.CallFailed) =&gt;
        RAISE NetObj.Error(InRef(c, h.hdr, TYPECODE(AtomList.T)));
    ELSE
      RaiseUnmarshalFailure();
    END;
    RETURN h.hdr;
  END AwaitResult;

PROCEDURE <A NAME="EndCall"><procedure>EndCall</procedure></A>(c: Conn; reUse: BOOLEAN)
    RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    TRY
      IF c.objStack.pos # 0 THEN
        NetObjRT.Unpin(SUBARRAY(c.objStack.objs^, 0, c.objStack.pos));
        FOR i := 0 TO c.objStack.pos-1 DO
          c.objStack.objs[i] := NIL;
        END;
      END;
      IF reUse AND c.inObj (* OR NOT UnsafeRd.FastEOF(c.rd) *) THEN
        VAR wr := c.wr;
            h := LOOPHOLE(ADR(wr.buff[wr.st+wr.cur-wr.lo]),
                                       UNTRACED REF MsgHeader);
        BEGIN
          h.hdr := NativeRep;
          h.hdr.private := ORD(Op.ResultAck);
          INC(wr.cur, BYTESIZE(MsgHeader));
          wr.nextMsg();
        END;
      END;
    FINALLY
      c.loc.free(c, reUse);
    END;
  END EndCall;

PROCEDURE <A NAME="StartResult"><procedure>StartResult</procedure></A>(c: Conn) =
  VAR wr := c.wr;
      h := LOOPHOLE(ADR(wr.buff[wr.st+wr.cur-wr.lo]),
                                 UNTRACED REF MsgHeader);
  BEGIN
    h.hdr := NativeRep;
    h.hdr.private := ORD(Op.Return);
    INC(wr.cur, BYTESIZE(MsgHeader));
  END StartResult;

PROCEDURE <A NAME="InChars"><procedure>InChars</procedure></A>(c: Conn; rep: DataRep; VAR arr: ARRAY OF CHAR)
    RAISES {NetObj.Error, Rd.Failure, Thread.Alerted} =
  BEGIN
    IF rep.charSet # NativeRep.charSet THEN
      RaiseError(NetObj.UnsupportedDataRep);
    END;
    IF c.rd.getSub(arr) # NUMBER(arr) THEN
      RaiseUnmarshalFailure();
    END;
  END InChars;

PROCEDURE <A NAME="InWideChars"><procedure>InWideChars</procedure></A>(c: Conn; rep: DataRep; VAR arr: ARRAY OF WIDECHAR)
    RAISES {NetObj.Error, Rd.Failure, Thread.Alerted} =
  VAR cnt: INTEGER := NUMBER(arr);  p: CharPtr;  n: INTEGER;
  BEGIN
    IF cnt &lt;= 0 THEN RETURN; END;
    INC(cnt, cnt);  (* == # of 8-bit characters *)
    p := LOOPHOLE(ADR(arr[0]), CharPtr);
    WHILE (cnt &gt; 0) DO
      n := MIN(cnt, NUMBER(p^));
      IF c.rd.getSub(SUBARRAY(p^, 0, n)) # n THEN
        RaiseUnmarshalFailure();
      END;
      INC(p, ADRSIZE(p^));  DEC(cnt, NUMBER(p^));
    END;
    IF NOT NativeEndian(rep) THEN
      (* we need to byte swap *)
      FOR i := 0 TO LAST(arr) DO
        WITH z = arr[i] DO  z := VAL (Swap.Swap2U (ORD (z)), WIDECHAR);  END;
      END;
    END;
  END InWideChars;

PROCEDURE <A NAME="OutChars"><procedure>OutChars</procedure></A>(c: Conn; READONLY arr: ARRAY OF CHAR)
    RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    c.wr.putString(arr);
  END OutChars;

PROCEDURE <A NAME="OutWideChars"><procedure>OutWideChars</procedure></A>(c: Conn; READONLY arr: ARRAY OF WIDECHAR)
    RAISES {Wr.Failure, Thread.Alerted} =
  VAR cnt: INTEGER := NUMBER (arr);  p: CharPtr;
  BEGIN
    IF cnt &lt;= 0 THEN RETURN; END;
    INC(cnt, cnt);  (* == # of 8-bit characters *)
    p := LOOPHOLE(ADR(arr[0]), CharPtr);
    WHILE (cnt &gt; 0) DO
      c.wr.putString(SUBARRAY(p^, 0, MIN (cnt, NUMBER(p^))));
      INC(p, ADRSIZE(p^)); DEC(cnt, NUMBER(p^));
    END;
  END OutWideChars;

PROCEDURE <A NAME="InBytes"><procedure>InBytes</procedure></A>(c: Conn; VAR arr: ARRAY OF Byte8)
    RAISES {NetObj.Error, Rd.Failure, Thread.Alerted} =
  VAR p: CharPtr;
  BEGIN
    IF NUMBER(arr) &lt;= 0 THEN RETURN; END;
    p := LOOPHOLE(ADR(arr[0]), CharPtr);
    IF c.rd.getSub(SUBARRAY(p^, 0, NUMBER(arr))) # NUMBER(arr) THEN
      RaiseUnmarshalFailure();
    END;
  END InBytes;

PROCEDURE <A NAME="OutBytes"><procedure>OutBytes</procedure></A>(c: Conn; READONLY arr: ARRAY OF Byte8)
    RAISES {Wr.Failure, Thread.Alerted} =
  VAR p: CharPtr;
  BEGIN
    IF NUMBER(arr) &lt;= 0 THEN RETURN; END;
    p := LOOPHOLE(ADR(arr[0]), CharPtr);
    c.wr.putString(SUBARRAY(p^, 0, NUMBER(arr)));
  END OutBytes;

CONST
  BigEndianFmt   = 16;
  IntFmt32Little = 0;
  IntFmt64Little = 1;
  IntFmt32Big    = BigEndianFmt;
  IntFmt64Big    = BigEndianFmt + 1;

  FloatIEEE      = 0;
  FloatOther     = 1;

TYPE
  Int64 = ARRAY [0..1] OF Int32;
</PRE> this code is integer-length dependent 
 we also rely on the invariant that MsgRd/MsgWr will
   provide contiguous 8-byte chunks at proper alignment ..
   as long as there is no intervening flush 

<P><PRE>PROCEDURE <A NAME="InInteger"><procedure>InInteger</procedure></A>(c: Conn;
                    rep: DataRep;
                    min := FIRST(INTEGER);
                    max := LAST(INTEGER)): INTEGER
    RAISES {NetObj.Error, Rd.Failure, Thread.Alerted} =
  VAR i: INTEGER;
  BEGIN
    IF rep.intFmt = NativeRep.intFmt THEN
      i := LOOPHOLE(AlignRd(c.rd, BYTESIZE(INTEGER)), UNTRACED REF INTEGER)^;
      INC(c.rd.cur, BYTESIZE(INTEGER));
    ELSE
      CASE rep.intFmt OF
      | IntFmt32Little, IntFmt32Big =&gt;
          VAR ii: Int32 :=
             LOOPHOLE(AlignRd(c.rd, BYTESIZE(Int32)), UNTRACED REF Int32)^;              BEGIN
            INC(c.rd.cur, BYTESIZE(Int32));
            IF NOT NativeEndian(rep) THEN ii := Swap.Swap4(ii); END;
            i := ii;
          END;
      | IntFmt64Little =&gt;
          (* this can only be 64 -&gt; 32 bit conversion *)
          (* no 64 -&gt; 64 bit byte swap at this point in time *)
          VAR
            ip := LOOPHOLE(AlignRd(c.rd, BYTESIZE(Int64)), UNTRACED REF Int64);
          BEGIN
            INC(c.rd.cur, BYTESIZE(Int64));
            IF NativeEndian(rep) THEN
              i := ip[0];
            ELSE
              i := Swap.Swap4(ip[0]);
            END;
            (* Don't need to swap ip[1] to do this check, since -1 and
               0 are the same regardless *)
            IF (i &lt; 0 AND ip[1] # -1) OR (i &gt;= 0 AND ip[1] # 0) THEN
              RaiseError(NetObj.UnsupportedDataRep);
            END;
          END;
      ELSE
          RaiseError(NetObj.UnsupportedDataRep);
      END;
    END;
    IF i &lt; min OR i &gt; max THEN RaiseUnmarshalFailure(); END;
    RETURN i;
  END InInteger;

PROCEDURE <A NAME="InInt32"><procedure>InInt32</procedure></A>(c: Conn;
                    rep: DataRep;
                    min := FIRST(Int32);
                    max := LAST(Int32)): Int32
    RAISES {NetObj.Error, Rd.Failure, Thread.Alerted} =
  VAR i: Int32;
  BEGIN
    IF rep.intFmt = NativeRep.intFmt THEN
      i := LOOPHOLE(AlignRd(c.rd, BYTESIZE(Int32)), UNTRACED REF Int32)^;
      INC(c.rd.cur, BYTESIZE(Int32));
    ELSE
      CASE rep.intFmt OF
      | IntFmt32Little, IntFmt32Big, IntFmt64Little =&gt;
          i := LOOPHOLE(AlignRd(c.rd, BYTESIZE(Int32)), UNTRACED REF Int32)^;
          INC(c.rd.cur, BYTESIZE(Int32));
          IF NOT NativeEndian(rep) THEN i := Swap.Swap4(i); END;
      ELSE
          RaiseError(NetObj.UnsupportedDataRep);
      END;
    END;
    IF i &lt; min OR i &gt; max THEN RaiseUnmarshalFailure(); END;
    RETURN i;
  END InInt32;

PROCEDURE <A NAME="AlignRd"><procedure>AlignRd</procedure></A>(rd: Rd.T; nb: CARDINAL) : ADDRESS
    RAISES {NetObj.Error, Rd.Failure, Thread.Alerted} =
  VAR diff := rd.cur MOD nb;
      res: ADDRESS;
  BEGIN
    (* here we rely on the alignment invariants of MsgRd.T *)
    IF diff # 0 THEN
      VAR n := rd.cur + nb - diff; BEGIN
        IF n &gt; rd.hi THEN RaiseUnmarshalFailure(); END;
        rd.cur := n;
      END;
    END;
    IF rd.cur = rd.hi THEN EVAL rd.seek(rd.cur, FALSE); END;
    IF rd.hi - rd.cur &lt; nb THEN RaiseUnmarshalFailure(); END;
    res := ADR(rd.buff[rd.st + rd.cur - rd.lo]);
    RETURN res;
  END AlignRd;

  (*
    A MsgRd fragment must be 64-bit aligned.  Fragments of types call, return,
    or call-failed, must either be a multiple of 8 bytes in length, or else
    contain the end-of-message.    MsgRd buffers must be 64-bit aligned in
    length.
   *)

PROCEDURE <A NAME="OutInteger"><procedure>OutInteger</procedure></A>(c: Conn; i: INTEGER)
    RAISES {Wr.Failure, Thread.Alerted} =
  VAR ip := LOOPHOLE(AlignWr(c.wr, BYTESIZE(INTEGER)), UNTRACED REF INTEGER);
  BEGIN
    ip^ := i;
    INC(c.wr.cur, BYTESIZE(INTEGER));
  END OutInteger;

PROCEDURE <A NAME="OutInt32"><procedure>OutInt32</procedure></A>(c: Conn; i: Int32)
    RAISES {Wr.Failure, Thread.Alerted} =
  VAR ip := LOOPHOLE(AlignWr(c.wr, BYTESIZE(Int32)), UNTRACED REF Int32);
  BEGIN
    ip^ := i;
    INC(c.wr.cur, BYTESIZE(Int32));
  END OutInt32;

PROCEDURE <A NAME="AlignWr"><procedure>AlignWr</procedure></A>(wr: Wr.T; align: CARDINAL) : ADDRESS
    RAISES {Wr.Failure, Thread.Alerted} =
  VAR diff := wr.cur MOD align;
      res: ADDRESS;
  BEGIN
    (* here we rely on the alignment invariants of MsgWr.T *)
    IF diff # 0 THEN INC(wr.cur, align-diff); END;
    IF wr.cur = wr.hi THEN wr.seek(wr.cur); END;
    res := ADR(wr.buff[wr.st + wr.cur - wr.lo]);
    RETURN res;
  END AlignWr;

  (*
    A MsgWr fragment must be 64-bit aligned.  Fragments of types call, return,
    or call-failed, must either be a multiple of 8 bytes in length, or else
    contain the end-of-message.  MsgWr buffers must be 64-bit aligned in
    length.
   *)

PROCEDURE <A NAME="InByte"><procedure>InByte</procedure></A>(c: Conn;
                 max := LAST(Byte8)): Byte8
     RAISES {NetObj.Error, Rd.Failure, Thread.Alerted} =
  VAR b: Byte8;
  BEGIN
    TRY
      b := LOOPHOLE(UnsafeRd.FastGetChar(c.rd), Byte8);
    EXCEPT
    | Rd.EndOfFile =&gt; RaiseUnmarshalFailure();
    END;
    IF b &gt; max THEN
      RaiseUnmarshalFailure();
    END;
    RETURN b
  END InByte;

PROCEDURE <A NAME="OutByte"><procedure>OutByte</procedure></A>(c: Conn; b: Byte8)
   RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    UnsafeWr.FastPutChar(c.wr, LOOPHOLE(b, CHAR));
  END OutByte;

TYPE MSpec = {Pickle, Text, NetObj, Reader, Writer, Texts};

PROCEDURE <A NAME="InRef"><procedure>InRef</procedure></A>(c: Conn; rep: DataRep; tc: INTEGER): REFANY
     RAISES {NetObj.Error, Rd.Failure, Thread.Alerted} =
  VAR r: REFANY;
  BEGIN
    CASE InByte(c) OF
    | ORD(MSpec.Pickle) =&gt;
        IF (c.protocol # 2)
          THEN  r := InPickle(c, rep, tc);
          ELSE  r := InPickle2(c, rep, tc);
        END;
    | ORD(MSpec.Text) =&gt; r := InText(c, rep);
    | ORD(MSpec.NetObj) =&gt; r := InObject(c, tc);
    | ORD(MSpec.Reader) =&gt; r := InReader(c);
    | ORD(MSpec.Writer) =&gt; r := InWriter(c);
    | ORD(MSpec.Texts) =&gt; r := InTexts(c, rep);
    ELSE RaiseUnmarshalFailure();
    END;
    RETURN r;
  END InRef;

PROCEDURE <A NAME="OutRef"><procedure>OutRef</procedure></A>(c: Conn; r: REFANY)
   RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    TYPECASE r OF
    | TEXT(x) =&gt; OutByte(c, ORD(MSpec.Text)); OutText(c, x);
    | NetObj.T(x) =&gt; OutByte(c, ORD(MSpec.NetObj)); OutObject(c, x);
    | Rd.T(x) =&gt; OutByte(c, ORD(MSpec.Reader)); OutReader(c, x);
    | Wr.T(x) =&gt; OutByte(c, ORD(MSpec.Writer)); OutWriter(c, x);
    | REF ARRAY OF TEXT(x) =&gt; OutByte(c, ORD(MSpec.Texts)); OutTexts(c, x);
    ELSE
      OutByte(c, ORD(MSpec.Pickle));
      IF (c.protocol # 2)
        THEN OutPickle(c, r);
        ELSE OutPickle2(c, r);
      END;
    END;
  END OutRef;

PROCEDURE <A NAME="InPickle"><procedure>InPickle</procedure></A>(c: Conn; rep: DataRep; tc: INTEGER): REFANY
     RAISES {NetObj.Error, Rd.Failure, Thread.Alerted} =
  VAR r: REFANY;  srd := NewRd(c, rep);  ok := FALSE;
  BEGIN
    TRY
      TRY
        r := srd.read();
        ok := TRUE;
      FINALLY
        IF ok THEN FreeRd(srd); END;
      END;
    EXCEPT
    | Rd.EndOfFile =&gt; RaiseUnmarshalFailure();
    | Pickle.Error(cause) =&gt;
        RAISE NetObj.Error(
          AtomList.List2(UnmarshalFailure, Atom.FromText(cause)));
    END;
    IF tc # -1 AND NOT RTType.IsSubtype(TYPECODE(r), tc) THEN
      RaiseUnmarshalFailure();
    END;
    RETURN r;
  END InPickle;

PROCEDURE <A NAME="InPickle2"><procedure>InPickle2</procedure></A>(c: Conn; rep: DataRep; tc: INTEGER): REFANY
     RAISES {NetObj.Error, Rd.Failure, Thread.Alerted} =
  VAR r: REFANY;  srd := NewRd2(c, rep);  ok := FALSE;
  BEGIN
    TRY
      TRY
        r := srd.read();
        ok := TRUE;
      FINALLY
        IF ok THEN FreeRd2(srd); END;
      END;
    EXCEPT
    | Rd.EndOfFile =&gt; RaiseUnmarshalFailure();
    | Pickle2.Error(cause) =&gt;
        RAISE NetObj.Error(
          AtomList.List2(UnmarshalFailure, Atom.FromText(cause)));
    END;
    IF tc # -1 AND NOT RTType.IsSubtype(TYPECODE(r), tc) THEN
      RaiseUnmarshalFailure();
    END;
    RETURN r;
  END InPickle2;

PROCEDURE <A NAME="OutPickle"><procedure>OutPickle</procedure></A>(c: Conn; r: REFANY)
   RAISES {Wr.Failure, Thread.Alerted} =
  VAR swr := NewWr(c); ok := FALSE;
  BEGIN
    TRY
      TRY
        swr.write(r);
        ok := TRUE;
      FINALLY
        IF ok THEN FreeWr(swr); END;
      END;
    EXCEPT
    | Pickle.Error(cause) =&gt;
        RAISE Wr.Failure(AtomList.List1(Atom.FromText(cause)));
    END;
  END OutPickle;

PROCEDURE <A NAME="OutPickle2"><procedure>OutPickle2</procedure></A>(c: Conn; r: REFANY)
   RAISES {Wr.Failure, Thread.Alerted} =
  VAR swr := NewWr2(c); ok := FALSE;
  BEGIN
    TRY
      TRY
        swr.write(r);
        ok := TRUE;
      FINALLY
        IF ok THEN FreeWr2(swr); END;
      END;
    EXCEPT
    | Pickle2.Error(cause) =&gt;
        RAISE Wr.Failure(AtomList.List1(Atom.FromText(cause)));
    END;
  END OutPickle2;

PROCEDURE <A NAME="InCardinal"><procedure>InCardinal</procedure></A>(c: Conn; rep: DataRep;
     lim: CARDINAL := LAST(CARDINAL)): CARDINAL
     RAISES {NetObj.Error, Rd.Failure, Thread.Alerted} =
  BEGIN
    RETURN InInteger(c, rep, 0, lim);
  END InCardinal;

PROCEDURE <A NAME="OutCardinal"><procedure>OutCardinal</procedure></A>(c: Conn; card: CARDINAL)
   RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    OutInteger(c, card);
  END OutCardinal;

PROCEDURE <A NAME="InReal"><procedure>InReal</procedure></A>(c: Conn; rep: DataRep): REAL
    RAISES {NetObj.Error, Rd.Failure, Thread.Alerted} =
  VAR i: REAL;
  BEGIN
    IF rep.floatFmt # NativeRep.floatFmt THEN
      RaiseError(NetObj.UnsupportedDataRep);
    END;
    IF c.rd.getSub(
        LOOPHOLE(i, ARRAY [0..BYTESIZE(REAL)-1] OF CHAR)) # BYTESIZE(REAL) THEN
      RaiseUnmarshalFailure();
    END;
    IF NOT NativeEndian(rep) THEN i := SwapReal(i); END;
    RETURN i;
  END InReal;

PROCEDURE <A NAME="OutReal"><procedure>OutReal</procedure></A>(c: Conn; i: REAL)
   RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    c.wr.putString(LOOPHOLE(i, ARRAY [0..BYTESIZE(REAL)-1] OF CHAR));
  END OutReal;

PROCEDURE <A NAME="InLongreal"><procedure>InLongreal</procedure></A>(c: Conn; rep: DataRep): LONGREAL
    RAISES {NetObj.Error, Rd.Failure, Thread.Alerted} =
  VAR i: LONGREAL;
  BEGIN
    IF rep.floatFmt # NativeRep.floatFmt THEN
      RaiseError(NetObj.UnsupportedDataRep);
    END;
    IF c.rd.getSub(
        LOOPHOLE(i, ARRAY [0..BYTESIZE(LONGREAL)-1] OF CHAR)) #
                       BYTESIZE(LONGREAL) THEN
      RaiseUnmarshalFailure();
    END;
    IF NOT NativeEndian(rep) THEN i := SwapLongReal(i); END;
    RETURN i;
  END InLongreal;

PROCEDURE <A NAME="OutLongreal"><procedure>OutLongreal</procedure></A>(c: Conn; i: LONGREAL)
   RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    c.wr.putString(LOOPHOLE(i, ARRAY [0..BYTESIZE(LONGREAL)-1] OF CHAR));
  END OutLongreal;

PROCEDURE <A NAME="InExtended"><procedure>InExtended</procedure></A>(c: Conn; rep: DataRep): EXTENDED
    RAISES {NetObj.Error, Rd.Failure, Thread.Alerted} =
  BEGIN
    RETURN LOOPHOLE(InLongreal(c, rep), EXTENDED);
  END InExtended;

PROCEDURE <A NAME="OutExtended"><procedure>OutExtended</procedure></A>(c: Conn; i: EXTENDED)
   RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    c.wr.putString(LOOPHOLE(i, ARRAY [0..BYTESIZE(EXTENDED)-1] OF CHAR));
  END OutExtended;

PROCEDURE <A NAME="InBoolean"><procedure>InBoolean</procedure></A>(c: Conn) : BOOLEAN
    RAISES {NetObj.Error, Rd.Failure, Thread.Alerted} =
  VAR res: BOOLEAN;
  BEGIN
    TRY
      res := UnsafeRd.FastGetChar(c.rd) # '\000';
    EXCEPT
    | Rd.EndOfFile =&gt; RaiseUnmarshalFailure();
    END;
    RETURN res;
  END InBoolean;

PROCEDURE <A NAME="OutBoolean"><procedure>OutBoolean</procedure></A>(c: Conn; bool: BOOLEAN)
    RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    IF bool THEN
      UnsafeWr.FastPutChar(c.wr, '\001');
    ELSE
      UnsafeWr.FastPutChar(c.wr, '\000');
    END;
  END OutBoolean;

PROCEDURE <A NAME="InText"><procedure>InText</procedure></A>(c: Conn; rep: DataRep) : TEXT
   RAISES {NetObj.Error, Rd.Failure, Thread.Alerted} =
  VAR len := InInt32(c, rep);
  BEGIN
    IF len = -1 THEN
      RETURN NIL;
    ELSIF len = 0 THEN
      RETURN &quot;&quot;;
    ELSIF len &lt; 0 THEN
      RaiseUnmarshalFailure();
      RETURN NIL;
    ELSIF InByte(c) # ORD(FALSE) THEN
      RETURN InText16(c, rep, len);
    ELSE
      RETURN InText8(c, rep, len);
    END;
  END InText;

PROCEDURE <A NAME="InText16"><procedure>InText16</procedure></A>(c: Conn; rep: DataRep;  len: INTEGER) : TEXT
  RAISES {NetObj.Error, Rd.Failure, Thread.Alerted} =
  VAR buf: ARRAY [0..255] OF WIDECHAR;  txt16: Text16.T;
  BEGIN
    IF len &lt;= NUMBER(buf) THEN
      WITH z = SUBARRAY(buf, 0, len) DO
        InWideChars(c, rep, z);
        RETURN Text.FromWideChars(z);
      END;
    ELSE
      txt16 := Text16.Create(len);
      InWideChars(c, rep, SUBARRAY(txt16.contents^, 0, len));
      RETURN txt16;
    END;
  END InText16;

PROCEDURE <A NAME="InText8"><procedure>InText8</procedure></A>(c: Conn; rep: DataRep;  len: INTEGER) : TEXT
  RAISES {NetObj.Error, Rd.Failure, Thread.Alerted} =
  VAR buf: ARRAY [0..255] OF CHAR;  txt8: Text8.T;
  BEGIN
    IF len &lt;= NUMBER(buf) THEN
      WITH z = SUBARRAY(buf, 0, len) DO
        InChars(c, rep, z);
        RETURN Text.FromChars(z);
      END;
    ELSE
      txt8 := Text8.Create(len);
      InChars(c, rep, SUBARRAY(txt8.contents^, 0, len));
      RETURN txt8;
    END;
  END InText8;

PROCEDURE <A NAME="OutText"><procedure>OutText</procedure></A>(c: Conn; txt: TEXT)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR info: TextClass.Info;
  BEGIN
    IF txt = NIL THEN
      OutInt32(c, -1);
    ELSE
      txt.get_info (info);
      OutInt32(c, info.length);
      IF info.length &gt; 0 THEN
        OutByte(c, ORD(info.wide));
        IF info.wide THEN
          IF info.start # NIL
            THEN OutString16(c, info.start, info.length);
            ELSE OutText16(c, txt, info.length);
          END;
        ELSE (* 8-bit characters only *)
          IF info.start # NIL
            THEN OutString8(c, info.start, info.length);
            ELSE OutText8(c, txt, info.length);
          END;
        END;
      END;
    END;
  END OutText;

PROCEDURE <A NAME="OutText16"><procedure>OutText16</procedure></A>(c: Conn;  txt: TEXT;  len: INTEGER)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR cnt := 0;  buf: ARRAY [0..511] OF WIDECHAR;
  BEGIN
    WHILE cnt &lt; len DO
      Text.SetWideChars (buf, txt, start := cnt);
      OutWideChars(c, SUBARRAY(buf, 0, MIN (len-cnt, NUMBER(buf))));
      INC(cnt, NUMBER(buf));
    END;
  END OutText16;

PROCEDURE <A NAME="OutString16"><procedure>OutString16</procedure></A>(c: Conn;  start: ADDRESS;  len: INTEGER)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR p: WCharPtr := start;
  BEGIN
    WHILE (len &gt; 0) DO
      OutWideChars(c, SUBARRAY(p^, 0, MIN(len, NUMBER(p^))));
      INC(p, ADRSIZE (p^));  DEC(len, NUMBER(p^));
    END;
  END OutString16;

PROCEDURE <A NAME="OutText8"><procedure>OutText8</procedure></A>(c: Conn;  txt: TEXT;  len: INTEGER)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR cnt := 0;  buf: ARRAY [0..511] OF CHAR;
  BEGIN
    WHILE cnt &lt; len DO
      Text.SetChars (buf, txt, start := cnt);
      OutChars(c, SUBARRAY(buf, 0, MIN (len-cnt, NUMBER(buf))));
      INC(cnt, NUMBER(buf));
    END;
  END OutText8;

PROCEDURE <A NAME="OutString8"><procedure>OutString8</procedure></A>(c: Conn;  start: ADDRESS;  len: INTEGER)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR p: CharPtr := start;
  BEGIN
    WHILE (len &gt; 0) DO
      OutChars(c, SUBARRAY(p^, 0, MIN(len, NUMBER(p^))));
      INC(p, ADRSIZE(p^));  DEC(len, NUMBER(p^));
    END;
  END OutString8;

PROCEDURE <A NAME="InTexts"><procedure>InTexts</procedure></A>(c: Conn; rep: DataRep): REF ARRAY OF TEXT
  RAISES {NetObj.Error, Rd.Failure, Thread.Alerted} =
  VAR n: CARDINAL;
  VAR rt: REF ARRAY OF TEXT;
  BEGIN
    n := InInt32(c, rep, 0);
    IF n = 0 THEN
      RETURN NIL;
    END;
    rt := NEW(REF ARRAY OF TEXT, n);
    IF n &gt; 0 THEN
      FOR i := 0 TO n-1 DO rt[i] := InText(c, rep); END;
    END;
    RETURN rt;
  END InTexts;

PROCEDURE <A NAME="OutTexts"><procedure>OutTexts</procedure></A>(c: Conn; rt: REF ARRAY OF TEXT)
    RAISES {Wr.Failure, Thread.Alerted} =
  VAR n: CARDINAL;
  BEGIN
    IF (rt = NIL) THEN n := 0 ELSE n := NUMBER(rt^); END;
    OutInt32(c, n);
    IF n &gt; 0 THEN
      FOR i := 0 TO n-1 DO OutText(c, rt[i]); END;
    END;
  END OutTexts;

TYPE
  VT = Voucher.T OBJECT
    stream: REFANY;
  OVERRIDES
    claimRd := ClaimRd;
    claimWr := ClaimWr;
  END;
</PRE><P>
PROCEDURE CleanupVT(&lt;*UNUSED*&gt; READONLY w: WeakRef.T; r: REFANY) =
  VAR v := NARROW(r, VT);
    &lt;*FATAL Thread.Alerted*&gt;
  BEGIN
    TRY
      TYPECASE v.stream OF
      <PRE>
      Rd.T(rd) =&gt; Rd.Close(rd);
            Wr.T(wr) =&gt; Wr.Close(wr);
      </PRE>
ELSE
      END;
    EXCEPT
    <PRE>
      Rd.Failure, Wr.Failure =&gt;
    </PRE>
END;
  END CleanupVT;


<P><PRE>PROCEDURE <A NAME="InReader"><procedure>InReader</procedure></A>(c: Conn) : Rd.T
    RAISES {NetObj.Error, Rd.Failure, Thread.Alerted} =
  VAR obj: NetObj.T := NIL;
      rd: Rd.T := NIL;
  BEGIN
    obj := InObject(c);
    TYPECASE obj OF
    | NULL =&gt;
    | Voucher.T(v) =&gt;  rd := v.claimRd();
    ELSE
        RaiseUnmarshalFailure();
    END;
    RETURN rd;
  END InReader;

PROCEDURE <A NAME="OutReader"><procedure>OutReader</procedure></A>(c: Conn; rd: Rd.T)
    RAISES {Wr.Failure, Thread.Alerted} =
  VAR obj: NetObj.T := NIL;
  BEGIN
    IF rd # NIL THEN
      obj := NEW(VT, stream := rd);
      (* EVAL WeakRef.FromRef(obj, CleanupVT); *)
    END;
    OutObject(c, obj);
  END OutReader;

PROCEDURE <A NAME="InWriter"><procedure>InWriter</procedure></A>(c: Conn) : Wr.T
    RAISES {NetObj.Error, Rd.Failure, Thread.Alerted} =
  VAR obj: NetObj.T := NIL;
      wr: Wr.T := NIL;
  BEGIN
    obj := InObject(c);
    TYPECASE obj OF
    | NULL =&gt;
    | Voucher.T(v) =&gt;  wr := v.claimWr();
    ELSE
        RaiseUnmarshalFailure();
    END;
    RETURN wr;
  END InWriter;

PROCEDURE <A NAME="OutWriter"><procedure>OutWriter</procedure></A>(c: Conn; wr: Wr.T)
    RAISES {Wr.Failure, Thread.Alerted} =
  VAR obj: NetObj.T := NIL;
  BEGIN
    IF wr # NIL THEN
      obj := NEW(VT, stream := wr);
      (* EVAL WeakRef.FromRef(obj, CleanupVT); *)
    END;
    OutObject(c, obj);
  END OutWriter;

PROCEDURE <A NAME="ClaimRd"><procedure>ClaimRd</procedure></A>(v: VT) : Rd.T =
  BEGIN
    TYPECASE v.stream OF
    | Rd.T(rd) =&gt; RETURN rd;
    ELSE RETURN NIL;
    END;
  END ClaimRd;

PROCEDURE <A NAME="ClaimWr"><procedure>ClaimWr</procedure></A>(v: VT) : Wr.T =
  BEGIN
    TYPECASE v.stream OF
    | Wr.T(wr) =&gt; RETURN wr;
    ELSE RETURN NIL;
    END;
  END ClaimWr;

CONST Align64 = 8;   (* to achieve 64-bit alignment *)

PROCEDURE <A NAME="OutObject"><procedure>OutObject</procedure></A> (c: Conn; o: NetObj.T)
    RAISES {Wr.Failure, Thread.Alerted} =
  VAR
    (* we believe that 16-byte records are 32-bit aligned!! *)
    wr := c.wr;
    pwrep := LOOPHOLE(AlignWr(wr, Align64),
                               UNTRACED REF WireRep.T);
  BEGIN
    IF wr.hi - wr.cur &gt;= BYTESIZE(WireRep.T) THEN
      IF o = NIL THEN
        pwrep^ := WireRep.NullT;
      ELSE
        pwrep^ := NetObjRT.InsertAndPin(o);
      END;
      INC(wr.cur, BYTESIZE(WireRep.T));
    ELSE
      IF o = NIL THEN
        OutBytes(c, WireRep.NullT.byte);
      ELSE
        OutBytes(c, NetObjRT.InsertAndPin(o).byte);
      END;
    END;
    VAR s := c.objStack.objs; BEGIN
      IF s = NIL THEN
        s := NEW(REF ARRAY OF NetObj.T, DefaultObjStackSize);
        c.objStack.objs := s;
      ELSIF c.objStack.pos = NUMBER(s^) THEN
        s := NEW(REF ARRAY OF NetObj.T, 2 * c.objStack.pos);
        SUBARRAY(s^, 0, c.objStack.pos) := c.objStack.objs^;
        c.objStack.objs := s;
      END;
      s[c.objStack.pos] := o;
      INC(c.objStack.pos);
    END;
  END OutObject;

PROCEDURE <A NAME="InObject"><procedure>InObject</procedure></A> (c: Conn; tc: INTEGER := -1): NetObj.T
    RAISES {NetObj.Error, Rd.Failure, Thread.Alerted} =
  VAR
    o: NetObj.T;
    rd := c.rd;
    pwrep := LOOPHOLE(AlignRd(rd, Align64),
                               UNTRACED REF WireRep.T);
  BEGIN
    IF rd.hi - rd.cur &gt;= BYTESIZE(WireRep.T) THEN
      INC(rd.cur, BYTESIZE(WireRep.T));
      IF pwrep^ = WireRep.NullT THEN RETURN NIL END;
      o := NetObjRT.Find(pwrep^, c.loc);
    ELSE
      VAR w: WireRep.T; BEGIN
        InBytes(c, w.byte);
        IF w = WireRep.NullT THEN RETURN NIL END;
        o := NetObjRT.Find(w, c.loc);
      END;
    END;
    IF tc # -1 AND NOT RTType.IsSubtype(TYPECODE(o), tc) THEN
      RaiseUnmarshalFailure();
    END;
    c.inObj := TRUE;
    RETURN o;
  END InObject;
</PRE> Procedures for Pickling -- free list management 

<P><PRE>PROCEDURE <A NAME="NewWr"><procedure>NewWr</procedure></A>(c: Conn): SpecWr =
  VAR pwr: SpecWr;
  BEGIN
    LOCK mu DO
      IF freeWr # NIL THEN
        pwr := freeWr; freeWr := pwr.next;
      ELSE
        pwr := NEW(SpecWr);
      END;
    END;
    pwr.wr := c.wr;
    pwr.c := c;
    pwr.next := NIL;
    RETURN pwr
  END NewWr;

PROCEDURE <A NAME="FreeWr"><procedure>FreeWr</procedure></A>(pwr: SpecWr) =
  BEGIN
    LOCK mu DO
      pwr.next := freeWr;
      pwr.c := NIL;
      pwr.wr := NIL;
      freeWr := pwr;
    END;
  END FreeWr;

PROCEDURE <A NAME="NewWr2"><procedure>NewWr2</procedure></A>(c: Conn): SpecWr2 =
  VAR pwr: SpecWr2;
  BEGIN
    LOCK mu DO
      IF freeWr2 # NIL THEN
        pwr := freeWr2; freeWr2 := pwr.next;
      ELSE
        pwr := NEW(SpecWr2);
      END;
    END;
    pwr.wr := c.wr;
    pwr.c := c;
    pwr.next := NIL;
    RETURN pwr
  END NewWr2;

PROCEDURE <A NAME="FreeWr2"><procedure>FreeWr2</procedure></A>(pwr: SpecWr2) =
  BEGIN
    LOCK mu DO
      pwr.next := freeWr2;
      pwr.c := NIL;
      pwr.wr := NIL;
      freeWr2 := pwr;
    END;
  END FreeWr2;

PROCEDURE <A NAME="NewRd"><procedure>NewRd</procedure></A>(c: Conn; rep: DataRep): SpecRd =
  VAR prd: SpecRd;
  BEGIN
    LOCK mu DO
      IF freeRd # NIL THEN
        prd := freeRd; freeRd := prd.next;
      ELSE
        prd := NEW(SpecRd);
      END;
    END;
    prd.rd := c.rd;
    prd.c := c;
    prd.rep := rep;
    prd.next := NIL;
    RETURN prd
  END NewRd;

PROCEDURE <A NAME="FreeRd"><procedure>FreeRd</procedure></A>(prd: SpecRd) =
  BEGIN
    LOCK mu DO
      prd.c := NIL;
      prd.rd := NIL;
      prd.next := freeRd;
      freeRd := prd;
    END;
  END FreeRd;

PROCEDURE <A NAME="NewRd2"><procedure>NewRd2</procedure></A>(c: Conn; rep: DataRep): SpecRd2 =
  VAR prd: SpecRd2;
  BEGIN
    LOCK mu DO
      IF freeRd2 # NIL THEN
        prd := freeRd2; freeRd2 := prd.next;
      ELSE
        prd := NEW(SpecRd2);
      END;
    END;
    prd.rd := c.rd;
    prd.c := c;
    prd.rep := rep;
    prd.next := NIL;
    RETURN prd
  END NewRd2;

PROCEDURE <A NAME="FreeRd2"><procedure>FreeRd2</procedure></A>(prd: SpecRd2) =
  BEGIN
    LOCK mu DO
      prd.c := NIL;
      prd.rd := NIL;
      prd.next := freeRd2;
      freeRd2 := prd;
    END;
  END FreeRd2;
</PRE> Pickle Special routines 

<P><PRE>PROCEDURE <A NAME="OutSpecial"><procedure>OutSpecial</procedure></A>(self: Pickle.Special;
                 r: REFANY;
                 writer: Pickle.Writer)
  RAISES  {Pickle.Error, Wr.Failure, Thread.Alerted} =
  BEGIN
    TYPECASE writer OF
    | SpecWr(wtr) =&gt; OutRef(wtr.c, r);
    ELSE
      TYPECASE r OF
      | NetObj.T(x) =&gt;
          IF NOT ISTYPE(x.r, Transport.Location) THEN
            (* This will gratuitously pickle the ExportInfo ref
               embedded in x.r.  It would be better to exclude this
               if and when possible, but it shouldn't hurt for now. *)
            Pickle.Special.write(self, r, writer);
          ELSE
            RAISE Pickle.Error(&quot;Can't pickle a surrogate object&quot;);
          END;
      ELSE RAISE Pickle.Error(&quot;Can't Pickle Rd.T or Wr.T&quot;);
      END;
    END;
  END OutSpecial;

PROCEDURE <A NAME="OutSpecial2"><procedure>OutSpecial2</procedure></A>(self: Pickle2.Special;
                 r: REFANY;
                 writer: Pickle2.Writer)
  RAISES  {Pickle2.Error, Wr.Failure, Thread.Alerted} =
  BEGIN
    TYPECASE writer OF
    | SpecWr2(wtr) =&gt; OutRef(wtr.c, r);
    ELSE
      TYPECASE r OF
      | NetObj.T(x) =&gt;
          IF NOT ISTYPE(x.r, Transport.Location) THEN
            (* This will gratuitously pickle the ExportInfo ref
               embedded in x.r.  It would be better to exclude this
               if and when possible, but it shouldn't hurt for now. *)
            Pickle2.Special.write(self, r, writer);
          ELSE
            RAISE Pickle2.Error(&quot;Can't pickle a surrogate object&quot;);
          END;
      ELSE RAISE Pickle2.Error(&quot;Can't Pickle Rd.T or Wr.T&quot;);
      END;
    END;
  END OutSpecial2;

PROCEDURE <A NAME="InSpecial"><procedure>InSpecial</procedure></A>(self: Pickle.Special;
                reader: Pickle.Reader;
                id: Pickle.RefID): REFANY
  RAISES { Pickle.Error, Rd.EndOfFile, Rd.Failure, Thread.Alerted } =
  BEGIN
    TRY
      TYPECASE reader OF
      | SpecRd(rdr) =&gt;
          RETURN InRef(rdr.c, rdr.rep, self.sc);
      ELSE
        TYPECASE Pickle.Special.read(self, reader, id) OF
        | NetObj.T(x) =&gt;
            x.w := WireRep.NullT;
            x.r := NIL;
            RETURN x;
        ELSE RAISE Pickle.Error(&quot;Can't Unpickle Rd.T or Wr.T&quot;);
        END;
      END;
    EXCEPT
      NetObj.Error(cause) =&gt; RAISE Pickle.Error(Atom.ToText(cause.head));
    END;
  END InSpecial;

PROCEDURE <A NAME="InSpecial2"><procedure>InSpecial2</procedure></A>(self: Pickle2.Special;
                reader: Pickle2.Reader;
                id: Pickle2.RefID): REFANY
  RAISES { Pickle2.Error, Rd.EndOfFile, Rd.Failure, Thread.Alerted } =
  BEGIN
    TRY
      TYPECASE reader OF
      | SpecRd2(rdr) =&gt;
          RETURN InRef(rdr.c, rdr.rep, self.sc);
      ELSE
        TYPECASE Pickle2.Special.read(self, reader, id) OF
        | NetObj.T(x) =&gt;
            x.w := WireRep.NullT;
            x.r := NIL;
            RETURN x;
        ELSE RAISE Pickle2.Error(&quot;Can't Unpickle Rd.T or Wr.T&quot;);
        END;
      END;
    EXCEPT
      NetObj.Error(cause) =&gt; RAISE Pickle2.Error(Atom.ToText(cause.head));
    END;
  END InSpecial2;
</PRE> NetObjF routines for checking if it's a netobj pickler 
<PRE>PROCEDURE <A NAME="IsNetObjWriter"><procedure>IsNetObjWriter</procedure></A>(wr: Pickle2.Writer): BOOLEAN =
  BEGIN
    RETURN ISTYPE(wr, SpecWr2);
  END IsNetObjWriter;

PROCEDURE <A NAME="IsNetObjReader"><procedure>IsNetObjReader</procedure></A>(rd: Pickle2.Reader): BOOLEAN =
  BEGIN
    RETURN ISTYPE(rd, SpecRd2);
  END IsNetObjReader;

PROCEDURE <A NAME="RaiseUnmarshalFailure"><procedure>RaiseUnmarshalFailure</procedure></A>() RAISES {NetObj.Error} =
  BEGIN
    RaiseError(UnmarshalFailure);
  END RaiseUnmarshalFailure;

PROCEDURE <A NAME="RaiseCommFailure"><procedure>RaiseCommFailure</procedure></A>(ec: AtomList.T) RAISES {NetObj.Error} =
  BEGIN
    RAISE NetObj.Error(AtomList.Cons(NetObj.CommFailure, ec));
  END RaiseCommFailure;

PROCEDURE <A NAME="RaiseError"><procedure>RaiseError</procedure></A>(a: Atom.T) RAISES {NetObj.Error} =
  BEGIN
    RAISE NetObj.Error(AtomList.List1(a));
  END RaiseError;
</PRE><P>
PROCEDURE Swap32(i: Int32) : Int32 =
  TYPE FourBytes = UNTRACED REF ARRAY [0..3] OF Byte8;
  VAR
    x : Int32;
    p := LOOPHOLE(ADR(i), FourBytes);
    r := LOOPHOLE(ADR(x), FourBytes);
  BEGIN
    r[0] := p[3];
    r[1] := p[2];
    r[2] := p[1];
    r[3] := p[0];
    RETURN x;
  END Swap32;


<P><PRE>PROCEDURE <A NAME="SwapReal"><procedure>SwapReal</procedure></A>(i: REAL) : REAL =
  BEGIN
    RETURN LOOPHOLE(Swap.Swap4(LOOPHOLE(i, Int32)), REAL);
  END SwapReal;

PROCEDURE <A NAME="SwapLongReal"><procedure>SwapLongReal</procedure></A>(i: LONGREAL) : LONGREAL =
  TYPE Ptr = UNTRACED REF RECORD a, b: Int32; END;
  VAR
    x : LONGREAL;
    p := LOOPHOLE(ADR(i), Ptr);
    r := LOOPHOLE(ADR(x), Ptr);
  BEGIN
    r.a := Swap.Swap4(p.b);
    r.b := Swap.Swap4(p.a);
    RETURN x;
  END SwapLongReal;

PROCEDURE <A NAME="NativeEndian"><procedure>NativeEndian</procedure></A>(rep: DataRep) : BOOLEAN =
  BEGIN
    RETURN (rep.intFmt &gt;= BigEndianFmt) = (Swap.endian = Swap.Endian.Big);
  END NativeEndian;

PROCEDURE <A NAME="ChooseIntFmt"><procedure>ChooseIntFmt</procedure></A>(): Byte8 =
  BEGIN
    IF BYTESIZE(INTEGER) = 8 THEN
      IF Swap.endian = Swap.Endian.Little THEN
        RETURN IntFmt64Little;
      ELSE
        RETURN IntFmt64Big;
      END;
    ELSE
      IF Swap.endian = Swap.Endian.Little THEN
        RETURN IntFmt32Little;
      ELSE
        RETURN IntFmt32Big;
      END;
    END;
  END ChooseIntFmt;

PROCEDURE <A NAME="ChooseFloatFmt"><procedure>ChooseFloatFmt</procedure></A>(): Byte8 =
  BEGIN
    IF FloatMode.IEEE THEN
      RETURN FloatIEEE;
    ELSE
      RETURN FloatOther;
    END;
  END ChooseFloatFmt;

BEGIN
  NativeRep := DataRep{private := 0,
                       intFmt := ChooseIntFmt(),
                       charSet := 0,
                       floatFmt := ChooseFloatFmt()};
  UnmarshalFailure := Atom.FromText(&quot;NetObj.UnmarshalFailure&quot;);

  (* Initialization for Pickle specials and free list *)
  mu := NEW(MUTEX);

  Pickle.RegisterSpecial(
      NEW(Pickle.Special, sc:= TYPECODE(NetObj.T),
                          write := OutSpecial,
                          read := InSpecial));
  Pickle.RegisterSpecial(
      NEW(Pickle.Special, sc:= TYPECODE(Rd.T),
                          write := OutSpecial,
                          read := InSpecial));
  Pickle.RegisterSpecial(
      NEW(Pickle.Special, sc:= TYPECODE(Wr.T),
                          write := OutSpecial,
                          read := InSpecial));

  Pickle2.RegisterSpecial(
      NEW(Pickle2.Special, sc:= TYPECODE(NetObj.T),
                          write := OutSpecial2,
                          read := InSpecial2));
  Pickle2.RegisterSpecial(
      NEW(Pickle2.Special, sc:= TYPECODE(Rd.T),
                          write := OutSpecial2,
                          read := InSpecial2));
  Pickle2.RegisterSpecial(
      NEW(Pickle2.Special, sc:= TYPECODE(Wr.T),
                          write := OutSpecial2,
                          read := InSpecial2));

END StubLib.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface Protocol is in:
</A><UL>
<LI><A HREF="Protocol.i3.html#0TOP0">netobj/src/netobjrt/Protocol.i3</A>
<LI><A HREF="../../../sharedobjgen/src/Protocol.i3.html#0TOP0">sharedobjgen/src/Protocol.i3</A>
<LI><A HREF="../../../stubgen/src/Protocol.i3.html#0TOP0">stubgen/src/Protocol.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
