<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>CM Modula-3: quake</title>
    <meta name="GENERATOR" content="Mozilla/2.0GoldB2 (Win32)">
    <LINK HREF="../../../normal.css" REL="stylesheet" TYPE="text/css">
    <style type="text/css">
    <!--
    .white    { color:#FFFFFF; }
    .bgred    { background:#FF4444; }
    .bggreen  { background:#44FF44; }
    .bgblue   { background:#5555FF; }
    .bgyellow { background:#FFFF00; }
    .small    { font-size: 8pt; }
    .tl       { text-align: left; vertical-align: top; }
    .ann      { font-weight: bold;
                font-size: 0.7em;
                font-style: italic;
                font-family: 'Lucida Sans Unicode', Tahoma, Lucida, sans-serif;
                color: #C01010;
              }
    dt        { font-weight: bold;
                text-indent: 1em;
                font-family: 'Courier New', Courier, fixed, mono;
                background: #FFFFB0;
              }
    pre, code { font-weight: normal;
                font-size: 0.95em;
                font-family: 'Courier New', Courier, fixed, mono;
                background: #F0F0C0;
              }
    .contents { font-weight: normal;
                font-size: 0.8em;
                margin-left: 3em;
                line-height: 1.1em;
                white-space: pre;
                background: #F0F0C0;
                font-family: 'Lucida Sans Unicode', Tahoma, Lucida, sans-serif;
              }
    //-->
    </style>
  </head>
<body>

<h2>quake</h2>

<p>This page documents <b>quake</b>. <b>Quake</b> is a simple, specialized
language and its interpreter drawing on elements of the C language, the
Bourne shell, and the C pre-processor. The <tt>cm3</tt> compiler includes
a quake interpreter as its extension language. In fact, the configuration
file, <tt>cm3.cfg</tt>, and <tt>m3makefiles</tt> are quake scripts.</p>

<p><b>Quake</b> was designed to be a simple extension language for the
builder. Building a complete, general-purpose language was not one of the
goals.</p>

<p>Cm3 calls out to quake every time it needs to do something that needs
to be specialized such as compiling C files or linking. Consult
<tt>cm3.cfg</tt>
in your installation (in the same directory as cm3 executable) for more
information. </p>

<h3>Contents</h3>

<div class="contents">
  <a href="#history">1  History</a>
  <a href="#values">2  Values</a>
        <a href="#strings">2.1  Strings</a>
        <a href="#arrays">2.2  Arrays</a>
        <a href="#tables">2.3  Tables</a>
  <a href="#names">3  Names</a>
  <a href="#comments">4  Comments</a>
  <a href="#conditionals">5  Conditionals</a>
  <a href="#expression">6  Expressions</a>
  <a href="#statements">7  Statements</a>
        <a href="#assignment">7.1  Assignment</a>
        <a href="#scope">7.2  Scope</a>
        <a href="#procedures">7.3  Procedures</a>
        <a href="#conditionalstatements">7.4  Conditional Statements</a>
        <a href="#loops">7.5  Loops</a>
  <a href="#keywords">8  Keywords</a>
  <a href="#builtinprocs">9  Built-in Functions and Procedures</a>
        <a href="#inputoutputproc">9.1  Input Output</a>
        <a href="#codeexecproc">9.2  Code Execution</a>
        <a href="#filesystemproc">9.3  File System Functions and Procedures</a>
        <a href="#pathnamefuncs">9.4  Pathname Functions</a>
        <a href="#argumentlists">9.5  Argument Lists</a>
        <a href="#genericpredicates">9.6  Generic Predicates</a>
        <a href="#textfuncs">9.7  Text Functions</a>
        <a href="#dirfuncs">9.8  Directory (Stack) Functions and Procedures</a>
        <a href="#systeminfo">9.9  System Information</a>
  <a href="#outputredir">10  Output Redirection</a>
  <a href="#runningquake">11  Running Quake</a>
</div>

<a name="history"></a>
<h3>1  History</h3>
<p>
  During the history of Modula-3, there have also been several
  different versions and implementations of quake. The first
  Modula-3 compilers didn't have any quake support at all. Unix
  makefiles were generated by the m3make utility from m3makefiles.
</p>
<p>
  The first quake implementation was written in C and called as a
  standalone executable. Later, in the PM3 and CM3 distributions,
  quake was reimplemented in Modula-3, and then integrated into the
  builder (m3build) and later the compiler frontend, which led to
  considerable performance improvements of the Modula-3 compilation
  process.
</p>
<p>
  This manual cannot achieve to document all the different variants
  and versions of quake. If not otherwise stated, it refers to the
  latest version of quake as it is contained in CM3 5.6.0 and later.
</p>

<a name="values"></a>
<h3>2  Values</h3>

<p><b>Quake</b> is designed to make it easy to assemble arrays and tables
of strings. The value space is strings, arrays of strings, and tables of
strings. An array is a list of elements, and a table is a set of key/value
pairs where the keys in a table are all distinct.
</p>
<p>
Quake also has some limited support for integers and booleans (at
least internally), those everything is converted on the fly to the
needed type (which is almost always string). Denotations for boolean
and integer values as well as arithmetic operations are mostly
missing.
</p>

<a name="strings"></a>
<h4>2.1  Strings</h4>

<p>A string is a sequence (delimited by <code>&quot;</code>) of
characters excluding newline and double quote. Several special
characters may be quoted (with <code>\</code>) as follows: </p>

<pre>    new-line    ignored
    \\          \
    \n          new-line
    \r          return
    \t          tab
    \b          backspace
    \f          formfeed
    \&quot;          double quote
</pre>

<a name="arrays"></a>
<h4>2.2  Arrays</h4>

<p>An array is constructed using <code>[</code> and
<code>]</code>. <code>[]</code> is the empty array,
<code>[&quot;a&quot;]</code> is an array of the single string
&quot;a&quot;. Elements are separated by <code>,</code>. Thus
<code>[&quot;a&quot;, &quot;b&quot;]</code> is an array
of two elements---the strings &quot;a&quot; and &quot;b&quot;.
</p>

<p>Arrays are flattened whenever they are referenced. This means that
<code>[&quot;a&quot;, [&quot;b&quot;, &quot;c&quot;]]</code> is
converted the the array <code>[&quot;a&quot;, &quot;b&quot;,
&quot;c&quot;]</code>. This means that an array can never be the
element of another array.
</p>

<p>Arrays are accessed by an integer index. <code>a[2]</code> is the
third element of the array a. The index expression may also be a
string which will be converted to an integer. The range of the index
is checked at run-time.
</p>

<a name="tables"></a>
<h4>2.3  Tables</h4>

<p>A table is constructed using <code>{</code> and
<code>}</code>. <code>{}</code> is the empty table. Elements
of a table are given as key/value pairs. An empty value may be omitted.
<code>{&quot;a&quot;, &quot;b&quot;}</code> is a table containing two
keys---the strings &quot;a&quot; and
&quot;b&quot;. <code>{&quot;p&quot; : &quot;q&quot;}</code> is the
constructor for a table with the single key &quot;p&quot; whose value
is the string &quot;q&quot;. Missing values are returned as &quot;&quot;.
</p>

<p>Tables are accessed using expressions of the form
<code>s{&quot;a&quot;}</code>.
This evaluates to the value of the key &quot;a&quot; in the table s.
</p>

<a name="names"></a>
<h3>3  Names</h3>

<p>Names in <b>quake</b> start with a letter
(<code>a</code>..<code>z</code>, <code>A</code>..<code>Z</code>) or an
underscore (<code>_</code>), followed by those characters, digits
(<code>0</code>..<code>9</code>), hyphens (<code>-</code>), or periods (<code>.</code>). </p>
<p>If the lookup for a name fails (it is undefined in any of the enclosing
scopes) it is installed in the current scope with an initial string value
of the text of the name. </p>

<a name="comments"></a>
<h3>4  Comments</h3>

<p>C-style comments are supported (delimited by <code>/*</code> and
<code>*/</code>) and do not nest.
</p>

<p>Single-line comments are introduced with <code>%</code> and
terminated with a new-line.
</p>

<a name="conditionals"></a>
<h3>5  Conditionals</h3>

<p>A Boolean value is represented as a string. The empty string is false,
and any other string is true.
If builtin quake functions return boolean values, they use "TRUE" for
true and "" for false.
</p>

<a name="expressions"></a>
<h3>6  Expressions</h3>

<p>An expression is: </p>

<pre>    string:                  &quot;baz&quot;
    name:                    foo
    environment variable:    $CPU_TYPE
    array selector:          array[5]
    array constructor:       [&quot;a&quot;, &quot;b&quot;]
    table selector:          t{&quot;a&quot;}
    table constructor:       {&quot;a&quot; : &quot;p&quot;, b}
    function call:           f(a, &quot;b&quot;)
    parentheses:             a and (b or f(c))
</pre>

<p>Operators are all left-associative, precedence is decreases from top
to bottom in the following list. </p>

<pre>    &amp;           string catenation (<code>&quot;Hello, &quot; &amp; foo</code>)
    contains    table inclusion (<code>s contains &quot;a&quot;</code>)
    not         logical negation (<code>not a</code>)
    and         logical conjunction (<code>c and not d</code>)
    or          logical disjunction (<code>a or b</code>)
</pre>

<p>
WARNING: The &quot;and&quot; and &quot;or&quot; operators are NOT short-circuit.
I.e., they always evaluate both their operands. 
</p>

<p>A note on string catenation. Operands of <code>&amp;</code> are converted to strings
whenever required and possible. Arrays and tables are converted to strings
by catenating their elements (for tables, their keys) separated by a single
spaces. For example, the expression </p>

<pre>    &quot;a&quot; &amp; &quot; &quot; &amp; [&quot;b&quot;, &quot;c&quot;]
</pre>

<p>evaluates to the string &quot;a b c&quot;. </p>

<a name="statements"></a>
<h3>7  Statements</h3>

<p>A statement is either an assignment, a procedure definition, a procedure
invocation, a conditional statement, or a loop.
</p>
<p>
There is no explicit statement separator or terminator, which may seem
quite unfamiliar to those used to C or Algol-derived languages. The
next statement just starts after the previous is finished without
semicolon or line-break.
</p>

<a name="assignment"></a>
<h4>7.1  Assignment</h4>

<p>Assign an expression (the string &quot;bar&quot;) to the variable
<code>foo</code> with </p>

<pre>    foo = &quot;bar&quot;
</pre>

<p>If <code>foo</code> already exists, and is an array, then </p>

<pre>    foo += &quot;baz&quot;
</pre>

<p>extends the array to include a new final element; the string &quot;baz&quot;.
</p>

<a name="scope"></a>
<h4>7.2  Scope</h4>

<p><b>Quake</b> has a global name space, but local scopes are always
introduced when a procedure is called, and a <code>foreach</code> loop
is executed.
</p>

<p>Scopes are searched from innermost to outermost each time a name is
looked up. The outermost scope is always the global scope.
</p>

<p>Assignments can be made local to the innermost scope by prefixing the
assignment statement with the keyword <code>local</code>. For example, </p>

<pre>    local foo = &quot;bog&quot;
</pre>

<p>In which case the values of any other instances of <code>foo</code>
in other scopes are hidden. The previous value of <code>foo</code> is
restored once the local scope is released by exiting the procedure or
<code>foreach</code> loop.
</p>

<p>To protect a name in the current scope, use </p>

<pre>    readonly dec = &quot;digital&quot;
</pre>

<p>If <code>local</code> or <code>readonly</code> are not used, all
variables are located in the outermost (global) scope. Beware of
side-effects!
</p>

<a name="procedures"></a>
<h4>7.3  Procedures</h4>

<p>A procedure definition may appear anywhere in Quake code, including
  inside inner scopes.  However, its name will always be declared in the
  global scope.  Similarly, any nonlocal identifier references from
  inside the procedure's definition that are not declared therein are
  further looked up only in the global scope.   
</p>

<p> Here is the
definition of a procedure <code>simple</code>, taking two arguments
bound to the local names <code>prefix</code> and <code>suffix</code>
in the procedure's local scope.
</p>

<pre>    proc simple(prefix, suffix) is
      q = prefix &amp; &quot;.&quot; &amp; suffix
    end
</pre>

<p>The string <code>prefix &amp; &quot;.&quot; &amp; suffix</code> is assigned to
the global variable <code>q</code>. </p>

<p>This procedure can then be invoked with </p>

<pre>    simple(&quot;Hello&quot;, &quot;m3&quot;)
</pre>

<p>Procedures can return values, in which case they become functions. For
example, </p>

<pre>    proc combine(prefix, suffix) is
      return prefix &amp; &quot;.&quot; &amp; suffix
    end
</pre>

<p>defines a function <code>combine</code> which catenates and returns
the three strings <code>prefix</code>, &quot;.&quot;, and
<code>suffix</code>. Now the function <code>combine</code> can be used
in an expression, for example
</p>

<pre>    q = combine(&quot;Hello&quot;, &quot;m3&quot;)
</pre>

<p>assigns the string &quot;Hello.m3&quot; to <code>q</code>. </p>

<a name="conditionalstatements"></a>
<h4>7.4  Conditional Statements</h4>

<p>Values may be tested using the <code>if</code> statement. For example, </p>

<pre>    if compiling
      message = &quot;compiling&quot;
    end
</pre>

<p>If statements may have an else part, for example </p>

<pre>    if not (ready or interested)
      return
    else
      message = &quot;congratulations&quot;
    end
</pre>

<p>returns from the current procedure if the test succeeds, otherwise
executes the assignment statement.
</p>

<a name="loops"></a>
<h4>7.5  Loops</h4>

<p><code>Foreach</code> statements iterate over the string values in
an array or in a table. For example, </p>

<pre>    foreach file in [&quot;.login&quot;, &quot;.profile&quot;, &quot;.Xdefaults&quot;]
      write(&quot;Copying &quot; &amp; file &amp; &quot; to &quot; &amp; backup_dir &amp; &quot;0)
      copy_file(file, backup_dir)
    end
</pre>

<p>binds the name <code>file</code> to each of &quot;.login&quot;,
&quot;.profile&quot;, and &quot;.Xdefaults&quot; in turn in a local
scope. This example assumes that the procedures
<code>copy_file</code>, and the variable <code>backup_dir</code> have
already been defined.
</p>

<p>Here is a function <code>squeeze</code> to remove duplicates from
an array </p>

<pre>    proc squeeze(array) is
      local t = {}

      foreach i in array
        t{i} = &quot;&quot;
      end

      return [t]
    end
</pre>

<a name="keywords"></a>
<h3>8  Keywords</h3>

<p>Here is a list of reserved words in <b>quake</b>: </p>

<pre>    and  contains  else  end  foreach  if  in
    is  local  not  or  proc  readonly  return
</pre>

<a name="builtinprocs"></a>
<h3>9  Built-in Procedures</h3>

<p><b>Quake</b> has a small collection of built-in
procedures. Built-ins cannot be redefined. The built-ins
<code>write</code>, <code>error</code>, and <code>exec</code> are variadic.
</p>
<p>
The list of built-ins was substantially extended in CM3 5.6 due to the
needs of enhanced regression testing on different target platforms
without further prerequisites.
</p>

<a name="inputoutputproc"></a>
<h4>9.1  Input / Output</h4>

<dl>
<dt>write(...)</dt>
<dd><p>
Writes its arguments to the current output stream.
Unlike the conversion of arrays to strings, there are no extra spaces
inserted between arguments.
</p></dd>

<dt>error(...)</dt>
<dd><p>
Writes its arguments to the standard error stream
and stop running <b>quake</b> with an error return value.
</p></dd>
</dl>

<a name="codeexecproc"></a>
<h4>9.2  Code Execution</h4>

<dl>
<dt>include(file)</dt>
<dd><p>
The contents of <code>file</code> is interpreted by <b>quake</b>
in place of the call to <code>include</code>. This is analogous the
<code>#include</code> directive in the C preprocessor. Calls to
<code>include</code> nest until you run out of file descriptors or
something equally bad.
</p></dd>

<dt>exec(...)</dt>
<dd><p>
The arguments are catenated and passed to the operating system to be
executed as a child process. The command may start <code>-</code> or
<code>@</code>. These are stripped before the command is passed to the
command interpreter.
</p><p>
A prefix of <code>@</code> indicates that the default action of
printing the command to the standard output stream before execution
should be overridden. A prefix character of <code>-</code> overrides
<b>quake</b>'s default action of aborting if it detects an error
return code after executing the command.
</p></dd>

<dt>cm3_exec(...) <span class="ann">compatibility, since CM3 
d5.5.1</span></dt>
<dd><p>
Same as the above, but imitating the old implementation which merged
stdout and stderr streams.
</p></dd>

<dt>quake( code ) <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Executes the quake code passed as a text.
</p></dd>

<dt>try_exec(...) --&gt; int</dt>
<dd><p>
The arguments are catenated and passed to the operating system to be
executed as a child process. The command may start <code>-</code> or
<code>@</code>. These are stripped before the command is passed to the
command interpreter.
</p><p>
A prefix of <code>@</code> indicates that the default action of
printing the command to the standard output stream before execution
should be overridden. The exit code of the program is returned.
</p></dd>

<dt>try_cm3_exec(...) --&gt; int <span class="ann">compatibility, since
CM3 d5.5.1</span></dt>
<dd><p>
Same as the above, but imitating the old implementation which merged
stdout and stderr streams.
</p></dd>

<dt>q_exec( cmd ) --&gt; int <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Executes the passed command or command list which may contain the
following input/output redirections:</p>
<pre>     &lt; fn   : read stdin from file fn
     &gt; fn   : write stdout into file fn
     1&gt; fn  : write stdout into file fn
     2&gt; fn  : write stderr into file fn
     &amp;&gt; fn  : write stdout and stderr into file fn
     &gt;&gt; fn  : append stdout to file fn
     1&gt;&gt; fn : append stdout to file fn
     2&gt;&gt; fn : append stderr to file fn
     &amp;&gt;&gt; fn : append stdout and stderr to file fn
</pre><p>
<code>cmd</code> is parsed and split into single commands at every
<code>;</code>, <code>|</code>, <code>&amp;&amp;</code>, and <code>||</code>. 
The concatenation characters have the usual Bourne Shell meaning:</p>
<pre>     a ; b    execute a followed by b
     a | b    execute a and pipe its output to b's standard input
     a &amp;&amp; b   execute a, then b if a has succeeded (returned 0)
     a || b   execute a, then b if a has failed (returned #0)
</pre><p>
Token may be grouped by single or double quotes.
</p>
<p>
The exit code of the command list is returned.
</p></dd>

<dt>q_exec_put( cmd, text ) --&gt; int <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Executes the given single command and pipe <code>text</code> to its standard
input. No other redirections are performed.
</p>
<p>
The exit code of the command list is returned.
</p></dd>

<dt>q_exec_get( cmd ) --&gt; [int, text] <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Executes the given single command and captures its stdout and stderr
output in <code>text</code>
</p>
<p>
This functions returns an array with two elements: First is the exit
code of the command, second the captured output. 
</p></dd>

</dl>

<a name="filesystemproc"></a>
<h4>9.3  File System Functions and Procedures</h4>

<dl>
<dt>cp_if(src, dest)</dt>
<dd><p>
If the file <code>src</code> differs from the file <code>dest</code>,
or <code>dest</code> is missing, copy <code>src</code> to
<code>dest</code>.
</p></dd>

<dt>fs_touch( pn ) <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Touches file <code>pn</code>, i.e. sets its access time to the current
time. If the files doesn't exist, it is created.
</p></dd>

<dt>fs_rmfile( pn ) <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Removes file <code>pn</code> if it exists.
</p></dd>

<dt>fs_rmdir( pn ) <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Removes directory <code>pn</code> if it exists and is empty.
</p></dd>

<dt>fs_rmrec( pn ) <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Removes the complete directory hierarchy at <code>pn</code>.
</p></dd>

<dt>fs_mkdir( pn ) <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Creates all non-existing elements of pathname <code>pn</code> as
directories.
</p></dd>

<dt>fs_cp( pn, pn2 ) <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Copies file <code>pn</code> to <code>pn2</code>.
</p></dd>

<dt>fs_putfile( pn, text ) <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Replaces the contents of file <code>pn</code> with
<code>text</code>. If the files does not exist, it is created.
</p></dd>

<dt>stale(target, deps) --&gt; bool</dt>
<dd><p>
<code>target</code> is interpreted as a file name, as is
<code>deps</code> (or the elements of <code>deps</code> if it's an
array). If the files <code>target</code> or <code>deps</code> cannot
be found, or if (one of) <code>deps</code> is more recent than <code>target</code>, <code>stale</code> returns true, otherwise false.
</p></dd>

<dt>unlink_file(f) --&gt; bool</dt>
<dd><p>
Deletes the file <code>f</code>. Returns "TRUE" in case of success, else "".
</p></dd>

<dt>path() --&gt; text</dt>
<dd><p>
Returns the directory of the currently executing file as a string.
</p></dd>

<dt>fs_exists( pn ) --&gt; bool <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Returns "TRUE" if <code>pn</code> exists as a file system object, else
"" (false).
</p></dd>

<dt>fs_readable( pn ) --&gt; bool <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Returns "TRUE" if <code>pn</code> is readable, else "" (false).
</p></dd>

<dt>fs_writable( pn ) --&gt; bool <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Returns "TRUE" if <code>pn</code> is writable, else "" (false).
</p></dd>

<dt>fs_executable( pn ) --&gt; bool <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Returns "TRUE" if <code>pn</code> is considered to be executable, else
"" (false).
</p></dd>

<dt>fs_isdir( pn ) --&gt; bool <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Returns "TRUE" if <code>pn</code> is a directory, else "" (false).
</p></dd>

<dt>fs_isfile( pn ) --&gt; bool <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Returns "TRUE" if <code>pn</code> is an ordinary file, else "" (false).
</p></dd>

<dt>fs_lsdirs( pn, baseonly ) --&gt; text[] <span class="ann">since CM3
d5.6.0</span></dt>
<dd><p>
Returns an array of all subdirectories of <code>pn</code>. If
<code>baseonly</code> is "" (false), only the basenames are returned,
else pathnames are returned.
</p></dd>

<dt>fs_lsfiles( pn, baseonly ) --&gt; text[] <span class="ann">since CM3
d5.6.0</span></dt>
<dd><p>
Returns an array of all ordinary files in directory <code>pn</code>. If
<code>baseonly</code> is "" (false), only the basenames are returned,
else pathnames are returned.
</p></dd>

<dt>fs_contents( pn ) --&gt; text <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Returns the contents of file <code>pn</code> as a text.
</p></dd>

</dl>

<a name="pathnamefuncs"></a>
<h4>9.4  Pathname Functions</h4>

<dl>
<dt>pn_valid(pn) --&gt; bool</dt>
<dd><p>
"TRUE" iff <code>pn</code> is a valid pathname.
</p></dd>

<dt>pn_absolute(pn) --&gt; bool</dt>
<dd><p>
"TRUE" iff <code>pn</code> is an absolute pathname.
</p></dd>

<dt>pn_compose(text[]) --&gt; text</dt>
<dd><p>
Builds a new pathname from <code>text[]</code>. The first element
is the root (which may be empty), the rest are arcs of the pathname.
</p></dd>

<dt>pn_decompose(pn) --&gt; text[]</dt>
<dd><p>
Decomposes <code>pn</code> into its root and arcs.
</p></dd>

<dt>pn_prefix(pn) --&gt; text</dt>
<dd><p>
Strips the last arc from <code>pn</code>.
</p></dd>

<dt>pn_last(pn) --&gt; text</dt>
<dd><p>
Returns the last arc of <code>pn</code>.
</p></dd>

<dt>pn_base(pn) --&gt; text</dt>
<dd><p>
Strips the last extension from <code>pn</code>.
</p></dd>

<dt>pn_lastbase(pn) --&gt; text</dt>
<dd><p>
Returns the last arc from <code>pn</code> without its extension.
</p></dd>

<dt>pn_lastext(pn) --&gt; text</dt>
<dd><p>
Returns the extension of the last arc of <code>pn</code>.
</p></dd>

<dt>pn_join(pna, pnb) --&gt; text</dt>
<dd><p>
Returns the concatenation of <code>pna</code> and <code>pnb</code>.
<code>pnb</code> must be a relative pathname.
</p></dd>

<dt>pn_join2(pna, pnb, ext) --&gt; text</dt>
<dd><p>
Returns the concatenation of <code>pna</code> and <code>pnb</code> and
the extension <code>ext</code>.
<code>pnb</code> must be a relative pathname.
</p></dd>

<dt>pn_replace_text(pn) --&gt; text</dt>
<dd><p>
Replaces the extension of the last arc of <code>pn</code>.
</p></dd>

<dt>pn_current() --&gt; text</dt>
<dd><p>
Returns a representation of the special arc denotating the current
directory.
</p></dd>

<dt>pn_parent() --&gt; text</dt>
<dd><p>
Returns a representation of the special arc denotating the parent
directory.
</p></dd>

</dl>

<a name="argumentlists"></a>
<h4>9.5  Argument Lists</h4>

<dl>
<dt>arglist(pfx, array)</dt>
<dd><p>
This function may be used to avoid the problems of limited space for
argument lists in some command interpreters. Some commands (notably
<code>m3</code>, the Modula-3 driver program) are prepared to accept
arguments from a file. The syntax for this is <code>-Ffile</code>.
</p><p>
Thus, <code>arglist(&quot;-F&quot;, really_huge_array)</code> returns
either the original array if it's not really all that huge, or it
creates a temporary file containing a list of the strings in the array
(one to a line) and returns the string &quot;-Ftemp&quot; where
<code>temp</code> is the name of the temporary file.
</p></dd>
</dl>

<a name="genericpredicates"></a>
<h4>9.6  Generic Predicates</h4>

<dl>
<dt>defined(foo) --&gt; bool</dt>
<dd><p>
Returns true if <code>foo</code> is defined, otherwise returns
false. Remember that the Boolean values false and true are represented
as empty and non-empty strings respectively. In this example,
<code>foo</code> looks like a name, and is evaluated before being
passed to <code>defined</code>. So if you really want to find out
whether <code>foo</code> is defined, use
<code>defined(&quot;foo&quot;)</code>.
</p></dd>

<dt>empty(foo) --&gt; bool</dt>
<dd><p>
Returns true if the string, array, or table is empty,
false otherwise.
</p></dd>

<dt>equal(foo, bar) --&gt; bool</dt>
<dd><p>
Returns true if the strings <code>foo</code> and <code>bar</code> are
the equivalent. For arrays and tables, equal is treated as reference
equality and not as structural equality as in Modula-3.
</p></dd>
</dl>

<a name="textfuncs"></a>
<h4>9.7  Text Functions</h4>

<dl>
<dt>escape(s) --&gt; text</dt>
<dd><p>
Returns the string <code>s</code> with backslash characters doubled.
</p></dd>

<dt>format(s, a...) --&gt; text</dt>
<dd><p>
Returns the string <code>s</code> with each instance of
<code>%s</code> replaced by successive <code>a</code> arguments. The
number of <code>a</code> arguments must match the number of
<code>%s</code>s.
</p></dd>

<dt>normalize(p, q) --&gt; text</dt>
<dd><p>
If the path <code>p</code> is a prefix of the path <code>q</code>,
returns the path from directory <code>p</code> to file
<code>q</code>. Otherwise, returns <code>q</code>.
</p></dd>

<dt>split( text, seps ) --&gt; text[] <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Splits the text into an array at every occurence of a character in
<code>seps</code>.
</p></dd>

<dt>sub( text, off, len ) --&gt; text <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Returns the subtext of <code>text</code> starting at position
<code>off</code> of length <code>len</code>.
</p></dd>

<dt>skipl( text ) --&gt; text <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Removes all white space at the left of the text.
</p></dd>

<dt>skipr( text ) --&gt; text <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Removes all white space at the right of the text.
</p></dd>

<dt>compress( text ) --&gt; text <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Removes all white space at the start and end of text.
</p></dd>

<dt>squeeze( text ) --&gt; text <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Removes multiple empty lines within <code>text</code>.
</p></dd>

<dt>pos( text, sub ) --&gt; int <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Returns the position of <code>sub</code> within <code>text</code> or
-1 if <code>sub</code> is not found.
</p></dd>

<dt>tcontains( text, sub ) --&gt; bool <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Returns true if <code>sub</code> is contained in <code>text</code>.
</p></dd>

<dt>bool( text ) --&gt; bool <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Returns "TRUE" for "true", "TRUE", "T", "yes", "YES", "1", otherwise
"" (false).
</p></dd>

<dt>subst_chars( text, a, b ) --&gt; text <span class="ann">since CM3
d5.6.0</span></dt>
<dd><p>
Returns <code>text</code> in which every character of <code>a</code>
is replaced with the character at the same position of <code>b</code>.
<code>a</code> and <code>b</code> must be of the same length.
</p></dd>

<dt>del_chars( text, a ) --&gt; text <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Returns <code>text</code> in which every occurence of characters from
<code>a</code> is removed.
</p></dd>

<dt>subst( text, a, b, n ) --&gt; text <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Returns <code>text</code> in which the subtext <code>a</code> is
replaced by subtext <code>b</code> for at most <code>n</code> times.
</p></dd>

<dt>subst_env( text ) --&gt; text <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Returns <code>text</code> in which all environment variables with the
denotation <code>${name}</code> or <code>$name</code> are replaced by
the values of the current process execution environment.
</p></dd>

<dt>add_prefix( text[], pre ) --&gt; text[] <span class="ann">since CM3
d5.6.0</span></dt>
<dd><p>
Returns an array of <code>text</code> where each element is prefixed
with <code>pre</code>.
</p></dd>

<dt>add_suffix( text[], suf ) --&gt; text[]
 <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Returns an array of <code>text</code> where each element is suffixed
with <code>suf</code>.
</p></dd>

</dl>

<a name="dirfuncs"></a>
<h4>9.8  Directory (Stack) Functions and Procedures</h4>

<dl>

<dt>pushd( dir ) <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Pushes the current directory onto the stack and changes the working
directory of the quake process to <code>dir</code>.
</p></dd>

<dt>popd() <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Pops the topmost directory from the directory stack and makes it the
working directory of the quake process.
</p></dd>

<dt>cd( dir ) <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Changes the current directory of the quake process to <code>dir</code>.
</p></dd>

<dt>getwd() --&gt; text <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Returns the current working directory of the quake process.
</p></dd>

</dl>


<a name="systeminfo"></a>
<h4>9.9  System Information</h4>

<dl>

<dt>hostname() --&gt; text <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Returns the hostname of the computer quake is running on.
</p></dd>

<dt>date() --&gt; text <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Returns the current date in ISO format: YYYY-MM-DD.
</p></dd>

<dt>datetime() --&gt; text <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Returns the current date and time in ISO format: YYYY-MM-DD hh:mm:ss.
</p></dd>

<dt>datestamp() --&gt; <span class="ann">since CM3 d5.6.0</span></dt>
<dd><p>
Returns the current date and time in this format: YYYY-MM-DD-hh-mm-ss.
</p></dd>

</dl>


<a name="outputredir"></a>
<h3>10  Output Redirection</h3>

<p>Sorry about the syntax for this. Suggestions (YACC permitting) welcome.
</p>

<p>Output (from the <code>write</code> built-in procedure) may be
temporarily redirected as follows: </p>

<pre>    &gt; &quot;foo.txt&quot; in
      write(&quot;Hello, world0)
    end
</pre>

<p>The output of the calls to <code>write</code> is written to the
file <code>foo.txt</code>.
</p>

<p>Output may be appended to a file by using <code>&gt;&gt;</code> in
place of <code>&gt;</code>.
</p>

<p>The special file names <code>_stdout</code> and
<code>_stderr</code> are special and are bound to the file descriptors
corresponding to normal and error terminal output respectively. </p>

<p>The default for output is the normal terminal stream. </p>

<a name="runningquake"></a>
<h3>11  Running Quake</h3>

<p>Older versions of <b>quake</b> were used as standalone executables
and run like this:</p>

<pre>    <b>quake</b> [definitions|files ...]
</pre>

<p>Each file argument is executed as it is encountered. </p>

<p>
Since the integration of quake into the builder and compiler frontend,
this is no more available (though it can be easily re-added it
needed).
</p>
<p>
Quake is now run implicitly by invoking the compiler with
</p>
<pre>    <b>cm3</b> -build | -clean
</pre>
<p>
Usually, the file <tt>src/m3makefile</tt> is executed. If
<code>-override</code> or <code>-x</code> is specified, the
definitions from <tt>src/m3overrides</tt> are executed before.
</p>
<p>
A definition has the form <code>-Dvar</code> or
<code>-Dvar=string</code>. The first form defines <code>var</code> in
the global scope of the program, the second form gives it a value.
</p>


<hr>
<p>Original Author:&nbsp;Stephen Harrison.</a></p>

</body>
</html>
