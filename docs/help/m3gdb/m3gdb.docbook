<?xml version="1.0" encoding="UTF-8"?>
<!-- Docbook documentation on m3gdb, the Modula-3-enhanced version of the gdb debugger.--> 
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.5//EN"
                  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd"
  [ <!ENTITY gdb "gdb">
    <!ENTITY m3gdb "m3gdb">
    <!ENTITY bothgdb "(m3)gdb">
    <!ENTITY src "SRC">
    <!ENTITY pm3 "PM3">
    <!ENTITY ezm3 "EZM3">
    <!ENTITY cm3 "CM3">
    <!ENTITY pm3etal "PM3 et. al.">
    <!ENTITY m3 "Modula-3">
    <!ENTITY expr_l '<link linkend="expressions">expression</link>'>
    <!ENTITY linespec "linespec">
    <!ENTITY linespec_l '<link linkend="linespecs">linespec</link>'>
    <!ENTITY print "<command>print</command>">
    <!ENTITY print_l '<command><link linkend="printcmd">print</link></command>'>
    <!ENTITY break_l '<command><link linkend="breakcmd">break</link></command>'>
  ]
>

<article id="m3gdb-doc" lang="en"> 
  <artheader>
  <title> &m3gdb;, the &m3;-enhanced version of &gdb; </title> 
    <author> <firstname>Rodney</firstname> <surname>Bates</surname> </author>
    <date> 2008-10-31 </date>  
  </artheader>


  <sect1 id="intro">
    <title> Introduction</title> 

    <para> &m3gdb; is a modified version of the well-known &gdb; debugger,
      with added support for the &m3; programming language. 
      Much of the function of &m3gdb; is the same as &gdb;, and this
      article makes no attempt to duplicate information found in existing
      <ulink url="http://www.gnu.org/software/gdb/documentation/"> 
              &gdb; documentation </ulink>. 
      Instead, it documents properties of &m3gdb; that add to or differ
      from &gdb;.  The reader is assumed to be familiar the &gdb; 
      documentation, or able to consult it as necessary.  Most of the
      commands, command line options, environment variables, etc. of
      &m3gdb; are the same as for &gdb;.  The differences lie in the
      syntax and semantics of &expr_l;s, &linespec_l;s, etc. and in the
      output &m3gdb; produces, when &m3; code is involved.    
    </para> 

    <para>
      Throughout, the term &quot;&gdb;&quot; will be used in statements 
      that apply only to unmodified &gdb;.  
      The term &quot;&m3gdb;&quot; will be used in statements 
      that are specific to &m3gdb;.  
      The term &quot;&bothgdb;&quot; will be used to 
      state properties that &m3gdb; inherits from &gdb;,
      and thus are the same in both debuggers.   
    </para> 

    <para>
      &gdb; is a multi-language debugger.  In deriving &bothgdb; from &gdb;,
      none of &gdb;&apos;s function is removed.  Only new support for 
      &m3; is added.  Thus, &bothgdb; is also a multi-language debugger,
      with one additional supported programming language.  &bothgdb; further
      supports debugging mixed-language programs, where modules written
      in different languages are linked together.       
    </para> 

    <para>
      &m3gdb; supports code compiled by the &src;, &pm3;, &ezm3;, and &cm3;
      &m3; compilers.  A single &m3gdb; executable dynamically detects and 
      adapts to code compiled by any of these compilers.  The &src;, &pm3;, 
      and &ezm3; compilers differ very little, as far as &m3gdb; is 
      concerned, so the phrase &quot;&pm3etal;&quot; will be used in statements
      that apply equally to any of these three &m3; compilers.  
      More information on the various compilers and other language
      implementation alternatives and be found in
      <link linkend="implementations">this section</link>. 
    </para> 
  </sect1>

  <sect1 id="building">
    <title> Building &bothgdb; </title> 

    <para>
      Despite its support for all four &m3; compilers, the current, maintained
      version of &m3gdb; is kept only in the &cm3; source repositories.  
      Within the repository it is found at 
      <filename>cm3/m3-sys/m3gdb</filename>.  
      It is entirely written in C, so a working &m3; compiler is not 
      required to build it.  
      However, it is integrated into &cm3;, 
      and this integration uses <filename>m3makefile</filename>s 
      and the &m3; build system.   
      Thus, the easiest way to build it is, with a working installed &cm3;,
      go into subdirectory <filename>cm3/scripts</filename> and execute 
      <command>./do-cm3-m3gdb.sh buildship</command>.  
      This will build and install &m3gdb; in the normal &cm3; 
      <filename>bin</filename> directory, usually 
      <filename>/usr/local/cm3/bin</filename>, where 
      the installed executable will be named <filename>m3gdb</filename>.
    </para> 

    <para>
      This will go through the usual configure process, which will build
      a debugger that both executes on and debugs programs on the machine
      the build process executes on.  
      Building by this method will always repeat the configuration
      process, which can be annoyingly time-consuming if you are doing
      development work on &m3gdb; and have only modified a source
      file or two.  
      Once the configure step has been done on a given machine, 
      it is safe to disable it for future recompiles on the same machine.  
      You can do this by uncommenting the line
      <literal>%quick = 1</literal>, found near the top of 
      <filename>cm3/m3-sys/m3gdb/src/m3makefile</filename>.  
      Note that this is <command>quake</command> code, where the
      &quot;%&quot; is the comment-start character.  
    </para> 

    <para>
      To build &m3gdb; without using a &m3; compiler, go in to 
      <filename>cm3/m3-sys/m3gdb/gdb</filename> and execute  
      <command>./configure</command> and <command>make</command>.
      This is the usual C build process.  The compiled executable
      will then be found in <filename>cm3/m3-sys/m3gdb/gdb/gdb</filename>,
      from whence you can move or copy it as desired.
    </para> 

    <para>
      &bothgdb; has a source file <filename>ada-lex.c</filename>,
      that is mechanically generated from <filename>ada-lex.l</filename>,
      by <command>flex</command>.  
      Normally, the &cm3; distribution will contain an up-to-date 
      <filename>ada-lex.c</filename>, but if not, you may need to 
      have <command>flex</command> installed to build &m3gdb;.  
      There are also several <filename>*.y</filename>
      files that need <command>bison</command> to regenerate their
      corresponding <filename>*.c</filename> files, following the same
      pattern.    
    </para> 

    <para>
      In order to be able to debug variables of &m3; types 
      <literal>INTEGER</literal> and <literal>LONGINT</literal>,
      &m3gdb; needs to be compiled by a C compiler that has an
      integer size at least as wide as each of these &m3; types. 
    </para> 

    <sect2>
      <title>Build Dependencies</title> 

      <para>
        &bothgdb; needs the development files for 
        <filename>libncurses</filename>.  
        In Ubuntu, this is in package <filename>libncurses5-dev</filename>.
      </para> 
    </sect2>
  </sect1>

  <sect1 id="compiling">
    <title> Compiling &m3; Code for Debugging </title> 

    <para>
      As with all debuggers, &bothgdb; requires that code to be debugged
      be compiled with certain options that ask the compiler to insert 
      debug information in the object modules and executable.  
      &bothgdb; needs this information to 
      know things like the names, memory locations, and types of variables.
      Without such information, &bothgdb; can still function, but only
      at the machine  instruction level,
      or in very limited ways at the source code level. 
      &m3gdb; recognizes only the 
      <literal>stabs</literal> or <literal>stabs+</literal> debug
      information format.  In &cm3;, the latter is required for full
      &m3gdb; function.     
    </para> 

    <para>
      To check whether an object or executable file has the right
      kind of debug information,
      execute <command>objdump -G &lt;filename&gt;|head</command>.  
      The file contains the needed debug information iff you
      see the line <literal>&quot;Contents of .stab section:&quot;</literal>. 
    </para> 

    <para>
      By default, the &cm3; distribution is set up to compile with 
      debug information, at least on some platforms.  
      There are mechanisms for specifying either on the <command>cm3</command>
      command line or in the <filename>m3makefile</filename>, that it should
      be produced, but these default to on, and there does not seem
      to be a way to turn them off.  
    </para> 

    <para>
      However, debug information can be turned off or on in 
      another way by omitting or adding the line 
      <literal>if debug     args += "-gstabs+"  end</literal>  
      in the <command>quake</command>
      procedure named <function>m3_backend</function>.  
      This is found in the &cm3; configuration file, usually located at 
      <filename>/usr/local/cm3/bin/cm3.cfg</filename>.
    </para> 

    <para>
      For example, to enable debug information, it should look someting like: 
      <programlisting>
        proc m3_backend (source, object, optimize, debug) is
          local args = [ "-quiet", source, "-o", object, "-fPIC", "-m32", "-fno-reorder-blocks" ]
          if optimize  args += "-O3"  end
          if debug     args += "-gstabs+"  end
          if M3_PROFILING args += "-p" end
          return try_exec (m3back, args)
        end
      </programlisting> 
      This line has been missing in the distributed configuration file
      for some targets, at some times in the past few years.  
    </para> 

    <para>
      By default, &pm3etal; produce debug information.
      If your installation is not giving debug information, add the line
      <literal>option("debuginfo","T")</literal> to your 
      <filename>m3makefile</filename>.  
      To suppress generation of debug information, add the line
      <literal>option("debuginfo","")</literal> to your 
      <filename>m3makefile</filename>.  
    </para> 
  </sect1>

  <sect1 id="commands">
    <title>Commands in &m3gdb;</title> 

    <sect2 id="printcmd"> 
      <title>The &print; Command</title> 
      <para>
        In C, every expression is also a statement and may return a
        result and/or have side-effects.  
        These semantics are reflected in &gdb;, which was first a C debugger.  
        In particular, the &print; command accepts an argument that is an 
        &expr_l;, which it both evaluates, printing the result, and carries out 
        its side-effects on the debugee program.  
        The expression could have no result,
        if its type is <type>void</type>, in which case, the 
        &print; command displays <literal>(void)</literal>.
        The user can execute a C assignment or call by typing it as
        the argument to the &print; command. 
        This facility is, in effect, an interpreter for a significant
        subset of the language, implemented by &gdb;.    
      </para> 

      <para>
        Many of the &m3;-specific extensions that &m3gdb; provides are
        interpretation capabilities for &m3;. 
        &m3gdb; follows the C-like pattern for the &print;
        command by allowing its argument to be either an &expr_l;, an
        assignment statement, or a call statement.  
        Note that an expression could also be a call on a function 
        procedure or method.  
        If the argument is a &m3; expression, the &print; command
        evaluates it and prints the result.  
        If the expression contains a function call, there could also 
        be side-effects as well.  
        If the argument is a statement, the command executes the statement and
        displays <literal>(void)</literal>.  
        Section <link linkend="expressions">Expressions</link> describes 
        the expressions &m3gdb; can evaluate.  
      </para> 
    </sect2>

    <sect2 id="startcmd">
      <title>The <command>start</command> command</title> 

      <para>
        When the main program is written in &m3;, 
        the &m3gdb; <command>start</command> command will
        execute all compiler-generated initializations and all
        module initialization bodies in the 
        <link linkend="initialization">runtime system</link>, which
        is in library <filename>libm3core</filename> 
        and always used when there is &m3; code.  
        <link linkend="globaloffsettable">(but see this note).</link>   
        Execution will stop before any of the other module initialization
        blocks. 
      </para> 

      <para id="breakcmd">
        For code compiled by &pm3etal;, &m3gdb; accomplishes this by setting 
        a breakpoint in procedure <literal>RunMainBodies</literal>, 
        and the stop after the <command>start</command> command will
        appear as hitting this breakpoint. 
        <literal>RunMainBodies</literal> is located in library 
        <filename>libm3core</filename>, and if it is dynamically linked, 
        it may not have been loaded at the time you type the 
        <command>start</command> command, thus requiring you to go 
        through the usual ritual of allowing the breakpoint to be made pending,
        until the containing library is loaded.  
        Answer <literal>y</literal> to the question.
        The breakpoint will be resolved automatically.   
      </para> 

      <para>
        For &cm3;-compiled code, &m3gdb; accomplishes this by setting 
        a breakpoint in <filename>Main.i3</filename>, and the stop 
        after the <literal>start</literal> command will
        appear as hitting this breakpoint. 
      </para> 
    </sect2>
  </sect1> 

  <sect1 id="linespecs">
    <title>Linespecs</title> 

    <para>
      &bothgdb; has commands, e.g., the &break_l; command,
      that take an argument called a 
      <emphasis>&linespec_l;</emphasis>. 
      A &linespec; is used to denote an executable place in the code.  
      There is overlap beween an &expr_l; and a &linespec;, 
      because either can refer to a module, interface, procedure, 
      or (anonymous) block.  
      In a &linespec;, a procedure or block directly denotes its first 
      executable statement, while any of the four can be used as qualifier in
      path eventually leading to a procedure or block.
      In an &expr_l;, a procedure can be named in a call, actual
      parameter, or as a procedure constant, an interface or module
      can similarly be used as a qualifier, leading to a procedure.
    </para> 

    <para id="exprlinespec">
      However, there are significant differences in &bothgdb;'s syntax 
      and semantics of &linespec_l;s and &expr_l;s.  An expression is 
      more general in one respect in that it can denote a variable, 
      formal parameter, type, field, method, or procedure.  But an
      expression needs to have a context where the debugee program is
      stopped, in order to get, e.g., values of variables, and,
      more fundamentally, to imply which language the expression
      is to be interpreted in.  
    </para> 

    <para>
      In contrast, a complete &linespec; can only denote an 
      executable location.  
      While this cannot be a variable, formal, type, field, or
      method, it must be possible to make sense of it independent of
      any execution context.  
      This means it could be a specification in the syntax of any of the 
      languages supported by &bothgdb;.  
      It could also have the form 
      <literal>&lt;sourceFileName&gt;:&lt;lineNumber&gt;</literal>, 
      where <literal>&lt;sourceFileName&gt;</literal> could contain dots.  
      So &bothgdb;&apos;s parsing and analysis of &expr_l;s and &linespec_l;s 
      is quite different.
      Nonetheless, &m3gdb; attempts to make them behave the same, for
      cases that can occur in either kind of denotation.  
    </para> 

    <sect2>
      <title>Linespecs using a file name and line number</title> 

      <para>
        A &linespec_l; with the form 
          <literal>&lt;sourceFileName&gt;:&lt;lineNumber&gt;</literal>
        denotes the specified line number of the source file.  This
        is no different from other &gdb;-supported languages.
        If this line is not an executable place, &bothgdb; will use
        a nearby line that is.   
      </para> 
    </sect2>

    <sect2>
      <title>Linespecs that are qualified references</title> 

      <para>
        A &linespec_l; can take the form of a list of components, 
        each of which is an identifier or a decimal number, separated 
        by dots, with embedded white space allowed between the tokens.  
        This is a kind of fully-qualified path to a procedure or block.  
        The first component must be an identifier and must denote an 
        interface, module, or procedure.   A subsequent identifier
        denotes a procedure by that name, declared local to the unit
        denoted by the prefix.  A number <emphasis>n</emphasis> denotes 
        the n-th anonymous block nested immediately inside the unit
        denoted by the prefix.  This system allows specification of any 
        procedure or block.          
      </para> 

      <para> 
        If the debugee program is running but stopped, and thus has an 
        execution context, &m3gdb; first tries to interpret the first 
        identifier in that context, using the scope rules of &m3;.   
        If that fails, &m3gdb; next tries to interpret the first 
        identifier as an interface name, looking in the entire link 
        closure of the program.  
        If that fails, &m3gdb; finally tries to interpret the first 
        identifier as a module name, again looking in the entire link 
        closure of the program.  
        If the first identifier refers to a module in a not-yet-loaded, 
        dynamically linked library, this will fail, and &bothgdb; 
        will try to find another way to interpret the &linespec_l;.   
      </para>

      <para>
        A subsequent identifier that denotes anything other than a 
        procedure is a failed attempt at interpreting the &linespec;.
        Likewise, a block number that would denote a nonexistent
        block is a failure.  
        Although a procedure can be referred to using an interface 
        as prefix, any further components of the &linespec; are 
        interpreted relative to the body of the procedure, 
        i.e., within the module that exports the procedure.  
        A procedure within a module will be found if it is either 
        explicitly declared in the module or in an exported interface
        of the module.  
        This means that, when the exporting module has
        a different name from an interface, a procedure can usually
        be referenced using either the interface name or the module 
        name as prefix.  
      </para>

      <para>
        The initialization block of a module can
        be specified as either the module name alone, or with the form
        <literal>&lt;moduleName&gt;.1</literal>, i.e., the first 
        (and only, in this case) block inside the module.  
        As a prefix of a longer &linespec; (i.e., to specify some 
        procedure or block inside the module initialization block), 
        the latter form is required, because, for example, 
        <literal>&lt;moduleName&gt;.&lt;procedureName&gt;;</literal>
        denotes a procedure declared local to the module, not to 
        the module's initialization block.    
        See this <link linkend="dot1modulebodies">note</link> about
        hitting breakpoints specified in this way.
      </para> 

      <para>
        &m3gdb; is inconsistent about what it does when an interpretation
        attempt fails.  Sometimes it tries the next way of looking up
        the first identifier as &m3; code.  This usually happens when the 
        failure occurs within the first two components. 
        Sometimes it abandons trying to interpret the entire &linespec_l; as
        &m3; code, but allows &gdb; to try other ways to interpret it,
        in other languages.  
        This usually happens when the first identifier can't be found
        and when the component list is ill-formed. 
        Sometimes it displays an error message and gives up altogether. 
        This happens for bad components after the second.    
        This inconsistency is considered a bug, but it is not obvious
        what the best semantics are.  
      </para>
    </sect2>

    <sect2>
      <title>Linespecs using mangled names</title> 

      <para>
        All the &m3; compilers emit mangled linker names for
        procedures, and such a name can be used in a &linespec_l;
        as an alternative way to identify a procedure.  
        The mangled name for any procedure is similar to the component list
        &linespec;s above, with each dot replaced by two underscores.
        The entire name is a single linker name, so no embedded 
        white space is allowed.  
        The first component is always the <emphasis>module</emphasis> 
        the procedure&apos;s body is declared in.  
        The block numbers have no leading zeros.
        It is possible for a programmer to spoof such a name by
        an identifier with double underscores, causing confusion
        to &m3gdb;.  
      </para> 
    </sect2>
  </sect1>

  <sect1 id="expressions">
    <title>Expressions</title> 

    <para>
      The following list gives &m3; code constructs that are supported, 
      to at least some degree, in &m3gdb; expressions. 
      Where &m3gdb; semantics are not identical to &m3;
      semantics, subsequent subsections describe the differences.
      All of these constructs are treated as expressions by &m3gdb;.
      but some are statements in &m3;. 
    </para>

    <para>
      <itemizedlist>
        <listitem><para>
          <link linkend="calls">Procedure and method calls</link>.
        </para></listitem>

        <listitem><para>
          <link linkend="subscripts">Array subscripting</link>.
        </para></listitem>

        <listitem><para>
          <link linkend="deref">Dereferencing with <literal>^</literal></link>.
        </para></listitem>

        <listitem><para>
          <link linkend="binarith">
            <literal>DIV</literal>, <literal>MOD</literal>, 
            <literal>*</literal>, <literal>/</literal>, 
            binary <literal>+</literal>, and binary <literal>-</literal>
          </link> operators.
        </para></listitem>

        <listitem><para>
          <link linkend="unarith">
            <literal>ABS</literal>, 
            unary <literal>+</literal>, and unary <literal>-</literal>
          </link> operators.
        </para></listitem>

        <listitem><para>
          <link linkend="relops">
            Relational operators
            <literal>=</literal>, <literal>#</literal>, 
            <literal>&lt;</literal>, <literal>&lt;=</literal>, 
            <literal>&gt;</literal>, and <literal>&gt;=</literal>
          </link>.
        </para></listitem>

        <listitem><para>
          Boolean operators 
          <literal>AND</literal>, <literal>OR</literal>, and
          <literal>NOT</literal>.
        </para></listitem>

        <listitem><para>
          The <literal>MIN</literal> and <literal>MAX</literal> functions.
        </para></listitem>

        <listitem><para>
          The <link linkend="debugeetext">
            concatenation operator <literal>&amp;</literal>
          </link>.
        </para></listitem>

        <listitem><para>
          The assignment statement <literal>:=</literal>.
          See notes on assignability of
          <link linkend="arrayassignability">arrays</link> and
          <link linkend="procassignability">procedures</link>.  
        </para></listitem>

        <listitem><para>
          The <literal>ORD</literal> and <literal>VAL</literal> functions.
        </para></listitem>

        <listitem><para>
          The <literal>CIELING</literal>, <literal>FLOOR</literal>, 
          <literal>ROUND</literal> and <literal>FLOAT</literal> functions. 
        </para></listitem>

        <listitem><para>
          The <link linkend="firstlastnumber">
            <literal>FIRST</literal>, <literal>LAST</literal>, 
            and <literal>NUMBER</literal>
          </link> functions.
        </para></listitem>

        <listitem><para>
          The <link linkend="typecode"><literal>TYPECODE</literal></link> 
          function.
        </para></listitem>

        <listitem><para>
          The <link linkend="loophole"><literal>LOOPHOLE</literal>.</link>
          function.
        </para></listitem>

        <listitem><para>
          The <link linkend="sizes">
            <literal>ADRSIZE</literal>, <literal>BITSIZE</literal>, 
            and <literal>BYTESIZE</literal>
          </link> functions.
        </para></listitem>

        <listitem><para>
          The <link linkend="adr"><literal>ADR</literal></link> function. 
        </para></listitem>
      </itemizedlist>
    </para> 

    <sect2 id="identifiers">
      <title>Identifiers</title> 

      <sect3>
        <title>Unqualified Identifiers</title> 

        <para>
          &m3gdb; generally follows &m3;'s rules for looking up an unqualified
          identifier, with some exceptions.  
        </para> 

        <para>
          The debug symbol data emitted by the compilers contains no information
          about identifiers declared in a <literal>CONST</literal>
          or <literal>EXCEPTION</literal> declaration, so you can't refer to
          these in an &m3gdb; &expr_l;.  
          (But you can refer to 
           <link linkend="enumconst">values of enumeration types</link>.)   
          This can further change the semantics of identifier lookup.  
          For example, in true &m3; code, there could be a reference to a 
          named constant that is declared in some inner scope.  
          In an &m3gdb; expression, the same identifier might end up denoting 
          an entirely different declaration by the same name, in some outer 
          scope.
          Since &m3gdb; doesn't know the constant exists, it will
          find the identifier in the outer scope. 
        </para> 

        <para>
          When a normal &m3; scope lookup of an identifier fails, &m3gdb; looks 
          for an interface or module by that name, in the entire link closure 
          of the program, excluding any not-yet-loaded dynamically linked 
          libraries.  
          The name of an interface or module, by itself, has no meaning in an
          &m3gdb; expression, but it can be followed by a dot and used to name
          a procedure, variable, or type declared in the interface or module.
          Identifiers known in a module via exported interfaces can be named
          in this way, in addition to those declared directly in the module. 
          If there is both an interface and a module by the same name, the
          interface is searched first, but a procedure named in that way is 
          treated as referring to the procedure body.  
        </para> 

        <para>
          If, perversely, there were a module that did not export
          a same-named interface and both contained different declarations
          of the same identifier, this lookup order would mean you could
          not name the meaning declared in the module, unless the program
          context were somewhere inside the module. 
        </para> 
      </sect3>

      <sect3 id="nonlocalvars">
        <title>References to nonlocal variables</title> 
        <para>
          For &pm3etal;, &m3gdb; fully supports references to
          variables that are declared in some scope outer to
          the referencing context.  
        </para> 

        <para>
          For &cm3;, the debug information for following static
          links is inadequate. 
          So long as nested procedures are called only as procedure
          constants, it should work correctly.  
          If a nested procedure is called through a formal parameter, m3gdb 
          might find the wrong instance of a statically containing
          procedure, when accessing the containing procedure's
          variables nonlocally.  
          For now, &m3gdb; warns whenever accessing variables nonlocally.
          Also, see <link linkend="othernonlocal">this note.</link>
        </para> 

        <para>
          This problem does not apply to fully global variables, since they
          do not require the static link mechanism to address them. 
        </para> 

      </sect3>

      <sect3>
        <title>Qualified Identifiers</title> 
        <para>
          Dot selections in &m3gdb; follow most of &m3;&apos;s rules.
          You can select:
          <itemizedlist>
            <listitem><para>
              A procedure, type, or variable of an interface or module.
            </para></listitem>

            <listitem><para>A field of a record value.</para></listitem>

            <listitem><para>
              A field or method of an object value.
            </para></listitem>

            <listitem><para>
              <anchor id="enumconst"/>
              One of the named values of an enumeration type.
            </para></listitem>
          </itemizedlist>
          You can not select a constant or exception of an interface or module.
          You can not select a method name of an 
          object <emphasis>type</emphasis>.
        </para> 
      </sect3>
    </sect2>

    <sect2>
      <title>Procedures</title> 

      <para>
        &m3gdb; displays the value of a procedure in both of two ways: 
        a qualified path as in a &linespec_l;, and a source file 
        and line number.  
      </para> 

      <para>
        A procedure can be referred to in an &m3gdb; &expr_l;, either
        as part of a call, to pass the procedure (constant) as an
        actual parameter, or to assign it to a variable. 
      </para> 

      <para id="procassignability">
        &m3gdb; does not check assignability of two procedure types.
        This is relevant for assignments and passing parameters.   
        If both are procedure types, it assumes they are assignable.  
        It warns when it makes this liberal assumption.  
        Bad things will almost certainly happen if you abuse this.   
      </para> 
    </sect2>

    <sect2>
      <title>Types</title> 

      <para>
        A type can be referred to in an &m3gdb; &expr_l;.  
        The primary use is as parameter to builtin functions such as 
        <literal>LOOPHOLE</literal>, <literal>VAL</literal>, etc.
        Only named types work, either builtin or declared in a 
        <literal>TYPE</literal> declaration.
        &m3gdb; does not recognize &m3; type expressions. 
      </para> 

      <para>
        &m3gdb; displays the value of a named type as a qualified
        path, as in a &linespec_l;, but ending with a type name.  
      </para> 

    </sect2>

    <sect2>
      <title>TEXT values</title> 

      <para>
        &m3gdb; displays values of type <literal>TEXT</literal> 
        and accepts them in &expr_l;s.  
        It supports both the form used in &pm3etal; and the form used in &cm3;.
        If the program was compiled by &cm3;, it will handle wide 
        <literal>TEXT</literal> literals and also the type 
        <literal>WIDECHAR</literal> and its literals.  
      </para> 

      <para>
        Normally, &m3gdb; displays <literal>TEXT</literal>
        values in &m3; lexical syntax, with double
        quotes, escape sequences, and, if appropriate, a leading 
        <literal>'W'</literal>. 
        However, the <command>/k</command> option in a &print_l; command will 
        cause it instead to display the <literal>TEXT</literal> 
        value&apos;s internal data structure.  
        For &pm3etal;, this is a traced reference to an open array of 
        characters.
        For &cm3;, this will be one of the several object subtypes of 
        <literal>TEXT</literal>.  
        &m3gdb; properly recognizes and displays values of &cm3; type 
        <literal>TextLiteral.T</literal>.
        Here, it takes the length of the text from the appropriate field, 
        instead of from the declared type, which contains a fixed array whose
        length is almost always far too long. 
      </para> 

      <para>
        Even without specifying the <command>/k</command> option, if you
        happen to know what the internal representation is, you can apply
        appropriate operators to it, e.g., dereferencing, field selection,
        subscripting, or even method calls.  
      </para> 

      <para id="debugeetext">
        There are some cases where, in order to evaluate/execute a user-typed
        &expr_l;, &m3gdb; has to actually allocate an object in the heap
        of the debugee program.  
        Examples are assigning a user-typed <literal>TEXT</literal> value
        to a variable or passing it as an actual parameter.
        This can happen unexpectedly if the expression in the &m3gdb; command
        contains the &m3; concatenation operator <literal>&amp;</literal>, 
        which &m3gdb; evaluates by calling <literal>Text.Cat</literal> 
        in the debugee process.
        This will alter the debugee's execution environment it a subtle way.  
        Usually this will not matter, and the garbage collector will eventually 
        collect such objects after they become inaccessible.  
        Such operations will not work if you are only debugging a 
        <filename>core</filename> file and don't have an executing 
        debugee program.    
      </para> 

      <para>
        If you type <command>print "ABC" &amp; "DEF"</command>, 
        &m3gdb; will execute three calls in the target program.  
        Two on <literal>Text.FromChars</literal> to get the 
        <literal>TEXT</literal> values allocated and one on 
        <literal>Text.Cat</literal> to do the concatenation.
        All three <literal>TEXT</literal> strings will be allocated
        in the debugee program&apos;s traced heap, 
        but will immediately become garbage, available for collection.
      </para> 
    </sect2>

    <sect2>
      <title> &m3; References</title> 

      <para id="deref">
        &m3gdb; tolerates application of a redundant dereferencing operator
        <literal>^</literal> to a value of an object type,
        with a warning. 
      </para> 

      <para>
        &m3gdb; always treats a heap object as having its 
        <emphasis>allocated</emphasis> type, not the static 
        type of the expression used to refer to it.  
        This allows you to select fields, etc. of the actual object. 
      </para> 

      <para>
        A <literal>LOOPHOLE</literal> applied to a heap object is an
        exception.  
        This would allow you to access a field or method of a supertype
        that was hidden by a different but same-named field or method
        in the allocated type. 
      </para> 
    </sect2>

    <sect2>
      <title>Arrays</title> 

      <para id="subscripts">
        &m3gdb; does not support subscripting on non-byte-aligned, 
        bitpacked arrays.
      </para> 

      <para>
        &m3gdb; does not support array constructors.
      </para> 

      <para id="arrayassignability">
        &m3gdb; does not allow assignability of references to non-equal 
        array types. 
        This is relevant for assignments and passing parameters.
        In &m3;, some such combinations are assignable.
        Sorry.  
      </para> 
    </sect2>

    <sect2 id="calls">
      <title>Calls</title> 

      <para>
        For ordinal types, &m3gdb; can't distinguish a <literal>VAR</literal>
        parameter from a <literal>READONLY</literal> parameter, given the
        information available from any of the compilers.  
        In this case, it assumes <literal>VAR</literal>, and requires 
        the actual and formal to have identical types.  
        This assumption makes <literal>VAR</literal> mode
        work (i.e., the actual can be changed by the called procedure), but
        means &m3gdb;'s type rule is overly strict for 
        <literal>READONLY</literal>.  
      </para> 

      <para>
        In the latter case, if the actual is
        assignable but not identical and you really need to pass it, you 
        will have to use a <literal>LOOPHOLE</literal> on the actual 
        parameter in the call.  
        On the other hand, if you use the <literal>LOOPHOLE</literal> 
        and the mode is really <literal>VAR</literal>, bad things could happen. 
      </para> 

      <para>
        For all other classes of types, either &m3gdb; has a way to 
        distinguish <literal>VAR</literal> from <literal>READONLY</literal>, 
        or it doesn't matter. 
      </para> 
    </sect2>

    <sect2 id="arith">
      <title>Arithmetic operators</title> 

      <para id="binarith">
        &m3gdb;&apos;s liberal type rules allow the integer binary 
        (i.e., two-operand) arithmetic operations
        to be performed on any subrange type and any reference type,
        as well as <literal>INTEGER</literal>, <literal>LONGINT</literal>, 
        <literal>CARDINAL</literal>, <literal>LONGCARD</literal>, 
        and mixtures thereof. 
      </para> 

      <para id="unarith">
        <literal>ABS</literal> and unary <literal>-</literal> 
        can only be applied to an <literal>INTEGER</literal>, 
        <literal>LONGINT</literal>, or floating operand.
        They won't even work on a <literal>PACKED</literal>
        or a formal parameter passed by reference.   
        Since it is semantically an identity, &m3gdb; just ignores 
        unary <literal>+</literal> without even bothering to type check it. 
      </para> 
    </sect2>

    <sect2 id="relops">
      <title>Relational operators</title> 

      <para>
        The relational operators 
            <literal>=</literal>, <literal>#</literal>, 
            <literal>&lt;</literal>, <literal>&lt;=</literal>, 
            <literal>&gt;</literal>, and <literal>&gt;=</literal>
        do no type checking at all.  
      </para> 
    </sect2>

    <sect2>
      <title>Builtin functions</title> 

      <para id="firstlastnumber">
        Builtin functions 
        <literal>FIRST</literal>, <literal>LAST</literal>, 
        and <literal>NUMBER</literal>
        work on ordinal and array <emphasis>types</emphasis> only. 
        They do not work on array <emphasis>values</emphasis>
        or on floating types or values.
      </para> 

      <para id="typecode">
        <literal>TYPECODE</literal> works on non-<literal>NIL</literal>
        <emphasis>values</emphasis> that have traced reference types.
        It does not work on <emphasis>types</emphasis>, 
        nor on the value <literal>NIL</literal>. 
      </para> 

      <para id="loophole">
        <literal>LOOPHOLE</literal> works as in &m3;, except it cannot be
        used to convert to an open array type.
      </para> 

      <para id="sizes">
        <literal>ADRSIZE</literal>, <literal>BITSIZE</literal>, 
        and <literal>BYTESIZE</literal> work as in &m3;, except they
        cannot be applied to an open array <emphasis>value</emphasis>. 
      </para> 

      <para id="adr">
        <literal>ADR</literal> can be applied to any value. 
      </para> 
    </sect2>
  </sect1>

  <sect1 id="implementations">
    <title>&m3gdb; Support of Alternate &m3; Implementations</title> 

    <para>
      &m3gdb; supports code compiled by the &src;, &pm3;, &ezm3;, and &cm3;
      &m3; compilers.  A single &m3gdb; executable dynamically detects and 
      adapts to code compiled by any of these compilers.  
    </para> 

    <para id="mixed">
      Programs that link together &m3; code produced by a mixture of 
      &cm3; and &pm3etal; compilers are likely to confuse &m3gdb;&apos;s
      detection of what compiler was used.
      These compilers have significant differences in their runtime
      organization, and &m3gdb; assumes there is not a mixture.  
      Any such problem behaviour can even depend on the order in which
      dynamically-linked libraries are brought in.  
      In fact, mixing code like this is likely to cause other problems,
      even without &m3gdb;&apos;s involvement.  
    </para> 

    <para>
      There are two different code generators in use by the various
      compilers.  
      One is derived from the well-known <command>gcc</command> compiler, 
      with modest modifications to support &m3;.  
      It inherits much of <command>gcc</command>&apos;s repertoire 
      of supported targets and its range of optimization options.  
      For &pm3etal;, it is derived from <command>gcc</command> 2.7.2.
      For &cm3;, it is derived from <command>gcc</command> 4.3.0.
      The other code generator is an i386-specific code generator,
      written in &m3; and designed for fast compilation.   
    </para> 

    <para>
      There are three different thread implementations for &m3; threads. 
      One uses <literal>setjmp</literal> and <literal>longjmp</literal>
      and is implemented entirely within the runtime library 
      <filename>libm3core</filename>.
      It subschedules the process thread that is provided by the 
      operating system, among the &m3; threads.  
      In recent years, it has been undermined by security-motivated changes
      in <literal>setjmp</literal> and <literal>longjmp</literal>.  
      Only a few platforms have an updated version.  
      The second is much newer and uses the library 
      <filename>libpthread</filename>.
      It integrates scheduling of &m3; threads with other threads.  
      It also is adapted to multi-core and multi-chip SMP systems. 
      The third uses Windows native threads and is used only on
      Windows platforms. 
    </para> 

    <para id="collectors">
      There are two different garbage collectors.  
      Both are capable of incremental collection, i.e., running
      collection activity in a parallel thread to the running
      program, thus avoiding unexpected pauses in execution.  
      The older, <link linkend="vmsync">virtual-memory-synchronized</link> 
      collector uses virtual memory to detect heap changes that 
      would otherwise undermine the correctness of the collector.
      The newer, compiler-assisted collector 
      uses compiler-inserted notifications for the same purpose.
    </para> 

    <sect2>
      <title>The <command>Info &m3;</command> command</title> 
      <para>
        &m3gdb; has a new command &quot;<command>Info &m3;</command>&quot;.
        This will tell you which compiler and which code generator
        were used to compile the debugee program and which threads 
        implementation and which garbage collector are in use.
        In case you have trouble remembering which spelling of the
        language name to use, it accepts the cartesian product of
        &quot;Modula&quot; spelled out or abbreviated with a 
        single &quot;M&quot;, lowercase/uppercase &quot;M&quot;, 
        and with/without the hyphen.
        A <link linkend="mixed">mixture</link> of implementations 
        will confuse it.  It may be unable to get some of the 
        information before the <link linkend="initialization"> 
        runtime system has been initialized</link>.  
      </para> 
    </sect2>

    <sect2>
      <title>&m3gdb; and Garbage Collection</title> 
      <para id="vmsync"> 
        The virtual-memory-synchronized garbage collector works by
        asking the operating system to artificially hardware-protect certain
        memory areas from access and to notify it when such and access occurs.
        The notification is through a segment fault that the garbage
        collector catches and handles.  
        Unfortunately, &m3gdb; can't distinguish this artificial segment
        fault from a normal one, resulting in numerous false stops of 
        the debugee program.
        &m3gdb; prevents this by automatically disabling incremental
        collection when debugging with this collector.  
        This is the equivalent of manually adding <literal>@M3novm</literal> 
        to the command line arguments, which you can also do redundantly 
        and harmlessly.
        You can reenable incremental collection by typing the command
        &quot;<command>print RTCollectorSRC.EnableVM()</command>&quot;, 
        after the <link linkend="initialization"> 
        runtime system has been initialized</link>.
      </para> 
    </sect2>

    <sect2>
      <title>&m3gdb; and thread support</title> 

      <para id="pthread">
        The <literal>libpthread</literal> thread implementation uses 
        signal <literal>SIG64</literal> internally.  
        By default, &bothgdb; stops when this signal is received,
        resulting in numerous false stops.  
        When this thread implementation is in use, &m3gdb; automatically 
        executes the command
        &quot;<command>handle SIG64 nostop noprint pass</command>&quot;, 
        before the debugee program starts to run.   
        This causes &m3gdb; to silently pass this signal to the program,
        preventing the false stops.  
        If you want to reverse this, for example, to debug this thread
        implementation, type the command 
        &quot;<command>handle SIG64 stop print pass</command>&quot;.
      </para> 
    </sect2>
  </sect1>

  <sect1 id="initialization">
    <title>Debugging and Runtime Initialization</title> 

    <para>
      Some debugging commands can fail if executed too early, before
      certain initializations have happened. 
      Understanding initialization can matter to you if you want
      to debug module body code or the runtime system itself, 
      or try to execute calls in &m3gdb; commands before everything 
      has been initialized.  
    </para> 

    <para>
      &m3gdb; uses addresses found in debug information in
      executable files to address global variables and procedures.
      On some targets, executable code uses a different mechanism
      that addresses global variables and procedures indirectly,
      using pointers that are also stored in global locations.
      These pointers are initialized by compiler/linker-generated
      machine code, and this happens during program startup.  
    </para> 

    <para>
      You can access a global variable with an &m3gdb; command
      any time, although its value may not yet be initialized.
      However, if you call a global procedure using an &m3gdb;
      command, and it or any other procedure it calls, directly or 
      indirectly, accesses a global variable, it may use 
      one of these pointers.
      If the pointer has not yet been initialized,  
      this will almost certainly cause your program to suffer 
      a segment fault that would never happen if you only executed
      compiler-generated code. 
    </para> 

    <para> 
      Other problems of more varied nature can also occur if the
      module body code, written by the &m3; programmer, has not been
      executed when you use an &m3gdb; command to call a procedure
      too early.  
    </para> 

    <para> 
      Using the &m3gdb; 
      <link linkend="startcmd"><command>start</command></link> command 
      will ensure that the runtime system has been initialized.
      After that, &m3gdb; calls on procedures that are in 
      <filename>libm3core</filename> and in the closure should be safe. 
      To use &m3gdb; safely to make calls in your own code, you need
      to be sure execution has proceeded at least through the first
      line of the body of the module that exports <literal>Main</literal>.
    </para> 

    <para id="globaloffsettable">
      If you link in a library, all the code of the entire library is loaded
      into your address space, and all the debug data is available to &m3gdb;,
      even for modules that are in the library but not in the 
      <literal>IMPORT/EXPORT</literal> closure of the main program.  
      This means you can call procedures in such modules and access their
      global variables from &m3gdb; commands.
      However, the compilers take care of initialization 
      only for modules in the closure, so such modules will
      never be initialized.  Similarly, only certain modules in   
      <filename>libm3core</filename> are initialized as part of
      the runtime system. 
    </para> 

    <para id="FromFingerprint">
      As an example, you can always call 
      <literal>RTTypeFP.FromFingerprint</literal>, because it
      is in <filename>libm3core</filename>.  
      And this could be a useful thing to want to do during
      a debug session (e.g., when debugging something involving pickles). 
      But <literal>RTTypeFP</literal> is not initialized as part
      of the runtime system and is usually not named in any 
      <literal>IMPORT</literal> or <literal>EXPORT</literal>
      in a typical program, and therefore is not in the closure.
    </para> 

    <para>
      So this call, in an &m3gdb; command, will result in a
      segment fault while trying allocate a heap object of a type 
      declared in <literal>RTTypeFP</literal>.
      Even the needed type definition is present in memory, 
      but the needed pointer to it is not set up.
      To make this work, you have to put 
      <literal>IMPORT RTTypeFP;</literal> somewhere in your
      program and recompile and also postpone the &m3gdb; call
      until the necessary initialization has taken place.  
    </para> 

    <sect2 id="dot1modulebodies">
      <title>Module Body execution in &cm3;</title> 
      <para >
        In &cm3;-compiled code, if you put a breakpoint at, e.g., 
        <literal>Mod.1</literal> rather than using a
        source code line number, you will see somewhat strange behaviour.
        The &cm3; runtime system invokes module bodies multiple times.
        The compiler translates them so they do different things
        on different invocations.  
        The compiler also gives them a parameter named 
        <literal>mode</literal>, whose value, in part, determines what
        the module body code will do.   
      </para> 

      <para>
        If execution stops at a breakpoint such as 
        <literal>Mod.1</literal>, and <literal>mode</literal> 
        has value <literal>0</literal>, the programmer-written 
        &m3; code of the module body will not be executed during this
        invocation, and the initialization of the runtime system 
        might not have been done either.  
        This can happen more than once.   
        When <literal>mode</literal> has value <literal>1</literal>,
        then the &m3; code itself is about to be executed.  
      </para> 

      <para>
        You can work around this by using a &linespec_l; with a source 
        code line number in your <command>break</command> command.
      </para> 
    </sect2>
  </sect1>

  <sect1 id="runtime">
  <title>Using the Modula-3 Runtime System to Aid Debugging</title> 

  <para>
    There are many things you can do to aid debugging, just by
    using &m3gdb; commands to print and set variables and to call 
    procedures in the runtime system.  
  </para> 

  <para>
    As an example, RTTypeFP.FromFingerprint 
    could be useful when debugging pickles themselves, or a program
    that uses them. 
    However, see <link linkend="globaloffsettable">here</link> for
    a caveat on how to use it. 
  </para> 
  </sect1>

  <sect1 id="misc">
  <title>Miscellaneous</title> 

    <sect2 id="othernonlocal">
    <title>Nonlocal variable problems in &cm3;</title> 
      <para>
        In &cm3;, there are problems in displaying variables and formal
        parameters that are nonlocally accessed somewhere in the &m3; code,  
        (in addition to <link linkend="nonlocalvars">this problem</link>.)
        If a formal parameter is accessed nonlocally anywhere in the program,
        accessing it locally in &m3gdb; by the commands
        <command>info arg</command>, <command>frame</command>, 
        or <command>backtrace</command> will display an incorrect value, 
        while <command>info loc</command> will give two values for 
        such a parameter, only one of which is correct.  
        The <command>&print_l;</command> command appears to be correct in 
        such cases, as far as tested to date.  
      </para> 
    </sect2>
  </sect1>

  <sect1 id="history">
  <title> History and Acknowledgements</title> 

    <para> 
      &m3gdb; was originally developed as a modification to
      &gdb;, version 4.17, done at DEC's Stanford Research
      Center, by unknown authors.  
      Over the years, the modifications have been moved to
      &gdb; versions 4.0.1.0, 5.3, 6.3, and 6.4, along with
      many enhancements, by Antony Hosking and Rodney Bates. 
      Any additional information about history or contributors
      would be welcomed.  
    </para> 

    <para>
      This document was originally written in October of 
      2008 by Rodney M. Bates, now at rodney.m.bates@acm.org
    </para> 
  </sect1>

</article><!--m3gdb-doc-->


