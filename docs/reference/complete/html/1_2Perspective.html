<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>1.2 Perspective</TITLE>
<META NAME="description" CONTENT="1.2 Perspective">
<META NAME="keywords" CONTENT="m3-defn-complete">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../../../../normal.css">

<LINK REL="next" HREF="1_3Overview.html">
<LINK REL="previous" HREF="1_1History.html">
<LINK REL="up" HREF="1_Introduction.html">
<LINK REL="next" HREF="1_3Overview.html">
</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<A NAME="tex2html80"
  HREF="1_3Overview.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html78"
  HREF="1_Introduction.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html72"
  HREF="1_1History.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A>   
<BR>
<B> Next:</B> <A NAME="tex2html81"
  HREF="1_3Overview.html">1.3 Overview</A>
<B> Up:</B> <A NAME="tex2html79"
  HREF="1_Introduction.html">1. Introduction</A>
<B> Previous:</B> <A NAME="tex2html73"
  HREF="1_1History.html">1.1 History</A>
<BR>
<BR></DIV>
<!--End of Navigation Panel-->

<H3><A NAME="SECTION00013200000000000000">
1.2 Perspective</A>
</H3>

<P>
Most systems programming today is done in the BCPL family of languages, which
includes B, Bliss, and C.  The beauty of these languages is the modest cost
with which they were able to take a great leap forward from assembly language.
To fully appreciate them, you must consider the engineering constraints of
machines in the 1960s.  What language designed in the 1980s has a compiler
that fits into four thousand 18-bit words, like Ken Thompson's B compiler for
the PDP-7? The most successful of these languages was C, which by the early
1970s had almost completely displaced assembly language in the Unix system.

<P>
The BCPL-like languages are easy to implement efficiently for the same reason
they are attractive to skeptical assembly language programmers: they present a
programming model that is close to the target machine.  Pointers are
identified with arrays, and address arithmetic is ubiquitous.  Unfortunately,
this low-level programming model is inherently dangerous.  Many errors are as
disastrous as they would be in machine language.  The type system is scanty,
and reveals enough quirks of the target machine that even experienced and
disciplined programmers sometimes write unportable code simply by accident.
The most modern language in this family, C++, has enriched C by adding
objects; but it has also given up C's best virtue--simplicity--without
relieving C's worst drawback--its low-level programming model.

<P>
At the other extreme are languages like Lisp, ML, Smalltalk, and CLU, whose
programming models originate from mathematics.  Lisp is the hybrid of the
lambda calculus and the theory of a pairing function; ML stems from
polymorphic type theory; Smalltalk from a theory of objects and inheritance;
CLU from a theory of abstract data types.  These languages have beautiful
programming models, but they tend to be difficult to implement efficiently,
because the uniform treatment of values in the programming model invites a
runtime system in which values are uniformly represented by pointers.  If the
implementer doesn't take steps to avoid it, as simple a statement as
<code>n := n + 1</code> could require an allocation, a method lookup, or both.  Good
implementations avoid most of the cost, and languages in this family have been
used successfully for systems programming.  But their general disposition
towards heap allocation rather than stack allocation remains, and they have
not become popular with systems programmers.  The runtime systems required to
make these languages efficient often isolate them in closed environments that
cannot accommodate programs written in other languages.  If you are a fan of
these languages you may find Modula-3 overly pragmatic; but read on anyway,
and give us a chance to show that pragmatic constraints do not exclude
attractive solutions.

<P>
Between the extremes of BCPL and Lisp is the Algol family of languages, whose
modern representatives include Pascal, Ada, Modula-2, and Modula-3.  These
languages have programming models that reflect the engineering constraints of
random-access machines but conceal the details of any particular machine.
They give up the beauty and mathematical symmetry of the Lisp family in order
to make efficient implementations possible without special tricks; they also
have strong type systems that avoid most of the dangerous and
machine-dependent features of the BCPL family.

<P>
In the 1960s, the trend in the Algol family was toward features for control
flow and data structuring.  In the 1970s, the trend was toward
information-hiding features like interfaces, opaque types, and generics.  More
recently, the trend in the Algol family has been to adopt a careful selection
of techniques from the Lisp and BCPL families.  This trend is demonstrated by
Modula-3, Oberon, and Cedar, to name three languages that have floated
portable implementations in the last few years.

<P>
Modula-3, Oberon, and Cedar all provide garbage collection, previously viewed
as a luxury available only in the closed runtime systems of the Lisp family.
But the world is starting to understand that garbage collection is the only
way to achieve an adequate level of safety, and that modern garbage collectors
can work in open runtime environments.

<P>
At the same time, these three languages allow a small set of unsafe,
machine-dependent operations of the sort usually associated with the BCPL
family.  In Modula-3, unsafe operations are allowed only in modules explicitly
labeled unsafe.  The combination of garbage collection with the explicit
isolation of unsafe features produces a language suitable for programming
entire systems from the highest-level applications down to the lowest-level
device drivers.

<P>

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A NAME="tex2html80"
  HREF="1_3Overview.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html78"
  HREF="1_Introduction.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html72"
  HREF="1_1History.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A>   
<BR>
<B> Next:</B> <A NAME="tex2html81"
  HREF="1_3Overview.html">1.3 Overview</A>
<B> Up:</B> <A NAME="tex2html79"
  HREF="1_Introduction.html">1. Introduction</A>
<B> Previous:</B> <A NAME="tex2html73"
  HREF="1_1History.html">1.1 History</A></DIV>
<!--End of Navigation Panel-->
<ADDRESS>
m3-support@elego.de
</ADDRESS>
</BODY>
</HTML>
