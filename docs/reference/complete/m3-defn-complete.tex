\documentclass[10pt]{article}
\usepackage{fullpage, graphicx, url}

\renewcommand{\sfdefault}{phv}
\renewcommand{\rmdefault}{ptm}

\setlength{\parskip}{1ex}
\setlength{\parindent}{0ex}
\title{Modula-3: Language definition}

\begin{document}
\section*{Modula-3: Language definition}

\textbf{Designed and written by Luca Cardelli, James Donahue, Lucille
  Glassman, Mick Jordan, Bill Kalsow, and Greg Nelson.}

\begin{quote}
  \emph{The language designer should be familiar with many alternative
    features designed by others, and should have excellent judgment in
    choosing the best and rejecting any that are mutually inconsistent... One
    thing he should not do is to include untried ideas of his own.  His task is
    consolidation, not innovation.  ---C.A.R.\ Hoare}
\end{quote}

The original definition of Modula-3 was given in SRC Research Report 31,
August 1988.  It was revised in report 52, November 1989.  And finally
published in Systems Programming with Modula-3, November 1989.

This edition of the language definition is derived from all of the above.  In
the few places where it differs from the version published in Systems
Programming with Modula-3, this on-line version is correct.  The errata to the
published version are available.  A multi-page, hierarchical version of this
language definition is also available.

Copyright (C) 1988 Digital Equipment Corporation, Ing.\ C.\ Olivetti and C.,
SpA.

This work may not be copied or reproduced in whole or in part except in
accordance with this provision.  Permission to copy in whole or in part
without payment of fee is granted only to licensees under (and is subject to
the terms and conditions of) the Digital License Agreement for SRC Modula-3,
as it appears, for example, on the Internet at the URL
\url{http://www.research.digital.com/SRC/m3sources/html/COPYRIGHT.html}.  All
such whole or partial copies must include the following: a notice that such
copying is by permission of the Systems Research Center of Digital Equipment
Corporation in Palo Alto, California; an acknowledgment of the authors and
individual contributors to the work; and this copyright notice.  All rights
reserved.

\subsection*{Contents}

\begin{itemize}
\item Acknowledgments
\item[1.~] Introduction
   \begin{itemize}
  \item History, Perspective, Overview, Features, Interfaces, Objects,
    Generics, Threads, Safety, Garbage collection, Exceptions, Type System,
    Simplicity
  \end{itemize}
\item[2.1] Definitions
\item[2.2] Types
  \begin{itemize}
  \item Ordinal types, Floating-point types, Arrays, Records, Packed types,
    Sets, References, Procedures, Objects, Subtyping rules, Predeclared opaque
    types
  \end{itemize}
\item[2.3] Statements
  \begin{itemize}
  \item Assignment, Procedure call, Eval, Block statement, Sequential
    composition, \verb|RAISE|, \verb|TRY|-\verb|EXCEPT|,
    \verb|TRY|-\verb|FINALLY|, \verb|LOOP|, \verb|EXIT|, \verb|RETURN|,
    \verb|IF|, \verb|WHILE|, \verb|REPEAT|, \verb|WITH|, \verb|FOR|,
    \verb|CASE|, \verb|TYPECASE|, \verb|LOCK|, \verb|INC|, \& \verb|DEC|
  \end{itemize}
\item[2.4] Declarations
  \begin{itemize}
  \item Types, Constants, Variables, Procedures, Exceptions, Opaque types,
    Revelations, Recursive declarations,
  \end{itemize}
\item[2.5] Modules and interfaces
  \begin{itemize}
  \item Import statements, Interfaces, Modules, Example, Generics,
    Initialization, Safety
  \end{itemize}
\item[2.6] Expressions
  \begin{itemize}
  \item Conventions, Operation syntax, Designators, Numeric literals, Text and
    character literals, NIL, Function application, Set, array, and record
    constructors, NEW, Arithmetic operations, Relations, Boolean operations,
    Type operations, Text operations, Constant expressions
  \end{itemize}
\item[2.7] Unsafe operations
\item[2.8] Syntax
  \begin{itemize}
  \item Keywords, Reserved identifiers, Operators, Comments, Pragmas,
    Conventions, Compilation units, Statements, Types, Expressions,
    Miscellaneous, Tokens
  \end{itemize}
\item About the authors
\end{itemize}

\subsection*{Acknowledgments}

Modula-3 was designed by Luca Cardelli, Jim Donahue, Mick Jordan, Bill Kalsow,
and Greg Nelson, as a joint project by the Digital Equipment Corporation
Systems Research Center and the Olivetti Research Center.  Paul Rovner made
many contributions as a founding member of the design committee.  The language
specification was written by Lucille Glassman and Greg Nelson, under the
watchful supervision of the whole committee.

Maurice Wilkes had the inspiration that sparked the project.

Our technical starting point was Modula-2+, which was designed by Paul Rovner,
Roy Levin, John Wick, Andrew Birrell, Butler Lampson, and Garret Swart.  We
made good use of the ruthlessly complete description of Modula-2+ in
Mary-Claire van Leunen's \emph{Modula-2+ User's Manual}.  The ideas in the
``+'' part of Modula-2+ were mostly derived from the Mesa and Cedar languages
developed at Xerox PARC.

Niklaus Wirth designed Modula-2, the starting point of our starting point.  He
also reviewed the evolving design and made many valuable suggestions---not one
of which was a suggested addition.  Indeed, he inspired us with the courage to
pull out a number of deep-rooted weeds.

SRC Modula-3 was implemented by Bill Kalsow and Eric Muller.  Olivetti
Modula-3 was implemented by Mick Jordan, Trevor Morris, David Chase, Steve
Glassman, and Marion Sturtevant.

The language and book were greatly improved by the helpful feedback from Bob
Ayers, Andrew Black, Regis Crelier, Dan Craft, Hans Eberle, John Ellis, Stu
Feldman, Michel Gangnet, Lucille Glassman, David Goldberg, Stephen Harrison,
Sam Harbison, Jim Horning, Solange Karsenty, Mike Kupfer, Butler Lampson, Mark
Manasse, Tim Mann, Eliot Moss, Dick Orgass, Sharon Perl, Norman Ramsey, Lyle
Ramshaw, Eric Roberts, Peter Robinson, Ed Satterthwaite, Jorge Stolfi, Garret
Swart, Chuck Thacker, and Ken Zadeck.

We are grateful for the support of Digital Equipment Corporation in general,
and Bob Taylor and Sam Fuller in particular.

\subsection*{1. Introduction}

\begin{quote}
  \emph{He that will not apply new remedies must expect new evils: for time is
    the greatest innovator, and if time of course alter things to the worse,
    and wisdom and counsel shall not alter them to the better, what shall be
    the end? ---Francis Bacon}
\end{quote}

\subsubsection*{1.1 History}

On November 6th, 1986, Maurice Wilkes wrote to Niklaus Wirth proposing that
the Modula-2+ language be revised and standardized as a successor to Modula-2.
Wirth gave this project his blessing, and the Modula-3 committee was born.

At the first meeting, the committee unanimously agreed to be true to the
spirit of Modula-2 by selecting simple, safe, proven features rather than
experimenting with our own untried ideas.  We found that unanimity was harder
to achieve when we got to the details.

Modula-3 supports interfaces, objects, generics, lightweight threads of
control, the isolation of unsafe code, garbage collection, exceptions, and
subtyping.  Some of the more problematical features of Modula-2 have been
removed, like variant records and the built-in unsigned numeric data type.
Modula-3 is substantially simpler than other languages with comparable power.

Modula-3 is closely based on Modula-2+, which was designed at the Digital
Equipment Corporation Systems Research Center and used to build the Topaz
system [McJones89, Rovner86].  The Modula-3 design was a joint project by
Digital and Olivetti.  The language definition was published in August 1988,
and immediately followed by implementation efforts at both companies.  In
January 1989, the committee revised the language to reflect the experiences of
these implementation teams.  A few final revisions were made for the
publication of this book.

SRC Modula-3 is distributed by the DEC Systems Research Center under a liberal
license.  The distribution includes a compiler for Modula-3, the Modula-3
Abstract Syntax Tree toolkit developed at Olivetti, and a runtime system with
configuration files for DEC, IBM, HP, and Sun workstations.

\subsubsection*{1.2 Perspective}

Most systems programming today is done in the BCPL family of languages, which
includes B, Bliss, and C.  The beauty of these languages is the modest cost
with which they were able to take a great leap forward from assembly language.
To fully appreciate them, you must consider the engineering constraints of
machines in the 1960s.  What language designed in the 1980s has a compiler
that fits into four thousand 18-bit words, like Ken Thompson's B compiler for
the PDP-7? The most successful of these languages was C, which by the early
1970s had almost completely displaced assembly language in the Unix system.

The BCPL-like languages are easy to implement efficiently for the same reason
they are attractive to skeptical assembly language programmers: they present a
programming model that is close to the target machine.  Pointers are
identified with arrays, and address arithmetic is ubiquitous.  Unfortunately,
this low-level programming model is inherently dangerous.  Many errors are as
disastrous as they would be in machine language.  The type system is scanty,
and reveals enough quirks of the target machine that even experienced and
disciplined programmers sometimes write unportable code simply by accident.
The most modern language in this family, C++, has enriched C by adding
objects; but it has also given up C's best virtue---simplicity---without
relieving C's worst drawback---its low-level programming model.

At the other extreme are languages like Lisp, ML, Smalltalk, and CLU, whose
programming models originate from mathematics.  Lisp is the hybrid of the
lambda calculus and the theory of a pairing function; ML stems from
polymorphic type theory; Smalltalk from a theory of objects and inheritance;
CLU from a theory of abstract data types.  These languages have beautiful
programming models, but they tend to be difficult to implement efficiently,
because the uniform treatment of values in the programming model invites a
runtime system in which values are uniformly represented by pointers.  If the
implementer doesn't take steps to avoid it, as simple a statement as
\verb|n := n + 1| could require an allocation, a method lookup, or both.  Good
implementations avoid most of the cost, and languages in this family have been
used successfully for systems programming.  But their general disposition
towards heap allocation rather than stack allocation remains, and they have
not become popular with systems programmers.  The runtime systems required to
make these languages efficient often isolate them in closed environments that
cannot accommodate programs written in other languages.  If you are a fan of
these languages you may find Modula-3 overly pragmatic; but read on anyway,
and give us a chance to show that pragmatic constraints do not exclude
attractive solutions.

Between the extremes of BCPL and Lisp is the Algol family of languages, whose
modern representatives include Pascal, Ada, Modula-2, and Modula-3.  These
languages have programming models that reflect the engineering constraints of
random-access machines but conceal the details of any particular machine.
They give up the beauty and mathematical symmetry of the Lisp family in order
to make efficient implementations possible without special tricks; they also
have strong type systems that avoid most of the dangerous and
machine-dependent features of the BCPL family.

In the 1960s, the trend in the Algol family was toward features for control
flow and data structuring.  In the 1970s, the trend was toward
information-hiding features like interfaces, opaque types, and generics.  More
recently, the trend in the Algol family has been to adopt a careful selection
of techniques from the Lisp and BCPL families.  This trend is demonstrated by
Modula-3, Oberon, and Cedar, to name three languages that have floated
portable implementations in the last few years.

Modula-3, Oberon, and Cedar all provide garbage collection, previously viewed
as a luxury available only in the closed runtime systems of the Lisp family.
But the world is starting to understand that garbage collection is the only
way to achieve an adequate level of safety, and that modern garbage collectors
can work in open runtime environments.

At the same time, these three languages allow a small set of unsafe,
machine-dependent operations of the sort usually associated with the BCPL
family.  In Modula-3, unsafe operations are allowed only in modules explicitly
labeled unsafe.  The combination of garbage collection with the explicit
isolation of unsafe features produces a language suitable for programming
entire systems from the highest-level applications down to the lowest-level
device drivers.

\subsubsection*{1.3 Overview}

[ This section discusses the organization of the entire book, \emph{Systems
  Programming with Modula-3}.  It doesn't seem worth including this material
in the on-line version. ]

\subsubsection*{1.4 Features}

The remainder of the introduction is an overview of the most important
features of Modula-3.

\paragraph{1.4.1 Interfaces.}

One of Modula-2's most successful features is the provision for explicit
interfaces between modules.  Interfaces are retained with essentially no
changes in Modula-3.  An interface to a module is a collection of declarations
that reveal the public parts of a module; things in the module that are not
declared in the interface are private.  A module \emph{imports} the interfaces
it depends on and \emph{exports} the interface (or, in Modula-3, the
interfaces) that it implements.

Interfaces make separate compilation type-safe; but it does them an injustice
to look at them in such a limited way.  Interfaces make it possible to think
about large systems without holding the whole system in your head at once.

Programmers who have never used Modula-style interfaces tend to underestimate
them, observing, for example, that anything that can be done with interfaces
can also be done with C-style include files.  This misses the point: many
things can be done with include files that cannot be done with interfaces.
For example, the meaning of an include file can be changed by defining macros
in the environment into which it is included.  Include files tempt programmers
into shortcuts across abstraction boundaries.  To keep large programs well
structured, you either need super-human will power, or proper language support
for interfaces.

\paragraph{1.4.2 Objects.}

The better we understand our programs, the bigger the building blocks we use
to structure them.  After the instruction came the statement, after the
statement came the procedure, after the procedure came the interface.  The
next step seems to be the \emph{abstract type}.

At the theoretical level, an abstract type is a type defined by the
specifications of its operations instead of by the representation of its data.
As realized in modern programming languages, a value of an abstract type is
represented by an ``object'' whose operations are implemented by a suite of
procedure values called the object's ``methods''.  A new object type can be
defined as a \emph{subtype} of an existing type, in which case the new type
has all the methods of the old type, and possibly new ones as well
(inheritance).  The new type can provide new implementations for the old
methods (overriding).

Objects were invented in the mid-sixties by the farsighted designers of Simula
[Birtwistle].  Objects in Modula-3 are very much like objects in Simula: they
are always references, they have both data fields and methods, and they have
single inheritance but not multiple inheritance.

Small examples are often used to get across the basic idea: truck as a subtype
of vehicle; rectangle as a subtype of polygon.  Modula-3 aims at larger
systems that illustrate how object types provide structure for large programs.
In Modula-3 the main design effort is concentrated into specifying the
properties of a single abstract type---a stream of characters, a window on the
screen.  Then dozens of interfaces and modules are coded that provide useful
subtypes of the central abstraction.  The abstract type provides the blueprint
for a whole family of interfaces and modules.  If the central abstraction is
well-designed then useful subtypes can be produced easily, and the original
design cost will be repaid with interest.

The combination of object types with Modula-2 opaque types produces something
new: the \emph{partially opaque type}, where some of an object's fields are
visible in a scope and others are hidden.  Because the committee had no
experience with partially opaque types, the first version of Modula-3
restricted them severely; but after a year of experience it was clear that
they were a good thing, and the language was revised to remove the
restrictions.

It is possible to use object-oriented techniques even in languages that were
not designed to support them, by explicitly allocating the data records and
method suites.  This approach works reasonably smoothly when there are no
subtypes; however it is through subtyping that object-oriented techniques
offer the most leverage.  The approach works badly when subtyping is needed:
either you allocate the data records for the different parts of the object
individually (which is expensive and notationally cumbersome) or you must rely
on unchecked type transfers, which is unsafe.  Whichever approach is taken,
the subtype relations are all in the programmer's head: only with an
object-oriented language is it possible to get object-oriented static
typechecking.

\paragraph{1.4.3 Generics.}

A generic module is a template in which some of the imported interfaces are
regarded as formal parameters, to be bound to actual interfaces when the
generic is instantiated.  For example, a generic hash table module could be
instantiated to produce tables of integers, tables of text strings, or tables
of any desired type.  The different generic instances are compiled
independently: the source program is reused, but the compiled code will
generally be different for different instances.

To keep Modula-3 generics simple, they are confined to the module level:
generic procedures and types do not exist in isolation, and generic parameters
must be entire interfaces.

In the same spirit of simplicity, there is no separate typechecking associated
with generics.  Implementations are expected to expand the generic and
typecheck the result.  The alternative would be to invent a polymorphic type
system flexible enough to express the constraints on the parameter interfaces
that are necessary in order for the generic body to compile.  This has been
achieved for ML and CLU, but it has not yet been achieved satisfactorily in
the Algol family of languages, where the type systems are less uniform.  (The
rules associated with Ada generics are too complicated for our taste.)

\paragraph{1.4.4 Threads.}

Dividing a computation into concurrent processes (or threads of control) is a
fundamental method of separating concerns.  For example, suppose you are
programming a terminal emulator with a blinking cursor: the most satisfactory
way to separate the cursor blinking code from the rest of the program is to
make it a separate thread.  Or suppose you are augmenting a program with a new
module that communicates over a buffered channel.  Without threads, the rest
of the program will be blocked whenever the new module blocks on its buffer,
and conversely, the new module will be unable to service the buffer whenever
any other part of the program blocks.  If this is unacceptable (as it almost
always is) there is no way to add the new module without finding and modifying
every statement of the program that might block.  These modifications destroy
the structure of the program by introducing undesirable dependencies between
what would otherwise be independent modules.

The provisions for threads in Modula-2 are weak, amounting essentially to
coroutines.  Hoare's monitors [Hoare] are a sounder basis for concurrent
programming.  Monitors were used in Mesa, where they worked well; except that
the requirement that a monitored data structure be an entire module was
irksome.  For example, it is often useful for a monitored data structure to be
an object instead of a module.  Mesa relaxed this requirement, made a slight
change in the details of the semantics of Hoare's \verb|Signal| primitive, and
introduced the \verb|Broadcast| primitive as a convenience [Lampson].  The Mesa
primitives were simplified in the Modula-2+ design, and the result was
successful enough to be incorporated with no substantial changes in Modula-3.

A threads package is a tool with a very sharp edge.  A common programming
error is to access a shared variable without obtaining the necessary lock.
This introduces a race condition that can lie dormant throughout testing and
strike after the program is shipped.  Theoretical work on process algebra has
raised hopes that the rendezvous model of concurrency may be safer than the
shared memory model, but the experience with Ada, which adopted the
rendezvous, lends at best equivocal support for this hope---Ada still allows
shared variables, and apparently they are widely used.

\paragraph{1.4.5 Safety.}

A language feature is \emph{unsafe} if its misuse can corrupt the runtime
system so that further execution of the program is not faithful to the
language semantics.  An example of an unsafe feature is array assignment
without bounds checking: if the index is out of bounds, then an arbitrary
location can be clobbered and the address space can become fatally corrupted.
An error in a safe program can cause the computation to abort with a run-time
error message or to give the wrong answer, but it can't cause the computation
to crash in a rubble of bits.

Safe programs can share the same address space, each safe from corruption by
errors in the others.  To get similar protection for unsafe programs requires
placing them in separate address spaces.  As large address spaces become
available, and programmers use them to produce tightly-coupled applications,
safety becomes more and more important.

Unfortunately, it is generally impossible to program the lowest levels of a
system with complete safety.  Neither the compiler nor the runtime system can
check the validity of a bus address for an I/O controller, nor can they limit
the ensuing havoc if it is invalid.  This presents the language designer with
a dilemma.  If he holds out for safety, then low level code will have to be
programmed in another language.  But if he adopts unsafe features, then his
safety guarantee becomes void everywhere.

The languages of the BCPL family are full of unsafe features; the languages of
the Lisp family generally have none (or none that are documented).  In this
area Modula-3 follows the lead of Cedar by adopting a small number of unsafe
features that are allowed only in modules explicitly labeled unsafe.  In a
safe module, the compiler prevents any errors that could corrupt the runtime
system; in an unsafe module, it is the programmer's responsibility to avoid
them.

\paragraph{1.4.6 Garbage collection.}

A classic unsafe runtime error is to free a data structure that is still
reachable by active references (or ``dangling pointers'').  The error plants a
time bomb that explodes later, when the storage is reused.  If on the other
hand the programmer fails to free records that have become unreachable, the
result will be a ``storage leak'' and the computation space will grow without
bound.  Problems due to dangling pointers and storage leaks tend to persist
long after other errors have been found and removed.  The only sure way to
avoid these problems is the automatic freeing of unreachable storage, or
garbage collection.

Modula-3 therefore provides ``traced references'', which are like Modula-2
pointers except that the storage they point to is kept in the ``traced heap''
where it will be freed automatically when all references to it are gone.

Another great benefit of garbage collection is that it simplifies interfaces.
Without garbage collection, an interface must specify whether the client or
the implementation has the responsibility for freeing each allocated
reference, and the conditions under which it is safe to do so.  This can swamp
the interface in complexity.  For example, Modula-3 supports text strings by a
simple required interface \verb|Text|, rather than with a built-in type.
Without garbage collection, this approach would not be nearly as attractive.

New refinements in garbage collection have appeared continually for more than
twenty years, but it is still difficult to implement efficiently.  For many
programs, the programming time saved by simplifying interfaces and eliminating
storage leaks and dangling pointers makes garbage collection a bargain, but
the lowest levels of a system may not be able to afford it.  For example, in
SRC's Topaz system, the part of the operating system that manages files and
heavy-weight processes relies on garbage collection, but the inner ``nub''
that implements virtual memory and thread context switching does not.
Essentially all Topaz application programs rely on garbage collection.

For programs that cannot afford garbage collection, Modula-3 provides a set of
reference types that are not traced by the garbage collector.  In most other
respects, traced and untraced references behave identically.

\paragraph{1.4.7 Exceptions.}

An exception is a control construct that exits many scopes at once.  Raising
an exception exits active scopes repeatedly until a handler is found for the
exception, and transfers control to the handler.  If there is no handler, the
computation terminates in some system-dependent way---for example, by entering
the debugger.

There are many arguments for and against exceptions, most of which revolve
around inconclusive issues of style and taste.  One argument in their favor
that has the weight of experience behind it is that exceptions are a good way
to handle any runtime error that is usually, but not necessarily, fatal.  If
exceptions are not available, each procedure that might encounter a runtime
error must return an additional code to the caller to identify whether an
error has occurred.  This can be clumsy, and has the practical drawback that
even careful programmers may inadvertently omit the test for the error return
code.  The frequency with which returned error codes are ignored has become
something of a standing joke in the Unix/C world.  Raising an exception is
more robust, since it stops the program unless there is an explicit handler
for it.

\paragraph{1.4.8 Type system.}

Like all languages in the Algol family, Modula-3 is strongly typed.  The basic
idea of strong typing is to partition the value space into types, restrict
variables to hold values of a single type, and restrict operations to apply to
operands of fixed types.  In actuality, strong typing is rarely so simple.
For example, each of the following complications is present in at least one
language of the Algol family: a variable of type \verb|[0..9]| may be safely
assigned to an \verb|INTEGER|, but not vice-versa (subtyping).  Operations
like absolute value may apply both to \verb|REAL|s and to \verb|INTEGER|s
instead of to a single type (overloading).  The types of literals (for
example, \verb|NIL|) can be ambiguous.  The type of an expression may be
determined by how it is used (target-typing).  Type mismatches may cause
automatic conversions instead of errors (as when a fractional real is rounded
upon assignment to an integer).

We adopted several principles in order to make Modula-3's type system as
uniform as possible.  First, there are no ambiguous types or target-typing:
the type of every expression is determined by its subexpressions, not by its
use.  Second, there are no automatic conversions.  In some cases the
\emph{representation} of a value changes when it is assigned (for example,
when assigning to a packed field of a record type) but the abstract value
itself is transferred without change.  Third, the rules for type compatibility
are defined in terms of a single subtype relation.  The subtype relation is
required for treating objects with inheritance, but it is also useful for
defining the type compatibility rules for conventional types.

\paragraph{1.4.9 Simplicity.}

In the early days of the Ada project, a general in the Ada Program Office
opined that ``obviously the Department of Defense is not interested in an
artificially simplified language such as Pascal''.  Modula-3 represents the
opposite point of view.  We used every artifice that we could find or invent
to make the language simple.

C.A.R.\ Hoare has suggested that as a rule of thumb a language is too
complicated if it can't be described precisely and readably in fifty pages.
The Modula-3 committee elevated this to a design principle: we gave ourselves
a ``complexity budget'' of fifty pages, and chose the most useful features
that we could accommodate within this budget.  In the end, we were over budget
by six lines plus the syntax equations.  This policy is a bit arbitrary, but
there are so many good ideas in programming language design that some kind of
arbitrary budget seems necessary to keep a language from getting too
complicated.

In retrospect, the features that made the cut were directed toward two main
goals.  Interfaces, objects, generics, and threads provide fundamental
patterns of abstraction that help to structure large programs.  The isolation
of unsafe code, garbage collection, and exceptions help make programs safer
and more robust.  Of the techniques that we used to keep the language
internally consistent, the most important was the definition of a clean type
system based on a subtype relation.  There is no special novelty in any one of
these features individually, but there is simplicity and power in their
combination.

\subsection*{2.1 Definitions}

A Modula-3 program specifies a computation that acts on a sequence of digital
components called \emph{locations}.  A \emph{variable} is a set of locations
that represents a mathematical value according to a convention determined by
the variable's \emph{type}.  If a value can be represented by some variable of
type \verb|T|, then we say that the value is a \emph{member} of \verb|T| and
\verb|T| \emph{contains} the value.

An \emph{identifier} is a symbol declared as a name for a variable, type,
procedure, etc.  The region of the program over which a declaration applies is
called the \emph{scope} of the declaration.  Scopes can be nested.  The
meaning of an identifier is determined by the smallest enclosing scope in
which the identifier is declared.

An \emph{expression} specifies a computation that produces a value or
variable.  Expressions that produce variables are called \emph{designators}.
A designator can denote either a variable or the value of that variable,
depending on the context.  Some designators are \emph{readonly}, which means
that they cannot be used in contexts that might change the value of the
variable.  A designator that is not readonly is called \emph{writable}.
Expressions whose values can be determined statically are called
\emph{constant expressions} ; they are never designators.

A \emph{static error} is an error that the implementation must detect before
program execution.  Violations of the language definition are static errors
unless they are explicitly classified as runtime errors.

A \emph{checked runtime error} is an error that the implementation must detect
and report at runtime.  The method for reporting such errors is
implementation-dependent.  (If the implementation maps them into exceptions,
then a program could handle these exceptions and continue.)

An \emph{unchecked runtime error} is an error that is not guaranteed to be
detected, and can cause the subsequent behavior of the computation to be
arbitrary.  Unchecked runtime errors can occur only in unsafe modules.

\subsection*{2.2 Types}

\begin{quote}
  \emph{I am the voice of today, the herald of tomorrow... I am the leaden
    army that conquers the world---I am TYPE.  ---Frederic William Goudy}
\end{quote}

Modula-3 uses structural equivalence, instead of the name equivalence of
Modula-2.  Two types are the same if their definitions become the same when
expanded; that is, when all constant expressions are replaced by their values
and all type names are replaced by their definitions.  In the case of recursive
types, the expansion is the infinite limit of the partial expansions.  A type
expression is generally allowed wherever a type is required.

A type is \emph{empty} if it contains no values.  For example, \verb|[1..0]|
is an empty type.  Empty types can be used to build non-empty types (for
example, \verb|SET OF [1..0]|, which is not empty because it contains the
empty set).  It is a static error to declare a variable of an empty type.

Every expression has a statically-determined type, which contains every value
that the expression can produce.  The type of a designator is the type of the
variable it produces.

Assignability and type compatibility are defined in terms of a single
syntactically specified subtype relation with the property that if \verb|T| is
a subtype of \verb|U|, then every member of \verb|T| is a member of \verb|U|.
The subtype relation is reflexive and transitive.

Every expression has a unique type, but a value can be a member of many types.
For example, the value \verb|6| is a member of both \verb|[0..9]| and
\verb|INTEGER|.  It would be ambiguous to talk about ``the type of a value''.
Thus the phrase ``type of \verb|x|'' means ``type of the expression
\verb|x|'', while ``\verb|x| is a member of \verb|T|'' means ``the value of
\verb|x| is a member of \verb|T|''.

However, there is one sense in which a value can be said to have a type: every
object or traced reference value includes a code for a type, called the
\emph{allocated type} of the reference value.  The allocated type is tested by
\verb|TYPECASE|.

\subsubsection*{2.2.1 Ordinal types}

There are three kinds of ordinal types: enumerations, subranges, and integers.

There are two integer types, which in order of increasing range 
are \verb|INTEGER| and \verb|LONGINT|.

An enumeration type is declared like this:
\begin{verbatim}
    TYPE T = {id_1, id_2, ..., id_n}
\end{verbatim}
where the \verb|id|'s are distinct identifiers.  The type \verb|T| is an
ordered set of \verb|n| values; the expression \verb|T.id_|$i$ denotes the
$i$'th value of the type in increasing order.  The empty enumeration
\verb|{ }| is allowed.

Integers and enumeration elements are collectively called \emph{ordinal
  values}.  The \emph{base type} of an ordinal value \verb|v| is
\verb|INTEGER| (or \verb|LONGINT|) if \verb|v| is an integer (or extended
range integer, respectively), otherwise it is the unique enumeration type
that contains \verb|v|.

A subrange type is declared like this:
\begin{verbatim}
    TYPE T = [Lo..Hi]
\end{verbatim}
where \verb|Lo| and \verb|Hi| are two ordinal values with the same base type,
called the base type of the subrange.  The values of \verb|T| are all the
values from \verb|Lo| to \verb|Hi| inclusive.  \verb|Lo| and \verb|Hi| must be
constant expressions.  If \verb|Lo| exceeds \verb|Hi|, the subrange is empty.

The operators \verb|ORD| and \verb|VAL| convert between enumerations and
integers.  The operators \verb|FIRST|, \verb|LAST|, and \verb|NUMBER| applied
to an ordinal type return the first element, last element, and number of
elements, respectively.

Here are the predeclared ordinal types:
\begin{quote}
  \begin{tabular}{ll}
    \verb|INTEGER|  & All integers represented by the implementation \\
    \verb|LONGINT|  & Extended range integers, with at least as much range as
                      \verb|INTEGER| \\
    \verb|CARDINAL| & Behaves just like the subrange \verb|[0..LAST(INTEGER)]|
    \\
    \verb|BOOLEAN|  & The enumeration \verb|{FALSE, TRUE}| \\
    \verb|CHAR|     & An enumeration containing at least 256 elements \\
    \verb|WIDECHAR| & An enumeration containing at least 65536 elements \\
  \end{tabular}
\end{quote}
The first 256 elements of type \verb|CHAR| represent characters in the
ISO-Latin-1 code, which is an extension of ASCII.  
The first 65536 elements of type \verb|WIDECHAR| represent characters in the
Unicode character code.  
The language does not specify the names of the elements of the \verb|CHAR| 
or \verb|WIDECHAR| enumerations.  The syntax
for character literals is specified in the section on literals.  \verb|FALSE|
and \verb|TRUE| are predeclared synonyms for \verb|BOOLEAN.FALSE| and
\verb|BOOLEAN.TRUE|.

Each distinct enumeration type introduces a new collection of values, but a
subrange type reuses the values from the underlying type.  For example:
\begin{verbatim}
    TYPE
       T1 = {A, B, C};
       T2 = {A, B, C};
       U1 = [T1.A..T1.C];
       U2 = [T1.A..T2.C];  (* sic *)
       V =   {A, B}
\end{verbatim}
\verb|T1| and \verb|T2| are the same type, since they have the same expanded
definition.  In particular, \verb|T1.C = T2.C| and therefore \verb|U1| and
\verb|U2| are also the same type.  But the types \verb|T1| and \verb|U1| are
distinct, although they contain the same values, because the expanded
definition of \verb|T1| is an enumeration while the expanded definition of
\verb|U1| is a subrange.  The type \verb|V| is a third type whose values
\verb|V.A| and \verb|V.B| are not related to the values \verb|T1.A| and
\verb|T1.B|.

\subsubsection*{2.2.2 Floating-point types}

There are three floating point types, which in order of increasing range and
precision are \verb|REAL|, \verb|LONGREAL|, and \verb|EXTENDED|.  The
properties of these types are specified by required interfaces.

\subsubsection*{2.2.3 Arrays}

An \emph{array} is an indexed collection of component variables, called the
\emph{elements} of the array.  The indexes are the values of an ordinal type,
called the \emph{index type} of the array.  The elements all have the same
size and the same type, called the \emph{element type} of the array.

There are two kinds of array types, \emph{fixed} and \emph{open}.  The length
of a fixed array is determined at compile time.  The length of an open array
type is determined at runtime, when it is allocated or bound.  The length
cannot be changed thereafter.

The \emph{shape} of a multi-dimensional array is the sequence of its lengths
in each dimension.  More precisely, the shape of an array is its length
followed by the shape of any of its elements; the shape of a non-array is the
empty sequence.

Arrays are assignable if they have the same element type and shape.  If either
the source or target of the assignment is an open array, a runtime shape check
is required.

A fixed array type declaration has the form:
\begin{verbatim}
    TYPE T = ARRAY Index OF Element
\end{verbatim}
where \verb|Index| is an ordinal type and \verb|Element| is any type other
than an open array type.  The values of type \verb|T| are arrays whose element
type is \verb|Element| and whose length is the number of elements of the type
\verb|Index|.  If \verb|Element| is an empty type, then so is \verb|T|.

If \verb|a| has type \verb|T|, then \verb|a[i]| designates the element of
\verb|a| whose position corresponds to the position of \verb|i| in
\verb|Index|.  For example, consider the declarations:
\begin{verbatim}
    VAR a := ARRAY [1..3] OF REAL {1.0, 2.0, 3.0};
    VAR b: ARRAY [-1..1] OF REAL := a;
\end{verbatim}
Now \verb|a = b| is \verb|TRUE|; yet \verb|a[1] = 1.0| while
\verb|b[1] = 3.0|.  The interpretation of indexes is determined by an array's
type, not its value; the assignment \verb|b := a| changes \verb|b|'s value,
not its type.  (This example uses variable initialization, and array
constructors.)

An expression of the form:
\begin{verbatim}
    ARRAY Index_1, ..., Index_n OF Element
\end{verbatim}
is shorthand for:
\begin{verbatim}
    ARRAY Index_1 OF ... OF ARRAY Index_n OF Element
\end{verbatim}
This shorthand is eliminated from the expanded type definition used to define
structural equivalence.  An expression of the form \verb|a[i_1, ..., i_n]| is
shorthand for \verb|a[i_1]...[i_n]|.

An open array type declaration has the form:
\begin{verbatim}
    TYPE T = ARRAY OF Element
\end{verbatim}
where \verb|Element| is any type.  The values of \verb|T| are arrays whose
element type is \verb|Element| and whose length is arbitrary.  The index type
of an open array is the integer subrange \verb|[0..n-1]|, where \verb|n| is
the length of the array.   If \verb|Element| is an empty type, then so 
is \verb|T|.

An open array type can be used only as the type of a formal parameter, the
referent of a reference type, the element type of another open array type, or
as the type in an array constructor.

Examples of array types:
\begin{verbatim}
    TYPE
       Transform = ARRAY [1..3], [1..3] OF REAL;
       Vector    = ARRAY OF REAL;
       SkipTable = ARRAY CHAR OF INTEGER
\end{verbatim}

\subsubsection*{2.2.4 Records}

A \emph{record} is a sequence of named variables, called the \emph{fields} of
the record.  Different fields can have different types.  The name and type of
each field is statically determined by the record's type.  The expression
\verb|r.f| designates the field named \verb|f| in the record \verb|r|.

A record type declaration has the form:
\begin{verbatim}
    TYPE T = RECORD FieldList END
\end{verbatim}
where \verb|FieldList| is a list of field declarations, each of which has the
form:
\begin{verbatim}
    fieldName: Type := default
\end{verbatim}
where \verb|fieldName| is an identifier, \verb|Type| is any non-empty type
other than an open array type, and \verb|default| is a constant expression.
The field names must be distinct.  A record is a member of \verb|T| if it has
fields with the given names and types, in the given order, and no other
fields.  Empty records are allowed.

The constant \verb|default| is a default value used when a record is
constructed or allocated.  Either ``\verb|:= default|'' or ``\verb|: Type|''
can be omitted, but not both.  If \verb|Type| is omitted, it is taken to be
the type of \verb|default|.  If both are present, the value of \verb|default|
must be a member of \verb|Type|.

When a series of fields shares the same type and default, any \verb|fieldName|
can be a list of identifiers separated by commas.  Such a list is shorthand
for a list in which the type and default are repeated for each identifier.
That is:
\begin{verbatim}
    f_1, ..., f_m: Type := default
\end{verbatim}
is shorthand for:
\begin{verbatim}
    f_1: Type := default; ...; f_m: Type := default
\end{verbatim}
This shorthand is eliminated from the expanded definition of the type.  The
default values are included.

Examples of record types:
\begin{verbatim}
    TYPE
      Time = RECORD
        seconds: INTEGER;
        milliseconds: [0..999]
      END;

      Alignment = {Left, Center, Right};

      TextWindowStyle = RECORD
         align          := Alignment.Center;
         font           := Font.Default;
         foreground     := Color.Black;
         background     := Color.White;
         margin, border := 2
      END
\end{verbatim}

\subsubsection*{2.2.5 Packed types}

A declaration of a packed type has the form:
\begin{verbatim}
    TYPE T = BITS n FOR Base
\end{verbatim}
where \verb|Base| is a type and \verb|n| is an integer-valued constant
expression.  The values of type \verb|T| are the same as the values of type
\verb|Base|, but variables of type \verb|T| that occur in records, objects, or
arrays will occupy exactly \verb|n| bits and be packed adjacent to the
preceding field or element.  For example, a variable of type
\begin{verbatim}
    ARRAY [0..255] OF BITS 1 FOR BOOLEAN
\end{verbatim}
is an array of 256 booleans, each of which occupies one bit of storage.

The values allowed for \verb|n| are implementation-dependent.  An illegal
value for \verb|n| is a static error.  The legality of a packed type can
depend on its context; for example, an implementation could prohibit packed
integers from spanning word boundaries.

\subsubsection*{2.2.6 Sets}

A \emph{set} is a collection of values taken from some ordinal type.  A set
type declaration has the form:
\begin{verbatim}
    TYPE T = SET OF Base
\end{verbatim}
where \verb|Base| is an ordinal type.  The values of \verb|T| are all sets
whose elements have type \verb|Base|.  For example, a variable whose type is
\verb|SET OF [0..1]| can assume the following values:
\begin{verbatim}
    {}     {0}     {1}     {0,1}
\end{verbatim}

Implementations are expected to use the same representation for a
\verb|SET OF T| as for an \texttt{ARRAY T OF BITS 1 FOR BOOLEAN}.  Hence,
programmers should expect \verb|SET OF [0..1023]| to be practical, but not
\verb|SET OF INTEGER|.

\subsubsection*{2.2.7 References}

A \emph{reference} value is either \verb|NIL| or the address of a variable,
called the referent.

A reference type is either \emph{traced} or \emph{untraced}.  When all traced
references to a piece of allocated storage are gone, the implementation
reclaims the storage.  Two reference types are of the same \emph{reference
  class} if they are both traced or both untraced.  A general type is traced
if it is a traced reference type, a record type any of whose field types is
traced, an array type whose element type is traced, or a packed type whose
underlying unpacked type is traced.

A declaration for a traced reference type has the form:
\begin{verbatim}
    TYPE T = REF Type
\end{verbatim}
where \verb|Type| is any type.  The values of \verb|T| are traced references
to variables of type \verb|Type|, which is called the \emph{referent type} of
\verb|T|.

A declaration for an untraced reference type has the form:
\begin{verbatim}
    TYPE T = UNTRACED REF Type
\end{verbatim}
where \verb|Type| is any untraced type.  (This restriction is lifted in unsafe
modules.) The values of \verb|T| are the untraced references to variables of
type \verb|Type|.

In both the traced and untraced cases, the keyword \verb|REF| can optionally
be preceded by ``\verb|BRANDED b|'' where \verb|b| is a text constant called
the \emph{brand}.  Brands distinguish types that would otherwise be the same;
they have no other semantic effect.  All brands in a program must be distinct.
If \verb|BRANDED| is present and \verb|b| is absent, the implementation
automatically supplies a unique value for \verb|b|.  Explicit brands are
useful for persistent data storage.

The following reference types are predeclared:
\begin{quote}
  \begin{tabular}{ll}
    \verb|REFANY|  & Contains all traced references \\
    \verb|ADDRESS| & Contains all untraced references \\
    \verb|NULL|    & Contains only \verb|NIL| \\
  \end{tabular}
\end{quote}
The \verb|TYPECASE| statement can be used to test the referent type of a
\verb|REFANY| or object, but there is no such test for an \verb|ADDRESS|.

Examples of reference types:
\begin{verbatim}
    TYPE TextLine = REF ARRAY OF CHAR;

    ControllerHandle = UNTRACED REF RECORD
      status: BITS 8 FOR [0..255];
      filler: BITS 12 FOR [0..0];
      pc: BITS 12 FOR [0..4095]
    END;

    T = BRANDED "ANSI-M3-040776" REF INTEGER;

    Apple  = BRANDED REF INTEGER;
    Orange = BRANDED REF INTEGER;
\end{verbatim}

\subsubsection*{2.2.8 Procedures}

A \emph{procedure} is either \verb|NIL| or a triple consisting of:
\begin{itemize}
\item the \emph{body}, which is a statement,
\item the \emph{signature}, which specifies the procedure's formal arguments,
  result type, and raises set (the set of exceptions that the procedure can
  raise),
\item the \emph{environment}, which is the scope with respect to which
  variable names in the body will be interpreted.
\end{itemize}

A procedure that returns a result is called a \emph{function procedure}; a
procedure that does not return a result is called a \emph{proper procedure}.
A \emph{top-level} procedure is a procedure declared in the outermost scope of
a module.  Any other procedure is a \emph{local} procedure.  A local procedure
can be passed as a parameter but not assigned, since in a stack implementation
a local procedure becomes invalid when the frame for the procedure containing
it is popped.

A \emph{procedure constant} is an identifier declared as a procedure.  (As
opposed to a procedure variable, which is a variable declared with a procedure
type.)

A procedure type declaration has the form:
\begin{verbatim}
    TYPE T = PROCEDURE sig
\end{verbatim}
where \verb|sig| is a signature specification, which has the form:
\begin{verbatim}
    (formal_1; ...; formal_n): R RAISES S
\end{verbatim}
where
\begin{itemize}
\item Each \verb|formal_|$i$ is a formal parameter declaration, as described
  below.
\item \verb|R| is the result type, which can be any type but an open array
  type.  The ``\verb|: R|'' can be omitted, making the signature that of a
  proper procedure.
\item \verb|S| is the raises set, which is either an explicit set of
  exceptions with the syntax \verb|{E_1, ..., E_n}|, or the symbol \verb|ANY|
  representing the set of all exceptions.  If ``\verb|RAISES S|'' is omitted,
  ``\verb|RAISES {}|'' is assumed.
\end{itemize}

A formal parameter declaration has the form
\begin{verbatim}
    Mode Name: Type := Default
\end{verbatim}
where
\begin{itemize}
\item \verb|Mode| is a parameter mode, which can be \verb|VALUE|, \verb|VAR|,
  or \verb|READONLY|.  If \verb|Mode| is omitted, it defaults to \verb|VALUE|.
\item \verb|Name| is an identifier that names the parameter.  The parameter
  names must be distinct.
\item \verb|Type| is the type of the parameter.
\item \verb|Default| is a constant expression, the default value for the
  parameter.  If \verb|Mode| is \verb|VAR|, ``\verb|:= Default|'' must be
  omitted, otherwise either ``\verb|:= Default|'' or ``\verb|: Type|'' can be
  omitted, but not both.  If \verb|Type| is omitted, it is taken to be the
  type of \verb|Default|. If both are present, the value of \verb|Default|
  must be a member of \verb|Type|.
\end{itemize}

When a series of parameters share the same mode, type, and default,
\verb|Name| can be a list of identifiers separated by commas.  Such a list is
shorthand for a list in which the mode, type, and default are repeated for
each identifier.  That is:
\begin{verbatim}
    Mode v_1, ..., v_n: Type := Default
\end{verbatim}
is shorthand for:
\begin{verbatim}
    Mode v_1: Type := Default; ...; Mode v_n: Type := Default
\end{verbatim}
This shorthand is eliminated from the expanded definition of the type.  The
default values are included.

A procedure value \verb|P| is a member of the type \verb|T| if it is
\verb|NIL| or its signature is \emph{covered} by the signature of \verb|T|,
where \verb|signature_1| covers \verb|signature_2| if:
\begin{itemize}
\item They have the same number of parameters, and corresponding parameters
  have the same type and mode.
\item  They have the same result type, or neither has a result type.
\item The raises set of \verb|signature_1| contains the raises set of
  \verb|signature_2|.
\end{itemize}

The parameter names and defaults affect the type of a procedure, but not its
value.  For example, consider the declarations:
\begin{verbatim}
    PROCEDURE P(txt: TEXT := "P") =
      BEGIN
        Wr.PutText(Stdio.stdout, txt)
      END P;

    VAR q: PROCEDURE(txt: TEXT := "Q") := P;
\end{verbatim}
Now \verb|P = q| is \verb|TRUE|, yet \verb|P()| prints ``\verb|P|'' and
\verb|q()| prints ``\verb|Q|''.  The interpretation of defaulted parameters is
determined by a procedure's type, not its value; the assignment \verb|q := P|
changes \verb|q|'s value, not its type.

Examples of procedure types:
\begin{verbatim}
    TYPE
      Integrand = PROCEDURE (x: REAL): REAL;
      Integrator = PROCEDURE(f: Integrand; lo, hi: REAL): REAL;

      TokenIterator = PROCEDURE(VAR t: Token) RAISES {TokenError};

      RenderProc = PROCEDURE(
        scene: REFANY;
        READONLY t: Transform := Identity)
\end{verbatim}

In a procedure type, \verb|RAISES| binds to the closest preceding
\verb|PROCEDURE|.  That is, the parentheses are required in:
\begin{verbatim}
    TYPE T = PROCEDURE (): (PROCEDURE ()) RAISES {}
\end{verbatim}

\subsubsection*{2.2.9 Objects}

An \emph{object} is either \verb|NIL| or a reference to a data record paired
with a method suite, which is a record of procedures that will accept the
object as a first argument.

An object type determines the types of a prefix of the fields of the data
record, as if ``\verb|OBJECT|'' were ``\verb|REF RECORD|''.  But in the case
of an object type, the data record can contain additional fields introduced by
subtypes of the object type.  Similarly, the object type determines a prefix
of the method suite, but the suite can contain additional methods introduced
by subtypes.

If \verb|o| is an object, then \verb|o.f| designates the data field named
\verb|f| in \verb|o|'s data record.  If \verb|m| is one of \verb|o|'s methods,
an invocation of the form \verb|o.m(...)| denotes an execution of \verb|o|'s
\verb|m| method.  An object's methods can be invoked, but not read or written.

If \verb|T| is an object type and \verb|m| is the name of one of \verb|T|'s
methods, then \verb|T.m| denotes \verb|T|'s \verb|m| method.  This notation
makes it convenient for a subtype method to invoke the corresponding method of
one of its supertypes.

A field or method in a subtype masks any field or method with the same name in
the supertype.  To access such a masked field, use \verb|NARROW| to view the
subtype variable as a member of the supertype, as illustrated below.

Object assignment is reference assignment.  Objects cannot be dereferenced,
since the static type of an object variable does not determine the type of its
data record.  To copy the data record of one object into another, the fields
must be assigned individually.

There are two predeclared object types:
\begin{quote}
  \begin{tabular}{ll}
    \verb|ROOT|          & The traced object type with no fields or methods \\
    \verb|UNTRACED ROOT| & The untraced object type with no fields or methods \\
  \end{tabular}
\end{quote}

The declaration of an object type has the form:
\begin{verbatim}
    TYPE T = ST OBJECT
               Fields
             METHODS
               Methods
             OVERRIDES
               Overrides
             END
\end{verbatim}
where \verb|ST| is an optional supertype, \verb|Fields| is a list of field
declarations, exactly as in a record type, \verb|Methods| is a list of
\emph{method declarations} and \verb|Overrides| is a list of \emph{method
  overrides}.  The fields of \verb|T| consist of the fields of \verb|ST|
followed by the fields declared in \verb|Fields|.  The methods of \verb|T|
consist of the methods of \verb|ST| modified by \verb|Overrides| and followed
by the methods declared in \verb|Methods|.  \verb|T| has the same reference
class as \verb|ST|.

The names introduced in \verb|Fields| and \verb|Methods| must be distinct from
one another and from the names overridden in \verb|Overrides|.  If \verb|ST|
is omitted, it defaults to \verb|ROOT|.  If \verb|ST| is untraced, then the
fields must not include traced types.  (This restriction is lifted in unsafe
modules.)  If \verb|ST| is declared as an opaque type, the declaration of
\verb|T| is legal only in scopes where \verb|ST|'s concrete type is known to
be an object type.

The keyword \verb|OBJECT| can optionally be preceded by ``\verb|BRANDED|'' or
by ``\verb|BRANDED b|'', where \verb|b| is a text constant.  The meaning is
the same as in non-object reference types.

A method declaration has the form:
\begin{verbatim}
    m sig := proc
\end{verbatim}
where \verb|m| is an identifier, \verb|sig| is a procedure signature, and
\verb|proc| is a top-level procedure constant.  It specifies that \verb|T|'s
\verb|m| method has signature \verb|sig| and value \verb|proc|.  If
``\verb|:= proc|'' is omitted, ``\verb|:= NIL|'' is assumed.  If \verb|proc|
is non-nil, its first parameter must have mode \verb|VALUE| and type some
supertype of \verb|T|, and dropping its first parameter must result in a
signature that is covered by \verb|sig|.

A method override has the form:
\begin{verbatim}
    m := proc
\end{verbatim}
where \verb|m| is the name of a method of the supertype \verb|ST| and
\verb|proc| is a top-level procedure constant.  It specifies that the \verb|m|
method for \verb|T| is \verb|proc|, rather than \verb|ST.m|.  If \verb|proc|
is non-nil, its first parameter must have mode \verb|VALUE| and type some
supertype of \verb|T|, and dropping its first parameter must result in a
signature that is covered by the signature of \verb|ST|'s \verb|m| method.

\textbf{Examples.}  Consider the following declarations:
\begin{verbatim}
    TYPE
      A  = OBJECT a: INTEGER; METHODS p() END;
      AB = A OBJECT b: INTEGER END;

    PROCEDURE Pa(self: A) = ... ;
    PROCEDURE Pab(self: AB) = ... ;
\end{verbatim}
The procedures \verb|Pa| and \verb|Pab| are candidate values for the \verb|p|
methods of objects of types \verb|A| and \verb|AB.| For example:
\begin{verbatim}
    TYPE T1 = AB OBJECT OVERRIDES p := Pab END
\end{verbatim}
declares a type with an \verb|AB| data record and a \verb|p| method that
expects an \verb|AB|.  \verb|T1| is a valid subtype of \verb|AB|.  Similarly,
\begin{verbatim}
    TYPE T2 = A OBJECT OVERRIDES p := Pa END
\end{verbatim}
declares a type with an \verb|A| data record and a method that expects an
\verb|A|.  \verb|T2| is a valid subtype of \verb|A|.  A more interesting
example is:
\begin{verbatim}
    TYPE T3 = AB OBJECT OVERRIDES p := Pa END
\end{verbatim}
which declares a type with an \verb|AB| data record and a \verb|p| method that
expects an \verb|A|.  Since every \verb|AB| is an \verb|A|, the method is not
too choosy for the objects in which it will be placed.  \verb|T3| is a valid
subtype of \verb|AB|.  In contrast,
\begin{verbatim}
    TYPE T4 = A OBJECT OVERRIDES p := Pab END
\end{verbatim}
attempts to declare a type with an \verb|A| data record and a method that
expects an \verb|AB|; since not every \verb|A| is an \verb|AB|, the method is
too choosy for the objects in which it would be placed.  The declaration of
\verb|T4| is a static error.

The following example illustrates the difference between declaring a new
method and overriding an existing method.  After the declarations
\begin{verbatim}
    TYPE
      A = OBJECT METHODS m() := P END;
      B = A OBJECT OVERRIDES m := Q END;
      C = A OBJECT METHODS m() := Q END;

    VAR
      a := NEW(A); b := NEW(B); c := NEW(C);
\end{verbatim}
we have that
\begin{verbatim}
    a.m()  activates  P(a)
    b.m()  activates  Q(b)
    c.m()  activates  Q(c)
\end{verbatim}
So far there is no difference between overriding and extending.  But
\verb|c|'s method suite has two methods, while \verb|b|'s has only one, as can
be revealed if \verb|b| and \verb|c| are viewed as members of type \verb|A|:
\begin{quote}
  \begin{tabular}{l}
    \verb|NARROW(b, A).m()|   activates  \verb|Q(b)| \\
    \verb|NARROW(c, A).m()|   activates  \verb|P(c)| \\
  \end{tabular}
\end{quote}
Here \verb|NARROW| is used to view a variable of a subtype as a value of its
supertype.  It is more often used for the opposite purpose, when it requires a
runtime check.

The last example uses object subtyping to define reusable queues.  First the
interface:
\begin{verbatim}
    TYPE
      Queue = RECORD head, tail: QueueElem END;
      QueueElem = OBJECT link: QueueElem END;

    PROCEDURE Insert (VAR q: Queue; x: QueueElem);
    PROCEDURE Delete (VAR q: Queue): QueueElem;
    PROCEDURE Clear  (VAR q: Queue);
\end{verbatim}

Then an example client:
\begin{verbatim}
    TYPE
      IntQueueElem = QueueElem OBJECT val: INTEGER END;
    VAR
      q: Queue;
      x: IntQueueElem;
      ...
      Clear(q);
      x := NEW(IntQueueElem, val := 6);
      Insert(q, x);
      ...
      x := Delete(q)
\end{verbatim}

Passing \verb|x| to \verb|Insert| is safe, since every \verb|IntQueueElem| is
a \verb|QueueElem|.  Assigning the result of \verb|Delete| to \verb|x| cannot
be guaranteed valid at compile-time, since other subtypes of \verb|QueueElem|
can be inserted into \verb|q|, but the assignment will produce a checked
runtime error if the source value is not a member of the target type.  Thus
\verb|IntQueueElem| bears the same relation to \verb|QueueElem| as
\verb|[0..9]| bears to \verb|INTEGER|.

\subsubsection*{2.2.10 Subtyping rules}

We write \verb|T <: U| to indicate that \verb|T| is a subtype of \verb|U| and
\verb|U| is a supertype of \verb|T|.

If \verb|T <: U|, then every value of type \verb|T| is also a value of type
\verb|U|.  The converse does not hold: for example, a record or array type
with packed fields contains the same values as the corresponding type with
unpacked fields, but there is no subtype relation between them.  This section
presents the rules that define the subtyping relation.

For ordinal types \verb|T| and \verb|U,| we have \verb|T <: U| if they have
the same base type and every member of \verb|T| is a member of \verb|U|.  That
is, subtyping on ordinal types reflects the subset relation on the value sets.

For array types,
\begin{quote}
\begin{verbatim}
   (ARRAY OF)^m  ARRAY J_1 OF ... ARRAY J_n OF
      ARRAY K_1 OF ... ARRAY K_p OF T
<: (ARRAY OF)^m  (ARRAY OF)^n
      ARRAY I_1 OF ... ARRAY I_p OF T
\end{verbatim}
  if \verb|NUMBER(I_|$i$\verb|) = NUMBER(K_|$i$\verb|)|
  for $i = 1, ..., \verb|p|$.
\end{quote}
That is, an array type \verb|A| is a subtype of an array type \verb|B| if they
have the same ultimate element type, the same number of dimensions, and, for
each dimension, either both are open (as in the first \verb|m| dimensions
above), or \verb|A| is fixed and \verb|B| is open (as in the next \verb|n|
dimensions above), or they are both fixed and have the same size (as in the
last \verb|p| dimensions above).

\begin{verbatim}
    NULL <: REF T <: REFANY
    NULL <: UNTRACED REF T <: ADDRESS
\end{verbatim}
That is, \verb|REFANY| and \verb|ADDRESS| contain all traced and untraced
references, respectively, and \verb|NIL| is a member of every reference type.
These rules also apply to branded types.

\begin{quote}
  \verb|NULL <: PROCEDURE(A): R RAISES S| for any \verb|A|, \verb|R|, and
  \verb|S|.
\end{quote}
That is, \verb|NIL| is a member of every procedure type.

\begin{quote}
\begin{verbatim}
PROCEDURE(A): Q RAISES E  <:  PROCEDURE(B): R RAISES F
\end{verbatim}
  if signature ``\verb|(B): R RAISES F|'' covers signature
  ``\verb|(A): Q RAISES E|''.
\end{quote}
That is, for procedure types, \verb|T <: U| if they are the same except for
parameter names, defaults, and raises sets, and the raises set for \verb|T| is
contained in the raises set for \verb|U|.

\begin{verbatim}
    ROOT <: REFANY
    UNTRACED ROOT <: ADDRESS
    NULL <: T OBJECT ... END <: T
\end{verbatim}
That is, every object is a reference, \verb|NIL| is a member of every object
type, and every subtype is included in its supertype.  The third rule also
applies to branded types.

\begin{quote}
  \verb|BITS n FOR T <: T| and \verb|T <: BITS n FOR T|
\end{quote}
That is, \verb|BITS FOR T| has the same values as \verb|T|.

\begin{quote}
  \verb|T <: T| for all \verb|T| \\
  \verb|T <: U| and \verb|U <: V| implies \verb|T <: V| for all \verb|T|,
  \verb|U|, \verb|V|.
\end{quote}
That is, \verb|<:| is reflexive and transitive.

Note that \verb|T <: U| and \verb|U <: T| does not imply that \verb|T| and
\verb|U| are the same, since the subtype relation is unaffected by parameter
names, default values, and packing.

For example, consider:
\begin{verbatim}
    TYPE
      T = [0..255];
      U = BITS 8 FOR [0..255];
      AT = ARRAY OF T;
      AU = ARRAY OF U;
\end{verbatim}
The types \verb|T| and \verb|U| are subtypes of one another but are not the
same.  The types \verb|AT| and \verb|AU| are unrelated by the subtype
relation.

\subsubsection*{2.2.11 Predeclared opaque types}

The language predeclares the two types:
\begin{verbatim}
    TEXT  <: REFANY
    MUTEX <: ROOT
\end{verbatim}
which represent text strings and mutual exclusion semaphores, respectively.
These are opaque types.  Their properties are specified in the required
interfaces \verb|Text| and \verb|Thread|.

\subsection*{2.3 Statements}

\begin{quote}
  \emph{Look into any carpenter's tool-bag and see how many different hammers,
    chisels, planes and screw-drivers he keeps there---not for ostentation or
    luxury, but for different sorts of jobs.  ---Robert Graves and Alan Hodge}
\end{quote}

Executing a statement produces a computation that can halt (normal outcome),
raise an exception, cause a checked runtime error, or loop forever.  If the
outcome is an exception, it can optionally be paired with an argument.

We define the semantics of \verb|EXIT| and \verb|RETURN| with exceptions
called the \emph{exit-exception} and the \emph{return-exception}.  The
exit-exception takes no argument; the return-exception takes an argument of
arbitrary type.  Programs cannot name these exceptions explicitly.

Implementations should speed up normal outcomes at the expense of exceptions
(except for the return-exception and exit-exception).  Expending a thousand
instructions per exception raised to save one instruction per procedure call
would be reasonable.

If an expression is evaluated as part of the execution of a statement, and the
evaluation raises an exception, then the exception becomes the outcome of the
statement.

The empty statement is a no-op.  In this report, empty statements are written
\verb|(*skip*)|.

\subsubsection*{2.3.1 Assignment}

To specify the typechecking of assignment statements we need to define
``assignable'', which is a relation between types and types, between
expressions and variables, and between expressions and types.

A type \verb|T| is \emph{assignable} to a type \verb|U| if:
\begin{itemize}
\item \verb|T <: U|, or
\item \verb|U <: T| and \verb|T| is an array or a reference type other than
  \verb|ADDRESS| (This restriction is lifted in unsafe modules.), or
\item \verb|T| and \verb|U| are ordinal types with at least one member in
  common.
\end{itemize}

An expression \verb|e| is \emph{assignable} to a variable \verb|v| if:
\begin{itemize}
\item the type of \verb|e| is assignable to the type of \verb|v|, and
\item the value of \verb|e| is a member of the type of \verb|v|, is not a
  local procedure, and if it is an array, then it has the same shape as
  \verb|v|.
\end{itemize}

The first point can be checked statically; the others generally require
runtime checks.  Since there is no way to determine statically whether the
value of a procedure parameter is local or global, assigning a local procedure
is a runtime rather than a static error.

An expression e is \emph{assignable} to a type \verb|T| if e is assignable to
some variable of type \verb|T|.  (If \verb|T| is not an open array type, this
is the same as saying that \verb|e| is assignable to any variable of type
\verb|T|.)

An assignment statement has the form:
\begin{verbatim}
    v := e
\end{verbatim}
where \verb|v| is a writable designator and \verb|e| is an expression
assignable to the variable designated by \verb|v|.  The statement sets
\verb|v| to the value of \verb|e|.  The order of evaluation of \verb|v| and
\verb|e| is undefined, but \verb|e| will be evaluated before \verb|v| is
updated.  In particular, if \verb|v| and \verb|e| are overlapping subarrays,
the assignment is performed in such a way that no element is used as a target
before it is used as a source.

Examples of assignments:
\begin{verbatim}
    VAR
      x: REFANY;
      a: REF INTEGER;
      b: REF BOOLEAN;

    a := b;  (* static error *)
    x := a;  (* no possible error *)
    a := x   (* possible checked runtime error *)
\end{verbatim}

The same comments would apply if \verb|x| had an ordinal type with
non-overlapping subranges \verb|a| and \verb|b|, or if \verb|x| had an object
type and \verb|a| and \verb|b| had incompatible subtypes.  The type
\verb|ADDRESS| is treated differently from other reference types, since a
runtime check cannot be performed on the assignment of raw addresses.  For
example:
\begin{verbatim}
    VAR
      x: ADDRESS;
      a: UNTRACED REF INTEGER;
      b: UNTRACED REF BOOLEAN;

    a := b;  (* static error *)
    x := a;  (* no possible error *)
    a := x   (* static error in safe modules *)
\end{verbatim}

\subsubsection*{2.3.2 Procedure call}

A procedure call has the form:
\begin{verbatim}
    P(Bindings)
\end{verbatim}
where \verb|P| is a procedure-valued expression and \verb|Bindings| is a list
of \emph{keyword} or \emph{positional} bindings.  A keyword binding has the
form \verb|name := actual|, where \verb|actual| is an expression and
\verb|name| is an identifier.  A positional binding has the form
\verb|actual|, where \verb|actual| is an expression.  When keyword and
positional bindings are mixed in a call, the positional bindings must precede
the keyword bindings.  If the list of bindings is empty, the parentheses are
still required.

The list of bindings is rewritten to fit the signature of \verb|P|'s type as
follows: First, each positional binding \verb|actual| is converted and added
to the list of keyword bindings by supplying the name of the $i$'th formal
parameter, where \verb|actual| is the i'th binding in \verb|Bindings|.
Second, for each parameter that has a default and is not bound after the first
step, the binding \verb|name := default| is added to the list of bindings,
where \verb|name| is the name of the parameter and \verb|default| is its
default value.  The rewritten list of bindings must bind only formal
parameters and must bind each formal parameter exactly once.  For example,
suppose that the type of \verb|P| is
\begin{verbatim}
    PROCEDURE(ch: CHAR; n: INTEGER := 0)
\end{verbatim}
Then the following calls are all equivalent:
\begin{verbatim}
    P('a', 0)
    P('a')
    P(ch := 'a')
    P(n := 0, ch := 'a')
    P('a', n := 0)
\end{verbatim}
The call \verb|P()| is illegal, since it doesn't bind \verb|ch|.  The call
\verb|P(n := 0, 'a')| is illegal, since it has a keyword parameter before a
positional parameter.

For a \verb|READONLY| or \verb|VALUE| parameter, the actual can be any
expression assignable to the type of the formal (except that the prohibition
against assigning local procedures is relaxed).  For a \verb|VAR| parameter,
the actual must be a writable designator whose type is the same as that of the
formal, or, in case of a \verb|VAR| array parameter, assignable to that of the
formal (see the section on designators).

A \verb|VAR| formal is bound to the variable designated by the corresponding
actual; that is, it is aliased.  A \verb|VALUE| formal is bound to a variable
with an unused location and initialized to the value of the corresponding
actual.  A \verb|READONLY| formal is treated as a \verb|VAR| formal if the
actual is a designator and the type of the actual is the same as the type of
the formal (or an array type that is assignable to the type of the formal);
otherwise it is treated as a \verb|VALUE| formal.

Implementations are allowed to forbid \verb|VAR| or \verb|READONLY| parameters
of packed types.

To execute the call, the procedure \verb|P| and its arguments are evaluated,
the formal parameters are bound, and the body of the procedure is executed.
The order of evaluation of \verb|P| and its actual arguments is undefined.  It
is a checked runtime error to call an undefined or \verb|NIL| procedure.

It is a checked runtime error for a procedure to raise an exception not
included in its raises set (If an implementation maps this runtime error into
an exception, the exception is implicitly included in all RAISES clauses.) or
for a function procedure to fail to return a result.

A procedure call is a statement only if the procedure is proper.  To call a
function procedure and discard its result, use \verb|EVAL|.

A procedure call can also have the form:
\begin{verbatim}
    o.m(Bindings)
\end{verbatim}
where \verb|o| is an object and \verb|m| names one of \verb|o|'s methods.
This is equivalent to:
\begin{quote}
  (\verb|o|'s \verb|m| method)\verb|(o, Bindings)|
\end{quote}

\subsubsection*{2.3.3 Eval}

An \verb|EVAL| statement has the form:
\begin{verbatim}
    EVAL e
\end{verbatim}
where \verb|e| is an expression.  The effect is to evaluate \verb|e| and
ignore the result.  For example:
\begin{verbatim}
    EVAL Thread.Fork(p)
\end{verbatim}

\subsubsection*{2.3.4 Block statement}

A block statement has the form:
\begin{verbatim}
    Decls BEGIN S END
\end{verbatim}
where \verb|Decls| is a sequence of declarations and \verb|S| is a statement.
The block introduces the constants, types, variables, and procedures declared
in \verb|Decls| and then executes \verb|S|.  The scope of the declared names
is the block.

\subsubsection*{2.3.5 Sequential composition}

A statement of the form:
\begin{verbatim}
    S_1; S_2
\end{verbatim}
executes \verb|S_1|, and then if the outcome is normal, executes \verb|S_2|.
If the outcome of \verb|S_1| is an exception, \verb|S_2| is ignored.

Some programmers use the semicolon as a statement terminator, some as a
statement separator.  Similarly, some use the vertical bar in case statements
as a case initiator, some as a separator.  Modula-3 allows both styles.  This
report uses both operators as separators.

\subsubsection*{2.3.6 Raise}

A \verb|RAISE| statement without an argument has the form:
\begin{verbatim}
    RAISE e
\end{verbatim}
where \verb|e| is an exception that takes no argument.  The outcome of the
statement is the exception \verb|e|.  A \verb|RAISE| statement with an
argument has the form:
\begin{verbatim}
    RAISE e(x)
\end{verbatim}
where \verb|e| is an exception that takes an argument and \verb|x| is an
expression assignable to \verb|e|'s argument type.  The outcome is the
exception \verb|e| paired with the argument \verb|x|.

\subsubsection*{2.3.7 Try Except}

A \verb|TRY|-\verb|EXCEPT| statement has the form:
\begin{verbatim}
    TRY
      Body
    EXCEPT
      id_1 (v_1) => Handler_1
    | ...
    | id_n (v_n) => Handler_n
    ELSE Handler_0
    END
\end{verbatim}
where \verb|Body| and each \verb|Handler| are statements, each \verb|id| names
an exception, and each \verb|v_|$i$ is an identifier.  The
``\verb|ELSE Handler_0|'' and each ``\verb|(v_|$i$\verb|)|'' are optional.
It is a static error for an exception to be named more than once in the list
of \verb|id|'s.

The statement executes \verb|Body|.  If the outcome is normal, the except
clause is ignored.  If \verb|Body| raises any listed exception \verb|id_|$i$,
then \verb|Handler_|$i$ is executed.  If \verb|Body| raises any other
exception and ``\verb|ELSE Handler_0|'' is present, then it is executed.  In
either case, the outcome of the \verb|TRY| statement is the outcome of the
selected handler.  If \verb|Body| raises an unlisted exception and
``\verb|ELSE Handler_0|'' is absent, then the outcome of the \verb|TRY|
statement is the exception raised by \verb|Body|.

Each \verb|(v_|$i$\verb|)| declares a variable whose type is the argument type
of the exception \verb|id_|$i$ and whose scope is \verb|Handler_|$i$.  When an
exception \verb|id_|$i$ paired with an argument \verb|x| is handled,
\verb|v_|$i$ is initialized to \verb|x| before \verb|Handler_|$i$ is executed.
It is a static error to include \verb|(v_|$i$\verb|)| if exception
\verb|id_|$i$ does not take an argument.

If \verb|(v_|$i$\verb|)| is absent, then \verb|id_|$i$ can be a list of
exceptions separated by commas, as shorthand for a list in which the rest of
the handler is repeated for each exception.  That is:
\begin{verbatim}
    id_1, ..., id_n => Handler
\end{verbatim}
is shorthand for:
\begin{verbatim}
    id_1 => Handler | ... | id_n => Handler
\end{verbatim}

It is a checked runtime error to raise an exception outside the dynamic scope
of a handler for that exception.  A ``\verb|TRY EXCEPT ELSE|'' counts as a
handler for all exceptions.

\subsubsection*{2.3.8 Try Finally}

A statement of the form:
\begin{verbatim}
    TRY S_1 FINALLY S_2 END
\end{verbatim}
executes statement \verb|S_1| and then statement \verb|S_2|.  If the outcome
of \verb|S_1| is normal, the \verb|TRY| statement is equivalent to
\verb|S_1; S_2|.  If the outcome of \verb|S_1| is an exception and the outcome
of \verb|S_2| is normal, the exception from \verb|S_1| is re-raised after
\verb|S_2| is executed.  If both outcomes are exceptions, the outcome of the
\verb|TRY| is the exception from \verb|S_2|.

\subsubsection*{2.3.9 Loop}

A statement of the form:
\begin{verbatim}
    LOOP S END
\end{verbatim}
repeatedly executes \verb|S| until it raises the exit-exception.  Informally
it is like:
\begin{verbatim}
    TRY S; S; S; ... EXCEPT  exit-exception  => (*skip*)  END
\end{verbatim}

\subsubsection*{2.3.10 Exit}

The statement
\begin{verbatim}
    EXIT
\end{verbatim}
raises the exit-exception.  An \verb|EXIT| statement must be textually
enclosed by a \verb|LOOP|, \verb|WHILE|, \verb|REPEAT|, or \verb|FOR|
statement.

We define \verb|EXIT| and \verb|RETURN| in terms of exceptions in order to
specify their interaction with the exception handling statements.  As a
pathological example, consider the following code, which is an elaborate
infinite loop:
\begin{verbatim}
    LOOP
      TRY
        TRY EXIT FINALLY RAISE E END
      EXCEPT
        E => (*skip*)
      END
    END
\end{verbatim}

\subsubsection*{2.3.11 Return}

A \verb|RETURN| statement for a proper procedure has the form:
\begin{verbatim}
    RETURN
\end{verbatim}
The statement raises the return-exception without an argument.  It is allowed
only in the body of a proper procedure.

A \verb|RETURN| statement for a function procedure has the form:
\begin{verbatim}
    RETURN Expr
\end{verbatim}
where \verb|Expr| is an expression assignable to the result type of the
procedure.  The statement raises the return-exception with the argument
\verb|Expr|.  It is allowed only in the body of a function procedure.

Failure to return a value from a function procedure is a checked runtime
error.

The effect of raising the return exception is to terminate the current
procedure activation.  To be precise, a call on a proper procedure with body
\verb|B| is equivalent (after binding the arguments) to:
\begin{verbatim}
    TRY B EXCEPT return-exception => (*skip*) END
\end{verbatim}
A call on a function procedure with body \verb|B| is equivalent to:
\begin{verbatim}
    TRY
      B;  (error: no returned value)
    EXCEPT
      return-exception (v) => (the result becomes v)
    END
\end{verbatim}

\subsubsection*{2.3.12 If}

An \verb|IF| statement has the form:
\begin{verbatim}
    IF    B_1 THEN S_1
    ELSIF B_2 THEN S_2
      ...
    ELSIF B_n THEN S_n
    ELSE S_0
    END
\end{verbatim}
where the \verb|B|'s are boolean expressions and the \verb|S|'s are
statements.  The ``\verb|ELSE S_0|'' and each ``\verb|ELSIF| \verb|B_|$i$
\verb|THEN| \verb|S_|$i$'' are optional.

The statement evaluates the \verb|B|'s in order until some \verb|B_|$i$
evaluates to \verb|TRUE|, and then executes \verb|S_|$i$.  If none of the
expressions evaluates to \verb|TRUE| and ``\verb|ELSE S_0|'' is present,
\verb|S_0| is executed.  If none of the expressions evaluates to \verb|TRUE|
and ``\verb|ELSE S_0|'' is absent, the statement is a no-op (except for any
side-effects of the \verb|B|'s).

\subsubsection*{2.3.13 While}

If \verb|B| is an expression of type \verb|BOOLEAN| and \verb|S| is a statement:
\begin{verbatim}
    WHILE B DO S END
\end{verbatim}
is shorthand for:
\begin{verbatim}
    LOOP IF B THEN S ELSE EXIT END END
\end{verbatim}

\subsubsection*{2.3.14 Repeat}

If \verb|B| is an expression of type \verb|BOOLEAN| and \verb|S| is a
statement:
\begin{verbatim}
    REPEAT S UNTIL B
\end{verbatim}
is shorthand for:
\begin{verbatim}
    LOOP S; IF B THEN EXIT END END
\end{verbatim}

\subsubsection*{2.3.15 With}

A \verb|WITH| statement has the form:
\begin{verbatim}
    WITH id = e DO S END
\end{verbatim}
where \verb|id| is an identifier, \verb|e| an expression, and \verb|S| a
statement.  The statement declares \verb|id| with scope \verb|S| as an alias
for the variable \verb|e| or as a readonly name for the value \verb|e|.  The
expression \verb|e| is evaluated once, at entry to the \verb|WITH| statement.

The statement is like the procedure call \verb|P(e)|, where \verb|P| is
declared as:
\begin{verbatim}
    PROCEDURE P(mode id: type of e) = BEGIN S END P;
\end{verbatim}
If \verb|e| is a writable designator, mode is \verb|VAR|; otherwise, mode is
\verb|READONLY|.  The only difference between the \verb|WITH| statement and
the call \verb|P(e)| is that free variables, \verb|RETURN|s, and \verb|EXIT|s
that occur in the \verb|WITH| statement are interpreted in the context of the
\verb|WITH| statement, not in the context of \verb|P| (see the section on
designators).

A single \verb|WITH| can contain multiple bindings, which are evaluated
sequentially.  That is:
\begin{verbatim}
    WITH id_1 = e_1, id_2 = e_2, ...
\end{verbatim}
is equivalent to:
\begin{verbatim}
    WITH id_1 = e_1 DO
      WITH id_2 = e_2 DO ...
\end{verbatim}

\subsubsection*{2.3.16 For}

A \verb|FOR| statement has the form:
\begin{verbatim}
    FOR id := first TO last BY step DO S END
\end{verbatim}
where \verb|id| is an identifier, \verb|first| and \verb|last| are ordinal
expressions with the same base type, \verb|step| is an integer-valued
expression, and \verb|S| is a statement.  ``\verb|BY step|'' is optional; if
omitted, \verb|step| defaults to \verb|1|.

The identifier \verb|id| denotes a readonly variable whose scope is \verb|S|
and whose type is the common base type of \verb|first| and \verb|last|.

If \verb|id| is an integer, the statement steps \verb|id| through the values
\verb|first|, \verb|first+step|, \verb|first+2*step|, ..., stopping when the
value of \verb|id| passes \verb|last|.  \verb|S| executes once for each value;
if the sequence of values is empty, \verb|S| never executes.  The expressions
\verb|first|, \verb|last|, and \verb|step| are evaluated once, before the loop
is entered.  If \verb|step| is negative, the loop iterates downward.

The case in which \verb|id| is an element of an enumeration is similar.  In
either case, the semantics are defined precisely by the following rewriting,
in which \verb|T| is the type of \verb|id| and in which \verb|i|, \verb|done|,
and \verb|delta| stand for variables that do not occur in the \verb|FOR|
statement:
\begin{verbatim}
    VAR
      i := ORD(first); done := ORD(last); delta := step;
    BEGIN
      IF delta >= 0 THEN
        WHILE i <= done DO
          WITH id = VAL(i, T) DO S END; INC(i, delta)
        END
      ELSE
        WHILE i >= done DO
          WITH id = VAL(i, T) DO S END; INC(i, delta)
        END
      END
    END
\end{verbatim}

If the upper bound of the loop is \verb|LAST(INTEGER)| or
\verb|LAST(LONGINT)|, it should be rewritten as a \verb|WHILE| loop to avoid
overflow.

\subsubsection*{2.3.17 Case}

A \verb|CASE| statement has the form:
\begin{verbatim}
    CASE Expr OF
      L_1 => S_1
    | ...
    | L_n => S_n
    ELSE S_0
    END
\end{verbatim}
where \verb|Expr| is an expression whose type is an ordinal type and each
\verb|L| is a list of constant expressions or ranges of constant expressions
denoted by ``\verb|e_1..e_2|'', which represent the values from \verb|e_1| to
\verb|e_2| inclusive.  If \verb|e_1| exceeds \verb|e_2|, the range is empty.
It is a static error if the sets represented by any two \verb|L|'s overlap or
if the value of any of the constant expressions is not a member of the type of
\verb|Expr|.  The ``\verb|ELSE S_0|'' is optional.

The statement evaluates \verb|Expr|.  If the resulting value is in any
\verb|L_|$i$, then \verb|S_|$i$ is executed.  If the value is in no
\verb|L_|$i$ and ``\verb|ELSE S_0|'' is present, then it is executed.  If the
value is in no \verb|L_|$i$ and ``\verb|ELSE S_0|'' is absent, a checked
runtime error occurs.

\subsubsection*{2.3.18 Typecase}

A \verb|TYPECASE| statement has the form:
\begin{verbatim}
    TYPECASE Expr OF
      T_1 (v_1) => S_1
    | ...
    | T_n (v_n) => S_n
    ELSE S_0
    END
\end{verbatim}
where \verb|Expr| is an expression whose type is a reference type, the
\verb|S|'s are statements, the \verb|T|'s are reference types, and the
\verb|v|'s are identifiers.  It is a static error if \verb|Expr| has type
\verb|ADDRESS| or if any \verb|T| is not a subtype of the type of \verb|Expr|.
The ``\verb|ELSE S_0|'' and each ``\verb|(v)|'' are optional.

The statement evaluates \verb|Expr|.  If the resulting reference value is a
member of any listed type \verb|T_|$i$, then \verb|S_|$i$ is executed, for the
minimum such $i$.  (Thus a \verb|NULL| case is useful only if it comes first.)
If the value is a member of no listed type and ``\verb|ELSE S_0|'' is present,
then it is executed.  If the value is a member of no listed type and
``\verb|ELSE S_0|'' is absent, a checked runtime error occurs.

Each \verb|(v_|$i$\verb|)| declares a variable whose type is \verb|T_|$i$ and
whose scope is \verb|S_|$i$.  If \verb|v_|$i$ is present, it is initialized to
the value of \verb|Expr| before \verb|S_|$i$ is executed.

If \verb|(v_|$i$\verb|)| is absent, then \verb|T_|$i$ can be a list of type
expressions separated by commas, as shorthand for a list in which the rest of
the branch is repeated for each type expression.  That is:
\begin{verbatim}
    T_1, ..., T_n => S
\end{verbatim}
is shorthand for:
\begin{verbatim}
    T_1 => S | ... | T_n => S
\end{verbatim}

For example:
\begin{verbatim}
    PROCEDURE ToText(r: REFANY): TEXT =
      (* Assume r = NIL or r^ is a BOOLEAN or INTEGER. *)
      BEGIN
        TYPECASE r OF
          NULL => RETURN "NIL"
        | REF BOOLEAN (rb) => RETURN Fmt.Bool(rb^)
        | REF INTEGER (ri) => RETURN Fmt.Int(ri^)
        END
      END ToText;
\end{verbatim}

\subsubsection*{2.3.19 Lock}

A \verb|LOCK| statement has the form:
\begin{verbatim}
    LOCK mu DO S END
\end{verbatim}
where \verb|S| is a statement and \verb|mu| is an expression.  It is
equivalent to:
\begin{verbatim}
    VAR m := mu; BEGIN
      Thread.Acquire(m);
      TRY S FINALLY Thread.Release(m) END
    END
\end{verbatim}
where \verb|m| stands for a variable that does not occur in \verb|S|.

\subsubsection*{2.3.20 Inc and Dec}

\verb|INC| and \verb|DEC| statements have the form:
\begin{verbatim}
    INC(v, n)
    DEC(v, n)
\end{verbatim}
where \verb|v| designates a variable of an ordinal type and \verb|n| is an
optional integer-valued argument.  If omitted, \verb|n| defaults to \verb|1|.
The statements increment and decrement \verb|v| by \verb|n|, respectively.
The statements are equivalent to:
\begin{verbatim}
    WITH x = v DO x := VAL(ORD(x) + n, T) END
    WITH x = v DO x := VAL(ORD(x) - n, T) END
\end{verbatim}
where \verb|T| is the type of \verb|v| and \verb|x| stands for a variable that
does not appear in \verb|n|.  As a consequence, the statements check for range
errors.

In unsafe modules, \verb|INC| and \verb|DEC| are extended to \verb|ADDRESS|.

\subsection*{2.4 Declarations}

\begin{quote}
  \emph{There are two basic methods of declaring high or low before the
    showdown in all High-Low Poker games.  They are (1) simultaneous
    declarations, and (2) consecutive declarations... It is a sad but true
    fact that the consecutive method spoils the game.  ---John Scarne's Guide
    to Modern Poker}
\end{quote}

A declaration introduces a name for a constant, type, variable, exception, or
procedure.  The scope of the name is the block containing the declaration.  A
block has the form:
\begin{verbatim}
    Decls BEGIN S END
\end{verbatim}
where \verb|Decls| is a sequence of declarations and \verb|S| is a statement,
the executable part of the block.  A block can appear as a statement or as the
body of a module or procedure.  The declarations of a block can introduce a
name at most once, though a name can be redeclared in nested blocks, and a
procedure declared in an interface can be redeclared in a module exporting the
interface.  The order of declarations in a block does not matter, except to
determine the order of initialization of variables.

\subsubsection*{2.4.1 Types}

If \verb|T| is an identifier and \verb|U| a type (or type expression, since a
type expression is allowed wherever a type is required), then:
\begin{verbatim}
    TYPE T = U
\end{verbatim}
declares \verb|T| to be the type \verb|U|.

\subsubsection*{2.4.2 Constants}

If \verb|id| is an identifier, \verb|T| a type, and \verb|C| a constant
expression, then:
\begin{verbatim}
    CONST id: T = C
\end{verbatim}
declares \verb|id| as a constant with the type \verb|T| and the value of
\verb|C|.  The ``\verb|: T|'' can be omitted, in which case the type of
\verb|id| is the type of \verb|C|.  If \verb|T| is present it must contain
\verb|C|.

\subsubsection*{2.4.3 Variables}

If \verb|id| is an identifier, \verb|T| a non-empty type other than an open
array type, and \verb|E| an expression, then:
\begin{verbatim}
    VAR id: T := E
\end{verbatim}
declares \verb|id| as a variable of type \verb|T| whose initial value is the
value of \verb|E|.  Either ``\verb|:= E|'' or ``\verb|: T|'' can be omitted,
but not both.  If \verb|T| is omitted, it is taken to be the type of \verb|E|.
If \verb|E| is omitted, the initial value is an arbitrary value of type
\verb|T|.  If both are present, \verb|E| must be assignable to \verb|T|.

The initial value is a shorthand that is equivalent to inserting the
assignment \verb|id := E| at the beginning of the executable part of the
block.  If several variables have initial values, their assignments are
inserted in the order they are declared.  For example:
\begin{verbatim}
    VAR i: [0..5] := j; j: [0..5] := i; BEGIN S END
\end{verbatim}
initializes \verb|i| and \verb|j| to the same arbitrary value in
\verb|[0..5]|; it is equivalent to:
\begin{verbatim}
    VAR i: [0..5]; j: [0..5]; BEGIN i := j; j := i; S END
\end{verbatim}

If a sequence of identifiers share the same type and initial value, \verb|id|
can be a list of identifiers separated by commas.  Such a list is shorthand
for a list in which the type and initial value are repeated for each
identifier.  That is:
\begin{verbatim}
    VAR v_1, ..., v_n: T := E
\end{verbatim}
is shorthand for:
\begin{verbatim}
    VAR v_1: T := E; ...; VAR v_n: T := E
\end{verbatim}
This means that \verb|E| is evaluated n times.

\subsubsection*{2.4.4 Procedures}

There are two forms of procedure declaration:
\begin{verbatim}
    PROCEDURE id sig = B id

    PROCEDURE id sig
\end{verbatim}
where \verb|id| is an identifier, \verb|sig| is a procedure signature, and
\verb|B| is a block.  In both cases, the type of \verb|id| is the procedure
type determined by \verb|sig|.  The first form is allowed only in modules; the
second form is allowed only in interfaces.

The first form declares \verb|id| as a procedure constant whose signature is
\verb|sig|, whose body is \verb|B|, and whose environment is the scope
containing the declaration.  The parameter names are treated as if they were
declared at the outer level of \verb|B|; the parameter types and default
values are evaluated in the scope containing the procedure declaration.  The
procedure name \verb|id| must be repeated after the \verb|END| that terminates
the body.

The second form declares \verb|id| to be a procedure constant whose signature
is \verb|sig|.  The procedure body is specified in a module exporting the
interface, by a declaration of the first form.

\subsubsection*{2.4.5 Exceptions}

If \verb|id| is an identifier and \verb|T| a type other than an open array
type, then:
\begin{verbatim}
    EXCEPTION id(T)
\end{verbatim}
declares \verb|id| as an exception with argument type \verb|T|.  If
``\verb|(T)|'' is omitted, the exception takes no argument.  An exception
declaration is allowed only in an interface or in the outermost scope of a
module.  All declared exceptions are distinct.

\subsubsection*{2.4.6 Opaque types}

An \emph{opaque type} is a name that denotes an unknown subtype of some given
reference type.  For example, an opaque subtype of \verb|REFANY| is an unknown
traced reference type; an opaque subtype of \verb|UNTRACED ROOT| is an unknown
untraced object type.  The actual type denoted by an opaque type name is
called its \emph{concrete type}.

Different scopes can reveal different information about an opaque type.  For
example, what is known in one scope only to be a subtype of \verb|REFANY|
could be known in another scope to be a subtype of \verb|ROOT|.

An opaque type declaration has the form:
\begin{verbatim}
    TYPE T <: U
\end{verbatim}
where \verb|T| is an identifier and \verb|U| an expression denoting a
reference type.  It introduces the name \verb|T| as an opaque type and reveals
that \verb|U| is a supertype of \verb|T|.  The concrete type of \verb|T| must
be revealed elsewhere in the program.

\subsubsection*{2.4.7 Revelations}

A \emph{revelation} introduces information about an opaque type into a scope.
Unlike other declarations, revelations introduce no new names.

There are two kinds of revelations, \emph{partial} and \emph{complete}.  A
program can contain any number of partial revelations for an opaque type; it
must contain exactly one complete revelation.

A partial revelation has the form:
\begin{verbatim}
    REVEAL T <: V
\end{verbatim}
where \verb|V| is a type expression (possibly just a name) and \verb|T| is an
identifier (possibly qualified) declared as an opaque type.  It reveals that
\verb|V| is a supertype of \verb|T|.

In any scope, the revealed supertypes of an opaque type must be linearly
ordered by the subtype relation.  That is, if it is revealed that
\verb|T <: U1| and \verb|T <: U2|, it must also be revealed either that
\verb|U1 <: U2| or that \verb|U2 <: U1|.

A complete revelation has the form:
\begin{verbatim}
    REVEAL T = V
\end{verbatim}
where \verb|V| is a type expression (not just a name) whose outermost type
constructor is a branded reference or object type and \verb|T| is an
identifier (possibly qualified) that has been declared as an opaque type.  The
revelation specifies that \verb|V| is the concrete type for \verb|T|.  It is a
static error if any type revealed in any scope as a supertype of \verb|T| is
not a supertype of \verb|V|.  Generally this error is detected at link time.

Distinct opaque types have distinct concrete types, since \verb|V| includes a
brand and all brands in a program are distinct.

A revelation is allowed only in an interface or in the outermost scope of a
module.  A revelation in an interface can be imported into any scope where it
is required, as illustrated by the stack example.

For example, consider:
\begin{verbatim}
    INTERFACE I; TYPE T <: ROOT; PROCEDURE P(x:T): T; END I.

    INTERFACE IClass; IMPORT I; REVEAL I.T <: MUTEX; END IClass.

    INTERFACE IRep; IMPORT I;
      REVEAL I.T = MUTEX BRANDED OBJECT count: INTEGER END;
    END IRep.
\end{verbatim}
An importer of \verb|I| sees \verb|I.T| as an opaque subtype of \verb|ROOT|,
and is limited to allocating objects of type \verb|I.T|, passing them to
\verb|I.P|, or declaring subtypes of \verb|I.T|.  An importer of \verb|IClass|
sees that every \verb|I.T| is a \verb|MUTEX|, and can therefore lock objects
of type \verb|I.T|.  Finally, an importer of \verb|IRep| sees the concrete
type, and can access the \verb|count| field.

\subsubsection*{2.4.8 Recursive declarations}

A constant, type, or procedure declaration \verb|N = E|, a variable
declaration \verb|N: E|, an exception declaration \verb|N(E)|, or a revelation
\verb|N = E| is \emph{recursive} if \verb|N| occurs in any partial expansion
of \verb|E|.  A variable declaration \verb|N := I| where the type is omitted
is recursive if \verb|N| occurs in any partial expansion of the type \verb|E|
of \verb|I|.  Such declarations are allowed if every occurrence of \verb|N| in
any partial expansion of \verb|E| is (1) within some occurrence of the type
constructor \verb|REF| or \verb|PROCEDURE|, (2) within a field or method type
of the type constructor \verb|OBJECT|, or (3) within a procedure body.

Examples of legal recursive declarations:
\begin{verbatim}
    TYPE
      List = REF RECORD x: REAL; link: List END;
      T = PROCEDURE(n: INTEGER; p: T);
      XList = X OBJECT link: XList END;
    CONST N = BYTESIZE(REF ARRAY [0..N] OF REAL);
    PROCEDURE P(b: BOOLEAN) = BEGIN IF b THEN P(NOT b) END END P;
    EXCEPTION E(PROCEDURE () RAISES {E});
    VAR v: REF ARRAY [0..BYTESIZE(v)] OF INTEGER;
\end{verbatim}

Examples of illegal recursive declarations:
\begin{verbatim}
    TYPE
      T = RECORD x: T END;
      U = OBJECT METHODS m() := U.m END;
    CONST N = N+1;
    REVEAL I.T = I.T BRANDED OBJECT END;
    VAR v := P(); PROCEDURE P(): ARRAY [0..LAST(v)] OF T;
\end{verbatim}

Examples of legal non-recursive declarations:
\begin{verbatim}
    VAR n := BITSIZE(n);
    REVEAL T <: T;
\end{verbatim}

\subsection*{2.5 Modules and interfaces}

\begin{quote}
  \emph{Art, it seems to me, should simplify.  That, indeed, is very nearly
    the whole of the higher artistic process; finding what conventions of form
    and what detail one can do without and yet preserve the spirit of the
    whole.  ---Willa Cather}
\end{quote}

A \emph{module} is like a block, except for the visibility of names.  An entity
is visible in a block if it is declared in the block or in some enclosing
block; an entity is visible in a module if it is declared in the module or in
an interface that is imported or exported by the module.

An \emph{interface} is a group of declarations.  Declarations in interfaces
are the same as in blocks, except that any variable initializations must be
constant, and procedure declarations must specify only the signature, not the
body.

A module \verb|X| \emph{exports} an interface \verb|I| to supply bodies for
one or more of the procedures declared in the interface.  A module or
interface \verb|X| \emph{imports} an interface \verb|I| to make the entities
declared in \verb|I| visible in \verb|X|.

A \emph{program} is a collection of modules and interfaces that contains every
interface imported or exported by any of its modules or interfaces, and in
which no procedure, module, or interface is multiply defined.  The effect of
executing a program is to execute the bodies of each of its modules.  The
order of execution of the modules is constrained by the initialization rule.

The module whose body is executed last is called the \emph{main module}.
Implementations are expected to provide a way to specify the main module, in
case the initialization rule does not determine it uniquely.  The recommended
rule is that the main module be the one that exports the interface
\verb|Main|, whose contents are implementation-dependent.

Program execution terminates when the body of the main module terminates, even
if concurrent threads of control are still executing.

The names of the modules and interfaces of a program are called \emph{global}
names.  The method for looking up global names---for example, by file system
search paths---is implementation-dependent.

\subsubsection*{2.5.1 Import statements}

There are two forms of import statements.  All imports of both forms are
interpreted simultaneously: their order doesn't matter.

The first form is
\begin{verbatim}
    IMPORT I AS J
\end{verbatim}
which imports the interface whose global name is \verb|I| and gives it the
local name \verb|J|.  The entities and revelations declared in \verb|I| become
accessible in the importing module or interface, but the entities and
revelations imported into \verb|I| do not.  To refer to the entity declared
with name \verb|N| in the interface \verb|I|, the importer must use the
\emph{qualified identifier} \verb|J.N|.

The statement \verb|IMPORT I| is short for \verb|IMPORT I AS I|.

The second form is
\begin{verbatim}
    FROM I IMPORT N
\end{verbatim}
which introduces \verb|N| as the local name for the entity declared as
\verb|N| in the interface \verb|I|.  A local binding for \verb|I| takes
precedence over a global binding.  For example,
\begin{verbatim}
    IMPORT I AS J, J AS I; FROM I IMPORT N
\end{verbatim}
simultaneously introduces local names \verb|J|, \verb|I|, and \verb|N| for the
entities whose global names are \verb|I|, \verb|J|, and \verb|J.N|,
respectively.

It is illegal to use the same local name twice:
\begin{verbatim}
    IMPORT J AS I, K AS I;
\end{verbatim}
is a static error, even if \verb|J| and \verb|K| are the same.

\subsubsection*{2.5.2 Interfaces}

An interface has the form:
\begin{verbatim}
    INTERFACE id;
      Imports;
      Decls
    END id.
\end{verbatim}
where \verb|id| is an identifier that names the interface, \verb|Imports| is a
sequence of import statements, and \verb|Decls| is a sequence of declarations
that contains no procedure bodies or non-constant variable initializations.
The names declared in \verb|Decls| and the visible imported names must be
distinct.  It is a static error for two or more interfaces to form an import
cycle.

\subsubsection*{2.5.3 Modules}

A module has the form:
\begin{verbatim}
    MODULE id EXPORTS Interfaces;
      Imports;
    Block id.
\end{verbatim}
where \verb|id| is an identifier that names the module, \verb|Interfaces| is a
list of distinct names of interfaces exported by the module, \verb|Imports| is
a list of import statements, and \verb|Block| is a block, the \emph{body} of
the module.  The name \verb|id| must be repeated after the \verb|END| that
terminates the body.  ``\verb|EXPORTS Interfaces|'' can be omitted, in which
case \verb|Interfaces| defaults to \verb|id|.

If module \verb|M| exports interface \verb|I|, then all declared names in
\verb|I| are visible without qualification in \verb|M|.  Any procedure
declared in \verb|I| can be redeclared in \verb|M|, with a body.  The
signature in \verb|M| must be covered by the signature in \verb|I|.  To
determine the interpretation of keyword bindings and parameter defaults in
calls to the procedure, the signature in \verb|M| is used within \verb|M|; the
signature in \verb|I| is used everywhere else.

Except for the redeclaration of exported procedures, the names declared at the
top level of \verb|Block|, the visible imported names, and the names declared
in the exported interfaces must be distinct.

For example, the following is illegal, since two names in exported interfaces
coincide:
\begin{verbatim}
    INTERFACE I;
      PROCEDURE X();  ...

    INTERFACE J;
      PROCEDURE X();  ...

    MODULE M EXPORTS I, J;
      PROCEDURE X() = ...;
\end{verbatim}

The following is also illegal, since the visible imported name \verb|X|
coincides with the top-level name \verb|X|:
\begin{verbatim}
    INTERFACE I;
      PROCEDURE X();  ...

    MODULE M EXPORTS I;
      FROM I IMPORT X;
      PROCEDURE X() = ...;
\end{verbatim}

But the following is legal, although peculiar:
\begin{verbatim}
    INTERFACE I;
      PROCEDURE X(...);  ...

    MODULE M EXPORTS I;
      IMPORT I;
      PROCEDURE X(...) = ...;
\end{verbatim}
since the only visible imported name is \verb|I|, and the coincidence between
\verb|X| as a top-level name and \verb|X| as a name in an exported interface
is allowed, assuming the interface signature covers the module signature.
Within \verb|M|, the interface declaration determines the signature of
\verb|I.X| and the module declaration determines the signature of \verb|X|.

\subsubsection*{2.5.4 Example module and interface}

Here is the canonical example of a public stack with hidden representation:
\begin{verbatim}
    INTERFACE Stack;
      TYPE T <: REFANY;
      PROCEDURE Create(): T;
      PROCEDURE Push(VAR s: T; x: REAL);
      PROCEDURE Pop(VAR s: T): REAL;
    END Stack.

    MODULE Stack;
      REVEAL T = BRANDED OBJECT item: REAL; link: T END;
      PROCEDURE Create(): T = BEGIN RETURN NIL END Create;

      PROCEDURE Push(VAR s: T; x: REAL) =
        BEGIN
          s := NEW(T, item := x, link := s)
        END Push;

      PROCEDURE Pop(VAR s: T): REAL =
        VAR res: REAL;
        BEGIN
          res := s.item; s := s.link; RETURN res
        END Pop;

    BEGIN
    END Stack.
\end{verbatim}

If the representation of stacks is required in more than one module, it should
be moved to a private interface, so that it can be imported wherever it is
required:
\begin{verbatim}
    INTERFACE Stack  (* ... as before ... *) END Stack.

    INTERFACE StackRep; IMPORT Stack;
      REVEAL Stack.T = BRANDED OBJECT item: REAL; link: Stack.T END
    END StackRep.

    MODULE Stack; IMPORT StackRep;
      (* Push, Pop, and Create as before *)
    BEGIN
    END Stack.
\end{verbatim}

\subsubsection*{2.5.5 Generics}

In a generic interface or module, some of the imported interface names are
treated as formal parameters, to be bound to actual interfaces when the
generic is instantiated.

A generic interface has the form
\begin{verbatim}
    GENERIC INTERFACE G(F_1, ..., F_n);
      Body
    END G.
\end{verbatim}
where \verb|G| is an identifier that names the generic interface,
\verb|F_1, ..., F_n| is a list of identifiers, called the formal imports of
\verb|G|, and \verb|Body| is a sequence of imports followed by a sequence of
declarations, exactly as in a non-generic interface.

An instance of \verb|G| has the form
\begin{verbatim}
    INTERFACE I = G(A_1, ..., A_n) END I.
\end{verbatim}
where \verb|I| is the name of the instance and \verb|A_1, ..., A_n| is a list
of actual interfaces to which the formal imports of \verb|G| are bound.  The
instance \verb|I| is equivalent to an ordinary interface defined as follows:
\begin{verbatim}
    INTERFACE I;
      IMPORT A_1 AS F_1, ..., A_n AS F_n;
      Body
    END I.
\end{verbatim}

A generic module has the form
\begin{verbatim}
    GENERIC MODULE G(F_1, ..., F_n);
      Body
    END G.
\end{verbatim}
where \verb|G| is an identifier that names the generic module,
\verb|F_1, ..., F_n| is a list of identifiers, called the formal imports of
\verb|G|, and \verb|Body| is a sequence of imports followed by a block,
exactly as in a non-generic module.

An instance of \verb|G| has the form
\begin{verbatim}
    MODULE I EXPORTS E = G(A_1, ..., A_n) END I.
\end{verbatim}
where \verb|I| is the name of the instance, \verb|E| is a list of interfaces
exported by \verb|I|, and \verb|A_1, ..., A_n| is a list of actual interfaces
to which the formal imports of \verb|G| are bound.  ``\verb|EXPORTS E|'' can
be omitted, in which case it defaults to ``\verb|EXPORTS I|''.  The instance
\verb|I| is equivalent to an ordinary module defined as follows:
\begin{verbatim}
    MODULE I EXPORTS E;
      IMPORT A_1 AS F_1, ..., A_n AS F_n;
      Body
    END I.
\end{verbatim}
Notice that the generic module itself has no exports; they are supplied only
when it is instantiated.

For example, here is a generic stack package:
\begin{verbatim}
    GENERIC INTERFACE Stack(Elem);
      (* where Elem.T is not an open array type. *)
      TYPE T <: REFANY;
      PROCEDURE Create(): T;
      PROCEDURE Push(VAR s: T; x: Elem.T);
      PROCEDURE Pop(VAR s: T): Elem.T;
    END Stack.

    GENERIC MODULE Stack(Elem);

      REVEAL
        T = BRANDED OBJECT  n: INTEGER;  a: REF ARRAY OF Elem.T  END;

      PROCEDURE Create(): T =
        BEGIN  RETURN NEW(T, n := 0, a := NIL)  END Create;

      PROCEDURE Push(VAR s: T; x: Elem.T) =
        BEGIN
          IF s.a = NIL THEN
            s.a := NEW(REF ARRAY OF Elem.T, 5)
          ELSIF s.n > LAST(s.a^) THEN
            WITH temp = NEW(REF ARRAY OF Elem.T, 2 * NUMBER(s.a^)) DO
              FOR i := 0 TO LAST(s.a^) DO temp[i] := s.a[i] END;
              s.a := temp
            END
          END;
          s.a[s.n] := x;
          INC(s.n)
        END Push;

      PROCEDURE Pop(VAR s: T): Elem.T =
        BEGIN  DEC(s.n);  RETURN s.a[s.n]  END Pop;

    BEGIN
    END Stack.
\end{verbatim}
To instantiate these generics to produce stacks of integers:
\begin{verbatim}
    INTERFACE Integer; TYPE T = INTEGER; END Integer.
    INTERFACE IntStack = Stack(Integer) END IntStack.
    MODULE IntStack = Stack(Integer) END IntStack.
\end{verbatim}
Implementations are not expected to share code between different instances of
a generic module, since this will not be possible in general.

Implementations are not required to typecheck uninstantiated generics, but
they must typecheck their instances.  For example, if one made the following
mistake:
\begin{verbatim}
    INTERFACE String; TYPE T = ARRAY OF CHAR; END String.
    INTERFACE StringStack = Stack(String) END StringStack.
    MODULE StringStack = Stack(String) END StringStack.
\end{verbatim}
everything would go well until the last line, when the compiler would attempt
to compile a version of \verb|Stack| in which the element type was an open
array.  It would then complain that the \verb|NEW| call in \verb|Push| does
not have enough parameters.

\subsubsection*{2.5.6 Initialization}

The order of execution of the modules in a program is constrained by the
following rule:

If module \verb|M| depends on module \verb|N| and \verb|N| does not depend on
\verb|M|, then \verb|N|'s body will be executed before \verb|M|'s body, where:
\begin{itemize}
\item A module \verb|M| \emph{depends on} a module \verb|N| if \verb|M| uses
  an interface that \verb|N| exports or if \verb|M| depends on a module that
  depends on \verb|N|.
\item A module \verb|M| \emph{uses} an interface \verb|I| if \verb|M| imports
  or exports \verb|I| or if \verb|M| uses an interface that (directly or
  indirectly) imports \verb|I|.
\end{itemize}

Except for this constraint, the order of execution is
implementation-dependent.

\subsubsection*{2.5.7 Safety}

The keyword \verb|UNSAFE| can precede the declaration of any interface or
module to indicate that it is \emph{unsafe}; that is, uses the unsafe features
of the language.  An interface or module not explicitly labeled \verb|UNSAFE|
is called \emph{safe}.

An interface is \emph{intrinsically safe} if there is no way to produce an
unchecked runtime error by using the interface in a safe module.  If all
modules that export a safe interface are safe, the compiler guarantees the
intrinsic safety of the interface.  If any of the modules that export a safe
interface are unsafe, it is the programmer, rather than the compiler, who
makes the guarantee.

It is a static error for a safe interface to import an unsafe one or for a
safe module to import or export an unsafe interface.

\subsection*{2.6 Expressions}

\begin{quote}
  \emph{The rules of logical syntax must follow of themselves, if we only
    know how every single sign signifies.  ---Ludwig Wittgenstein}
\end{quote}

An expression prescribes a computation that produces a value or variable.
Syntactically, an expression is either an operand, or an operation applied to
arguments, which are themselves expressions.  Operands are identifiers,
literals, or types.  An expression is evaluated by recursively evaluating its
arguments and performing the operation.  The order of argument evaluation is
undefined for all operations except \verb|AND| and \verb|OR|.

\subsubsection*{2.6.1 Conventions for describing operations}

To describe the argument and result types of operations, we use a notation
like procedure signatures.  But since most operations are too general to be
described by a Modula-3 procedure signature, we extend the notation in several
ways.

The argument to an operation can be required to have a type in a particular
class, such as an ordinal type, set type, etc.  In this case the formal
specifies a type class instead of a type.  For example:
\begin{verbatim}
    ORD (x: Ordinal): Integer
\end{verbatim}
The formal type \verb|Any| specifies an argument of any type.

A single operation name can be overloaded, which means that it denotes more
than one operation.  In this case, we write a separate signature for each of
the operations.  For example:
\begin{verbatim}
    ABS (x: Integer) : Integer
        (x: Float)   : Float
\end{verbatim}
The particular operation will be selected so that each actual argument type is
a subtype of the corresponding formal type or a member of the corresponding
formal type class.  This selection is always unambiguous. 

The argument to an operation can be an expression denoting a type.  In this
case, we write \verb|Type| as the argument type.  For example:
\begin{verbatim}
    BYTESIZE (T: Type): CARDINAL
\end{verbatim}
The result type of an operation can depend on its argument values (although
the result type can always be determined statically).  In this case, the
expression for the result type contains the appropriate arguments.  For
example:
\begin{verbatim}
    FIRST (T: FixedArrayType): IndexType(T)
\end{verbatim}
\verb|IndexType(T)| denotes the index type of the array type \verb|T| and
\verb|IndexType(a)| denotes the index type of the array \verb|a|.  The
definitions of \verb|ElemType(T)| and \verb|ElemType(a)| are similar.

\subsubsection*{2.6.2 Operation syntax}

The operators that have special syntax are classified and listed in order of
decreasing binding power in the following table:
\begin{quote}
  \begin{tabular}{ll}
    \verb|x.a|               &    infix dot \\
    \verb|f(x) a[i] T{x}|    &    applicative \verb|(|, \verb|[|, \verb|{| \\
    \verb|p^|                &    postfix \verb|^| \\
    \verb|+  -|              &    prefix arithmetics \\
    \verb|* / DIV MOD|       &    infix arithmetics \\
    \verb|+ - &|             &    infix arithmetics \\
    \verb|= # < <= >= > IN|  &    infix relations \\
    \verb|NOT|               &    prefix \verb|NOT| \\
    \verb|AND|               &    infix \verb|AND| \\
    \verb|OR|                &    infix \verb|OR| \\
  \end{tabular}
\end{quote}

All infix operators are left associative.  Parentheses can be used to override
the precedence rules.  Here are some examples of expressions together with
their fully parenthesized forms:
\begin{quote}
  \begin{tabular}{lll}
    \verb|M.F(x)| & \verb|(M.F)(x)| & dot before application \\
    \verb|Q(x)^| & \verb|(Q(x))^| & application before \verb|^| \\
    \verb|- p^| & \verb|- (p^)| & \verb|^| before prefix \verb|-| \\
    \verb|- a * b| & \verb|(- a) * b| & prefix \verb|-| before \verb|*| \\
    \verb|a * b - c| & \verb|(a * b) - c| & \verb|*| before infix \verb|-| \\
    \verb|x IN s - t| & \verb|x IN (s - t)| & infix \verb|-| before \verb|IN| \\
    \verb|NOT x IN s| & \verb|NOT (x IN s)| & \verb|IN| before \verb|NOT| \\
    \verb|NOT p AND q| & \verb|(NOT p) AND q| & \verb|NOT| before \verb|AND| \\
    \verb|A OR B AND C| & \verb|A OR (B AND C)| & \verb|AND| before \verb|OR| \\
  \end{tabular}
\end{quote}

Operators without special syntax are \emph{procedural}.  An application of a
procedural operator has the form \verb|op(args)|, where \verb|op| is the
operation and \verb|args| is the list of argument expressions.  For example,
\verb|MAX| and \verb|MIN| are procedural operators.

\subsubsection*{2.6.3 Designators}

An identifier is a \emph{writable designator} if it is declared as a variable,
is a \verb|VAR| or \verb|VALUE| parameter, is a local of a \verb|TYPECASE| or
\verb|TRY|-\verb|EXCEPT| statement, or is a \verb|WITH| local that is bound to a
writable designator.  An identifier is a \emph{readonly designator} if it is a
\verb|READONLY| parameter, a local of a \verb|FOR| statement, or a \verb|WITH|
local bound to a non-designator or readonly designator.

The only operations that produce designators are dereferencing, subscripting,
selection, and \verb|SUBARRAY|.  This section defines these operations and
specifies the conditions under which they produce designators.  In unsafe
modules, \verb|LOOPHOLE| can also produce a designator.

\begin{description}
\item \verb|r^| \\
  denotes the the referent of \verb|r|; this operation is called
  \emph{dereferencing}.  The expression \verb|r^| is always a writable
  designator.  It is a static error if the type of \verb|r| is \verb|REFANY|,
  \verb|ADDRESS|, \verb|NULL|, an object type, or an opaque type, and a
  checked runtime error if \verb|r| is \verb|NIL|.  The type of \verb|r^| is
  the referent type of \verb|r|.
\item \verb|a[i]| \\
  denotes the \verb|(i + 1 - FIRST(a))|-th element of the array \verb|a|.  The
  expression \verb|a[i]| is a designator if \verb|a| is, and is writable if
  \verb|a| is.  The expression \verb|i| must be assignable to the index type
  of \verb|a|.  The type of \verb|a[i]| is the element type of \verb|a|.

  An expression of the form \verb|a[i_1, ..., i_n]| is shorthand for
  \verb|a[i_1]...[i_n]|.  If \verb|a| is a reference to an array, then
  \verb|a[i]| is shorthand for \verb|a^[i]|.
\item \verb|r.f|, \verb|o.f|, \verb|I.x|, \verb|T.m|, \verb|E.id| \\
  If \verb|r| denotes a record, \verb|r.f| denotes its \verb|f| field.  In
  this case \verb|r.f| is a designator if \verb|r| is, and is writable if
  \verb|r| is.  The type of \verb|r.f| is the declared type of the field.

  If \verb|r| is a reference to a record, then \verb|r.f| is shorthand for
  \verb|r^.f|.

  If \verb|o| denotes an object and \verb|f| names a data field specified in
  the type of \verb|o|, then \verb|o.f| denotes that data field of \verb|o|.
  In this case \verb|o.f| is a writable designator whose type is the declared
  type of the field.

  If \verb|I| denotes an imported interface, then \verb|I.x| denotes the
  entity named \verb|x| in the interface \verb|I|.  In this case \verb|I.x| is
  a designator if \verb|x| is declared as a variable; such a designator is
  always writable.

  If \verb|T| is an object type and \verb|m| is the name of one of \verb|T|'s
  methods, then \verb|T.m| denotes the m method of type \verb|T|.  In this
  case \verb|T.m| is not a designator.  Its type is the procedure type whose
  first argument has mode \verb|VALUE| and type \verb|T|, and whose remaining
  arguments are determined by the method declaration for \verb|m| in \verb|T|.
  The name of the first argument is unspecified; thus in calls to \verb|T.m|,
  this argument must be given positionally, not by keyword.  \verb|T.m| is a
  procedure constant.

  If \verb|E| is an enumerated type, then \verb|E.id| denotes its value named
  \verb|id|.  In this case \verb|E.id| is not a designator.  The type of
  \verb|E.id| is \verb|E|.
\item \verb|SUBARRAY(a: Array; from, for: CARDINAL): ARRAY OF ElemType(a)| \\
  \verb|SUBARRAY| produces a subarray of \verb|a|.  It does not copy the
  array; it is a designator if \verb|a| is, and is writable if \verb|a| is.
  If \verb|a| is a multi-dimensional array, \verb|SUBARRAY| applies only to
  the top-level array.

  The operation returns the subarray that skips the first \verb|from| elements
  of \verb|a| and contains the next \verb|for| elements.  Note that if
  \verb|from| is zero, the subarray is a prefix of \verb|a|, whether the type
  of \verb|a| is zero-based or not.  It is a checked runtime error if
  \verb|from+for| exceeds \verb|NUMBER(a)|.

  Implementations may restrict or prohibit the \verb|SUBARRAY| operation for
  arrays with packed element types.
\end{description}

\subsubsection*{2.6.4 Numeric literals}

Numeric literals denote constant non-negative integers or reals.  The types of
these literals are \verb|INTEGER|, \verb|LONGINT|, \verb|REAL|,
\verb|LONGREAL|, and \verb|EXTENDED|.

A literal \verb|INTEGER| has the form \verb|base_digits|, where \verb|base| is
one of ``\verb|2|'', ``\verb|3|'', ..., ``\verb|16|'', and \verb|digits| is a
non-empty sequence of the decimal digits \verb|0| through \verb|9| plus the
hexadecimal digits \verb|A| through \verb|F|.  The ``\verb|base_|'' can be
omitted, in which case \verb|base| defaults to \verb|10|.  The digits are
interpreted in the given base.  Each digit must be less than \verb|base|.  For
example, \verb|16_FF| and \verb|255| are equivalent integer literals.

If no explicit base is present, the value of the literal must be at most
\verb|LAST(INTEGER)|.  If an explicit base is present, the value of the
literal must be less than \verb|2^Word.Size|, and its interpretation uses the
convention of the \verb|Word| interface.  For example, on a 32-bit two's
complement machine, \verb|16_FFFFFFFF| and \verb|-1| represent the same value.

A literal \verb|LONGINT| has the form \verb|integer L|, where \verb|integer|
has the same form as a literal \verb|INTEGER|.  If no explicit base is
present, the value of the literal must be at most \verb|LAST(LONGINT)|.  If an
explicit base is present, the value of the literal must be less than
\verb|2^Long.Size|, and its interpretation uses the convention of the
\verb|Long| interface.  For example, the \verb|LONGINT| having the value zero
would be written \verb|0L|.

A literal \verb|REAL| has the form \verb|decimal E exponent|, where
\verb|decimal| is a non-empty sequence of decimal digits followed by a decimal
point followed by a non-empty sequence of decimal digits, and \verb|exponent|
is a non-empty sequence of decimal digits optionally beginning with a \verb|+|
or \verb|-|.  The literal denotes \verb|decimal| times \verb|10^exponent|.  If
``\verb|E exponent|'' is omitted, \verb|exponent| defaults to \verb|0|.

\verb|LONGREAL| and \verb|EXTENDED| literals are like \verb|REAL| literals,
but instead of \verb|E| they use \verb|D| and \verb|X| respectively.

Case is not significant in any letter in a numeric literal.  
Embedded spaces are not allowed in a numeric literal.

For example, \verb|1.0| and \verb|0.5| are valid, \verb|1.| and \verb|.5| are
not; \verb|6.624E-27| is a \verb|REAL|, and \verb|3.1415926535d0| a
\verb|LONGREAL|.

\subsubsection*{2.6.5 Text and character literals}

A character literal is a pair of single quotes enclosing either a single
ISO-Latin-1 printing character (excluding single quote) or an escape sequence.
The type of a character literal is \verb|CHAR|.

A text literal is a pair of double quotes enclosing a sequence of ISO-Latin-1
printing characters (excluding double quote) and escape sequences.  The type
of a text literal is \verb|TEXT|.

Here are are the legal escape sequences and the characters they denote:
\begin{quote}
  \begin{tabular}{llll}
    \verb|\n| & newline (linefeed) & \verb|\f| & form feed \\
    \verb|\t| & tab                & \verb|\\| & backslash \\
    \verb|\r| & carriage return    & \verb|\"| & double quote \\
    \verb|\'| & single quote       & \verb|\nnn| & char with code \verb|8_nnn| \\
              &                    & \verb|\Xnn| & char with code \verb|16_nn| \\
  \end{tabular}
\end{quote}
A \verb|\| followed by exactly three octal digits specifies the character
whose code is that octal value.  
A \verb|\X| followed by exactly two hexadecimal digits specifies the character
whose code is that hexadecimal value.  
The hexadecimal digits are case-insensitive. 
The 'X' in a hexadecimal escape sequence is case-insensitive.  
A \verb|\| that is not a part of one of these
escape sequences is a static error.

A wide character literal has the form \verb|W charlit|, where \verb|charlit|
is like a character literal, except that an octal escape sequence
within must have exactly six octal digits, a hexadecimal escape sequence 
within must have exactly four hexadecimal digits. and the escape 
sequence \verb|\U| followed by exactly six hexadecimal digits is allowed and
specifies the Unicode character whose code point has that hexadecimal value.  
It is a static error if that value lies outside the Unicode code point range. 
The 'U' in a Unicode escape sequence is case-insensitive.  
The type of a wide character literal is \verb|WIDECHAR|.
The leading 'W' is case-insensitive. 

Similarly, a wide text literal has the form \verb|W textlit|, 
where \verb|textlit| is like a text literal, except any octal or hexadecimal
escape sequences within must have exactly six octal or four hexadecimal 
digits, respectively, and Unicode escape sequences are allowed.  
Unlike character literals, ordinary text literals and wide text literals 
both have the type \verb|TEXT|, differing only in the method of specifying 
the literal's value. 
The leading 'W' is case-insensitive. 

For example, \verb|'a'| and \verb|'\''| are valid character literals,
\verb|'''| is not; \verb|""| and \verb|"Don't\n"| are valid text literals,
\verb|"""| is not.

\subsubsection*{2.6.6 Nil}

The literal ``\verb|NIL|'' denotes the value \verb|NIL|.  Its type is
\verb|NULL|.

\subsubsection*{2.6.7 Function application}

A procedure call is an expression if the procedure returns a result.  The type
of the expression is the result type of the procedure.

\subsubsection*{2.6.8 Set, array, and record constructors}

A set constructor has the form:
\begin{verbatim}
    S{e_1, ..., e_n}
\end{verbatim}
where \verb|S| is a set type and the \verb|e|'s are expressions or ranges of
the form \verb|lo..hi|.  The constructor denotes a value of type \verb|S|
containing the listed values and the values in the listed ranges.  The
\verb|e|'s, \verb|lo|'s, and \verb|hi|'s must be assignable to the element
type of \verb|S|.

An array constructor has the form:
\begin{verbatim}
    A{e_1, ..., e_n}
\end{verbatim}
where \verb|A| is an array type and the \verb|e|'s are expressions.  The
constructor denotes a value of type \verb|A| containing the listed elements in
the listed order.  The \verb|e|'s must be assignable to the element type of
\verb|A|.  This means that if \verb|A| is a multi-dimensional array, the
\verb|e|'s must themselves be array-valued expressions.

If \verb|A| is a fixed array type and \verb|n| is at least \verb|1|, then
\verb|e_n| can be followed by ``\verb|, ..|'' to indicate that the value of
\verb|e_n| will be replicated as many times as necessary to fill out the
array.  It is a static error to provide too many or too few elements for a
fixed array type.

A record constructor has the form:
\begin{verbatim}
    R{Bindings}
\end{verbatim}
where \verb|R| is a record type and \verb|Bindings| is a list of keyword or
positional bindings, exactly as in a procedure call.  The list of bindings is
rewritten to fit the list of fields and defaults of \verb|R|, exactly as for a
procedure call; the record field names play the role of the procedure formal
parameters.  The expression denotes a value of type \verb|R| whose field
values are specified by the rewritten binding.

The rewritten binding must bind only field names and must bind each field name
exactly once.  Each expression in the binding must be assignable to the type
of the corresponding record field.

\subsubsection*{2.6.9 New}

An allocation operation has the form:
\begin{verbatim}
    NEW(T, ...)
\end{verbatim}
where \verb|T| is a reference type other than \verb|REFANY|, \verb|ADDRESS|,
or \verb|NULL|.  The operation returns the address of a newly-allocated
variable of \verb|T|'s referent type; or if \verb|T| is an object type, a
newly-allocated data record paired with a method suite.  The reference
returned by \verb|NEW| is distinct from all existing references.  The
allocated type of the new reference is \verb|T|.

It is a static error if \verb|T|'s referent type is empty.  If \verb|T| is
declared as an opaque type, \verb|NEW(T)| is legal only in scopes where
\verb|T|'s concrete type is known completely, or is known to be an object
type.

The initial state of the referent generally represents an arbitrary value of
its type.  If \verb|T| is an object type or a reference to a record or open
array then \verb|NEW| takes additional arguments to control the initial state
of the new variable.

If \verb|T| is a reference to an array with \verb|k| open dimensions, the
\verb|NEW| operation has the form:
\begin{verbatim}
    NEW(T, n_1, ..., n_k)
\end{verbatim}
where the \verb|n|'s are integer-valued expressions that specify the lengths
of the new array in its first \verb|k| dimensions.  The values in the array
will be arbitrary values of their type.

If \verb|T| is an object type or a reference to a record, the \verb|NEW|
operation has the form:
\begin{verbatim}
    NEW(T, Bindings)
\end{verbatim}
where \verb|Bindings| is a list of keyword bindings used to initialize the new
fields.  Positional bindings are not allowed.

Each binding \verb|f := v| initializes the field \verb|f| to the value
\verb|v|.  Fields for which no binding is supplied will be initialized to
their defaults if they have defaults; otherwise they will be initialized to
arbitrary values of their types.

The order of the field bindings makes no difference.

If \verb|T| is an object type then \verb|Bindings| can also include method
overrides of the form \verb|m := P|, where \verb|m| is a method of \verb|T|
and \verb|P| is a top-level procedure constant.  This is syntactic sugar for
the allocation of a subtype of \verb|T| that includes the given overrides, in
the given order.  For example, \verb|NEW(T, m := P)| is sugar for
\begin{verbatim}
    NEW(T OBJECT OVERRIDES m := P END).
\end{verbatim}

\subsubsection*{2.6.10 Arithmetic operations}

The basic arithmetic operations are built into the language; additional
operations are provided by the required floating-point interfaces.

To test or set the implementation's behavior for overflow, underflow,
rounding, and division by zero, see the required interface \verb|FloatMode|.
Modula-3 arithmetic was designed to support the IEEE floating-point standard,
but not to require it.

To perform arithmetic operations modulo the word size, programs should use the
routines in the required interface \verb|Word|.

Implementations must not rearrange the computation of expressions in a way
that could affect the result.  For example, \verb|(x+y)+z| generally cannot be
computed as \verb|x+(y+z)|, since addition is not associative either for
bounded integers or for floating-point values.

\begin{quote}
  \begin{tabbing}
    \=prefix  \= \verb|BYTESIZE|\= \kill
    \>prefix  \> \verb|+|       \> \verb|(x: Integer)    : Integer| \\
    \>        \>                \> \verb|(x: Float)      : Float| \\
    \>infix   \> \verb|+|       \> \verb|(x,y: Integer)  : Integer| \\
    \>        \>                \> \verb|(x,y: Float)    : Float| \\
    \>        \>                \> \verb|(x,y: Set)      : Set|
  \end{tabbing}
\end{quote}
As a prefix operator, \verb|+x| returns \verb|x|.  As an infix operator on
numeric arguments, \verb|+| denotes addition.  On sets, \verb|+| denotes set
union.  That is, \verb|e IN (x + y)| if and only if
\verb|(e IN x) OR (e IN y)|.  The types of \verb|x| and \verb|y| must be the
same, and the result is the same type as both.  In unsafe modules, \verb|+| is
extended to \verb|ADDRESS|.

\begin{quote}
  \begin{tabbing}
    \=prefix \= \verb|BYTESIZE| \= \kill
    \>prefix \> \verb|-|       \> \verb|(x: Integer)    : Integer| \\
    \>       \>                \> \verb|(x: Float)      : Float| \\
    \>infix  \> \verb|-|       \> \verb|(x,y: Integer)  : Integer| \\
    \>       \>                \> \verb|(x,y: Float)    : Float| \\
    \>       \>                \> \verb|(x,y: Set)      : Set|
  \end{tabbing}
\end{quote}
As a prefix operator, \verb|-x| is the negative of \verb|x|.  As an infix
operator on numeric arguments, \verb|-| denotes subtraction.  On sets,
\verb|-| denotes set difference.  That is, \verb|e IN (x - y)| if and only if
\verb|(e IN x) AND NOT (e IN y)|.  The types of \verb|x| and \verb|y| must be
the same, and the result is the same type as both.  In unsafe modules,
\verb|-| is extended to \verb|ADDRESS|.

\begin{quote}
  \begin{tabbing}
    \=prefix \= \verb|BYTESIZE| \= \kill
    \>infix  \> \verb|*|       \> \verb|(x,y: Integer)  : Integer| \\
    \>       \>                \> \verb|(x,y: Float)    : Float| \\
    \>       \>                \> \verb|(x,y: Set)      : Set|
  \end{tabbing}
\end{quote}
On numeric arguments, \verb|*| denotes multiplication.  On sets, \verb|*|
denotes intersection.  That is, \verb|e IN (x * y)| if and only if
\verb|(e IN x) AND (e IN y)|.  The types of \verb|x| and \verb|y| must be the
same, and the result is the same type as both.

\begin{quote}
  \begin{tabbing}
    \=prefix \= \verb|BYTESIZE| \= \kill
    \>infix  \> \verb|/|       \> \verb|(x,y: Float)    : Float| \\
    \>       \>                \> \verb|(x,y: Set)      : Set|
  \end{tabbing}
\end{quote}
On reals, \verb|/| denotes division.  On sets, \verb|/| denotes symmetric
difference.  That is, \verb|e IN (x / y)| if and only if
\verb|(e IN x) # (e IN y)|.  The types of \verb|x| and \verb|y| must be the
same, and the result is the same type as both.

\begin{quote}
  \begin{tabbing}
    \=prefix \= \verb|BYTESIZE| \= \kill
    \>infix  \> \verb|DIV|     \> \verb|(x,y: Integer) : Integer| \\
    \>infix  \> \verb|MOD|     \> \verb|(x,y: Integer) : Integer| \\
    \>       \>                \> \verb|(x,y: Float)   : Float|
  \end{tabbing}
\end{quote}
The value \verb|x DIV y| is the floor of the quotient of \verb|x| and
\verb|y|; that is, the maximum integer not exceeding the real number \verb|z|
such that \verb|z * y = x|.  For integers \verb|x| and \verb|y|, the value of
\verb|x MOD y| is defined to be \verb|x - y * (x DIV y)|.

This means that for positive \verb|y|, the value of \verb|x MOD y| lies in the
interval \verb|[0 ..  y-1]|, regardless of the sign of \verb|x|.  For negative
\verb|y|, the value of \verb|x MOD y| lies in the interval \verb|[y+1 ..  0]|,
regardless of the sign of \verb|x|.

If \verb|x| and \verb|y| are floats, the value of \verb|x MOD y| is
\verb|x - y * FLOOR(x / y)|.  This may be computed as a Modula-3 expression,
or by a method that avoids overflow if \verb|x| is much greater than y.  The
types of \verb|x| and \verb|y| must be the same, and the result is the same
type as both.

\begin{quote}
  \begin{tabbing}
    prefix \= \verb|BYTESIZE| \= \kill
           \> \verb|ABS|     \> \verb|(x: Integer) : Integer| \\
           \>                \> \verb|(x: Float)   : Float|
  \end{tabbing}
\end{quote}
\verb|ABS(x)| is the absolute value of \verb|x|.  The type of \verb|ABS(x)| is
the same as the type of \verb|x|.

\begin{quote}
  \begin{tabbing}
    prefix \= \verb|BYTESIZE| \= \kill
           \> \verb|FLOAT|   \> \verb|(x: Integer; T: Type := REAL): T| \\
           \>                \> \verb|(x: Float;   T: Type := REAL): T|
  \end{tabbing}
\end{quote}
\verb|FLOAT(x, T)| is a floating-point value of type \verb|T| that is equal to
or very near \verb|x|.  The type \verb|T| must be a floating-point type; it
defaults to \verb|REAL|.  The exact semantics depend on the thread's current
rounding mode, as explained in the required interface \verb|FloatMode|.

\begin{quote}
  \begin{tabbing}
    prefix \= \verb|BYTESIZE| \= \kill
           \> \verb|FLOOR|   \> \verb|(x: Float; T: Type := INTEGER): T| \\
           \> \verb|CEILING| \> \verb|(x: Float; T: Type := INTEGER): T|
  \end{tabbing}
\end{quote}
\verb|FLOOR(x)| is the greatest integer not exceeding \verb|x|.
\verb|CEILING(x)| is the least integer not less than \verb|x|.
The type \verb|T| must be an integer type; it defaults to \verb|INTEGER|.

\begin{quote}
  \begin{tabbing}
    prefix \= \verb|BYTESIZE| \= \kill
           \> \verb|ROUND|   \> \verb|(r: Float; T: Type := INTEGER): T| \\
           \> \verb|TRUNC|   \> \verb|(r: Float; T: Type := INTEGER): T|
  \end{tabbing}
\end{quote}
\verb|ROUND(r)| is the nearest integer to \verb|r|; ties are broken according
to the constant \verb|RoundDefault| in the required interface
\verb|FloatMode|.  \verb|TRUNC(r)| rounds \verb|r| toward zero; it equals
\verb|FLOOR(r)| for positive \verb|r| and \verb|CEILING(r)| for negative
\verb|r|.
The type \verb|T| must be an integer type; it defaults to \verb|INTEGER|.

\begin{quote}
  \begin{tabbing}
    prefix \= \verb|BYTESIZE| \= \kill
           \> \verb|MAX|, \verb|MIN| \> \verb|(x,y: Ordinal) : Ordinal| \\
           \>                        \> \verb|(x,y: Float)   : Float|
  \end{tabbing}
\end{quote}
\verb|MAX| returns the greater of the two values \verb|x| and \verb|y|;
\verb|MIN| returns the lesser.  If \verb|x| and \verb|y| are ordinals, they
must have the same base type, which is the type of the result.  If \verb|x|
and \verb|y| are floats, they must have the same type, and the result is the
same type as both.

\subsubsection*{2.6.11 Relations}

\begin{quote}
  \begin{tabbing}
    \=prefix \= \verb|BYTESIZE| \= \kill
    \>infix  \> \verb|=|, \verb|#|     \> \verb|(x, y: Any): BOOLEAN|
  \end{tabbing}
\end{quote}
The operator \verb|=| returns \verb|TRUE| if \verb|x| and \verb|y| are equal.
The operator \verb|#| returns \verb|TRUE| if \verb|x| and \verb|y| are not
equal.  It is a static error if the type of \verb|x| is not assignable to the
type of \verb|y| or vice versa.

Ordinals are equal if they have the same value.  Floats are equal if the
underlying implementation defines them to be; for example, on an IEEE
implementation, \verb|+0| equals \verb|-0| and \verb|NaN| does not equal
itself.  References are equal if they address the same location.  Procedures
are equal if they agree as closures; that is, if they refer to the same
procedure body and environment.  Sets are equal if they have the same
elements.  Arrays are equal if they have the same length and corresponding
elements are equal.  Records are equal if they have the same fields and
corresponding fields are equal.

\begin{quote}
  \begin{tabbing}
    \=prefix \= \verb|BYTESIZE| \= \kill
    \>infix  \> \verb|<=|, \verb|>=| \> \verb|(x,y: Ordinal) : BOOLEAN| \\
    \>       \>                      \> \verb|(x,y: Float)   : BOOLEAN| \\
    \>       \>                      \> \verb|(x,y: ADDRESS) : BOOLEAN| \\
    \>       \>                      \> \verb|(x,y: Set)     : BOOLEAN|
  \end{tabbing}
\end{quote}
In the first three cases, \verb|<=| returns \verb|TRUE| if \verb|x| is at most
as large as \verb|y|.  In the last case, \verb|<=| returns \verb|TRUE| if
every element of \verb|x| is an element of \verb|y|.  In all cases, it is a
static error if the type of \verb|x| is not assignable to the type of
\verb|y|, or vice versa.  The expression \verb|x >= y| is equivalent to
\verb|y <= x|.

\begin{quote}
  \begin{tabbing}
    \=prefix \= \verb|BYTESIZE| \= \kill
    \>infix  \> \verb|>|, \verb|<| \> \verb|(x,y: Ordinal) : BOOLEAN| \\
    \>       \>                    \> \verb|(x,y: Float)   : BOOLEAN| \\
    \>       \>                    \> \verb|(x,y: ADDRESS) : BOOLEAN| \\
    \>       \>                    \> \verb|(x,y: Set)     : BOOLEAN|
  \end{tabbing}
\end{quote}
In all cases, \verb|x < y| means \verb|(x $<$= y) AND (x \# y)|, and
\verb|x > y| means \verb|y < x|.  It is a static error if the type of \verb|x|
is not assignable to the type of \verb|y|, or vice versa.

Warning: with IEEE floating-point, \verb|x <= y| is not the same as
\verb|NOT x > y|.

\begin{quote}
  \begin{tabbing}
    \=prefix \= \verb|BYTESIZE| \= \kill
    \>infix  \> \verb|IN| \> \verb|(e: Ordinal; s: Set): BOOLEAN|
  \end{tabbing}
\end{quote}
Returns \verb|TRUE| if \verb|e| is an element of the set \verb|s|.  It is a
static error if the type of \verb|e| is not assignable to the element type of
\verb|s|.  If the value of \verb|e| is not a member of the element type, no
error occurs, but \verb|IN| returns \verb|FALSE|.

\subsubsection*{2.6.12 Boolean operations}

\begin{quote}
  \begin{tabbing}
    \=prefix \= \verb|BYTESIZE| \= \kill
    \>prefix \> \verb|NOT| \> \verb|(p: BOOLEAN)   : BOOLEAN| \\
    \>infix  \> \verb|AND| \> \verb|(p,q: BOOLEAN) : BOOLEAN| \\
    \>infix  \> \verb|OR|  \> \verb|(p,q: BOOLEAN) : BOOLEAN|
  \end{tabbing}
\end{quote}
\verb|NOT p| is the complement of \verb|p|.

\verb|p AND q| is \verb|TRUE| if both \verb|p| and \verb|q| are \verb|TRUE|.
If \verb|p| is \verb|FALSE|, \verb|q| is not evaluated.

\verb|p OR q| is \verb|TRUE| if at least one of \verb|p| and \verb|q| is
\verb|TRUE|.  If \verb|p| is \verb|TRUE|, \verb|q| is not evaluated.

\subsubsection*{2.6.13 Type operations}

\begin{quote}
  \begin{tabbing}
    \=prefix \= \verb|BYTESIZE| \= \kill
    \>       \> \verb|ISTYPE| \> \verb|(x: Reference; T: RefType) : BOOLEAN|
  \end{tabbing}
\end{quote}
\verb|ISTYPE(x, T)| is \verb|TRUE| if and only if \verb|x| is a member of
\verb|T|.  \verb|T| must be an object type or traced reference type, and
\verb|x| must be assignable to \verb|T|.
\begin{quote}
  \begin{tabbing}
    \=prefix \= \verb|BYTESIZE| \= \kill
    \>       \> \verb|NARROW| \> \verb|(x: Reference; T: RefType): T|
  \end{tabbing}
\end{quote}
\verb|NARROW(x, T)| returns \verb|x| after checking that \verb|x| is a member
of \verb|T|.  If the check fails, a runtime error occurs.  \verb|T| must be an
object type or traced reference type, and \verb|x| must be assignable to
\verb|T|.

\begin{quote}
  \begin{tabbing}
    \=prefix \= \verb|BYTESIZE| \= \kill
    \>       \> \verb|TYPECODE| \> \verb|(T: RefType)       : CARDINAL| \\
    \>       \>                 \> \verb|(r: REFANY)        : CARDINAL| \\
    \>       \>                 \> \verb|(r: UNTRACED ROOT) : CARDINAL|
  \end{tabbing}
\end{quote}
Every object type or traced reference type (including NULL) has an associated
integer code.  Different types have different codes.  The code for a type is
constant for any single execution of a program, but may differ for different
executions.  TYPECODE(T) returns the code for the type T and TYPECODE(r)
returns the code for the allocated type of r.  It is a static error if T is
REFANY or is not an object type or traced reference type.

\begin{quote}
  \begin{tabbing}
    \=prefix \= \verb|BYTESIZE| \= \kill
    \>       \> \verb|ORD| \> \verb|(element: Ordinal): INTEGER| \\
    \>       \> \verb|VAL| \> \verb|(i: INTEGER; T: OrdinalType): T|
  \end{tabbing}
\end{quote}
\verb|ORD| converts an element of an enumeration to the integer that
represents its position in the enumeration order.  The first value in any
enumeration is represented by zero.  If the type of \verb|element| is a
subrange of an enumeration \verb|T|, the result is the position of the element
within \verb|T|, not within the subrange.

\verb|VAL| is the inverse of \verb|ORD|; it converts from a numeric position
\verb|i| into the element that occupies that position in an enumeration.  If
\verb|T| is a subrange, \verb|VAL| returns the element with the position
\verb|i| in the original enumeration type, not the subrange.  It is a checked
runtime error for the value of \verb|i| to be out of range for \verb|T|.

If \verb|n| is an integer of type \verb|T|, \verb|ORD(n) = VAL(n, T) = n|.

\begin{quote}
  \begin{tabbing}
    prefix \= \verb|BYTESIZE| \= \kill
           \> \verb|NUMBER| \> \verb|(T: OrdinalType)    : CARDINAL| \\
           \>               \> \verb|(A: FixedArrayType) : CARDINAL| \\
           \>               \> \verb|(a: Array)          : CARDINAL|
  \end{tabbing}
\end{quote}
For an ordinal type \verb|T|, \verb|NUMBER(T)| returns the number of elements
in \verb|T|.  For a fixed array type \verb|A|, \verb|NUMBER(A)| is defined by
\verb|NUMBER(IndexType(A))|.  Similarly, for an array \verb|a|,
\verb|NUMBER(a)| is defined by \verb|NUMBER(IndexType(a))|.  In this case, the
expression \verb|a| will be evaluated only if it denotes an open array.

\begin{quote}
  \begin{tabbing}
    prefix \= \verb|BYTESIZE| \= \kill
    \> \verb|FIRST| \> \verb|(T: OrdinalType)    : BaseType(T)| \\
    \>              \> \verb|(T: FloatType)      : T| \\
    \>              \> \verb|(A: FixedArrayType) : BaseType(IndexType(A))| \\
    \>              \> \verb|(a: Array)          : BaseType(IndexType(a))| \\
    \\
    \> \verb|LAST|  \> \verb|(T: OrdinalType)    : BaseType(T)| \\
    \>              \> \verb|(T: FloatType)      : T| \\
    \>              \> \verb|(A: FixedArrayType) : BaseType(IndexType(A))| \\
    \>              \> \verb|(a: Array)          : BaseType(IndexType(a))|
  \end{tabbing}
\end{quote}
For a non-empty ordinal type \verb|T|, \verb|FIRST| returns the smallest value
of \verb|T| and \verb|LAST| returns the largest value.  If \verb|T| is the
empty enumeration, \verb|FIRST(T)| and \verb|LAST(T)| are static errors.  If
\verb|T| is any other empty ordinal type, the values returned are
implementation-dependent, but they satisfy \verb|FIRST(T) > LAST(T)|.

For a floating-point type \verb|T|, \verb|FIRST(T)| and \verb|LAST(T)| are the
smallest and largest values of the type, respectively.  On IEEE
implementations, these are minus and plus infinity.

For a fixed array type \verb|A|, \verb|FIRST(A)| is defined by
\verb|FIRST(IndexType(A))| and \verb|LAST(A)| by \verb|LAST(IndexType(A))|.
Similarly, for an array \verb|a|, \verb|FIRST(a)| and \verb|LAST(a)| are
defined by \verb|FIRST(IndexType(a))| and \verb|LAST(IndexType(a))|.  The
expression \verb|a| will be evaluated only if it is an open array.  Note that
if \verb|a| is an open array, \verb|FIRST(a)| and \verb|LAST(a)| have type
\verb|INTEGER|.

\begin{quote}
  \begin{tabbing}
    prefix \= \verb|BYTESIZE| \= \kill
    \> \verb|BITSIZE|  \> \verb|(x: Any)  : CARDINAL| \\
    \>                 \> \verb|(T: Type) : CARDINAL| \\
    \\
    \> \verb|BYTESIZE| \> \verb|(x: Any)  : CARDINAL| \\
    \>                 \> \verb|(T: Type) : CARDINAL| \\
    \\
    \> \verb|ADRSIZE|  \> \verb|(x: Any)  : CARDINAL| \\
    \>                 \> \verb|(T: Type) : CARDINAL|
  \end{tabbing}
\end{quote}
These operations return the size of the variable \verb|x| or of variables of
type \verb|T|.  \verb|BITSIZE| returns the number of bits, \verb|BYTESIZE| the
number of 8-bit bytes, and \verb|ADRSIZE| the number of addressable locations.
In all cases, \verb|x| must be a designator and \verb|T| must not be an open
array type.  A designator \verb|x| will be evaluated only if its type is an
open array type.

\subsubsection*{2.6.14 Text operations}

\begin{quote}
  \begin{tabbing}
    \=prefix \= \verb|BYTESIZE| \= \kill
    \>infix  \> \verb|&| \> \verb|(a,b: TEXT): TEXT|
  \end{tabbing}
\end{quote}
The concatenation of \verb|a| and \verb|b|, as defined by \verb|Text.Cat|.

\subsubsection*{2.6.15 Constant expressions}

Constant expressions are a subset of the general class of expressions,
restricted by the requirement that it be possible to evaluate the expression
statically.  All operations are legal in constant expressions except for
\verb|ADR|, \verb|LOOPHOLE|, \verb|TYPECODE|, \verb|NARROW|, \verb|ISTYPE|,
\verb|SUBARRAY|, \verb|NEW|, dereferencing (explicit or implicit), and the
only procedures that can be applied are the functions in the \verb|Word|
interface.

A variable can appear in a constant expression only as an argument to
\verb|FIRST|, \verb|LAST|, \verb|NUMBER|, \verb|BITSIZE|, \verb|BYTESIZE|, or
\verb|ADRSIZE|, and such a variable must not have an open array type.
Literals and top-level procedure constants are legal in constant expressions.

\subsection*{2.7 Unsafe operations}

\begin{quote}
  \emph{There are some cases that no law can be framed to cover.
    ---Aristotle}
\end{quote}

The features defined in this section can potentially cause unchecked runtime
errors and are thus forbidden in safe interfaces and modules.

An unchecked type transfer operation has the form:
\begin{quote}
  \begin{tabbing}
    prefix \= \verb|BYTESIZE| \= \kill
    \> \verb|LOOPHOLE| \> \verb|(e, T)|
  \end{tabbing}
\end{quote}
where \verb|e| is an expression whose type is not an open array type and
\verb|T| is a type.  It denotes \verb|e|'s bit pattern interpreted as a
variable or value of type \verb|T|.  It is a designator if \verb|e| is, and is
writable if \verb|e| is.  An unchecked runtime error can occur if \verb|e|'s
bit pattern is not a legal \verb|T|, or if \verb|e| is a designator and some
legal bit pattern for \verb|T| is not legal for \verb|e|.

If \verb|T| is not an open array type, \verb|BITSIZE(e)| must equal
\verb|BITSIZE(T)|.  If \verb|T| is an open array type, its element type must
not be an open array type, and \verb|e|'s bit pattern is interpreted as an
array whose length is \verb|BITSIZE(e)| divided by \verb|BITSIZE(|the element
type of \verb|T)|.  The division must come out even.

The following operations are primarily used for address arithmetic:
\begin{quote}
  \begin{tabbing}
    \=prefix \= \verb|BYTESIZE| \= \kill
    \>       \> \verb|ADR| \> \verb|(VAR x: Any)            : ADDRESS| \\
    \>infix  \> \verb|+|   \> \verb|(x: ADDRESS, y:INTEGER) : ADDRESS| \\
    \>infix  \> \verb|-|   \> \verb|(x: ADDRESS, y:INTEGER) : ADDRESS| \\
    \>infix  \> \verb|-|   \> \verb|(x,y: ADDRESS)          : INTEGER|
  \end{tabbing}
\end{quote}
\verb|ADR(x)| is the address of the variable \verb|x|.  The actual argument
must be a designator but need not be writable.  The operations \verb|+| and
\verb|-| treat addresses as integers.  The validity of the addresses produced
by these operations is implementation-dependent.  For example, the address of
a variable in a local procedure frame is probably valid only for the duration
of the call.  The address of the referent of a traced reference is probably
valid only as long as traced references prevent it from being collected (and
not even that long if the implementation uses a compacting collector).

In unsafe modules the \verb|INC| and \verb|DEC| statements apply to addresses
as well as ordinals:
\begin{quote}
  \begin{tabbing}
    \=prefix \= \verb|BYTESIZE| \= \kill
    \> \verb|INC| \> \verb|(VAR x: ADDRESS; n: INTEGER := 1)| \\
    \> \verb|DEC| \> \verb|(VAR x: ADDRESS; n: INTEGER := 1)|
  \end{tabbing}
\end{quote}
These are short for \verb|x := x + n| and \verb|x := x - n|, except that
\verb|x| is evaluated only once.

A \verb|DISPOSE| statement has the form:
\begin{quote}
  \begin{tabbing}
    \=prefix \= \verb|BYTESIZE| \= \kill
    \>       \> \verb|DISPOSE|  \> \verb|(v)|
  \end{tabbing}
\end{quote}
where \verb|v| is a writable designator whose type is not \verb|REFANY|,
\verb|ADDRESS|, or \verb|NULL|.  If \verb|v| is untraced, the statement frees
the storage for \verb|v|'s referent and sets \verb|v| to \verb|NIL|.  Freeing
storage to which active references remain is an unchecked runtime error.  If
\verb|v| is traced, the statement is equivalent to \verb|v := NIL|.  If
\verb|v| is \verb|NIL|, the statement is a no-op.

In unsafe interfaces and modules the definition of ``assignable'' for types is
extended: two reference types \verb|T| and \verb|U| are assignable if
\verb|T <: U| or \verb|U <: T|.  The only effect of this change is to allow a
value of type \verb|ADDRESS| to be assigned to a variable of type
\verb|UNTRACED REF T|.  It is an unchecked runtime error if the value does not
address a variable of type \verb|T|.

In unsafe interfaces and modules the type constructor \verb|UNTRACED REF T| is
allowed for traced as well as untraced \verb|T|, and the fields of untraced
objects can be traced.  If \verb|u| is an untraced reference to a traced
variable \verb|t|, then the validity of the traced references in \verb|t| is
implementation-dependent, since the garbage collector probably will not trace
them through \verb|u|.

\subsection*{2.8 Syntax}

\begin{quote}
  \emph{Care should be taken, when using colons and semicolons in the same
    sentence, that the reader understands how far the force of each sign
    carries.  ---Robert Graves and Alan Hodge}
\end{quote}

\subsubsection*{2.8.1 Keywords}

\begin{verbatim}
AND       DO          FROM        NOT         REPEAT     UNTIL
ANY       ELSE        GENERIC     OBJECT      RETURN     UNTRACED
ARRAY     ELSIF       IF          OF          REVEAL     VALUE
AS        END         IMPORT      OR          ROOT       VAR
BEGIN     EVAL        IN          OVERRIDES   SET        WHILE
BITS      EXCEPT      INTERFACE   PROCEDURE   THEN       WITH
BRANDED   EXCEPTION   LOCK        RAISE       TO
BY        EXIT        LOOP        RAISES      TRY
CASE      EXPORTS     METHODS     READONLY    TYPE
CONST     FINALLY     MOD         RECORD      TYPECASE
DIV       FOR         MODULE      REF         UNSAFE
\end{verbatim}

\subsubsection*{2.8.2 Reserved identifiers}

\begin{verbatim}
ABS       BYTESIZE   EXTENDED  INTEGER    MAX     NULL      SUBARRAY
ADDRESS   CARDINAL   FALSE     ISTYPE     MIN     NUMBER    TEXT
ADR       CEILING    FIRST     LAST       MUTEX   ORD       TRUE
ADRSIZE   CHAR       FLOAT     LONGINT    NARROW  REAL      TRUNC
BITSIZE   DEC        FLOOR     LONGREAL   NEW     REFANY    TYPECODE
BOOLEAN   DISPOSE    INC       LOOPHOLE   NIL     ROUND     VAL
                                                            WIDECHAR
\end{verbatim}

\subsubsection*{2.8.3 Operators}

\begin{verbatim}
+        <         #        =        ;        ..       :
-        >         {        }        |        :=       <:
*        <=        (        )        ^        ,        =>
/        >=        [        ]        .        &
\end{verbatim}

\subsubsection*{2.8.4 Comments}

A comment is an arbitrary character sequence opened by \verb|(*| and closed by
\verb|*)|.  Comments can be nested and can extend over more than one line.

\subsubsection*{2.8.5 Pragmas}

A pragma is an arbitrary character sequence opened by \verb|<*| and closed by
\verb|*>|.  Pragmas can be nested and can extend over more than one line.
Pragmas are hints to the implementation; they do not affect the language
semantics.

We recommend supporting the two pragmas \verb|<*INLINE*>| and
\verb|<*EXTERNAL*>|.  The pragma \verb|<*INLINE*>| precedes a procedure
declaration to indicate that the procedure should be expanded at the point of
call.  The pragma \verb|<*EXTERNAL| \verb|N:L*>| precedes an interface or a
declaration in an interface to indicate that the entity it precedes is
implemented by the language \verb|L|, where it has the name \verb|N|.  If
``\verb|:L|'' is omitted, then the implementation's default external language
is assumed.  If ``\verb|N|'' is omitted, then the external name is determined
from the Modula-3 name in some implementation-dependent way.

\subsubsection*{2.8.6 Conventions for syntax}

We use the following notation for defining syntax:
\begin{quote}
  \begin{tabular}{cl}
    \verb|X Y| & \verb|X| followed by \verb|Y| \\
    \verb+X|Y+ & \verb|X| or \verb|Y| \\
    \verb|[X]| & \verb|X| or empty \\
    \verb|{X}| & A possibly empty sequence of \verb|X|'s \\
    \verb|X&Y| & \verb|X| or \verb|Y| or \verb|X Y| \\
  \end{tabular}
\end{quote}
``Followed by'' has greater binding power than \verb+|+ or \verb|&|;
parentheses are used to override this precedence rule.  Non-terminals begin
with an upper-case letter.  Terminals are either keywords or quoted operators.
The symbols \verb|Id|, \verb|Number|, \verb|TextLiteral|, and
\verb|CharLiteral| are defined in the token grammar.  Each production is
terminated by a period.  The syntax does not reflect the restrictions that
revelations and exceptions can be declared only at the top level; nor does it
include explicit productions for \verb|NEW|, \verb|INC|, and \verb|DEC|, which
parse like procedure calls.

\subsubsection*{2.8.7 Compilation unit productions}

\begin{verbatim}
Compilation = [UNSAFE] (Interface | Module) | GenInf | GenMod.

Interface   = INTERFACE Id ";" {Import} {Decl} END Id "."
            | INTERFACE Id "=" Id GenActls END Id ".".
Module      = MODULE Id [EXPORTS IdList] ";" {Import} Block Id "."
            | MODULE Id [EXPORTS IdList] "=" Id GenActls END Id ".".

GenInf = GENERIC INTERFACE Id GenFmls ";" {Import} {Decl} END Id ".".
GenMod = GENERIC MODULE Id GenFmls ";" {Import} Block Id ".".

Import      = AsImport | FromImport.
AsImport    = IMPORT ImportItem {"," ImportItem} ";".
FromImport  = FROM Id IMPORT IdList ";".
Block       = {Decl} BEGIN S END.
Decl = CONST {ConstDecl ";"}
     | TYPE {TypeDecl ";"}
     | EXCEPTION {ExceptionDecl ";"}
     | VAR {VariableDecl ";"}
     | ProcedureHead ["=" Block Id] ";"
     | REVEAL {QualId ("=" | "<:") Type ";"}.

GenFmls        = "(" [IdList] ")".
GenActls       = "(" [IdList] ")".
ImportItem     = Id | Id AS Id.
ConstDecl      = Id [":" Type] "=" ConstExpr.
TypeDecl       = Id ("=" | "<:") Type.
ExceptionDecl  = Id ["(" Type ")"].
VariableDecl   = IdList (":" Type & ":=" Expr).
ProcedureHead  = PROCEDURE Id Signature.

Signature      = "(" Formals ")" [":" Type] [RAISES Raises].
Formals        = [ Formal {";" Formal} [";"] ].
Formal         = [Mode] IdList (":" Type & ":=" ConstExpr).
Mode           = VALUE | VAR | READONLY.
Raises         = "{" [ QualId {"," QualId} ] "}" | ANY.
\end{verbatim}

\subsubsection*{2.8.8 Statement productions}

\begin{verbatim}
Stmt = AssignSt | Block | CallSt | CaseSt | ExitSt | EvalSt | ForSt
     | IfSt | LockSt | LoopSt | RaiseSt | RepeatSt | ReturnSt
     | TCaseSt | TryXptSt | TryFinSt | WhileSt | WithSt.

S =  [ Stmt {";" Stmt} [";"] ].

AssignSt = Expr ":=" Expr.
CallSt   = Expr "(" [Actual {"," Actual}] ")".
CaseSt   = CASE Expr OF [Case] {"|" Case} [ELSE S] END.
ExitSt   = EXIT.
EvalSt   = EVAL Expr.
ForSt    = FOR Id ":=" Expr TO Expr [BY Expr] DO S END.
IfSt     = IF Expr THEN S {ELSIF Expr THEN S} [ELSE S] END.
LockSt   = LOCK Expr DO S END.
LoopSt   = LOOP S END.
RaiseSt  = RAISE QualId ["(" Expr ")"].
RepeatSt = REPEAT S UNTIL Expr.
ReturnSt = RETURN [Expr].
TCaseSt  = TYPECASE Expr OF [TCase] {"|" TCase} [ELSE S] END.
TryXptSt = TRY S EXCEPT [Handler] {"|" Handler} [ELSE S] END.
TryFinSt = TRY S FINALLY S END.
WhileSt  = WHILE Expr DO S END.
WithSt   = WITH Binding {"," Binding} DO S END.

Case    = Labels {"," Labels} "=>" S.
Labels  = ConstExpr [".." ConstExpr].
Handler = QualId {"," QualId} ["(" Id ")"] "=>" S.
TCase   = Type {"," Type} ["(" Id ")"] "=>" S.
Binding = Id "=" Expr.
Actual  = Type | [Id ":="] Expr .
\end{verbatim}

\subsubsection*{2.8.9 Type productions}

\begin{verbatim}
Type = TypeName | ArrayType | PackedType | EnumType | ObjectType
     | ProcedureType | RecordType | RefType | SetType | SubrangeType
     | "(" Type ")".

ArrayType     = ARRAY [Type {"," Type}] OF Type.
PackedType    = BITS ConstExpr FOR Type.
EnumType      = "{" [IdList] "}".
ObjectType    = [TypeName | ObjectType] [Brand] OBJECT Fields
                 [METHODS Methods] [OVERRIDES Overrides] END.
ProcedureType = PROCEDURE Signature.
RecordType    = RECORD Fields END.
RefType       = [UNTRACED] [Brand] REF Type.
SetType       = SET OF Type.
SubrangeType  = "[" ConstExpr ".." ConstExpr "]".

Brand     = BRANDED [ConstExpr].
Fields    = [ Field {";" Field} [";"] ].
Field     = IdList (":" Type & ":=" ConstExpr).
Methods   = [ Method {";" Method} [";"] ].
Method    = Id Signature [":=" ConstExpr].
Overrides = [ Override {";" Override} [";"] ].
Override  = Id ":=" ConstExpr .
\end{verbatim}

\subsubsection*{2.8.10 Expression productions}

\begin{verbatim}
ConstExpr = Expr.

Expr = E1 {OR E1}.
  E1 = E2 {AND E2}.
  E2 = {NOT} E3.
  E3 = E4 {Relop E4}.
  E4 = E5 {Addop E5}.
  E5 = E6 {Mulop E6}.
  E6 = {"+" | "-"} E7.
  E7 = E8 {Selector}.
  E8 = Id | Number | CharLiteral | TextLiteral
     | Constructor | "(" Expr ")".

Relop =  "=" | "#" | "<"  | "<=" | ">" | ">=" | IN.
Addop =  "+" | "-" | "&".
Mulop =  "*" | "/" | DIV | MOD.

Selector = "^"  |  "." Id  |  "[" Expr {"," Expr} "]"
         | "(" [ Actual {"," Actual} ] ")".

Constructor = Type "{" [ SetCons | RecordCons | ArrayCons ] "}".

SetCons = SetElt {"," SetElt}.
SetElt = Expr [".." Expr].
RecordCons = RecordElt {"," RecordElt}.
RecordElt = [Id ":="] Expr.
ArrayCons =  Expr {"," Expr} ["," ".."].
\end{verbatim}

\subsubsection*{2.8.11 Miscellaneous productions}

\begin{verbatim}
IdList      =  Id {"," Id}.
QualId      =  Id ["." Id].
TypeName    =  QualId | ROOT | UNTRACED ROOT.
\end{verbatim}

\subsubsection*{2.8.12 Token productions}

To read a token, first skip all blanks, tabs, newlines, carriage returns,
vertical tabs, form feeds, comments, and pragmas.  Then read the longest
sequence of characters that forms an operator or an \verb|Id| or
\verb|Literal|.

An \verb|Id| is a case-significant sequence of letters, digits, and
underscores that begins with a letter.  An \verb|Id| is a keyword if it
appears in the list of keywords, a reserved identifier if it appears in the
list of reserved identifiers, and an ordinary identifier otherwise.

In the following grammar, terminals are characters surrounded by double-quotes
and the special terminal \verb|DQUOTE| represents double-quote itself.

\begin{verbatim}
Id = Letter {Letter | Digit | "_"}.

Literal = Number | CharLiteral | TextLiteral.

CharLiteral = "'"  (PrintingChar | Escape | DQUOTE) "'".

TextLiteral = DQUOTE {PrintingChar | Escape | "'"} DQUOTE.

Escape = "\" "n"   | "\" "t"     | "\" "r"     | "\" "f"
       | "\" "\"   | "\" "'"     | "\" DQUOTE
       | "\" OctalDigit OctalDigit OctalDigit.

Number = Digit {Digit}
       | Digit {Digit} "_" HexDigit {HexDigit}
       | Digit {Digit} "." Digit {Digit} [Exp].

Exp = ("E" | "e" | "D" | "d" | "X" | "x") ["+" | "-"] Digit {Digit}.

PrintingChar = Letter | Digit | OtherChar.

HexDigit = Digit | "A" | "B" | "C" | "D" | "E" | "F"
                 | "a" | "b" | "c" | "d" | "e" | "f".

Digit = "0" | "1" | ... | "9".

OctalDigit = "0" | "1" | ... | "7".

Letter = "A"  | "B"  | ... | "Z"  | "a"  | "b"  | ... | "z".

OtherChar = " " | "!" | "#" | "$" | "%" | "&" | "(" | ")"
          | "*" | "+" | "," | "-" | "." | "/" | ":" | ";"
          | "<" | "=" | ">" | "?" | "@" | "[" | "]" | "^"
          | "_" | "`" | "{" | "|" | "}" | "~"
          | ExtendedChar

ExtendedChar = any char with ISO-Latin-1 code in [8_240..8_377].
\end{verbatim}

\subsection*{About the authors}

Luca Cardelli was an undergraduate in Pisa and has a Ph.D.\ in Computer
Science from the University of Edinburgh (1982).  He worked at AT\&T Bell
Labs, Murray Hill, from 1982 to 1985 before assuming his current position at
DEC SRC.  His main interests are in constructive logic, type theory, and
language design and implementation.

Jim Donahue received his Ph.D.\ in Computer Science at the University of
Toronto (1975).  He was an Assistant Professor at Cornell University from 1975
to 1981.  In 1981, he joined the Computer Science Laboratory of the Xerox Palo
Alto Research Center.  In 1986, he established the Olivetti Research Center
and was its Director until 1990.  He is now a Senior Scientist and Product
Manager for Teknekron Software Systems.  His interests include programming
language design, distributed system design, and database systems and
applications.

Lucille Glassman is a technical writer for DEC SRC.

Mick Jordan has a Ph.D.\ in Computer Science from the University of Cambridge.
From 1984 to 1988 he worked at the Acorn Research Center in Palo Alto on a
programming environment for Modula-2+.  Before joining DEC SRC in 1990 he was
at Olivetti Research, where he led the group that produced the Olivetti
Modula-3 implementation.  His principal current interest is in programming
tools that are based on Modula-3 Abstract Syntax Trees.

Bill Kalsow received his Ph.D.\ in Computer Science from the University of
Wisconsin at Madison (1986).  Since then he has worked as DEC SRC.  His
primary interests are programming languages and their implementations.

Greg Nelson got his Ph.D.\ from Stanford in 1980, where he worked on program
verification and algorithms for mechanical theorem proving.  He was the author
of the Juno constraint-based graphics system at Xerox PARC's Computer Science
Laboratory, has taught at Princeton University, and is now a member of DEC
SRC.  Currently his active interests are window systems, programming language
design, and the semantic theory of guarded commands.

\par \vskip 1em \vskip -0.4pt \hrule width \linewidth height 0.4pt depth 0.0pt
\vskip 1em \par
[Modula-3 home page]

m3-request@src.dec.com
\begin{verbatim}
Last modified on Fri Jan  8 10:49:37 PST 1999 by heydon
\end{verbatim}

Legal Statement Privacy Statement
\end{document}
